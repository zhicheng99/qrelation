(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("qrelation", [], factory);
	else if(typeof exports === 'object')
		exports["qrelation"] = factory();
	else
		root["qrelation"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\n * Vue.js v2.6.12\n * (c) 2014-2020 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n   true ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.Vue = factory());\n}(this, function () { 'use strict';\n\n  /*  */\n\n  var emptyObject = Object.freeze({});\n\n  // These helpers produce better VM code in JS engines due to their\n  // explicitness and function inlining.\n  function isUndef (v) {\n    return v === undefined || v === null\n  }\n\n  function isDef (v) {\n    return v !== undefined && v !== null\n  }\n\n  function isTrue (v) {\n    return v === true\n  }\n\n  function isFalse (v) {\n    return v === false\n  }\n\n  /**\n   * Check if value is primitive.\n   */\n  function isPrimitive (value) {\n    return (\n      typeof value === 'string' ||\n      typeof value === 'number' ||\n      // $flow-disable-line\n      typeof value === 'symbol' ||\n      typeof value === 'boolean'\n    )\n  }\n\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   */\n  function isObject (obj) {\n    return obj !== null && typeof obj === 'object'\n  }\n\n  /**\n   * Get the raw type string of a value, e.g., [object Object].\n   */\n  var _toString = Object.prototype.toString;\n\n  function toRawType (value) {\n    return _toString.call(value).slice(8, -1)\n  }\n\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   */\n  function isPlainObject (obj) {\n    return _toString.call(obj) === '[object Object]'\n  }\n\n  function isRegExp (v) {\n    return _toString.call(v) === '[object RegExp]'\n  }\n\n  /**\n   * Check if val is a valid array index.\n   */\n  function isValidArrayIndex (val) {\n    var n = parseFloat(String(val));\n    return n >= 0 && Math.floor(n) === n && isFinite(val)\n  }\n\n  function isPromise (val) {\n    return (\n      isDef(val) &&\n      typeof val.then === 'function' &&\n      typeof val.catch === 'function'\n    )\n  }\n\n  /**\n   * Convert a value to a string that is actually rendered.\n   */\n  function toString (val) {\n    return val == null\n      ? ''\n      : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n        ? JSON.stringify(val, null, 2)\n        : String(val)\n  }\n\n  /**\n   * Convert an input value to a number for persistence.\n   * If the conversion fails, return original string.\n   */\n  function toNumber (val) {\n    var n = parseFloat(val);\n    return isNaN(n) ? val : n\n  }\n\n  /**\n   * Make a map and return a function for checking if a key\n   * is in that map.\n   */\n  function makeMap (\n    str,\n    expectsLowerCase\n  ) {\n    var map = Object.create(null);\n    var list = str.split(',');\n    for (var i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n    return expectsLowerCase\n      ? function (val) { return map[val.toLowerCase()]; }\n      : function (val) { return map[val]; }\n  }\n\n  /**\n   * Check if a tag is a built-in tag.\n   */\n  var isBuiltInTag = makeMap('slot,component', true);\n\n  /**\n   * Check if an attribute is a reserved attribute.\n   */\n  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n  /**\n   * Remove an item from an array.\n   */\n  function remove (arr, item) {\n    if (arr.length) {\n      var index = arr.indexOf(item);\n      if (index > -1) {\n        return arr.splice(index, 1)\n      }\n    }\n  }\n\n  /**\n   * Check whether an object has the property.\n   */\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  function hasOwn (obj, key) {\n    return hasOwnProperty.call(obj, key)\n  }\n\n  /**\n   * Create a cached version of a pure function.\n   */\n  function cached (fn) {\n    var cache = Object.create(null);\n    return (function cachedFn (str) {\n      var hit = cache[str];\n      return hit || (cache[str] = fn(str))\n    })\n  }\n\n  /**\n   * Camelize a hyphen-delimited string.\n   */\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cached(function (str) {\n    return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n  });\n\n  /**\n   * Capitalize a string.\n   */\n  var capitalize = cached(function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1)\n  });\n\n  /**\n   * Hyphenate a camelCase string.\n   */\n  var hyphenateRE = /\\B([A-Z])/g;\n  var hyphenate = cached(function (str) {\n    return str.replace(hyphenateRE, '-$1').toLowerCase()\n  });\n\n  /**\n   * Simple bind polyfill for environments that do not support it,\n   * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n   * since native bind is now performant enough in most browsers.\n   * But removing it would mean breaking code that was able to run in\n   * PhantomJS 1.x, so this must be kept for backward compatibility.\n   */\n\n  /* istanbul ignore next */\n  function polyfillBind (fn, ctx) {\n    function boundFn (a) {\n      var l = arguments.length;\n      return l\n        ? l > 1\n          ? fn.apply(ctx, arguments)\n          : fn.call(ctx, a)\n        : fn.call(ctx)\n    }\n\n    boundFn._length = fn.length;\n    return boundFn\n  }\n\n  function nativeBind (fn, ctx) {\n    return fn.bind(ctx)\n  }\n\n  var bind = Function.prototype.bind\n    ? nativeBind\n    : polyfillBind;\n\n  /**\n   * Convert an Array-like object to a real Array.\n   */\n  function toArray (list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n    while (i--) {\n      ret[i] = list[i + start];\n    }\n    return ret\n  }\n\n  /**\n   * Mix properties into target object.\n   */\n  function extend (to, _from) {\n    for (var key in _from) {\n      to[key] = _from[key];\n    }\n    return to\n  }\n\n  /**\n   * Merge an Array of Objects into a single Object.\n   */\n  function toObject (arr) {\n    var res = {};\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        extend(res, arr[i]);\n      }\n    }\n    return res\n  }\n\n  /* eslint-disable no-unused-vars */\n\n  /**\n   * Perform no operation.\n   * Stubbing args to make Flow happy without leaving useless transpiled code\n   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n   */\n  function noop (a, b, c) {}\n\n  /**\n   * Always return false.\n   */\n  var no = function (a, b, c) { return false; };\n\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * Return the same value.\n   */\n  var identity = function (_) { return _; };\n\n  /**\n   * Generate a string containing static keys from compiler modules.\n   */\n  function genStaticKeys (modules) {\n    return modules.reduce(function (keys, m) {\n      return keys.concat(m.staticKeys || [])\n    }, []).join(',')\n  }\n\n  /**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   */\n  function looseEqual (a, b) {\n    if (a === b) { return true }\n    var isObjectA = isObject(a);\n    var isObjectB = isObject(b);\n    if (isObjectA && isObjectB) {\n      try {\n        var isArrayA = Array.isArray(a);\n        var isArrayB = Array.isArray(b);\n        if (isArrayA && isArrayB) {\n          return a.length === b.length && a.every(function (e, i) {\n            return looseEqual(e, b[i])\n          })\n        } else if (a instanceof Date && b instanceof Date) {\n          return a.getTime() === b.getTime()\n        } else if (!isArrayA && !isArrayB) {\n          var keysA = Object.keys(a);\n          var keysB = Object.keys(b);\n          return keysA.length === keysB.length && keysA.every(function (key) {\n            return looseEqual(a[key], b[key])\n          })\n        } else {\n          /* istanbul ignore next */\n          return false\n        }\n      } catch (e) {\n        /* istanbul ignore next */\n        return false\n      }\n    } else if (!isObjectA && !isObjectB) {\n      return String(a) === String(b)\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * Return the first index at which a loosely equal value can be\n   * found in the array (if value is a plain object, the array must\n   * contain an object of the same shape), or -1 if it is not present.\n   */\n  function looseIndexOf (arr, val) {\n    for (var i = 0; i < arr.length; i++) {\n      if (looseEqual(arr[i], val)) { return i }\n    }\n    return -1\n  }\n\n  /**\n   * Ensure a function is called only once.\n   */\n  function once (fn) {\n    var called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        fn.apply(this, arguments);\n      }\n    }\n  }\n\n  var SSR_ATTR = 'data-server-rendered';\n\n  var ASSET_TYPES = [\n    'component',\n    'directive',\n    'filter'\n  ];\n\n  var LIFECYCLE_HOOKS = [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated',\n    'errorCaptured',\n    'serverPrefetch'\n  ];\n\n  /*  */\n\n\n\n  var config = ({\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    // $flow-disable-line\n    optionMergeStrategies: Object.create(null),\n\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n\n    /**\n     * Show production mode tip message on boot?\n     */\n    productionTip: \"development\" !== 'production',\n\n    /**\n     * Whether to enable devtools\n     */\n    devtools: \"development\" !== 'production',\n\n    /**\n     * Whether to record perf\n     */\n    performance: false,\n\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n\n    /**\n     * Warn handler for watcher warns\n     */\n    warnHandler: null,\n\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: [],\n\n    /**\n     * Custom user key aliases for v-on\n     */\n    // $flow-disable-line\n    keyCodes: Object.create(null),\n\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n\n    /**\n     * Check if an attribute is reserved so that it cannot be used as a component\n     * prop. This is platform-dependent and may be overwritten.\n     */\n    isReservedAttr: no,\n\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n\n    /**\n     * Parse the real tag name for the specific platform.\n     */\n    parsePlatformTagName: identity,\n\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n\n    /**\n     * Perform updates asynchronously. Intended to be used by Vue Test Utils\n     * This will significantly reduce performance if set to false.\n     */\n    async: true,\n\n    /**\n     * Exposed for legacy reasons\n     */\n    _lifecycleHooks: LIFECYCLE_HOOKS\n  });\n\n  /*  */\n\n  /**\n   * unicode letters used for parsing html tags, component names and property paths.\n   * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n   * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n   */\n  var unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n\n  /**\n   * Check if a string starts with $ or _\n   */\n  function isReserved (str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5F\n  }\n\n  /**\n   * Define a property.\n   */\n  function def (obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n      value: val,\n      enumerable: !!enumerable,\n      writable: true,\n      configurable: true\n    });\n  }\n\n  /**\n   * Parse simple path.\n   */\n  var bailRE = new RegExp((\"[^\" + (unicodeRegExp.source) + \".$_\\\\d]\"));\n  function parsePath (path) {\n    if (bailRE.test(path)) {\n      return\n    }\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) { return }\n        obj = obj[segments[i]];\n      }\n      return obj\n    }\n  }\n\n  /*  */\n\n  // can we use __proto__?\n  var hasProto = '__proto__' in {};\n\n  // Browser environment sniffing\n  var inBrowser = typeof window !== 'undefined';\n  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\n  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\n  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n  var isIE = UA && /msie|trident/.test(UA);\n  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n  var isEdge = UA && UA.indexOf('edge/') > 0;\n  var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\n  var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\n  var isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n  var isPhantomJS = UA && /phantomjs/.test(UA);\n  var isFF = UA && UA.match(/firefox\\/(\\d+)/);\n\n  // Firefox has a \"watch\" function on Object.prototype...\n  var nativeWatch = ({}).watch;\n\n  var supportsPassive = false;\n  if (inBrowser) {\n    try {\n      var opts = {};\n      Object.defineProperty(opts, 'passive', ({\n        get: function get () {\n          /* istanbul ignore next */\n          supportsPassive = true;\n        }\n      })); // https://github.com/facebook/flow/issues/285\n      window.addEventListener('test-passive', null, opts);\n    } catch (e) {}\n  }\n\n  // this needs to be lazy-evaled because vue may be required before\n  // vue-server-renderer can set VUE_ENV\n  var _isServer;\n  var isServerRendering = function () {\n    if (_isServer === undefined) {\n      /* istanbul ignore if */\n      if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n        // detect presence of vue-server-renderer and avoid\n        // Webpack shimming the process\n        _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n      } else {\n        _isServer = false;\n      }\n    }\n    return _isServer\n  };\n\n  // detect devtools\n  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n  /* istanbul ignore next */\n  function isNative (Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n  }\n\n  var hasSymbol =\n    typeof Symbol !== 'undefined' && isNative(Symbol) &&\n    typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n  var _Set;\n  /* istanbul ignore if */ // $flow-disable-line\n  if (typeof Set !== 'undefined' && isNative(Set)) {\n    // use native Set when available.\n    _Set = Set;\n  } else {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set = /*@__PURE__*/(function () {\n      function Set () {\n        this.set = Object.create(null);\n      }\n      Set.prototype.has = function has (key) {\n        return this.set[key] === true\n      };\n      Set.prototype.add = function add (key) {\n        this.set[key] = true;\n      };\n      Set.prototype.clear = function clear () {\n        this.set = Object.create(null);\n      };\n\n      return Set;\n    }());\n  }\n\n  /*  */\n\n  var warn = noop;\n  var tip = noop;\n  var generateComponentTrace = (noop); // work around flow check\n  var formatComponentName = (noop);\n\n  {\n    var hasConsole = typeof console !== 'undefined';\n    var classifyRE = /(?:^|[-_])(\\w)/g;\n    var classify = function (str) { return str\n      .replace(classifyRE, function (c) { return c.toUpperCase(); })\n      .replace(/[-_]/g, ''); };\n\n    warn = function (msg, vm) {\n      var trace = vm ? generateComponentTrace(vm) : '';\n\n      if (config.warnHandler) {\n        config.warnHandler.call(null, msg, vm, trace);\n      } else if (hasConsole && (!config.silent)) {\n        console.error((\"[Vue warn]: \" + msg + trace));\n      }\n    };\n\n    tip = function (msg, vm) {\n      if (hasConsole && (!config.silent)) {\n        console.warn(\"[Vue tip]: \" + msg + (\n          vm ? generateComponentTrace(vm) : ''\n        ));\n      }\n    };\n\n    formatComponentName = function (vm, includeFile) {\n      if (vm.$root === vm) {\n        return '<Root>'\n      }\n      var options = typeof vm === 'function' && vm.cid != null\n        ? vm.options\n        : vm._isVue\n          ? vm.$options || vm.constructor.options\n          : vm;\n      var name = options.name || options._componentTag;\n      var file = options.__file;\n      if (!name && file) {\n        var match = file.match(/([^/\\\\]+)\\.vue$/);\n        name = match && match[1];\n      }\n\n      return (\n        (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n        (file && includeFile !== false ? (\" at \" + file) : '')\n      )\n    };\n\n    var repeat = function (str, n) {\n      var res = '';\n      while (n) {\n        if (n % 2 === 1) { res += str; }\n        if (n > 1) { str += str; }\n        n >>= 1;\n      }\n      return res\n    };\n\n    generateComponentTrace = function (vm) {\n      if (vm._isVue && vm.$parent) {\n        var tree = [];\n        var currentRecursiveSequence = 0;\n        while (vm) {\n          if (tree.length > 0) {\n            var last = tree[tree.length - 1];\n            if (last.constructor === vm.constructor) {\n              currentRecursiveSequence++;\n              vm = vm.$parent;\n              continue\n            } else if (currentRecursiveSequence > 0) {\n              tree[tree.length - 1] = [last, currentRecursiveSequence];\n              currentRecursiveSequence = 0;\n            }\n          }\n          tree.push(vm);\n          vm = vm.$parent;\n        }\n        return '\\n\\nfound in\\n\\n' + tree\n          .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n              ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n              : formatComponentName(vm))); })\n          .join('\\n')\n      } else {\n        return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n      }\n    };\n  }\n\n  /*  */\n\n  var uid = 0;\n\n  /**\n   * A dep is an observable that can have multiple\n   * directives subscribing to it.\n   */\n  var Dep = function Dep () {\n    this.id = uid++;\n    this.subs = [];\n  };\n\n  Dep.prototype.addSub = function addSub (sub) {\n    this.subs.push(sub);\n  };\n\n  Dep.prototype.removeSub = function removeSub (sub) {\n    remove(this.subs, sub);\n  };\n\n  Dep.prototype.depend = function depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this);\n    }\n  };\n\n  Dep.prototype.notify = function notify () {\n    // stabilize the subscriber list first\n    var subs = this.subs.slice();\n    if (!config.async) {\n      // subs aren't sorted in scheduler if not running async\n      // we need to sort them now to make sure they fire in correct\n      // order\n      subs.sort(function (a, b) { return a.id - b.id; });\n    }\n    for (var i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();\n    }\n  };\n\n  // The current target watcher being evaluated.\n  // This is globally unique because only one watcher\n  // can be evaluated at a time.\n  Dep.target = null;\n  var targetStack = [];\n\n  function pushTarget (target) {\n    targetStack.push(target);\n    Dep.target = target;\n  }\n\n  function popTarget () {\n    targetStack.pop();\n    Dep.target = targetStack[targetStack.length - 1];\n  }\n\n  /*  */\n\n  var VNode = function VNode (\n    tag,\n    data,\n    children,\n    text,\n    elm,\n    context,\n    componentOptions,\n    asyncFactory\n  ) {\n    this.tag = tag;\n    this.data = data;\n    this.children = children;\n    this.text = text;\n    this.elm = elm;\n    this.ns = undefined;\n    this.context = context;\n    this.fnContext = undefined;\n    this.fnOptions = undefined;\n    this.fnScopeId = undefined;\n    this.key = data && data.key;\n    this.componentOptions = componentOptions;\n    this.componentInstance = undefined;\n    this.parent = undefined;\n    this.raw = false;\n    this.isStatic = false;\n    this.isRootInsert = true;\n    this.isComment = false;\n    this.isCloned = false;\n    this.isOnce = false;\n    this.asyncFactory = asyncFactory;\n    this.asyncMeta = undefined;\n    this.isAsyncPlaceholder = false;\n  };\n\n  var prototypeAccessors = { child: { configurable: true } };\n\n  // DEPRECATED: alias for componentInstance for backwards compat.\n  /* istanbul ignore next */\n  prototypeAccessors.child.get = function () {\n    return this.componentInstance\n  };\n\n  Object.defineProperties( VNode.prototype, prototypeAccessors );\n\n  var createEmptyVNode = function (text) {\n    if ( text === void 0 ) text = '';\n\n    var node = new VNode();\n    node.text = text;\n    node.isComment = true;\n    return node\n  };\n\n  function createTextVNode (val) {\n    return new VNode(undefined, undefined, undefined, String(val))\n  }\n\n  // optimized shallow clone\n  // used for static nodes and slot nodes because they may be reused across\n  // multiple renders, cloning them avoids errors when DOM manipulations rely\n  // on their elm reference.\n  function cloneVNode (vnode) {\n    var cloned = new VNode(\n      vnode.tag,\n      vnode.data,\n      // #7975\n      // clone children array to avoid mutating original in case of cloning\n      // a child.\n      vnode.children && vnode.children.slice(),\n      vnode.text,\n      vnode.elm,\n      vnode.context,\n      vnode.componentOptions,\n      vnode.asyncFactory\n    );\n    cloned.ns = vnode.ns;\n    cloned.isStatic = vnode.isStatic;\n    cloned.key = vnode.key;\n    cloned.isComment = vnode.isComment;\n    cloned.fnContext = vnode.fnContext;\n    cloned.fnOptions = vnode.fnOptions;\n    cloned.fnScopeId = vnode.fnScopeId;\n    cloned.asyncMeta = vnode.asyncMeta;\n    cloned.isCloned = true;\n    return cloned\n  }\n\n  /*\n   * not type checking this file because flow doesn't play well with\n   * dynamically accessing methods on Array prototype\n   */\n\n  var arrayProto = Array.prototype;\n  var arrayMethods = Object.create(arrayProto);\n\n  var methodsToPatch = [\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'splice',\n    'sort',\n    'reverse'\n  ];\n\n  /**\n   * Intercept mutating methods and emit events\n   */\n  methodsToPatch.forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted;\n      switch (method) {\n        case 'push':\n        case 'unshift':\n          inserted = args;\n          break\n        case 'splice':\n          inserted = args.slice(2);\n          break\n      }\n      if (inserted) { ob.observeArray(inserted); }\n      // notify change\n      ob.dep.notify();\n      return result\n    });\n  });\n\n  /*  */\n\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n  /**\n   * In some cases we may want to disable observation inside a component's\n   * update computation.\n   */\n  var shouldObserve = true;\n\n  function toggleObserving (value) {\n    shouldObserve = value;\n  }\n\n  /**\n   * Observer class that is attached to each observed\n   * object. Once attached, the observer converts the target\n   * object's property keys into getter/setters that\n   * collect dependencies and dispatch updates.\n   */\n  var Observer = function Observer (value) {\n    this.value = value;\n    this.dep = new Dep();\n    this.vmCount = 0;\n    def(value, '__ob__', this);\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods);\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys);\n      }\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  };\n\n  /**\n   * Walk through all properties and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  Observer.prototype.walk = function walk (obj) {\n    var keys = Object.keys(obj);\n    for (var i = 0; i < keys.length; i++) {\n      defineReactive$$1(obj, keys[i]);\n    }\n  };\n\n  /**\n   * Observe a list of Array items.\n   */\n  Observer.prototype.observeArray = function observeArray (items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      observe(items[i]);\n    }\n  };\n\n  // helpers\n\n  /**\n   * Augment a target Object or Array by intercepting\n   * the prototype chain using __proto__\n   */\n  function protoAugment (target, src) {\n    /* eslint-disable no-proto */\n    target.__proto__ = src;\n    /* eslint-enable no-proto */\n  }\n\n  /**\n   * Augment a target Object or Array by defining\n   * hidden properties.\n   */\n  /* istanbul ignore next */\n  function copyAugment (target, src, keys) {\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      def(target, key, src[key]);\n    }\n  }\n\n  /**\n   * Attempt to create an observer instance for a value,\n   * returns the new observer if successfully observed,\n   * or the existing observer if the value already has one.\n   */\n  function observe (value, asRootData) {\n    if (!isObject(value) || value instanceof VNode) {\n      return\n    }\n    var ob;\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n      ob = value.__ob__;\n    } else if (\n      shouldObserve &&\n      !isServerRendering() &&\n      (Array.isArray(value) || isPlainObject(value)) &&\n      Object.isExtensible(value) &&\n      !value._isVue\n    ) {\n      ob = new Observer(value);\n    }\n    if (asRootData && ob) {\n      ob.vmCount++;\n    }\n    return ob\n  }\n\n  /**\n   * Define a reactive property on an Object.\n   */\n  function defineReactive$$1 (\n    obj,\n    key,\n    val,\n    customSetter,\n    shallow\n  ) {\n    var dep = new Dep();\n\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n    if (property && property.configurable === false) {\n      return\n    }\n\n    // cater for pre-defined getter/setters\n    var getter = property && property.get;\n    var setter = property && property.set;\n    if ((!getter || setter) && arguments.length === 2) {\n      val = obj[key];\n    }\n\n    var childOb = !shallow && observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: function reactiveGetter () {\n        var value = getter ? getter.call(obj) : val;\n        if (Dep.target) {\n          dep.depend();\n          if (childOb) {\n            childOb.dep.depend();\n            if (Array.isArray(value)) {\n              dependArray(value);\n            }\n          }\n        }\n        return value\n      },\n      set: function reactiveSetter (newVal) {\n        var value = getter ? getter.call(obj) : val;\n        /* eslint-disable no-self-compare */\n        if (newVal === value || (newVal !== newVal && value !== value)) {\n          return\n        }\n        /* eslint-enable no-self-compare */\n        if (customSetter) {\n          customSetter();\n        }\n        // #7981: for accessor properties without setter\n        if (getter && !setter) { return }\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n        childOb = !shallow && observe(newVal);\n        dep.notify();\n      }\n    });\n  }\n\n  /**\n   * Set a property on an object. Adds the new property and\n   * triggers change notification if the property doesn't\n   * already exist.\n   */\n  function set (target, key, val) {\n    if (isUndef(target) || isPrimitive(target)\n    ) {\n      warn((\"Cannot set reactive property on undefined, null, or primitive value: \" + ((target))));\n    }\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val\n    }\n    if (key in target && !(key in Object.prototype)) {\n      target[key] = val;\n      return val\n    }\n    var ob = (target).__ob__;\n    if (target._isVue || (ob && ob.vmCount)) {\n      warn(\n        'Avoid adding reactive properties to a Vue instance or its root $data ' +\n        'at runtime - declare it upfront in the data option.'\n      );\n      return val\n    }\n    if (!ob) {\n      target[key] = val;\n      return val\n    }\n    defineReactive$$1(ob.value, key, val);\n    ob.dep.notify();\n    return val\n  }\n\n  /**\n   * Delete a property and trigger change if necessary.\n   */\n  function del (target, key) {\n    if (isUndef(target) || isPrimitive(target)\n    ) {\n      warn((\"Cannot delete reactive property on undefined, null, or primitive value: \" + ((target))));\n    }\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.splice(key, 1);\n      return\n    }\n    var ob = (target).__ob__;\n    if (target._isVue || (ob && ob.vmCount)) {\n      warn(\n        'Avoid deleting properties on a Vue instance or its root $data ' +\n        '- just set it to null.'\n      );\n      return\n    }\n    if (!hasOwn(target, key)) {\n      return\n    }\n    delete target[key];\n    if (!ob) {\n      return\n    }\n    ob.dep.notify();\n  }\n\n  /**\n   * Collect dependencies on array elements when the array is touched, since\n   * we cannot intercept array element access like property getters.\n   */\n  function dependArray (value) {\n    for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n      e = value[i];\n      e && e.__ob__ && e.__ob__.dep.depend();\n      if (Array.isArray(e)) {\n        dependArray(e);\n      }\n    }\n  }\n\n  /*  */\n\n  /**\n   * Option overwriting strategies are functions that handle\n   * how to merge a parent option value and a child option\n   * value into the final value.\n   */\n  var strats = config.optionMergeStrategies;\n\n  /**\n   * Options with restrictions\n   */\n  {\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n      if (!vm) {\n        warn(\n          \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n          'creation with the `new` keyword.'\n        );\n      }\n      return defaultStrat(parent, child)\n    };\n  }\n\n  /**\n   * Helper that recursively merges two data objects together.\n   */\n  function mergeData (to, from) {\n    if (!from) { return to }\n    var key, toVal, fromVal;\n\n    var keys = hasSymbol\n      ? Reflect.ownKeys(from)\n      : Object.keys(from);\n\n    for (var i = 0; i < keys.length; i++) {\n      key = keys[i];\n      // in case the object is already observed...\n      if (key === '__ob__') { continue }\n      toVal = to[key];\n      fromVal = from[key];\n      if (!hasOwn(to, key)) {\n        set(to, key, fromVal);\n      } else if (\n        toVal !== fromVal &&\n        isPlainObject(toVal) &&\n        isPlainObject(fromVal)\n      ) {\n        mergeData(toVal, fromVal);\n      }\n    }\n    return to\n  }\n\n  /**\n   * Data\n   */\n  function mergeDataOrFn (\n    parentVal,\n    childVal,\n    vm\n  ) {\n    if (!vm) {\n      // in a Vue.extend merge, both should be functions\n      if (!childVal) {\n        return parentVal\n      }\n      if (!parentVal) {\n        return childVal\n      }\n      // when parentVal & childVal are both present,\n      // we need to return a function that returns the\n      // merged result of both functions... no need to\n      // check if parentVal is a function here because\n      // it has to be a function to pass previous merges.\n      return function mergedDataFn () {\n        return mergeData(\n          typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n          typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n        )\n      }\n    } else {\n      return function mergedInstanceDataFn () {\n        // instance merge\n        var instanceData = typeof childVal === 'function'\n          ? childVal.call(vm, vm)\n          : childVal;\n        var defaultData = typeof parentVal === 'function'\n          ? parentVal.call(vm, vm)\n          : parentVal;\n        if (instanceData) {\n          return mergeData(instanceData, defaultData)\n        } else {\n          return defaultData\n        }\n      }\n    }\n  }\n\n  strats.data = function (\n    parentVal,\n    childVal,\n    vm\n  ) {\n    if (!vm) {\n      if (childVal && typeof childVal !== 'function') {\n        warn(\n          'The \"data\" option should be a function ' +\n          'that returns a per-instance value in component ' +\n          'definitions.',\n          vm\n        );\n\n        return parentVal\n      }\n      return mergeDataOrFn(parentVal, childVal)\n    }\n\n    return mergeDataOrFn(parentVal, childVal, vm)\n  };\n\n  /**\n   * Hooks and props are merged as arrays.\n   */\n  function mergeHook (\n    parentVal,\n    childVal\n  ) {\n    var res = childVal\n      ? parentVal\n        ? parentVal.concat(childVal)\n        : Array.isArray(childVal)\n          ? childVal\n          : [childVal]\n      : parentVal;\n    return res\n      ? dedupeHooks(res)\n      : res\n  }\n\n  function dedupeHooks (hooks) {\n    var res = [];\n    for (var i = 0; i < hooks.length; i++) {\n      if (res.indexOf(hooks[i]) === -1) {\n        res.push(hooks[i]);\n      }\n    }\n    return res\n  }\n\n  LIFECYCLE_HOOKS.forEach(function (hook) {\n    strats[hook] = mergeHook;\n  });\n\n  /**\n   * Assets\n   *\n   * When a vm is present (instance creation), we need to do\n   * a three-way merge between constructor options, instance\n   * options and parent options.\n   */\n  function mergeAssets (\n    parentVal,\n    childVal,\n    vm,\n    key\n  ) {\n    var res = Object.create(parentVal || null);\n    if (childVal) {\n      assertObjectType(key, childVal, vm);\n      return extend(res, childVal)\n    } else {\n      return res\n    }\n  }\n\n  ASSET_TYPES.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n  });\n\n  /**\n   * Watchers.\n   *\n   * Watchers hashes should not overwrite one\n   * another, so we merge them as arrays.\n   */\n  strats.watch = function (\n    parentVal,\n    childVal,\n    vm,\n    key\n  ) {\n    // work around Firefox's Object.prototype.watch...\n    if (parentVal === nativeWatch) { parentVal = undefined; }\n    if (childVal === nativeWatch) { childVal = undefined; }\n    /* istanbul ignore if */\n    if (!childVal) { return Object.create(parentVal || null) }\n    {\n      assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal) { return childVal }\n    var ret = {};\n    extend(ret, parentVal);\n    for (var key$1 in childVal) {\n      var parent = ret[key$1];\n      var child = childVal[key$1];\n      if (parent && !Array.isArray(parent)) {\n        parent = [parent];\n      }\n      ret[key$1] = parent\n        ? parent.concat(child)\n        : Array.isArray(child) ? child : [child];\n    }\n    return ret\n  };\n\n  /**\n   * Other object hashes.\n   */\n  strats.props =\n  strats.methods =\n  strats.inject =\n  strats.computed = function (\n    parentVal,\n    childVal,\n    vm,\n    key\n  ) {\n    if (childVal && \"development\" !== 'production') {\n      assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal) { return childVal }\n    var ret = Object.create(null);\n    extend(ret, parentVal);\n    if (childVal) { extend(ret, childVal); }\n    return ret\n  };\n  strats.provide = mergeDataOrFn;\n\n  /**\n   * Default strategy.\n   */\n  var defaultStrat = function (parentVal, childVal) {\n    return childVal === undefined\n      ? parentVal\n      : childVal\n  };\n\n  /**\n   * Validate component names\n   */\n  function checkComponents (options) {\n    for (var key in options.components) {\n      validateComponentName(key);\n    }\n  }\n\n  function validateComponentName (name) {\n    if (!new RegExp((\"^[a-zA-Z][\\\\-\\\\.0-9_\" + (unicodeRegExp.source) + \"]*$\")).test(name)) {\n      warn(\n        'Invalid component name: \"' + name + '\". Component names ' +\n        'should conform to valid custom element name in html5 specification.'\n      );\n    }\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + name\n      );\n    }\n  }\n\n  /**\n   * Ensure all props option syntax are normalized into the\n   * Object-based format.\n   */\n  function normalizeProps (options, vm) {\n    var props = options.props;\n    if (!props) { return }\n    var res = {};\n    var i, val, name;\n    if (Array.isArray(props)) {\n      i = props.length;\n      while (i--) {\n        val = props[i];\n        if (typeof val === 'string') {\n          name = camelize(val);\n          res[name] = { type: null };\n        } else {\n          warn('props must be strings when using array syntax.');\n        }\n      }\n    } else if (isPlainObject(props)) {\n      for (var key in props) {\n        val = props[key];\n        name = camelize(key);\n        res[name] = isPlainObject(val)\n          ? val\n          : { type: val };\n      }\n    } else {\n      warn(\n        \"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n        \"but got \" + (toRawType(props)) + \".\",\n        vm\n      );\n    }\n    options.props = res;\n  }\n\n  /**\n   * Normalize all injections into Object-based format\n   */\n  function normalizeInject (options, vm) {\n    var inject = options.inject;\n    if (!inject) { return }\n    var normalized = options.inject = {};\n    if (Array.isArray(inject)) {\n      for (var i = 0; i < inject.length; i++) {\n        normalized[inject[i]] = { from: inject[i] };\n      }\n    } else if (isPlainObject(inject)) {\n      for (var key in inject) {\n        var val = inject[key];\n        normalized[key] = isPlainObject(val)\n          ? extend({ from: key }, val)\n          : { from: val };\n      }\n    } else {\n      warn(\n        \"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n        \"but got \" + (toRawType(inject)) + \".\",\n        vm\n      );\n    }\n  }\n\n  /**\n   * Normalize raw function directives into object format.\n   */\n  function normalizeDirectives (options) {\n    var dirs = options.directives;\n    if (dirs) {\n      for (var key in dirs) {\n        var def$$1 = dirs[key];\n        if (typeof def$$1 === 'function') {\n          dirs[key] = { bind: def$$1, update: def$$1 };\n        }\n      }\n    }\n  }\n\n  function assertObjectType (name, value, vm) {\n    if (!isPlainObject(value)) {\n      warn(\n        \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n        \"but got \" + (toRawType(value)) + \".\",\n        vm\n      );\n    }\n  }\n\n  /**\n   * Merge two option objects into a new one.\n   * Core utility used in both instantiation and inheritance.\n   */\n  function mergeOptions (\n    parent,\n    child,\n    vm\n  ) {\n    {\n      checkComponents(child);\n    }\n\n    if (typeof child === 'function') {\n      child = child.options;\n    }\n\n    normalizeProps(child, vm);\n    normalizeInject(child, vm);\n    normalizeDirectives(child);\n\n    // Apply extends and mixins on the child options,\n    // but only if it is a raw options object that isn't\n    // the result of another mergeOptions call.\n    // Only merged options has the _base property.\n    if (!child._base) {\n      if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm);\n      }\n      if (child.mixins) {\n        for (var i = 0, l = child.mixins.length; i < l; i++) {\n          parent = mergeOptions(parent, child.mixins[i], vm);\n        }\n      }\n    }\n\n    var options = {};\n    var key;\n    for (key in parent) {\n      mergeField(key);\n    }\n    for (key in child) {\n      if (!hasOwn(parent, key)) {\n        mergeField(key);\n      }\n    }\n    function mergeField (key) {\n      var strat = strats[key] || defaultStrat;\n      options[key] = strat(parent[key], child[key], vm, key);\n    }\n    return options\n  }\n\n  /**\n   * Resolve an asset.\n   * This function is used because child instances need access\n   * to assets defined in its ancestor chain.\n   */\n  function resolveAsset (\n    options,\n    type,\n    id,\n    warnMissing\n  ) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n      return\n    }\n    var assets = options[type];\n    // check local registration variations first\n    if (hasOwn(assets, id)) { return assets[id] }\n    var camelizedId = camelize(id);\n    if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n    var PascalCaseId = capitalize(camelizedId);\n    if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n    // fallback to prototype chain\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n    if (warnMissing && !res) {\n      warn(\n        'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n        options\n      );\n    }\n    return res\n  }\n\n  /*  */\n\n\n\n  function validateProp (\n    key,\n    propOptions,\n    propsData,\n    vm\n  ) {\n    var prop = propOptions[key];\n    var absent = !hasOwn(propsData, key);\n    var value = propsData[key];\n    // boolean casting\n    var booleanIndex = getTypeIndex(Boolean, prop.type);\n    if (booleanIndex > -1) {\n      if (absent && !hasOwn(prop, 'default')) {\n        value = false;\n      } else if (value === '' || value === hyphenate(key)) {\n        // only cast empty string / same name to boolean if\n        // boolean has higher priority\n        var stringIndex = getTypeIndex(String, prop.type);\n        if (stringIndex < 0 || booleanIndex < stringIndex) {\n          value = true;\n        }\n      }\n    }\n    // check default value\n    if (value === undefined) {\n      value = getPropDefaultValue(vm, prop, key);\n      // since the default value is a fresh copy,\n      // make sure to observe it.\n      var prevShouldObserve = shouldObserve;\n      toggleObserving(true);\n      observe(value);\n      toggleObserving(prevShouldObserve);\n    }\n    {\n      assertProp(prop, key, value, vm, absent);\n    }\n    return value\n  }\n\n  /**\n   * Get the default value of a prop.\n   */\n  function getPropDefaultValue (vm, prop, key) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n      return undefined\n    }\n    var def = prop.default;\n    // warn against non-factory defaults for Object & Array\n    if (isObject(def)) {\n      warn(\n        'Invalid default value for prop \"' + key + '\": ' +\n        'Props with type Object/Array must use a factory function ' +\n        'to return the default value.',\n        vm\n      );\n    }\n    // the raw prop value was also undefined from previous render,\n    // return previous default value to avoid unnecessary watcher trigger\n    if (vm && vm.$options.propsData &&\n      vm.$options.propsData[key] === undefined &&\n      vm._props[key] !== undefined\n    ) {\n      return vm._props[key]\n    }\n    // call factory function for non-Function types\n    // a value is Function if its prototype is function even across different execution context\n    return typeof def === 'function' && getType(prop.type) !== 'Function'\n      ? def.call(vm)\n      : def\n  }\n\n  /**\n   * Assert whether a prop is valid.\n   */\n  function assertProp (\n    prop,\n    name,\n    value,\n    vm,\n    absent\n  ) {\n    if (prop.required && absent) {\n      warn(\n        'Missing required prop: \"' + name + '\"',\n        vm\n      );\n      return\n    }\n    if (value == null && !prop.required) {\n      return\n    }\n    var type = prop.type;\n    var valid = !type || type === true;\n    var expectedTypes = [];\n    if (type) {\n      if (!Array.isArray(type)) {\n        type = [type];\n      }\n      for (var i = 0; i < type.length && !valid; i++) {\n        var assertedType = assertType(value, type[i]);\n        expectedTypes.push(assertedType.expectedType || '');\n        valid = assertedType.valid;\n      }\n    }\n\n    if (!valid) {\n      warn(\n        getInvalidTypeMessage(name, value, expectedTypes),\n        vm\n      );\n      return\n    }\n    var validator = prop.validator;\n    if (validator) {\n      if (!validator(value)) {\n        warn(\n          'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n          vm\n        );\n      }\n    }\n  }\n\n  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\n  function assertType (value, type) {\n    var valid;\n    var expectedType = getType(type);\n    if (simpleCheckRE.test(expectedType)) {\n      var t = typeof value;\n      valid = t === expectedType.toLowerCase();\n      // for primitive wrapper objects\n      if (!valid && t === 'object') {\n        valid = value instanceof type;\n      }\n    } else if (expectedType === 'Object') {\n      valid = isPlainObject(value);\n    } else if (expectedType === 'Array') {\n      valid = Array.isArray(value);\n    } else {\n      valid = value instanceof type;\n    }\n    return {\n      valid: valid,\n      expectedType: expectedType\n    }\n  }\n\n  /**\n   * Use function string name to check built-in types,\n   * because a simple equality check will fail when running\n   * across different vms / iframes.\n   */\n  function getType (fn) {\n    var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n    return match ? match[1] : ''\n  }\n\n  function isSameType (a, b) {\n    return getType(a) === getType(b)\n  }\n\n  function getTypeIndex (type, expectedTypes) {\n    if (!Array.isArray(expectedTypes)) {\n      return isSameType(expectedTypes, type) ? 0 : -1\n    }\n    for (var i = 0, len = expectedTypes.length; i < len; i++) {\n      if (isSameType(expectedTypes[i], type)) {\n        return i\n      }\n    }\n    return -1\n  }\n\n  function getInvalidTypeMessage (name, value, expectedTypes) {\n    var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n      \" Expected \" + (expectedTypes.map(capitalize).join(', '));\n    var expectedType = expectedTypes[0];\n    var receivedType = toRawType(value);\n    var expectedValue = styleValue(value, expectedType);\n    var receivedValue = styleValue(value, receivedType);\n    // check if we need to specify expected value\n    if (expectedTypes.length === 1 &&\n        isExplicable(expectedType) &&\n        !isBoolean(expectedType, receivedType)) {\n      message += \" with value \" + expectedValue;\n    }\n    message += \", got \" + receivedType + \" \";\n    // check if we need to specify received value\n    if (isExplicable(receivedType)) {\n      message += \"with value \" + receivedValue + \".\";\n    }\n    return message\n  }\n\n  function styleValue (value, type) {\n    if (type === 'String') {\n      return (\"\\\"\" + value + \"\\\"\")\n    } else if (type === 'Number') {\n      return (\"\" + (Number(value)))\n    } else {\n      return (\"\" + value)\n    }\n  }\n\n  function isExplicable (value) {\n    var explicitTypes = ['string', 'number', 'boolean'];\n    return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })\n  }\n\n  function isBoolean () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })\n  }\n\n  /*  */\n\n  function handleError (err, vm, info) {\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n    // See: https://github.com/vuejs/vuex/issues/1505\n    pushTarget();\n    try {\n      if (vm) {\n        var cur = vm;\n        while ((cur = cur.$parent)) {\n          var hooks = cur.$options.errorCaptured;\n          if (hooks) {\n            for (var i = 0; i < hooks.length; i++) {\n              try {\n                var capture = hooks[i].call(cur, err, vm, info) === false;\n                if (capture) { return }\n              } catch (e) {\n                globalHandleError(e, cur, 'errorCaptured hook');\n              }\n            }\n          }\n        }\n      }\n      globalHandleError(err, vm, info);\n    } finally {\n      popTarget();\n    }\n  }\n\n  function invokeWithErrorHandling (\n    handler,\n    context,\n    args,\n    vm,\n    info\n  ) {\n    var res;\n    try {\n      res = args ? handler.apply(context, args) : handler.call(context);\n      if (res && !res._isVue && isPromise(res) && !res._handled) {\n        res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\n        // issue #9511\n        // avoid catch triggering multiple times when nested calls\n        res._handled = true;\n      }\n    } catch (e) {\n      handleError(e, vm, info);\n    }\n    return res\n  }\n\n  function globalHandleError (err, vm, info) {\n    if (config.errorHandler) {\n      try {\n        return config.errorHandler.call(null, err, vm, info)\n      } catch (e) {\n        // if the user intentionally throws the original error in the handler,\n        // do not log it twice\n        if (e !== err) {\n          logError(e, null, 'config.errorHandler');\n        }\n      }\n    }\n    logError(err, vm, info);\n  }\n\n  function logError (err, vm, info) {\n    {\n      warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n    }\n    /* istanbul ignore else */\n    if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n\n  /*  */\n\n  var isUsingMicroTask = false;\n\n  var callbacks = [];\n  var pending = false;\n\n  function flushCallbacks () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // Here we have async deferring wrappers using microtasks.\n  // In 2.5 we used (macro) tasks (in combination with microtasks).\n  // However, it has subtle problems when state is changed right before repaint\n  // (e.g. #6813, out-in transitions).\n  // Also, using (macro) tasks in event handler would cause some weird behaviors\n  // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n  // So we now use microtasks everywhere, again.\n  // A major drawback of this tradeoff is that there are some scenarios\n  // where microtasks have too high a priority and fire in between supposedly\n  // sequential events (e.g. #4521, #6690, which have workarounds)\n  // or even between bubbling of the same event (#6566).\n  var timerFunc;\n\n  // The nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore next, $flow-disable-line */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    timerFunc = function () {\n      p.then(flushCallbacks);\n      // In problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n    isUsingMicroTask = true;\n  } else if (!isIE && typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // Use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS, iOS7, Android 4.4\n    // (#6466 MutationObserver is unreliable in IE11)\n    var counter = 1;\n    var observer = new MutationObserver(flushCallbacks);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n    isUsingMicroTask = true;\n  } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n    // Fallback to setImmediate.\n    // Technically it leverages the (macro) task queue,\n    // but it is still a better choice than setTimeout.\n    timerFunc = function () {\n      setImmediate(flushCallbacks);\n    };\n  } else {\n    // Fallback to setTimeout.\n    timerFunc = function () {\n      setTimeout(flushCallbacks, 0);\n    };\n  }\n\n  function nextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    // $flow-disable-line\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      })\n    }\n  }\n\n  /*  */\n\n  var mark;\n  var measure;\n\n  {\n    var perf = inBrowser && window.performance;\n    /* istanbul ignore if */\n    if (\n      perf &&\n      perf.mark &&\n      perf.measure &&\n      perf.clearMarks &&\n      perf.clearMeasures\n    ) {\n      mark = function (tag) { return perf.mark(tag); };\n      measure = function (name, startTag, endTag) {\n        perf.measure(name, startTag, endTag);\n        perf.clearMarks(startTag);\n        perf.clearMarks(endTag);\n        // perf.clearMeasures(name)\n      };\n    }\n  }\n\n  /* not type checking this file because flow doesn't play well with Proxy */\n\n  var initProxy;\n\n  {\n    var allowedGlobals = makeMap(\n      'Infinity,undefined,NaN,isFinite,isNaN,' +\n      'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n      'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n      'require' // for Webpack/Browserify\n    );\n\n    var warnNonPresent = function (target, key) {\n      warn(\n        \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n        'referenced during render. Make sure that this property is reactive, ' +\n        'either in the data option, or for class-based components, by ' +\n        'initializing the property. ' +\n        'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\n        target\n      );\n    };\n\n    var warnReservedPrefix = function (target, key) {\n      warn(\n        \"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" +\n        'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\n        'prevent conflicts with Vue internals. ' +\n        'See: https://vuejs.org/v2/api/#data',\n        target\n      );\n    };\n\n    var hasProxy =\n      typeof Proxy !== 'undefined' && isNative(Proxy);\n\n    if (hasProxy) {\n      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n      config.keyCodes = new Proxy(config.keyCodes, {\n        set: function set (target, key, value) {\n          if (isBuiltInModifier(key)) {\n            warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n            return false\n          } else {\n            target[key] = value;\n            return true\n          }\n        }\n      });\n    }\n\n    var hasHandler = {\n      has: function has (target, key) {\n        var has = key in target;\n        var isAllowed = allowedGlobals(key) ||\n          (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));\n        if (!has && !isAllowed) {\n          if (key in target.$data) { warnReservedPrefix(target, key); }\n          else { warnNonPresent(target, key); }\n        }\n        return has || !isAllowed\n      }\n    };\n\n    var getHandler = {\n      get: function get (target, key) {\n        if (typeof key === 'string' && !(key in target)) {\n          if (key in target.$data) { warnReservedPrefix(target, key); }\n          else { warnNonPresent(target, key); }\n        }\n        return target[key]\n      }\n    };\n\n    initProxy = function initProxy (vm) {\n      if (hasProxy) {\n        // determine which proxy handler to use\n        var options = vm.$options;\n        var handlers = options.render && options.render._withStripped\n          ? getHandler\n          : hasHandler;\n        vm._renderProxy = new Proxy(vm, handlers);\n      } else {\n        vm._renderProxy = vm;\n      }\n    };\n  }\n\n  /*  */\n\n  var seenObjects = new _Set();\n\n  /**\n   * Recursively traverse an object to evoke all converted\n   * getters, so that every nested property inside the object\n   * is collected as a \"deep\" dependency.\n   */\n  function traverse (val) {\n    _traverse(val, seenObjects);\n    seenObjects.clear();\n  }\n\n  function _traverse (val, seen) {\n    var i, keys;\n    var isA = Array.isArray(val);\n    if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n      return\n    }\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n      if (seen.has(depId)) {\n        return\n      }\n      seen.add(depId);\n    }\n    if (isA) {\n      i = val.length;\n      while (i--) { _traverse(val[i], seen); }\n    } else {\n      keys = Object.keys(val);\n      i = keys.length;\n      while (i--) { _traverse(val[keys[i]], seen); }\n    }\n  }\n\n  /*  */\n\n  var normalizeEvent = cached(function (name) {\n    var passive = name.charAt(0) === '&';\n    name = passive ? name.slice(1) : name;\n    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n    name = once$$1 ? name.slice(1) : name;\n    var capture = name.charAt(0) === '!';\n    name = capture ? name.slice(1) : name;\n    return {\n      name: name,\n      once: once$$1,\n      capture: capture,\n      passive: passive\n    }\n  });\n\n  function createFnInvoker (fns, vm) {\n    function invoker () {\n      var arguments$1 = arguments;\n\n      var fns = invoker.fns;\n      if (Array.isArray(fns)) {\n        var cloned = fns.slice();\n        for (var i = 0; i < cloned.length; i++) {\n          invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n        }\n      } else {\n        // return handler return value for single handlers\n        return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\")\n      }\n    }\n    invoker.fns = fns;\n    return invoker\n  }\n\n  function updateListeners (\n    on,\n    oldOn,\n    add,\n    remove$$1,\n    createOnceHandler,\n    vm\n  ) {\n    var name, def$$1, cur, old, event;\n    for (name in on) {\n      def$$1 = cur = on[name];\n      old = oldOn[name];\n      event = normalizeEvent(name);\n      if (isUndef(cur)) {\n        warn(\n          \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n          vm\n        );\n      } else if (isUndef(old)) {\n        if (isUndef(cur.fns)) {\n          cur = on[name] = createFnInvoker(cur, vm);\n        }\n        if (isTrue(event.once)) {\n          cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n        }\n        add(event.name, cur, event.capture, event.passive, event.params);\n      } else if (cur !== old) {\n        old.fns = cur;\n        on[name] = old;\n      }\n    }\n    for (name in oldOn) {\n      if (isUndef(on[name])) {\n        event = normalizeEvent(name);\n        remove$$1(event.name, oldOn[name], event.capture);\n      }\n    }\n  }\n\n  /*  */\n\n  function mergeVNodeHook (def, hookKey, hook) {\n    if (def instanceof VNode) {\n      def = def.data.hook || (def.data.hook = {});\n    }\n    var invoker;\n    var oldHook = def[hookKey];\n\n    function wrappedHook () {\n      hook.apply(this, arguments);\n      // important: remove merged hook to ensure it's called only once\n      // and prevent memory leak\n      remove(invoker.fns, wrappedHook);\n    }\n\n    if (isUndef(oldHook)) {\n      // no existing hook\n      invoker = createFnInvoker([wrappedHook]);\n    } else {\n      /* istanbul ignore if */\n      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n        // already a merged invoker\n        invoker = oldHook;\n        invoker.fns.push(wrappedHook);\n      } else {\n        // existing plain hook\n        invoker = createFnInvoker([oldHook, wrappedHook]);\n      }\n    }\n\n    invoker.merged = true;\n    def[hookKey] = invoker;\n  }\n\n  /*  */\n\n  function extractPropsFromVNodeData (\n    data,\n    Ctor,\n    tag\n  ) {\n    // we are only extracting raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    var propOptions = Ctor.options.props;\n    if (isUndef(propOptions)) {\n      return\n    }\n    var res = {};\n    var attrs = data.attrs;\n    var props = data.props;\n    if (isDef(attrs) || isDef(props)) {\n      for (var key in propOptions) {\n        var altKey = hyphenate(key);\n        {\n          var keyInLowerCase = key.toLowerCase();\n          if (\n            key !== keyInLowerCase &&\n            attrs && hasOwn(attrs, keyInLowerCase)\n          ) {\n            tip(\n              \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n              (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n              \" \\\"\" + key + \"\\\". \" +\n              \"Note that HTML attributes are case-insensitive and camelCased \" +\n              \"props need to use their kebab-case equivalents when using in-DOM \" +\n              \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n            );\n          }\n        }\n        checkProp(res, props, key, altKey, true) ||\n        checkProp(res, attrs, key, altKey, false);\n      }\n    }\n    return res\n  }\n\n  function checkProp (\n    res,\n    hash,\n    key,\n    altKey,\n    preserve\n  ) {\n    if (isDef(hash)) {\n      if (hasOwn(hash, key)) {\n        res[key] = hash[key];\n        if (!preserve) {\n          delete hash[key];\n        }\n        return true\n      } else if (hasOwn(hash, altKey)) {\n        res[key] = hash[altKey];\n        if (!preserve) {\n          delete hash[altKey];\n        }\n        return true\n      }\n    }\n    return false\n  }\n\n  /*  */\n\n  // The template compiler attempts to minimize the need for normalization by\n  // statically analyzing the template at compile time.\n  //\n  // For plain HTML markup, normalization can be completely skipped because the\n  // generated render function is guaranteed to return Array<VNode>. There are\n  // two cases where extra normalization is needed:\n\n  // 1. When the children contains components - because a functional component\n  // may return an Array instead of a single root. In this case, just a simple\n  // normalization is needed - if any child is an Array, we flatten the whole\n  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n  // because functional components already normalize their own children.\n  function simpleNormalizeChildren (children) {\n    for (var i = 0; i < children.length; i++) {\n      if (Array.isArray(children[i])) {\n        return Array.prototype.concat.apply([], children)\n      }\n    }\n    return children\n  }\n\n  // 2. When the children contains constructs that always generated nested Arrays,\n  // e.g. <template>, <slot>, v-for, or when the children is provided by user\n  // with hand-written render functions / JSX. In such cases a full normalization\n  // is needed to cater to all possible types of children values.\n  function normalizeChildren (children) {\n    return isPrimitive(children)\n      ? [createTextVNode(children)]\n      : Array.isArray(children)\n        ? normalizeArrayChildren(children)\n        : undefined\n  }\n\n  function isTextNode (node) {\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n  }\n\n  function normalizeArrayChildren (children, nestedIndex) {\n    var res = [];\n    var i, c, lastIndex, last;\n    for (i = 0; i < children.length; i++) {\n      c = children[i];\n      if (isUndef(c) || typeof c === 'boolean') { continue }\n      lastIndex = res.length - 1;\n      last = res[lastIndex];\n      //  nested\n      if (Array.isArray(c)) {\n        if (c.length > 0) {\n          c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n          // merge adjacent text nodes\n          if (isTextNode(c[0]) && isTextNode(last)) {\n            res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n            c.shift();\n          }\n          res.push.apply(res, c);\n        }\n      } else if (isPrimitive(c)) {\n        if (isTextNode(last)) {\n          // merge adjacent text nodes\n          // this is necessary for SSR hydration because text nodes are\n          // essentially merged when rendered to HTML strings\n          res[lastIndex] = createTextVNode(last.text + c);\n        } else if (c !== '') {\n          // convert primitive to vnode\n          res.push(createTextVNode(c));\n        }\n      } else {\n        if (isTextNode(c) && isTextNode(last)) {\n          // merge adjacent text nodes\n          res[lastIndex] = createTextVNode(last.text + c.text);\n        } else {\n          // default key for nested array children (likely generated by v-for)\n          if (isTrue(children._isVList) &&\n            isDef(c.tag) &&\n            isUndef(c.key) &&\n            isDef(nestedIndex)) {\n            c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n          }\n          res.push(c);\n        }\n      }\n    }\n    return res\n  }\n\n  /*  */\n\n  function initProvide (vm) {\n    var provide = vm.$options.provide;\n    if (provide) {\n      vm._provided = typeof provide === 'function'\n        ? provide.call(vm)\n        : provide;\n    }\n  }\n\n  function initInjections (vm) {\n    var result = resolveInject(vm.$options.inject, vm);\n    if (result) {\n      toggleObserving(false);\n      Object.keys(result).forEach(function (key) {\n        /* istanbul ignore else */\n        {\n          defineReactive$$1(vm, key, result[key], function () {\n            warn(\n              \"Avoid mutating an injected value directly since the changes will be \" +\n              \"overwritten whenever the provided component re-renders. \" +\n              \"injection being mutated: \\\"\" + key + \"\\\"\",\n              vm\n            );\n          });\n        }\n      });\n      toggleObserving(true);\n    }\n  }\n\n  function resolveInject (inject, vm) {\n    if (inject) {\n      // inject is :any because flow is not smart enough to figure out cached\n      var result = Object.create(null);\n      var keys = hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        // #6574 in case the inject object is observed...\n        if (key === '__ob__') { continue }\n        var provideKey = inject[key].from;\n        var source = vm;\n        while (source) {\n          if (source._provided && hasOwn(source._provided, provideKey)) {\n            result[key] = source._provided[provideKey];\n            break\n          }\n          source = source.$parent;\n        }\n        if (!source) {\n          if ('default' in inject[key]) {\n            var provideDefault = inject[key].default;\n            result[key] = typeof provideDefault === 'function'\n              ? provideDefault.call(vm)\n              : provideDefault;\n          } else {\n            warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n          }\n        }\n      }\n      return result\n    }\n  }\n\n  /*  */\n\n\n\n  /**\n   * Runtime helper for resolving raw children VNodes into a slot object.\n   */\n  function resolveSlots (\n    children,\n    context\n  ) {\n    if (!children || !children.length) {\n      return {}\n    }\n    var slots = {};\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      var data = child.data;\n      // remove slot attribute if the node is resolved as a Vue slot node\n      if (data && data.attrs && data.attrs.slot) {\n        delete data.attrs.slot;\n      }\n      // named slots should only be respected if the vnode was rendered in the\n      // same context.\n      if ((child.context === context || child.fnContext === context) &&\n        data && data.slot != null\n      ) {\n        var name = data.slot;\n        var slot = (slots[name] || (slots[name] = []));\n        if (child.tag === 'template') {\n          slot.push.apply(slot, child.children || []);\n        } else {\n          slot.push(child);\n        }\n      } else {\n        (slots.default || (slots.default = [])).push(child);\n      }\n    }\n    // ignore slots that contains only whitespace\n    for (var name$1 in slots) {\n      if (slots[name$1].every(isWhitespace)) {\n        delete slots[name$1];\n      }\n    }\n    return slots\n  }\n\n  function isWhitespace (node) {\n    return (node.isComment && !node.asyncFactory) || node.text === ' '\n  }\n\n  /*  */\n\n  function normalizeScopedSlots (\n    slots,\n    normalSlots,\n    prevSlots\n  ) {\n    var res;\n    var hasNormalSlots = Object.keys(normalSlots).length > 0;\n    var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n    var key = slots && slots.$key;\n    if (!slots) {\n      res = {};\n    } else if (slots._normalized) {\n      // fast path 1: child component re-render only, parent did not change\n      return slots._normalized\n    } else if (\n      isStable &&\n      prevSlots &&\n      prevSlots !== emptyObject &&\n      key === prevSlots.$key &&\n      !hasNormalSlots &&\n      !prevSlots.$hasNormal\n    ) {\n      // fast path 2: stable scoped slots w/ no normal slots to proxy,\n      // only need to normalize once\n      return prevSlots\n    } else {\n      res = {};\n      for (var key$1 in slots) {\n        if (slots[key$1] && key$1[0] !== '$') {\n          res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n        }\n      }\n    }\n    // expose normal slots on scopedSlots\n    for (var key$2 in normalSlots) {\n      if (!(key$2 in res)) {\n        res[key$2] = proxyNormalSlot(normalSlots, key$2);\n      }\n    }\n    // avoriaz seems to mock a non-extensible $scopedSlots object\n    // and when that is passed down this would cause an error\n    if (slots && Object.isExtensible(slots)) {\n      (slots)._normalized = res;\n    }\n    def(res, '$stable', isStable);\n    def(res, '$key', key);\n    def(res, '$hasNormal', hasNormalSlots);\n    return res\n  }\n\n  function normalizeScopedSlot(normalSlots, key, fn) {\n    var normalized = function () {\n      var res = arguments.length ? fn.apply(null, arguments) : fn({});\n      res = res && typeof res === 'object' && !Array.isArray(res)\n        ? [res] // single vnode\n        : normalizeChildren(res);\n      return res && (\n        res.length === 0 ||\n        (res.length === 1 && res[0].isComment) // #9658\n      ) ? undefined\n        : res\n    };\n    // this is a slot using the new v-slot syntax without scope. although it is\n    // compiled as a scoped slot, render fn users would expect it to be present\n    // on this.$slots because the usage is semantically a normal slot.\n    if (fn.proxy) {\n      Object.defineProperty(normalSlots, key, {\n        get: normalized,\n        enumerable: true,\n        configurable: true\n      });\n    }\n    return normalized\n  }\n\n  function proxyNormalSlot(slots, key) {\n    return function () { return slots[key]; }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering v-for lists.\n   */\n  function renderList (\n    val,\n    render\n  ) {\n    var ret, i, l, keys, key;\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      if (hasSymbol && val[Symbol.iterator]) {\n        ret = [];\n        var iterator = val[Symbol.iterator]();\n        var result = iterator.next();\n        while (!result.done) {\n          ret.push(render(result.value, ret.length));\n          result = iterator.next();\n        }\n      } else {\n        keys = Object.keys(val);\n        ret = new Array(keys.length);\n        for (i = 0, l = keys.length; i < l; i++) {\n          key = keys[i];\n          ret[i] = render(val[key], key, i);\n        }\n      }\n    }\n    if (!isDef(ret)) {\n      ret = [];\n    }\n    (ret)._isVList = true;\n    return ret\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering <slot>\n   */\n  function renderSlot (\n    name,\n    fallback,\n    props,\n    bindObject\n  ) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    var nodes;\n    if (scopedSlotFn) { // scoped slot\n      props = props || {};\n      if (bindObject) {\n        if (!isObject(bindObject)) {\n          warn(\n            'slot v-bind without argument expects an Object',\n            this\n          );\n        }\n        props = extend(extend({}, bindObject), props);\n      }\n      nodes = scopedSlotFn(props) || fallback;\n    } else {\n      nodes = this.$slots[name] || fallback;\n    }\n\n    var target = props && props.slot;\n    if (target) {\n      return this.$createElement('template', { slot: target }, nodes)\n    } else {\n      return nodes\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for resolving filters\n   */\n  function resolveFilter (id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity\n  }\n\n  /*  */\n\n  function isKeyNotMatch (expect, actual) {\n    if (Array.isArray(expect)) {\n      return expect.indexOf(actual) === -1\n    } else {\n      return expect !== actual\n    }\n  }\n\n  /**\n   * Runtime helper for checking keyCodes from config.\n   * exposed as Vue.prototype._k\n   * passing in eventKeyName as last argument separately for backwards compat\n   */\n  function checkKeyCodes (\n    eventKeyCode,\n    key,\n    builtInKeyCode,\n    eventKeyName,\n    builtInKeyName\n  ) {\n    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n      return isKeyNotMatch(builtInKeyName, eventKeyName)\n    } else if (mappedKeyCode) {\n      return isKeyNotMatch(mappedKeyCode, eventKeyCode)\n    } else if (eventKeyName) {\n      return hyphenate(eventKeyName) !== key\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n   */\n  function bindObjectProps (\n    data,\n    tag,\n    value,\n    asProp,\n    isSync\n  ) {\n    if (value) {\n      if (!isObject(value)) {\n        warn(\n          'v-bind without argument expects an Object or Array value',\n          this\n        );\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n        var hash;\n        var loop = function ( key ) {\n          if (\n            key === 'class' ||\n            key === 'style' ||\n            isReservedAttribute(key)\n          ) {\n            hash = data;\n          } else {\n            var type = data.attrs && data.attrs.type;\n            hash = asProp || config.mustUseProp(tag, type, key)\n              ? data.domProps || (data.domProps = {})\n              : data.attrs || (data.attrs = {});\n          }\n          var camelizedKey = camelize(key);\n          var hyphenatedKey = hyphenate(key);\n          if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n            hash[key] = value[key];\n\n            if (isSync) {\n              var on = data.on || (data.on = {});\n              on[(\"update:\" + key)] = function ($event) {\n                value[key] = $event;\n              };\n            }\n          }\n        };\n\n        for (var key in value) loop( key );\n      }\n    }\n    return data\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering static trees.\n   */\n  function renderStatic (\n    index,\n    isInFor\n  ) {\n    var cached = this._staticTrees || (this._staticTrees = []);\n    var tree = cached[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree.\n    if (tree && !isInFor) {\n      return tree\n    }\n    // otherwise, render a fresh tree.\n    tree = cached[index] = this.$options.staticRenderFns[index].call(\n      this._renderProxy,\n      null,\n      this // for render fns generated for functional component templates\n    );\n    markStatic(tree, (\"__static__\" + index), false);\n    return tree\n  }\n\n  /**\n   * Runtime helper for v-once.\n   * Effectively it means marking the node as static with a unique key.\n   */\n  function markOnce (\n    tree,\n    index,\n    key\n  ) {\n    markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n    return tree\n  }\n\n  function markStatic (\n    tree,\n    key,\n    isOnce\n  ) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode (node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n\n  /*  */\n\n  function bindObjectListeners (data, value) {\n    if (value) {\n      if (!isPlainObject(value)) {\n        warn(\n          'v-on without argument expects an Object value',\n          this\n        );\n      } else {\n        var on = data.on = data.on ? extend({}, data.on) : {};\n        for (var key in value) {\n          var existing = on[key];\n          var ours = value[key];\n          on[key] = existing ? [].concat(existing, ours) : ours;\n        }\n      }\n    }\n    return data\n  }\n\n  /*  */\n\n  function resolveScopedSlots (\n    fns, // see flow/vnode\n    res,\n    // the following are added in 2.6\n    hasDynamicKeys,\n    contentHashKey\n  ) {\n    res = res || { $stable: !hasDynamicKeys };\n    for (var i = 0; i < fns.length; i++) {\n      var slot = fns[i];\n      if (Array.isArray(slot)) {\n        resolveScopedSlots(slot, res, hasDynamicKeys);\n      } else if (slot) {\n        // marker for reverse proxying v-slot without scope on this.$slots\n        if (slot.proxy) {\n          slot.fn.proxy = true;\n        }\n        res[slot.key] = slot.fn;\n      }\n    }\n    if (contentHashKey) {\n      (res).$key = contentHashKey;\n    }\n    return res\n  }\n\n  /*  */\n\n  function bindDynamicKeys (baseObj, values) {\n    for (var i = 0; i < values.length; i += 2) {\n      var key = values[i];\n      if (typeof key === 'string' && key) {\n        baseObj[values[i]] = values[i + 1];\n      } else if (key !== '' && key !== null) {\n        // null is a special value for explicitly removing a binding\n        warn(\n          (\"Invalid value for dynamic directive argument (expected string or null): \" + key),\n          this\n        );\n      }\n    }\n    return baseObj\n  }\n\n  // helper to dynamically append modifier runtime markers to event names.\n  // ensure only append when value is already string, otherwise it will be cast\n  // to string and cause the type check to miss.\n  function prependModifier (value, symbol) {\n    return typeof value === 'string' ? symbol + value : value\n  }\n\n  /*  */\n\n  function installRenderHelpers (target) {\n    target._o = markOnce;\n    target._n = toNumber;\n    target._s = toString;\n    target._l = renderList;\n    target._t = renderSlot;\n    target._q = looseEqual;\n    target._i = looseIndexOf;\n    target._m = renderStatic;\n    target._f = resolveFilter;\n    target._k = checkKeyCodes;\n    target._b = bindObjectProps;\n    target._v = createTextVNode;\n    target._e = createEmptyVNode;\n    target._u = resolveScopedSlots;\n    target._g = bindObjectListeners;\n    target._d = bindDynamicKeys;\n    target._p = prependModifier;\n  }\n\n  /*  */\n\n  function FunctionalRenderContext (\n    data,\n    props,\n    children,\n    parent,\n    Ctor\n  ) {\n    var this$1 = this;\n\n    var options = Ctor.options;\n    // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n    var contextVm;\n    if (hasOwn(parent, '_uid')) {\n      contextVm = Object.create(parent);\n      // $flow-disable-line\n      contextVm._original = parent;\n    } else {\n      // the context vm passed in is a functional context as well.\n      // in this case we want to make sure we are able to get a hold to the\n      // real context instance.\n      contextVm = parent;\n      // $flow-disable-line\n      parent = parent._original;\n    }\n    var isCompiled = isTrue(options._compiled);\n    var needNormalization = !isCompiled;\n\n    this.data = data;\n    this.props = props;\n    this.children = children;\n    this.parent = parent;\n    this.listeners = data.on || emptyObject;\n    this.injections = resolveInject(options.inject, parent);\n    this.slots = function () {\n      if (!this$1.$slots) {\n        normalizeScopedSlots(\n          data.scopedSlots,\n          this$1.$slots = resolveSlots(children, parent)\n        );\n      }\n      return this$1.$slots\n    };\n\n    Object.defineProperty(this, 'scopedSlots', ({\n      enumerable: true,\n      get: function get () {\n        return normalizeScopedSlots(data.scopedSlots, this.slots())\n      }\n    }));\n\n    // support for compiled functional template\n    if (isCompiled) {\n      // exposing $options for renderStatic()\n      this.$options = options;\n      // pre-resolve slots for renderSlot()\n      this.$slots = this.slots();\n      this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n    }\n\n    if (options._scopeId) {\n      this._c = function (a, b, c, d) {\n        var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n        if (vnode && !Array.isArray(vnode)) {\n          vnode.fnScopeId = options._scopeId;\n          vnode.fnContext = parent;\n        }\n        return vnode\n      };\n    } else {\n      this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n    }\n  }\n\n  installRenderHelpers(FunctionalRenderContext.prototype);\n\n  function createFunctionalComponent (\n    Ctor,\n    propsData,\n    data,\n    contextVm,\n    children\n  ) {\n    var options = Ctor.options;\n    var props = {};\n    var propOptions = options.props;\n    if (isDef(propOptions)) {\n      for (var key in propOptions) {\n        props[key] = validateProp(key, propOptions, propsData || emptyObject);\n      }\n    } else {\n      if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n      if (isDef(data.props)) { mergeProps(props, data.props); }\n    }\n\n    var renderContext = new FunctionalRenderContext(\n      data,\n      props,\n      children,\n      contextVm,\n      Ctor\n    );\n\n    var vnode = options.render.call(null, renderContext._c, renderContext);\n\n    if (vnode instanceof VNode) {\n      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)\n    } else if (Array.isArray(vnode)) {\n      var vnodes = normalizeChildren(vnode) || [];\n      var res = new Array(vnodes.length);\n      for (var i = 0; i < vnodes.length; i++) {\n        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n      }\n      return res\n    }\n  }\n\n  function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\n    // that should not be matched to match.\n    var clone = cloneVNode(vnode);\n    clone.fnContext = contextVm;\n    clone.fnOptions = options;\n    {\n      (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n    }\n    if (data.slot) {\n      (clone.data || (clone.data = {})).slot = data.slot;\n    }\n    return clone\n  }\n\n  function mergeProps (to, from) {\n    for (var key in from) {\n      to[camelize(key)] = from[key];\n    }\n  }\n\n  /*  */\n\n  /*  */\n\n  /*  */\n\n  /*  */\n\n  // inline hooks to be invoked on component VNodes during patch\n  var componentVNodeHooks = {\n    init: function init (vnode, hydrating) {\n      if (\n        vnode.componentInstance &&\n        !vnode.componentInstance._isDestroyed &&\n        vnode.data.keepAlive\n      ) {\n        // kept-alive components, treat as a patch\n        var mountedNode = vnode; // work around flow\n        componentVNodeHooks.prepatch(mountedNode, mountedNode);\n      } else {\n        var child = vnode.componentInstance = createComponentInstanceForVnode(\n          vnode,\n          activeInstance\n        );\n        child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n      }\n    },\n\n    prepatch: function prepatch (oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(\n        child,\n        options.propsData, // updated props\n        options.listeners, // updated listeners\n        vnode, // new parent vnode\n        options.children // new children\n      );\n    },\n\n    insert: function insert (vnode) {\n      var context = vnode.context;\n      var componentInstance = vnode.componentInstance;\n      if (!componentInstance._isMounted) {\n        componentInstance._isMounted = true;\n        callHook(componentInstance, 'mounted');\n      }\n      if (vnode.data.keepAlive) {\n        if (context._isMounted) {\n          // vue-router#1212\n          // During updates, a kept-alive component's child components may\n          // change, so directly walking the tree here may call activated hooks\n          // on incorrect children. Instead we push them into a queue which will\n          // be processed after the whole patch process ended.\n          queueActivatedComponent(componentInstance);\n        } else {\n          activateChildComponent(componentInstance, true /* direct */);\n        }\n      }\n    },\n\n    destroy: function destroy (vnode) {\n      var componentInstance = vnode.componentInstance;\n      if (!componentInstance._isDestroyed) {\n        if (!vnode.data.keepAlive) {\n          componentInstance.$destroy();\n        } else {\n          deactivateChildComponent(componentInstance, true /* direct */);\n        }\n      }\n    }\n  };\n\n  var hooksToMerge = Object.keys(componentVNodeHooks);\n\n  function createComponent (\n    Ctor,\n    data,\n    context,\n    children,\n    tag\n  ) {\n    if (isUndef(Ctor)) {\n      return\n    }\n\n    var baseCtor = context.$options._base;\n\n    // plain options object: turn it into a constructor\n    if (isObject(Ctor)) {\n      Ctor = baseCtor.extend(Ctor);\n    }\n\n    // if at this stage it's not a constructor or an async component factory,\n    // reject.\n    if (typeof Ctor !== 'function') {\n      {\n        warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n      }\n      return\n    }\n\n    // async component\n    var asyncFactory;\n    if (isUndef(Ctor.cid)) {\n      asyncFactory = Ctor;\n      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n      if (Ctor === undefined) {\n        // return a placeholder node for async component, which is rendered\n        // as a comment node but preserves all the raw information for the node.\n        // the information will be used for async server-rendering and hydration.\n        return createAsyncPlaceholder(\n          asyncFactory,\n          data,\n          context,\n          children,\n          tag\n        )\n      }\n    }\n\n    data = data || {};\n\n    // resolve constructor options in case global mixins are applied after\n    // component constructor creation\n    resolveConstructorOptions(Ctor);\n\n    // transform component v-model data into props & events\n    if (isDef(data.model)) {\n      transformModel(Ctor.options, data);\n    }\n\n    // extract props\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n    // functional component\n    if (isTrue(Ctor.options.functional)) {\n      return createFunctionalComponent(Ctor, propsData, data, context, children)\n    }\n\n    // extract listeners, since these needs to be treated as\n    // child component listeners instead of DOM listeners\n    var listeners = data.on;\n    // replace with listeners with .native modifier\n    // so it gets processed during parent component patch.\n    data.on = data.nativeOn;\n\n    if (isTrue(Ctor.options.abstract)) {\n      // abstract components do not keep anything\n      // other than props & listeners & slot\n\n      // work around flow\n      var slot = data.slot;\n      data = {};\n      if (slot) {\n        data.slot = slot;\n      }\n    }\n\n    // install component management hooks onto the placeholder node\n    installComponentHooks(data);\n\n    // return a placeholder vnode\n    var name = Ctor.options.name || tag;\n    var vnode = new VNode(\n      (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n      data, undefined, undefined, undefined, context,\n      { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n      asyncFactory\n    );\n\n    return vnode\n  }\n\n  function createComponentInstanceForVnode (\n    vnode, // we know it's MountedComponentVNode but flow doesn't\n    parent // activeInstance in lifecycle state\n  ) {\n    var options = {\n      _isComponent: true,\n      _parentVnode: vnode,\n      parent: parent\n    };\n    // check inline-template render functions\n    var inlineTemplate = vnode.data.inlineTemplate;\n    if (isDef(inlineTemplate)) {\n      options.render = inlineTemplate.render;\n      options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n    return new vnode.componentOptions.Ctor(options)\n  }\n\n  function installComponentHooks (data) {\n    var hooks = data.hook || (data.hook = {});\n    for (var i = 0; i < hooksToMerge.length; i++) {\n      var key = hooksToMerge[i];\n      var existing = hooks[key];\n      var toMerge = componentVNodeHooks[key];\n      if (existing !== toMerge && !(existing && existing._merged)) {\n        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n      }\n    }\n  }\n\n  function mergeHook$1 (f1, f2) {\n    var merged = function (a, b) {\n      // flow complains about extra args which is why we use any\n      f1(a, b);\n      f2(a, b);\n    };\n    merged._merged = true;\n    return merged\n  }\n\n  // transform component v-model info (value and callback) into\n  // prop and event handler respectively.\n  function transformModel (options, data) {\n    var prop = (options.model && options.model.prop) || 'value';\n    var event = (options.model && options.model.event) || 'input'\n    ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;\n    var on = data.on || (data.on = {});\n    var existing = on[event];\n    var callback = data.model.callback;\n    if (isDef(existing)) {\n      if (\n        Array.isArray(existing)\n          ? existing.indexOf(callback) === -1\n          : existing !== callback\n      ) {\n        on[event] = [callback].concat(existing);\n      }\n    } else {\n      on[event] = callback;\n    }\n  }\n\n  /*  */\n\n  var SIMPLE_NORMALIZE = 1;\n  var ALWAYS_NORMALIZE = 2;\n\n  // wrapper function for providing a more flexible interface\n  // without getting yelled at by flow\n  function createElement (\n    context,\n    tag,\n    data,\n    children,\n    normalizationType,\n    alwaysNormalize\n  ) {\n    if (Array.isArray(data) || isPrimitive(data)) {\n      normalizationType = children;\n      children = data;\n      data = undefined;\n    }\n    if (isTrue(alwaysNormalize)) {\n      normalizationType = ALWAYS_NORMALIZE;\n    }\n    return _createElement(context, tag, data, children, normalizationType)\n  }\n\n  function _createElement (\n    context,\n    tag,\n    data,\n    children,\n    normalizationType\n  ) {\n    if (isDef(data) && isDef((data).__ob__)) {\n      warn(\n        \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n        'Always create fresh vnode data objects in each render!',\n        context\n      );\n      return createEmptyVNode()\n    }\n    // object syntax in v-bind\n    if (isDef(data) && isDef(data.is)) {\n      tag = data.is;\n    }\n    if (!tag) {\n      // in case of component :is set to falsy value\n      return createEmptyVNode()\n    }\n    // warn against non-primitive key\n    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n    ) {\n      {\n        warn(\n          'Avoid using non-primitive value as key, ' +\n          'use string/number value instead.',\n          context\n        );\n      }\n    }\n    // support single function children as default scoped slot\n    if (Array.isArray(children) &&\n      typeof children[0] === 'function'\n    ) {\n      data = data || {};\n      data.scopedSlots = { default: children[0] };\n      children.length = 0;\n    }\n    if (normalizationType === ALWAYS_NORMALIZE) {\n      children = normalizeChildren(children);\n    } else if (normalizationType === SIMPLE_NORMALIZE) {\n      children = simpleNormalizeChildren(children);\n    }\n    var vnode, ns;\n    if (typeof tag === 'string') {\n      var Ctor;\n      ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n      if (config.isReservedTag(tag)) {\n        // platform built-in elements\n        if (isDef(data) && isDef(data.nativeOn)) {\n          warn(\n            (\"The .native modifier for v-on is only valid on components but it was used on <\" + tag + \">.\"),\n            context\n          );\n        }\n        vnode = new VNode(\n          config.parsePlatformTagName(tag), data, children,\n          undefined, undefined, context\n        );\n      } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n        // component\n        vnode = createComponent(Ctor, data, context, children, tag);\n      } else {\n        // unknown or unlisted namespaced elements\n        // check at runtime because it may get assigned a namespace when its\n        // parent normalizes children\n        vnode = new VNode(\n          tag, data, children,\n          undefined, undefined, context\n        );\n      }\n    } else {\n      // direct component options / constructor\n      vnode = createComponent(tag, data, context, children);\n    }\n    if (Array.isArray(vnode)) {\n      return vnode\n    } else if (isDef(vnode)) {\n      if (isDef(ns)) { applyNS(vnode, ns); }\n      if (isDef(data)) { registerDeepBindings(data); }\n      return vnode\n    } else {\n      return createEmptyVNode()\n    }\n  }\n\n  function applyNS (vnode, ns, force) {\n    vnode.ns = ns;\n    if (vnode.tag === 'foreignObject') {\n      // use default namespace inside foreignObject\n      ns = undefined;\n      force = true;\n    }\n    if (isDef(vnode.children)) {\n      for (var i = 0, l = vnode.children.length; i < l; i++) {\n        var child = vnode.children[i];\n        if (isDef(child.tag) && (\n          isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n          applyNS(child, ns, force);\n        }\n      }\n    }\n  }\n\n  // ref #5318\n  // necessary to ensure parent re-render when deep bindings like :style and\n  // :class are used on slot nodes\n  function registerDeepBindings (data) {\n    if (isObject(data.style)) {\n      traverse(data.style);\n    }\n    if (isObject(data.class)) {\n      traverse(data.class);\n    }\n  }\n\n  /*  */\n\n  function initRender (vm) {\n    vm._vnode = null; // the root of the child tree\n    vm._staticTrees = null; // v-once cached trees\n    var options = vm.$options;\n    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n    var renderContext = parentVnode && parentVnode.context;\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\n    vm.$scopedSlots = emptyObject;\n    // bind the createElement fn to this instance\n    // so that we get proper render context inside it.\n    // args order: tag, data, children, normalizationType, alwaysNormalize\n    // internal version is used by render functions compiled from templates\n    vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n    // normalization is always applied for the public version, used in\n    // user-written render functions.\n    vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n    // $attrs & $listeners are exposed for easier HOC creation.\n    // they need to be reactive so that HOCs using them are always updated\n    var parentData = parentVnode && parentVnode.data;\n\n    /* istanbul ignore else */\n    {\n      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n      }, true);\n      defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n      }, true);\n    }\n  }\n\n  var currentRenderingInstance = null;\n\n  function renderMixin (Vue) {\n    // install runtime convenience helpers\n    installRenderHelpers(Vue.prototype);\n\n    Vue.prototype.$nextTick = function (fn) {\n      return nextTick(fn, this)\n    };\n\n    Vue.prototype._render = function () {\n      var vm = this;\n      var ref = vm.$options;\n      var render = ref.render;\n      var _parentVnode = ref._parentVnode;\n\n      if (_parentVnode) {\n        vm.$scopedSlots = normalizeScopedSlots(\n          _parentVnode.data.scopedSlots,\n          vm.$slots,\n          vm.$scopedSlots\n        );\n      }\n\n      // set parent vnode. this allows render functions to have access\n      // to the data on the placeholder node.\n      vm.$vnode = _parentVnode;\n      // render self\n      var vnode;\n      try {\n        // There's no need to maintain a stack because all render fns are called\n        // separately from one another. Nested component's render fns are called\n        // when parent component is patched.\n        currentRenderingInstance = vm;\n        vnode = render.call(vm._renderProxy, vm.$createElement);\n      } catch (e) {\n        handleError(e, vm, \"render\");\n        // return error render result,\n        // or previous vnode to prevent render error causing blank component\n        /* istanbul ignore else */\n        if (vm.$options.renderError) {\n          try {\n            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n          } catch (e) {\n            handleError(e, vm, \"renderError\");\n            vnode = vm._vnode;\n          }\n        } else {\n          vnode = vm._vnode;\n        }\n      } finally {\n        currentRenderingInstance = null;\n      }\n      // if the returned array contains only a single node, allow it\n      if (Array.isArray(vnode) && vnode.length === 1) {\n        vnode = vnode[0];\n      }\n      // return empty vnode in case the render function errored out\n      if (!(vnode instanceof VNode)) {\n        if (Array.isArray(vnode)) {\n          warn(\n            'Multiple root nodes returned from render function. Render function ' +\n            'should return a single root node.',\n            vm\n          );\n        }\n        vnode = createEmptyVNode();\n      }\n      // set parent\n      vnode.parent = _parentVnode;\n      return vnode\n    };\n  }\n\n  /*  */\n\n  function ensureCtor (comp, base) {\n    if (\n      comp.__esModule ||\n      (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n    ) {\n      comp = comp.default;\n    }\n    return isObject(comp)\n      ? base.extend(comp)\n      : comp\n  }\n\n  function createAsyncPlaceholder (\n    factory,\n    data,\n    context,\n    children,\n    tag\n  ) {\n    var node = createEmptyVNode();\n    node.asyncFactory = factory;\n    node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n    return node\n  }\n\n  function resolveAsyncComponent (\n    factory,\n    baseCtor\n  ) {\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\n      return factory.errorComp\n    }\n\n    if (isDef(factory.resolved)) {\n      return factory.resolved\n    }\n\n    var owner = currentRenderingInstance;\n    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n      // already pending\n      factory.owners.push(owner);\n    }\n\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n      return factory.loadingComp\n    }\n\n    if (owner && !isDef(factory.owners)) {\n      var owners = factory.owners = [owner];\n      var sync = true;\n      var timerLoading = null;\n      var timerTimeout = null\n\n      ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });\n\n      var forceRender = function (renderCompleted) {\n        for (var i = 0, l = owners.length; i < l; i++) {\n          (owners[i]).$forceUpdate();\n        }\n\n        if (renderCompleted) {\n          owners.length = 0;\n          if (timerLoading !== null) {\n            clearTimeout(timerLoading);\n            timerLoading = null;\n          }\n          if (timerTimeout !== null) {\n            clearTimeout(timerTimeout);\n            timerTimeout = null;\n          }\n        }\n      };\n\n      var resolve = once(function (res) {\n        // cache resolved\n        factory.resolved = ensureCtor(res, baseCtor);\n        // invoke callbacks only if this is not a synchronous resolve\n        // (async resolves are shimmed as synchronous during SSR)\n        if (!sync) {\n          forceRender(true);\n        } else {\n          owners.length = 0;\n        }\n      });\n\n      var reject = once(function (reason) {\n        warn(\n          \"Failed to resolve async component: \" + (String(factory)) +\n          (reason ? (\"\\nReason: \" + reason) : '')\n        );\n        if (isDef(factory.errorComp)) {\n          factory.error = true;\n          forceRender(true);\n        }\n      });\n\n      var res = factory(resolve, reject);\n\n      if (isObject(res)) {\n        if (isPromise(res)) {\n          // () => Promise\n          if (isUndef(factory.resolved)) {\n            res.then(resolve, reject);\n          }\n        } else if (isPromise(res.component)) {\n          res.component.then(resolve, reject);\n\n          if (isDef(res.error)) {\n            factory.errorComp = ensureCtor(res.error, baseCtor);\n          }\n\n          if (isDef(res.loading)) {\n            factory.loadingComp = ensureCtor(res.loading, baseCtor);\n            if (res.delay === 0) {\n              factory.loading = true;\n            } else {\n              timerLoading = setTimeout(function () {\n                timerLoading = null;\n                if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                  factory.loading = true;\n                  forceRender(false);\n                }\n              }, res.delay || 200);\n            }\n          }\n\n          if (isDef(res.timeout)) {\n            timerTimeout = setTimeout(function () {\n              timerTimeout = null;\n              if (isUndef(factory.resolved)) {\n                reject(\n                  \"timeout (\" + (res.timeout) + \"ms)\"\n                );\n              }\n            }, res.timeout);\n          }\n        }\n      }\n\n      sync = false;\n      // return in case resolved synchronously\n      return factory.loading\n        ? factory.loadingComp\n        : factory.resolved\n    }\n  }\n\n  /*  */\n\n  function isAsyncPlaceholder (node) {\n    return node.isComment && node.asyncFactory\n  }\n\n  /*  */\n\n  function getFirstComponentChild (children) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var c = children[i];\n        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n          return c\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  /*  */\n\n  function initEvents (vm) {\n    vm._events = Object.create(null);\n    vm._hasHookEvent = false;\n    // init parent attached events\n    var listeners = vm.$options._parentListeners;\n    if (listeners) {\n      updateComponentListeners(vm, listeners);\n    }\n  }\n\n  var target;\n\n  function add (event, fn) {\n    target.$on(event, fn);\n  }\n\n  function remove$1 (event, fn) {\n    target.$off(event, fn);\n  }\n\n  function createOnceHandler (event, fn) {\n    var _target = target;\n    return function onceHandler () {\n      var res = fn.apply(null, arguments);\n      if (res !== null) {\n        _target.$off(event, onceHandler);\n      }\n    }\n  }\n\n  function updateComponentListeners (\n    vm,\n    listeners,\n    oldListeners\n  ) {\n    target = vm;\n    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n    target = undefined;\n  }\n\n  function eventsMixin (Vue) {\n    var hookRE = /^hook:/;\n    Vue.prototype.$on = function (event, fn) {\n      var vm = this;\n      if (Array.isArray(event)) {\n        for (var i = 0, l = event.length; i < l; i++) {\n          vm.$on(event[i], fn);\n        }\n      } else {\n        (vm._events[event] || (vm._events[event] = [])).push(fn);\n        // optimize hook:event cost by using a boolean flag marked at registration\n        // instead of a hash lookup\n        if (hookRE.test(event)) {\n          vm._hasHookEvent = true;\n        }\n      }\n      return vm\n    };\n\n    Vue.prototype.$once = function (event, fn) {\n      var vm = this;\n      function on () {\n        vm.$off(event, on);\n        fn.apply(vm, arguments);\n      }\n      on.fn = fn;\n      vm.$on(event, on);\n      return vm\n    };\n\n    Vue.prototype.$off = function (event, fn) {\n      var vm = this;\n      // all\n      if (!arguments.length) {\n        vm._events = Object.create(null);\n        return vm\n      }\n      // array of events\n      if (Array.isArray(event)) {\n        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n          vm.$off(event[i$1], fn);\n        }\n        return vm\n      }\n      // specific event\n      var cbs = vm._events[event];\n      if (!cbs) {\n        return vm\n      }\n      if (!fn) {\n        vm._events[event] = null;\n        return vm\n      }\n      // specific handler\n      var cb;\n      var i = cbs.length;\n      while (i--) {\n        cb = cbs[i];\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i, 1);\n          break\n        }\n      }\n      return vm\n    };\n\n    Vue.prototype.$emit = function (event) {\n      var vm = this;\n      {\n        var lowerCaseEvent = event.toLowerCase();\n        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n          tip(\n            \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n            (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and you cannot use \" +\n            \"v-on to listen to camelCase events when using in-DOM templates. \" +\n            \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n          );\n        }\n      }\n      var cbs = vm._events[event];\n      if (cbs) {\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n        var args = toArray(arguments, 1);\n        var info = \"event handler for \\\"\" + event + \"\\\"\";\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n        }\n      }\n      return vm\n    };\n  }\n\n  /*  */\n\n  var activeInstance = null;\n  var isUpdatingChildComponent = false;\n\n  function setActiveInstance(vm) {\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    return function () {\n      activeInstance = prevActiveInstance;\n    }\n  }\n\n  function initLifecycle (vm) {\n    var options = vm.$options;\n\n    // locate first non-abstract parent\n    var parent = options.parent;\n    if (parent && !options.abstract) {\n      while (parent.$options.abstract && parent.$parent) {\n        parent = parent.$parent;\n      }\n      parent.$children.push(vm);\n    }\n\n    vm.$parent = parent;\n    vm.$root = parent ? parent.$root : vm;\n\n    vm.$children = [];\n    vm.$refs = {};\n\n    vm._watcher = null;\n    vm._inactive = null;\n    vm._directInactive = false;\n    vm._isMounted = false;\n    vm._isDestroyed = false;\n    vm._isBeingDestroyed = false;\n  }\n\n  function lifecycleMixin (Vue) {\n    Vue.prototype._update = function (vnode, hydrating) {\n      var vm = this;\n      var prevEl = vm.$el;\n      var prevVnode = vm._vnode;\n      var restoreActiveInstance = setActiveInstance(vm);\n      vm._vnode = vnode;\n      // Vue.prototype.__patch__ is injected in entry points\n      // based on the rendering backend used.\n      if (!prevVnode) {\n        // initial render\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n      } else {\n        // updates\n        vm.$el = vm.__patch__(prevVnode, vnode);\n      }\n      restoreActiveInstance();\n      // update __vue__ reference\n      if (prevEl) {\n        prevEl.__vue__ = null;\n      }\n      if (vm.$el) {\n        vm.$el.__vue__ = vm;\n      }\n      // if parent is an HOC, update its $el as well\n      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n        vm.$parent.$el = vm.$el;\n      }\n      // updated hook is called by the scheduler to ensure that children are\n      // updated in a parent's updated hook.\n    };\n\n    Vue.prototype.$forceUpdate = function () {\n      var vm = this;\n      if (vm._watcher) {\n        vm._watcher.update();\n      }\n    };\n\n    Vue.prototype.$destroy = function () {\n      var vm = this;\n      if (vm._isBeingDestroyed) {\n        return\n      }\n      callHook(vm, 'beforeDestroy');\n      vm._isBeingDestroyed = true;\n      // remove self from parent\n      var parent = vm.$parent;\n      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n        remove(parent.$children, vm);\n      }\n      // teardown watchers\n      if (vm._watcher) {\n        vm._watcher.teardown();\n      }\n      var i = vm._watchers.length;\n      while (i--) {\n        vm._watchers[i].teardown();\n      }\n      // remove reference from data ob\n      // frozen object may not have observer.\n      if (vm._data.__ob__) {\n        vm._data.__ob__.vmCount--;\n      }\n      // call the last hook...\n      vm._isDestroyed = true;\n      // invoke destroy hooks on current rendered tree\n      vm.__patch__(vm._vnode, null);\n      // fire destroyed hook\n      callHook(vm, 'destroyed');\n      // turn off all instance listeners.\n      vm.$off();\n      // remove __vue__ reference\n      if (vm.$el) {\n        vm.$el.__vue__ = null;\n      }\n      // release circular reference (#6759)\n      if (vm.$vnode) {\n        vm.$vnode.parent = null;\n      }\n    };\n  }\n\n  function mountComponent (\n    vm,\n    el,\n    hydrating\n  ) {\n    vm.$el = el;\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      {\n        /* istanbul ignore if */\n        if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n          vm.$options.el || el) {\n          warn(\n            'You are using the runtime-only build of Vue where the template ' +\n            'compiler is not available. Either pre-compile the templates into ' +\n            'render functions, or use the compiler-included build.',\n            vm\n          );\n        } else {\n          warn(\n            'Failed to mount component: template or render function not defined.',\n            vm\n          );\n        }\n      }\n    }\n    callHook(vm, 'beforeMount');\n\n    var updateComponent;\n    /* istanbul ignore if */\n    if (config.performance && mark) {\n      updateComponent = function () {\n        var name = vm._name;\n        var id = vm._uid;\n        var startTag = \"vue-perf-start:\" + id;\n        var endTag = \"vue-perf-end:\" + id;\n\n        mark(startTag);\n        var vnode = vm._render();\n        mark(endTag);\n        measure((\"vue \" + name + \" render\"), startTag, endTag);\n\n        mark(startTag);\n        vm._update(vnode, hydrating);\n        mark(endTag);\n        measure((\"vue \" + name + \" patch\"), startTag, endTag);\n      };\n    } else {\n      updateComponent = function () {\n        vm._update(vm._render(), hydrating);\n      };\n    }\n\n    // we set this to vm._watcher inside the watcher's constructor\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n    // component's mounted hook), which relies on vm._watcher being already defined\n    new Watcher(vm, updateComponent, noop, {\n      before: function before () {\n        if (vm._isMounted && !vm._isDestroyed) {\n          callHook(vm, 'beforeUpdate');\n        }\n      }\n    }, true /* isRenderWatcher */);\n    hydrating = false;\n\n    // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n    return vm\n  }\n\n  function updateChildComponent (\n    vm,\n    propsData,\n    listeners,\n    parentVnode,\n    renderChildren\n  ) {\n    {\n      isUpdatingChildComponent = true;\n    }\n\n    // determine whether component has slot children\n    // we need to do this before overwriting $options._renderChildren.\n\n    // check if there are dynamic scopedSlots (hand-written or compiled but with\n    // dynamic slot names). Static scoped slots compiled from template has the\n    // \"$stable\" marker.\n    var newScopedSlots = parentVnode.data.scopedSlots;\n    var oldScopedSlots = vm.$scopedSlots;\n    var hasDynamicScopedSlot = !!(\n      (newScopedSlots && !newScopedSlots.$stable) ||\n      (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n      (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)\n    );\n\n    // Any static slot children from the parent may have changed during parent's\n    // update. Dynamic scoped slots may also have changed. In such cases, a forced\n    // update is necessary to ensure correctness.\n    var needsForceUpdate = !!(\n      renderChildren ||               // has new static slots\n      vm.$options._renderChildren ||  // has old static slots\n      hasDynamicScopedSlot\n    );\n\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n    if (vm._vnode) { // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n    vm.$options._renderChildren = renderChildren;\n\n    // update $attrs and $listeners hash\n    // these are also reactive so they may trigger child update if the child\n    // used them during render\n    vm.$attrs = parentVnode.data.attrs || emptyObject;\n    vm.$listeners = listeners || emptyObject;\n\n    // update props\n    if (propsData && vm.$options.props) {\n      toggleObserving(false);\n      var props = vm._props;\n      var propKeys = vm.$options._propKeys || [];\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        var propOptions = vm.$options.props; // wtf flow?\n        props[key] = validateProp(key, propOptions, propsData, vm);\n      }\n      toggleObserving(true);\n      // keep a copy of raw propsData\n      vm.$options.propsData = propsData;\n    }\n\n    // update listeners\n    listeners = listeners || emptyObject;\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n\n    // resolve slots + force update if has children\n    if (needsForceUpdate) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n\n    {\n      isUpdatingChildComponent = false;\n    }\n  }\n\n  function isInInactiveTree (vm) {\n    while (vm && (vm = vm.$parent)) {\n      if (vm._inactive) { return true }\n    }\n    return false\n  }\n\n  function activateChildComponent (vm, direct) {\n    if (direct) {\n      vm._directInactive = false;\n      if (isInInactiveTree(vm)) {\n        return\n      }\n    } else if (vm._directInactive) {\n      return\n    }\n    if (vm._inactive || vm._inactive === null) {\n      vm._inactive = false;\n      for (var i = 0; i < vm.$children.length; i++) {\n        activateChildComponent(vm.$children[i]);\n      }\n      callHook(vm, 'activated');\n    }\n  }\n\n  function deactivateChildComponent (vm, direct) {\n    if (direct) {\n      vm._directInactive = true;\n      if (isInInactiveTree(vm)) {\n        return\n      }\n    }\n    if (!vm._inactive) {\n      vm._inactive = true;\n      for (var i = 0; i < vm.$children.length; i++) {\n        deactivateChildComponent(vm.$children[i]);\n      }\n      callHook(vm, 'deactivated');\n    }\n  }\n\n  function callHook (vm, hook) {\n    // #7573 disable dep collection when invoking lifecycle hooks\n    pushTarget();\n    var handlers = vm.$options[hook];\n    var info = hook + \" hook\";\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n      }\n    }\n    if (vm._hasHookEvent) {\n      vm.$emit('hook:' + hook);\n    }\n    popTarget();\n  }\n\n  /*  */\n\n  var MAX_UPDATE_COUNT = 100;\n\n  var queue = [];\n  var activatedChildren = [];\n  var has = {};\n  var circular = {};\n  var waiting = false;\n  var flushing = false;\n  var index = 0;\n\n  /**\n   * Reset the scheduler's state.\n   */\n  function resetSchedulerState () {\n    index = queue.length = activatedChildren.length = 0;\n    has = {};\n    {\n      circular = {};\n    }\n    waiting = flushing = false;\n  }\n\n  // Async edge case #6566 requires saving the timestamp when event listeners are\n  // attached. However, calling performance.now() has a perf overhead especially\n  // if the page has thousands of event listeners. Instead, we take a timestamp\n  // every time the scheduler flushes and use that for all event listeners\n  // attached during that flush.\n  var currentFlushTimestamp = 0;\n\n  // Async edge case fix requires storing an event listener's attach timestamp.\n  var getNow = Date.now;\n\n  // Determine what event timestamp the browser is using. Annoyingly, the\n  // timestamp can either be hi-res (relative to page load) or low-res\n  // (relative to UNIX epoch), so in order to compare time we have to use the\n  // same timestamp type when saving the flush timestamp.\n  // All IE versions use low-res event timestamps, and have problematic clock\n  // implementations (#9632)\n  if (inBrowser && !isIE) {\n    var performance = window.performance;\n    if (\n      performance &&\n      typeof performance.now === 'function' &&\n      getNow() > document.createEvent('Event').timeStamp\n    ) {\n      // if the event timestamp, although evaluated AFTER the Date.now(), is\n      // smaller than it, it means the event is using a hi-res timestamp,\n      // and we need to use the hi-res version for event listener timestamps as\n      // well.\n      getNow = function () { return performance.now(); };\n    }\n  }\n\n  /**\n   * Flush both queues and run the watchers.\n   */\n  function flushSchedulerQueue () {\n    currentFlushTimestamp = getNow();\n    flushing = true;\n    var watcher, id;\n\n    // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child)\n    // 2. A component's user watchers are run before its render watcher (because\n    //    user watchers are created before the render watcher)\n    // 3. If a component is destroyed during a parent component's watcher run,\n    //    its watchers can be skipped.\n    queue.sort(function (a, b) { return a.id - b.id; });\n\n    // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n    for (index = 0; index < queue.length; index++) {\n      watcher = queue[index];\n      if (watcher.before) {\n        watcher.before();\n      }\n      id = watcher.id;\n      has[id] = null;\n      watcher.run();\n      // in dev build, check and stop circular updates.\n      if (has[id] != null) {\n        circular[id] = (circular[id] || 0) + 1;\n        if (circular[id] > MAX_UPDATE_COUNT) {\n          warn(\n            'You may have an infinite update loop ' + (\n              watcher.user\n                ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n                : \"in a component render function.\"\n            ),\n            watcher.vm\n          );\n          break\n        }\n      }\n    }\n\n    // keep copies of post queues before resetting state\n    var activatedQueue = activatedChildren.slice();\n    var updatedQueue = queue.slice();\n\n    resetSchedulerState();\n\n    // call component updated and activated hooks\n    callActivatedHooks(activatedQueue);\n    callUpdatedHooks(updatedQueue);\n\n    // devtool hook\n    /* istanbul ignore if */\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n  }\n\n  function callUpdatedHooks (queue) {\n    var i = queue.length;\n    while (i--) {\n      var watcher = queue[i];\n      var vm = watcher.vm;\n      if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'updated');\n      }\n    }\n  }\n\n  /**\n   * Queue a kept-alive component that was activated during patch.\n   * The queue will be processed after the entire tree has been patched.\n   */\n  function queueActivatedComponent (vm) {\n    // setting _inactive to false here so that a render function can\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\n    vm._inactive = false;\n    activatedChildren.push(vm);\n  }\n\n  function callActivatedHooks (queue) {\n    for (var i = 0; i < queue.length; i++) {\n      queue[i]._inactive = true;\n      activateChildComponent(queue[i], true /* true */);\n    }\n  }\n\n  /**\n   * Push a watcher into the watcher queue.\n   * Jobs with duplicate IDs will be skipped unless it's\n   * pushed when the queue is being flushed.\n   */\n  function queueWatcher (watcher) {\n    var id = watcher.id;\n    if (has[id] == null) {\n      has[id] = true;\n      if (!flushing) {\n        queue.push(watcher);\n      } else {\n        // if already flushing, splice the watcher based on its id\n        // if already past its id, it will be run next immediately.\n        var i = queue.length - 1;\n        while (i > index && queue[i].id > watcher.id) {\n          i--;\n        }\n        queue.splice(i + 1, 0, watcher);\n      }\n      // queue the flush\n      if (!waiting) {\n        waiting = true;\n\n        if (!config.async) {\n          flushSchedulerQueue();\n          return\n        }\n        nextTick(flushSchedulerQueue);\n      }\n    }\n  }\n\n  /*  */\n\n\n\n  var uid$2 = 0;\n\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   * This is used for both the $watch() api and directives.\n   */\n  var Watcher = function Watcher (\n    vm,\n    expOrFn,\n    cb,\n    options,\n    isRenderWatcher\n  ) {\n    this.vm = vm;\n    if (isRenderWatcher) {\n      vm._watcher = this;\n    }\n    vm._watchers.push(this);\n    // options\n    if (options) {\n      this.deep = !!options.deep;\n      this.user = !!options.user;\n      this.lazy = !!options.lazy;\n      this.sync = !!options.sync;\n      this.before = options.before;\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false;\n    }\n    this.cb = cb;\n    this.id = ++uid$2; // uid for batching\n    this.active = true;\n    this.dirty = this.lazy; // for lazy watchers\n    this.deps = [];\n    this.newDeps = [];\n    this.depIds = new _Set();\n    this.newDepIds = new _Set();\n    this.expression = expOrFn.toString();\n    // parse expression for getter\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn;\n    } else {\n      this.getter = parsePath(expOrFn);\n      if (!this.getter) {\n        this.getter = noop;\n        warn(\n          \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n          'Watcher only accepts simple dot-delimited paths. ' +\n          'For full control, use a function instead.',\n          vm\n        );\n      }\n    }\n    this.value = this.lazy\n      ? undefined\n      : this.get();\n  };\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n  Watcher.prototype.get = function get () {\n    pushTarget(this);\n    var value;\n    var vm = this.vm;\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n      } else {\n        throw e\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value);\n      }\n      popTarget();\n      this.cleanupDeps();\n    }\n    return value\n  };\n\n  /**\n   * Add a dependency to this directive.\n   */\n  Watcher.prototype.addDep = function addDep (dep) {\n    var id = dep.id;\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id);\n      this.newDeps.push(dep);\n      if (!this.depIds.has(id)) {\n        dep.addSub(this);\n      }\n    }\n  };\n\n  /**\n   * Clean up for dependency collection.\n   */\n  Watcher.prototype.cleanupDeps = function cleanupDeps () {\n    var i = this.deps.length;\n    while (i--) {\n      var dep = this.deps[i];\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this);\n      }\n    }\n    var tmp = this.depIds;\n    this.depIds = this.newDepIds;\n    this.newDepIds = tmp;\n    this.newDepIds.clear();\n    tmp = this.deps;\n    this.deps = this.newDeps;\n    this.newDeps = tmp;\n    this.newDeps.length = 0;\n  };\n\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n  Watcher.prototype.update = function update () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true;\n    } else if (this.sync) {\n      this.run();\n    } else {\n      queueWatcher(this);\n    }\n  };\n\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n  Watcher.prototype.run = function run () {\n    if (this.active) {\n      var value = this.get();\n      if (\n        value !== this.value ||\n        // Deep watchers and watchers on Object/Arrays should fire even\n        // when the value is the same, because the value may\n        // have mutated.\n        isObject(value) ||\n        this.deep\n      ) {\n        // set new value\n        var oldValue = this.value;\n        this.value = value;\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue);\n          } catch (e) {\n            handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue);\n        }\n      }\n    }\n  };\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n  Watcher.prototype.evaluate = function evaluate () {\n    this.value = this.get();\n    this.dirty = false;\n  };\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n  Watcher.prototype.depend = function depend () {\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].depend();\n    }\n  };\n\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n  Watcher.prototype.teardown = function teardown () {\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this);\n      }\n      var i = this.deps.length;\n      while (i--) {\n        this.deps[i].removeSub(this);\n      }\n      this.active = false;\n    }\n  };\n\n  /*  */\n\n  var sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n  };\n\n  function proxy (target, sourceKey, key) {\n    sharedPropertyDefinition.get = function proxyGetter () {\n      return this[sourceKey][key]\n    };\n    sharedPropertyDefinition.set = function proxySetter (val) {\n      this[sourceKey][key] = val;\n    };\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function initState (vm) {\n    vm._watchers = [];\n    var opts = vm.$options;\n    if (opts.props) { initProps(vm, opts.props); }\n    if (opts.methods) { initMethods(vm, opts.methods); }\n    if (opts.data) {\n      initData(vm);\n    } else {\n      observe(vm._data = {}, true /* asRootData */);\n    }\n    if (opts.computed) { initComputed(vm, opts.computed); }\n    if (opts.watch && opts.watch !== nativeWatch) {\n      initWatch(vm, opts.watch);\n    }\n  }\n\n  function initProps (vm, propsOptions) {\n    var propsData = vm.$options.propsData || {};\n    var props = vm._props = {};\n    // cache prop keys so that future props updates can iterate using Array\n    // instead of dynamic object key enumeration.\n    var keys = vm.$options._propKeys = [];\n    var isRoot = !vm.$parent;\n    // root instance props should be converted\n    if (!isRoot) {\n      toggleObserving(false);\n    }\n    var loop = function ( key ) {\n      keys.push(key);\n      var value = validateProp(key, propsOptions, propsData, vm);\n      /* istanbul ignore else */\n      {\n        var hyphenatedKey = hyphenate(key);\n        if (isReservedAttribute(hyphenatedKey) ||\n            config.isReservedAttr(hyphenatedKey)) {\n          warn(\n            (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n            vm\n          );\n        }\n        defineReactive$$1(props, key, value, function () {\n          if (!isRoot && !isUpdatingChildComponent) {\n            warn(\n              \"Avoid mutating a prop directly since the value will be \" +\n              \"overwritten whenever the parent component re-renders. \" +\n              \"Instead, use a data or computed property based on the prop's \" +\n              \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n              vm\n            );\n          }\n        });\n      }\n      // static props are already proxied on the component's prototype\n      // during Vue.extend(). We only need to proxy props defined at\n      // instantiation here.\n      if (!(key in vm)) {\n        proxy(vm, \"_props\", key);\n      }\n    };\n\n    for (var key in propsOptions) loop( key );\n    toggleObserving(true);\n  }\n\n  function initData (vm) {\n    var data = vm.$options.data;\n    data = vm._data = typeof data === 'function'\n      ? getData(data, vm)\n      : data || {};\n    if (!isPlainObject(data)) {\n      data = {};\n      warn(\n        'data functions should return an object:\\n' +\n        'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n        vm\n      );\n    }\n    // proxy data on instance\n    var keys = Object.keys(data);\n    var props = vm.$options.props;\n    var methods = vm.$options.methods;\n    var i = keys.length;\n    while (i--) {\n      var key = keys[i];\n      {\n        if (methods && hasOwn(methods, key)) {\n          warn(\n            (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n            vm\n          );\n        }\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n          \"Use prop default value instead.\",\n          vm\n        );\n      } else if (!isReserved(key)) {\n        proxy(vm, \"_data\", key);\n      }\n    }\n    // observe data\n    observe(data, true /* asRootData */);\n  }\n\n  function getData (data, vm) {\n    // #7573 disable dep collection when invoking data getters\n    pushTarget();\n    try {\n      return data.call(vm, vm)\n    } catch (e) {\n      handleError(e, vm, \"data()\");\n      return {}\n    } finally {\n      popTarget();\n    }\n  }\n\n  var computedWatcherOptions = { lazy: true };\n\n  function initComputed (vm, computed) {\n    // $flow-disable-line\n    var watchers = vm._computedWatchers = Object.create(null);\n    // computed properties are just getters during SSR\n    var isSSR = isServerRendering();\n\n    for (var key in computed) {\n      var userDef = computed[key];\n      var getter = typeof userDef === 'function' ? userDef : userDef.get;\n      if (getter == null) {\n        warn(\n          (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n          vm\n        );\n      }\n\n      if (!isSSR) {\n        // create internal watcher for the computed property.\n        watchers[key] = new Watcher(\n          vm,\n          getter || noop,\n          noop,\n          computedWatcherOptions\n        );\n      }\n\n      // component-defined computed properties are already defined on the\n      // component prototype. We only need to define computed properties defined\n      // at instantiation here.\n      if (!(key in vm)) {\n        defineComputed(vm, key, userDef);\n      } else {\n        if (key in vm.$data) {\n          warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n        } else if (vm.$options.props && key in vm.$options.props) {\n          warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n        }\n      }\n    }\n  }\n\n  function defineComputed (\n    target,\n    key,\n    userDef\n  ) {\n    var shouldCache = !isServerRendering();\n    if (typeof userDef === 'function') {\n      sharedPropertyDefinition.get = shouldCache\n        ? createComputedGetter(key)\n        : createGetterInvoker(userDef);\n      sharedPropertyDefinition.set = noop;\n    } else {\n      sharedPropertyDefinition.get = userDef.get\n        ? shouldCache && userDef.cache !== false\n          ? createComputedGetter(key)\n          : createGetterInvoker(userDef.get)\n        : noop;\n      sharedPropertyDefinition.set = userDef.set || noop;\n    }\n    if (sharedPropertyDefinition.set === noop) {\n      sharedPropertyDefinition.set = function () {\n        warn(\n          (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n          this\n        );\n      };\n    }\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function createComputedGetter (key) {\n    return function computedGetter () {\n      var watcher = this._computedWatchers && this._computedWatchers[key];\n      if (watcher) {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n        if (Dep.target) {\n          watcher.depend();\n        }\n        return watcher.value\n      }\n    }\n  }\n\n  function createGetterInvoker(fn) {\n    return function computedGetter () {\n      return fn.call(this, this)\n    }\n  }\n\n  function initMethods (vm, methods) {\n    var props = vm.$options.props;\n    for (var key in methods) {\n      {\n        if (typeof methods[key] !== 'function') {\n          warn(\n            \"Method \\\"\" + key + \"\\\" has type \\\"\" + (typeof methods[key]) + \"\\\" in the component definition. \" +\n            \"Did you reference the function correctly?\",\n            vm\n          );\n        }\n        if (props && hasOwn(props, key)) {\n          warn(\n            (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n            vm\n          );\n        }\n        if ((key in vm) && isReserved(key)) {\n          warn(\n            \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n            \"Avoid defining component methods that start with _ or $.\"\n          );\n        }\n      }\n      vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n    }\n  }\n\n  function initWatch (vm, watch) {\n    for (var key in watch) {\n      var handler = watch[key];\n      if (Array.isArray(handler)) {\n        for (var i = 0; i < handler.length; i++) {\n          createWatcher(vm, key, handler[i]);\n        }\n      } else {\n        createWatcher(vm, key, handler);\n      }\n    }\n  }\n\n  function createWatcher (\n    vm,\n    expOrFn,\n    handler,\n    options\n  ) {\n    if (isPlainObject(handler)) {\n      options = handler;\n      handler = handler.handler;\n    }\n    if (typeof handler === 'string') {\n      handler = vm[handler];\n    }\n    return vm.$watch(expOrFn, handler, options)\n  }\n\n  function stateMixin (Vue) {\n    // flow somehow has problems with directly declared definition object\n    // when using Object.defineProperty, so we have to procedurally build up\n    // the object here.\n    var dataDef = {};\n    dataDef.get = function () { return this._data };\n    var propsDef = {};\n    propsDef.get = function () { return this._props };\n    {\n      dataDef.set = function () {\n        warn(\n          'Avoid replacing instance root $data. ' +\n          'Use nested data properties instead.',\n          this\n        );\n      };\n      propsDef.set = function () {\n        warn(\"$props is readonly.\", this);\n      };\n    }\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n    Vue.prototype.$set = set;\n    Vue.prototype.$delete = del;\n\n    Vue.prototype.$watch = function (\n      expOrFn,\n      cb,\n      options\n    ) {\n      var vm = this;\n      if (isPlainObject(cb)) {\n        return createWatcher(vm, expOrFn, cb, options)\n      }\n      options = options || {};\n      options.user = true;\n      var watcher = new Watcher(vm, expOrFn, cb, options);\n      if (options.immediate) {\n        try {\n          cb.call(vm, watcher.value);\n        } catch (error) {\n          handleError(error, vm, (\"callback for immediate watcher \\\"\" + (watcher.expression) + \"\\\"\"));\n        }\n      }\n      return function unwatchFn () {\n        watcher.teardown();\n      }\n    };\n  }\n\n  /*  */\n\n  var uid$3 = 0;\n\n  function initMixin (Vue) {\n    Vue.prototype._init = function (options) {\n      var vm = this;\n      // a uid\n      vm._uid = uid$3++;\n\n      var startTag, endTag;\n      /* istanbul ignore if */\n      if (config.performance && mark) {\n        startTag = \"vue-perf-start:\" + (vm._uid);\n        endTag = \"vue-perf-end:\" + (vm._uid);\n        mark(startTag);\n      }\n\n      // a flag to avoid this being observed\n      vm._isVue = true;\n      // merge options\n      if (options && options._isComponent) {\n        // optimize internal component instantiation\n        // since dynamic options merging is pretty slow, and none of the\n        // internal component options needs special treatment.\n        initInternalComponent(vm, options);\n      } else {\n        vm.$options = mergeOptions(\n          resolveConstructorOptions(vm.constructor),\n          options || {},\n          vm\n        );\n      }\n      /* istanbul ignore else */\n      {\n        initProxy(vm);\n      }\n      // expose real self\n      vm._self = vm;\n      initLifecycle(vm);\n      initEvents(vm);\n      initRender(vm);\n      callHook(vm, 'beforeCreate');\n      initInjections(vm); // resolve injections before data/props\n      initState(vm);\n      initProvide(vm); // resolve provide after data/props\n      callHook(vm, 'created');\n\n      /* istanbul ignore if */\n      if (config.performance && mark) {\n        vm._name = formatComponentName(vm, false);\n        mark(endTag);\n        measure((\"vue \" + (vm._name) + \" init\"), startTag, endTag);\n      }\n\n      if (vm.$options.el) {\n        vm.$mount(vm.$options.el);\n      }\n    };\n  }\n\n  function initInternalComponent (vm, options) {\n    var opts = vm.$options = Object.create(vm.constructor.options);\n    // doing this because it's faster than dynamic enumeration.\n    var parentVnode = options._parentVnode;\n    opts.parent = options.parent;\n    opts._parentVnode = parentVnode;\n\n    var vnodeComponentOptions = parentVnode.componentOptions;\n    opts.propsData = vnodeComponentOptions.propsData;\n    opts._parentListeners = vnodeComponentOptions.listeners;\n    opts._renderChildren = vnodeComponentOptions.children;\n    opts._componentTag = vnodeComponentOptions.tag;\n\n    if (options.render) {\n      opts.render = options.render;\n      opts.staticRenderFns = options.staticRenderFns;\n    }\n  }\n\n  function resolveConstructorOptions (Ctor) {\n    var options = Ctor.options;\n    if (Ctor.super) {\n      var superOptions = resolveConstructorOptions(Ctor.super);\n      var cachedSuperOptions = Ctor.superOptions;\n      if (superOptions !== cachedSuperOptions) {\n        // super option changed,\n        // need to resolve new options.\n        Ctor.superOptions = superOptions;\n        // check if there are any late-modified/attached options (#4976)\n        var modifiedOptions = resolveModifiedOptions(Ctor);\n        // update base extend options\n        if (modifiedOptions) {\n          extend(Ctor.extendOptions, modifiedOptions);\n        }\n        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n        if (options.name) {\n          options.components[options.name] = Ctor;\n        }\n      }\n    }\n    return options\n  }\n\n  function resolveModifiedOptions (Ctor) {\n    var modified;\n    var latest = Ctor.options;\n    var sealed = Ctor.sealedOptions;\n    for (var key in latest) {\n      if (latest[key] !== sealed[key]) {\n        if (!modified) { modified = {}; }\n        modified[key] = latest[key];\n      }\n    }\n    return modified\n  }\n\n  function Vue (options) {\n    if (!(this instanceof Vue)\n    ) {\n      warn('Vue is a constructor and should be called with the `new` keyword');\n    }\n    this._init(options);\n  }\n\n  initMixin(Vue);\n  stateMixin(Vue);\n  eventsMixin(Vue);\n  lifecycleMixin(Vue);\n  renderMixin(Vue);\n\n  /*  */\n\n  function initUse (Vue) {\n    Vue.use = function (plugin) {\n      var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n      if (installedPlugins.indexOf(plugin) > -1) {\n        return this\n      }\n\n      // additional parameters\n      var args = toArray(arguments, 1);\n      args.unshift(this);\n      if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args);\n      } else if (typeof plugin === 'function') {\n        plugin.apply(null, args);\n      }\n      installedPlugins.push(plugin);\n      return this\n    };\n  }\n\n  /*  */\n\n  function initMixin$1 (Vue) {\n    Vue.mixin = function (mixin) {\n      this.options = mergeOptions(this.options, mixin);\n      return this\n    };\n  }\n\n  /*  */\n\n  function initExtend (Vue) {\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n    Vue.cid = 0;\n    var cid = 1;\n\n    /**\n     * Class inheritance\n     */\n    Vue.extend = function (extendOptions) {\n      extendOptions = extendOptions || {};\n      var Super = this;\n      var SuperId = Super.cid;\n      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n      if (cachedCtors[SuperId]) {\n        return cachedCtors[SuperId]\n      }\n\n      var name = extendOptions.name || Super.options.name;\n      if (name) {\n        validateComponentName(name);\n      }\n\n      var Sub = function VueComponent (options) {\n        this._init(options);\n      };\n      Sub.prototype = Object.create(Super.prototype);\n      Sub.prototype.constructor = Sub;\n      Sub.cid = cid++;\n      Sub.options = mergeOptions(\n        Super.options,\n        extendOptions\n      );\n      Sub['super'] = Super;\n\n      // For props and computed properties, we define the proxy getters on\n      // the Vue instances at extension time, on the extended prototype. This\n      // avoids Object.defineProperty calls for each instance created.\n      if (Sub.options.props) {\n        initProps$1(Sub);\n      }\n      if (Sub.options.computed) {\n        initComputed$1(Sub);\n      }\n\n      // allow further extension/mixin/plugin usage\n      Sub.extend = Super.extend;\n      Sub.mixin = Super.mixin;\n      Sub.use = Super.use;\n\n      // create asset registers, so extended classes\n      // can have their private assets too.\n      ASSET_TYPES.forEach(function (type) {\n        Sub[type] = Super[type];\n      });\n      // enable recursive self-lookup\n      if (name) {\n        Sub.options.components[name] = Sub;\n      }\n\n      // keep a reference to the super options at extension time.\n      // later at instantiation we can check if Super's options have\n      // been updated.\n      Sub.superOptions = Super.options;\n      Sub.extendOptions = extendOptions;\n      Sub.sealedOptions = extend({}, Sub.options);\n\n      // cache constructor\n      cachedCtors[SuperId] = Sub;\n      return Sub\n    };\n  }\n\n  function initProps$1 (Comp) {\n    var props = Comp.options.props;\n    for (var key in props) {\n      proxy(Comp.prototype, \"_props\", key);\n    }\n  }\n\n  function initComputed$1 (Comp) {\n    var computed = Comp.options.computed;\n    for (var key in computed) {\n      defineComputed(Comp.prototype, key, computed[key]);\n    }\n  }\n\n  /*  */\n\n  function initAssetRegisters (Vue) {\n    /**\n     * Create asset registration methods.\n     */\n    ASSET_TYPES.forEach(function (type) {\n      Vue[type] = function (\n        id,\n        definition\n      ) {\n        if (!definition) {\n          return this.options[type + 's'][id]\n        } else {\n          /* istanbul ignore if */\n          if (type === 'component') {\n            validateComponentName(id);\n          }\n          if (type === 'component' && isPlainObject(definition)) {\n            definition.name = definition.name || id;\n            definition = this.options._base.extend(definition);\n          }\n          if (type === 'directive' && typeof definition === 'function') {\n            definition = { bind: definition, update: definition };\n          }\n          this.options[type + 's'][id] = definition;\n          return definition\n        }\n      };\n    });\n  }\n\n  /*  */\n\n\n\n  function getComponentName (opts) {\n    return opts && (opts.Ctor.options.name || opts.tag)\n  }\n\n  function matches (pattern, name) {\n    if (Array.isArray(pattern)) {\n      return pattern.indexOf(name) > -1\n    } else if (typeof pattern === 'string') {\n      return pattern.split(',').indexOf(name) > -1\n    } else if (isRegExp(pattern)) {\n      return pattern.test(name)\n    }\n    /* istanbul ignore next */\n    return false\n  }\n\n  function pruneCache (keepAliveInstance, filter) {\n    var cache = keepAliveInstance.cache;\n    var keys = keepAliveInstance.keys;\n    var _vnode = keepAliveInstance._vnode;\n    for (var key in cache) {\n      var cachedNode = cache[key];\n      if (cachedNode) {\n        var name = getComponentName(cachedNode.componentOptions);\n        if (name && !filter(name)) {\n          pruneCacheEntry(cache, key, keys, _vnode);\n        }\n      }\n    }\n  }\n\n  function pruneCacheEntry (\n    cache,\n    key,\n    keys,\n    current\n  ) {\n    var cached$$1 = cache[key];\n    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n      cached$$1.componentInstance.$destroy();\n    }\n    cache[key] = null;\n    remove(keys, key);\n  }\n\n  var patternTypes = [String, RegExp, Array];\n\n  var KeepAlive = {\n    name: 'keep-alive',\n    abstract: true,\n\n    props: {\n      include: patternTypes,\n      exclude: patternTypes,\n      max: [String, Number]\n    },\n\n    created: function created () {\n      this.cache = Object.create(null);\n      this.keys = [];\n    },\n\n    destroyed: function destroyed () {\n      for (var key in this.cache) {\n        pruneCacheEntry(this.cache, key, this.keys);\n      }\n    },\n\n    mounted: function mounted () {\n      var this$1 = this;\n\n      this.$watch('include', function (val) {\n        pruneCache(this$1, function (name) { return matches(val, name); });\n      });\n      this.$watch('exclude', function (val) {\n        pruneCache(this$1, function (name) { return !matches(val, name); });\n      });\n    },\n\n    render: function render () {\n      var slot = this.$slots.default;\n      var vnode = getFirstComponentChild(slot);\n      var componentOptions = vnode && vnode.componentOptions;\n      if (componentOptions) {\n        // check pattern\n        var name = getComponentName(componentOptions);\n        var ref = this;\n        var include = ref.include;\n        var exclude = ref.exclude;\n        if (\n          // not included\n          (include && (!name || !matches(include, name))) ||\n          // excluded\n          (exclude && name && matches(exclude, name))\n        ) {\n          return vnode\n        }\n\n        var ref$1 = this;\n        var cache = ref$1.cache;\n        var keys = ref$1.keys;\n        var key = vnode.key == null\n          // same constructor may get registered as different local components\n          // so cid alone is not enough (#3269)\n          ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n          : vnode.key;\n        if (cache[key]) {\n          vnode.componentInstance = cache[key].componentInstance;\n          // make current key freshest\n          remove(keys, key);\n          keys.push(key);\n        } else {\n          cache[key] = vnode;\n          keys.push(key);\n          // prune oldest entry\n          if (this.max && keys.length > parseInt(this.max)) {\n            pruneCacheEntry(cache, keys[0], keys, this._vnode);\n          }\n        }\n\n        vnode.data.keepAlive = true;\n      }\n      return vnode || (slot && slot[0])\n    }\n  };\n\n  var builtInComponents = {\n    KeepAlive: KeepAlive\n  };\n\n  /*  */\n\n  function initGlobalAPI (Vue) {\n    // config\n    var configDef = {};\n    configDef.get = function () { return config; };\n    {\n      configDef.set = function () {\n        warn(\n          'Do not replace the Vue.config object, set individual fields instead.'\n        );\n      };\n    }\n    Object.defineProperty(Vue, 'config', configDef);\n\n    // exposed util methods.\n    // NOTE: these are not considered part of the public API - avoid relying on\n    // them unless you are aware of the risk.\n    Vue.util = {\n      warn: warn,\n      extend: extend,\n      mergeOptions: mergeOptions,\n      defineReactive: defineReactive$$1\n    };\n\n    Vue.set = set;\n    Vue.delete = del;\n    Vue.nextTick = nextTick;\n\n    // 2.6 explicit observable API\n    Vue.observable = function (obj) {\n      observe(obj);\n      return obj\n    };\n\n    Vue.options = Object.create(null);\n    ASSET_TYPES.forEach(function (type) {\n      Vue.options[type + 's'] = Object.create(null);\n    });\n\n    // this is used to identify the \"base\" constructor to extend all plain-object\n    // components with in Weex's multi-instance scenarios.\n    Vue.options._base = Vue;\n\n    extend(Vue.options.components, builtInComponents);\n\n    initUse(Vue);\n    initMixin$1(Vue);\n    initExtend(Vue);\n    initAssetRegisters(Vue);\n  }\n\n  initGlobalAPI(Vue);\n\n  Object.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n  });\n\n  Object.defineProperty(Vue.prototype, '$ssrContext', {\n    get: function get () {\n      /* istanbul ignore next */\n      return this.$vnode && this.$vnode.ssrContext\n    }\n  });\n\n  // expose FunctionalRenderContext for ssr runtime helper installation\n  Object.defineProperty(Vue, 'FunctionalRenderContext', {\n    value: FunctionalRenderContext\n  });\n\n  Vue.version = '2.6.12';\n\n  /*  */\n\n  // these are reserved for web because they are directly compiled away\n  // during template compilation\n  var isReservedAttr = makeMap('style,class');\n\n  // attributes that should be using props for binding\n  var acceptValue = makeMap('input,textarea,option,select,progress');\n  var mustUseProp = function (tag, type, attr) {\n    return (\n      (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n      (attr === 'selected' && tag === 'option') ||\n      (attr === 'checked' && tag === 'input') ||\n      (attr === 'muted' && tag === 'video')\n    )\n  };\n\n  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\n  var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\n  var convertEnumeratedValue = function (key, value) {\n    return isFalsyAttrValue(value) || value === 'false'\n      ? 'false'\n      // allow arbitrary string value for contenteditable\n      : key === 'contenteditable' && isValidContentEditableValue(value)\n        ? value\n        : 'true'\n  };\n\n  var isBooleanAttr = makeMap(\n    'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n    'required,reversed,scoped,seamless,selected,sortable,translate,' +\n    'truespeed,typemustmatch,visible'\n  );\n\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\n\n  var isXlink = function (name) {\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n  };\n\n  var getXlinkProp = function (name) {\n    return isXlink(name) ? name.slice(6, name.length) : ''\n  };\n\n  var isFalsyAttrValue = function (val) {\n    return val == null || val === false\n  };\n\n  /*  */\n\n  function genClassForVnode (vnode) {\n    var data = vnode.data;\n    var parentNode = vnode;\n    var childNode = vnode;\n    while (isDef(childNode.componentInstance)) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode && childNode.data) {\n        data = mergeClassData(childNode.data, data);\n      }\n    }\n    while (isDef(parentNode = parentNode.parent)) {\n      if (parentNode && parentNode.data) {\n        data = mergeClassData(data, parentNode.data);\n      }\n    }\n    return renderClass(data.staticClass, data.class)\n  }\n\n  function mergeClassData (child, parent) {\n    return {\n      staticClass: concat(child.staticClass, parent.staticClass),\n      class: isDef(child.class)\n        ? [child.class, parent.class]\n        : parent.class\n    }\n  }\n\n  function renderClass (\n    staticClass,\n    dynamicClass\n  ) {\n    if (isDef(staticClass) || isDef(dynamicClass)) {\n      return concat(staticClass, stringifyClass(dynamicClass))\n    }\n    /* istanbul ignore next */\n    return ''\n  }\n\n  function concat (a, b) {\n    return a ? b ? (a + ' ' + b) : a : (b || '')\n  }\n\n  function stringifyClass (value) {\n    if (Array.isArray(value)) {\n      return stringifyArray(value)\n    }\n    if (isObject(value)) {\n      return stringifyObject(value)\n    }\n    if (typeof value === 'string') {\n      return value\n    }\n    /* istanbul ignore next */\n    return ''\n  }\n\n  function stringifyArray (value) {\n    var res = '';\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n        if (res) { res += ' '; }\n        res += stringified;\n      }\n    }\n    return res\n  }\n\n  function stringifyObject (value) {\n    var res = '';\n    for (var key in value) {\n      if (value[key]) {\n        if (res) { res += ' '; }\n        res += key;\n      }\n    }\n    return res\n  }\n\n  /*  */\n\n  var namespaceMap = {\n    svg: 'http://www.w3.org/2000/svg',\n    math: 'http://www.w3.org/1998/Math/MathML'\n  };\n\n  var isHTMLTag = makeMap(\n    'html,body,base,head,link,meta,style,title,' +\n    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n    'embed,object,param,source,canvas,script,noscript,del,ins,' +\n    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n    'output,progress,select,textarea,' +\n    'details,dialog,menu,menuitem,summary,' +\n    'content,element,shadow,template,blockquote,iframe,tfoot'\n  );\n\n  // this map is intentionally selective, only covering SVG elements that may\n  // contain child elements.\n  var isSVG = makeMap(\n    'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n    'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n    true\n  );\n\n  var isPreTag = function (tag) { return tag === 'pre'; };\n\n  var isReservedTag = function (tag) {\n    return isHTMLTag(tag) || isSVG(tag)\n  };\n\n  function getTagNamespace (tag) {\n    if (isSVG(tag)) {\n      return 'svg'\n    }\n    // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n    if (tag === 'math') {\n      return 'math'\n    }\n  }\n\n  var unknownElementCache = Object.create(null);\n  function isUnknownElement (tag) {\n    /* istanbul ignore if */\n    if (!inBrowser) {\n      return true\n    }\n    if (isReservedTag(tag)) {\n      return false\n    }\n    tag = tag.toLowerCase();\n    /* istanbul ignore if */\n    if (unknownElementCache[tag] != null) {\n      return unknownElementCache[tag]\n    }\n    var el = document.createElement(tag);\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return (unknownElementCache[tag] = (\n        el.constructor === window.HTMLUnknownElement ||\n        el.constructor === window.HTMLElement\n      ))\n    } else {\n      return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n    }\n  }\n\n  var isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n  /*  */\n\n  /**\n   * Query an element selector if it's not an element already.\n   */\n  function query (el) {\n    if (typeof el === 'string') {\n      var selected = document.querySelector(el);\n      if (!selected) {\n        warn(\n          'Cannot find element: ' + el\n        );\n        return document.createElement('div')\n      }\n      return selected\n    } else {\n      return el\n    }\n  }\n\n  /*  */\n\n  function createElement$1 (tagName, vnode) {\n    var elm = document.createElement(tagName);\n    if (tagName !== 'select') {\n      return elm\n    }\n    // false or null will remove the attribute but undefined will not\n    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n      elm.setAttribute('multiple', 'multiple');\n    }\n    return elm\n  }\n\n  function createElementNS (namespace, tagName) {\n    return document.createElementNS(namespaceMap[namespace], tagName)\n  }\n\n  function createTextNode (text) {\n    return document.createTextNode(text)\n  }\n\n  function createComment (text) {\n    return document.createComment(text)\n  }\n\n  function insertBefore (parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  function removeChild (node, child) {\n    node.removeChild(child);\n  }\n\n  function appendChild (node, child) {\n    node.appendChild(child);\n  }\n\n  function parentNode (node) {\n    return node.parentNode\n  }\n\n  function nextSibling (node) {\n    return node.nextSibling\n  }\n\n  function tagName (node) {\n    return node.tagName\n  }\n\n  function setTextContent (node, text) {\n    node.textContent = text;\n  }\n\n  function setStyleScope (node, scopeId) {\n    node.setAttribute(scopeId, '');\n  }\n\n  var nodeOps = /*#__PURE__*/Object.freeze({\n    createElement: createElement$1,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    setStyleScope: setStyleScope\n  });\n\n  /*  */\n\n  var ref = {\n    create: function create (_, vnode) {\n      registerRef(vnode);\n    },\n    update: function update (oldVnode, vnode) {\n      if (oldVnode.data.ref !== vnode.data.ref) {\n        registerRef(oldVnode, true);\n        registerRef(vnode);\n      }\n    },\n    destroy: function destroy (vnode) {\n      registerRef(vnode, true);\n    }\n  };\n\n  function registerRef (vnode, isRemoval) {\n    var key = vnode.data.ref;\n    if (!isDef(key)) { return }\n\n    var vm = vnode.context;\n    var ref = vnode.componentInstance || vnode.elm;\n    var refs = vm.$refs;\n    if (isRemoval) {\n      if (Array.isArray(refs[key])) {\n        remove(refs[key], ref);\n      } else if (refs[key] === ref) {\n        refs[key] = undefined;\n      }\n    } else {\n      if (vnode.data.refInFor) {\n        if (!Array.isArray(refs[key])) {\n          refs[key] = [ref];\n        } else if (refs[key].indexOf(ref) < 0) {\n          // $flow-disable-line\n          refs[key].push(ref);\n        }\n      } else {\n        refs[key] = ref;\n      }\n    }\n  }\n\n  /**\n   * Virtual DOM patching algorithm based on Snabbdom by\n   * Simon Friis Vindum (@paldepind)\n   * Licensed under the MIT License\n   * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n   *\n   * modified by Evan You (@yyx990803)\n   *\n   * Not type-checking this because this file is perf-critical and the cost\n   * of making flow understand it is not worth it.\n   */\n\n  var emptyNode = new VNode('', {}, []);\n\n  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\n  function sameVnode (a, b) {\n    return (\n      a.key === b.key && (\n        (\n          a.tag === b.tag &&\n          a.isComment === b.isComment &&\n          isDef(a.data) === isDef(b.data) &&\n          sameInputType(a, b)\n        ) || (\n          isTrue(a.isAsyncPlaceholder) &&\n          a.asyncFactory === b.asyncFactory &&\n          isUndef(b.asyncFactory.error)\n        )\n      )\n    )\n  }\n\n  function sameInputType (a, b) {\n    if (a.tag !== 'input') { return true }\n    var i;\n    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n  }\n\n  function createKeyToOldIdx (children, beginIdx, endIdx) {\n    var i, key;\n    var map = {};\n    for (i = beginIdx; i <= endIdx; ++i) {\n      key = children[i].key;\n      if (isDef(key)) { map[key] = i; }\n    }\n    return map\n  }\n\n  function createPatchFunction (backend) {\n    var i, j;\n    var cbs = {};\n\n    var modules = backend.modules;\n    var nodeOps = backend.nodeOps;\n\n    for (i = 0; i < hooks.length; ++i) {\n      cbs[hooks[i]] = [];\n      for (j = 0; j < modules.length; ++j) {\n        if (isDef(modules[j][hooks[i]])) {\n          cbs[hooks[i]].push(modules[j][hooks[i]]);\n        }\n      }\n    }\n\n    function emptyNodeAt (elm) {\n      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n    }\n\n    function createRmCb (childElm, listeners) {\n      function remove$$1 () {\n        if (--remove$$1.listeners === 0) {\n          removeNode(childElm);\n        }\n      }\n      remove$$1.listeners = listeners;\n      return remove$$1\n    }\n\n    function removeNode (el) {\n      var parent = nodeOps.parentNode(el);\n      // element may have already been removed due to v-html / v-text\n      if (isDef(parent)) {\n        nodeOps.removeChild(parent, el);\n      }\n    }\n\n    function isUnknownElement$$1 (vnode, inVPre) {\n      return (\n        !inVPre &&\n        !vnode.ns &&\n        !(\n          config.ignoredElements.length &&\n          config.ignoredElements.some(function (ignore) {\n            return isRegExp(ignore)\n              ? ignore.test(vnode.tag)\n              : ignore === vnode.tag\n          })\n        ) &&\n        config.isUnknownElement(vnode.tag)\n      )\n    }\n\n    var creatingElmInVPre = 0;\n\n    function createElm (\n      vnode,\n      insertedVnodeQueue,\n      parentElm,\n      refElm,\n      nested,\n      ownerArray,\n      index\n    ) {\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // This vnode was used in a previous render!\n        // now it's used as a new node, overwriting its elm would cause\n        // potential patch errors down the road when it's used as an insertion\n        // reference node. Instead, we clone the node on-demand before creating\n        // associated DOM element for it.\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      vnode.isRootInsert = !nested; // for transition enter check\n      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n        return\n      }\n\n      var data = vnode.data;\n      var children = vnode.children;\n      var tag = vnode.tag;\n      if (isDef(tag)) {\n        {\n          if (data && data.pre) {\n            creatingElmInVPre++;\n          }\n          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n            warn(\n              'Unknown custom element: <' + tag + '> - did you ' +\n              'register the component correctly? For recursive components, ' +\n              'make sure to provide the \"name\" option.',\n              vnode.context\n            );\n          }\n        }\n\n        vnode.elm = vnode.ns\n          ? nodeOps.createElementNS(vnode.ns, tag)\n          : nodeOps.createElement(tag, vnode);\n        setScope(vnode);\n\n        /* istanbul ignore if */\n        {\n          createChildren(vnode, children, insertedVnodeQueue);\n          if (isDef(data)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n          }\n          insert(parentElm, vnode.elm, refElm);\n        }\n\n        if (data && data.pre) {\n          creatingElmInVPre--;\n        }\n      } else if (isTrue(vnode.isComment)) {\n        vnode.elm = nodeOps.createComment(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      } else {\n        vnode.elm = nodeOps.createTextNode(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      }\n    }\n\n    function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i = vnode.data;\n      if (isDef(i)) {\n        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n        if (isDef(i = i.hook) && isDef(i = i.init)) {\n          i(vnode, false /* hydrating */);\n        }\n        // after calling the init hook, if the vnode is a child component\n        // it should've created a child instance and mounted it. the child\n        // component also has set the placeholder vnode's elm.\n        // in that case we can just return the element and be done.\n        if (isDef(vnode.componentInstance)) {\n          initComponent(vnode, insertedVnodeQueue);\n          insert(parentElm, vnode.elm, refElm);\n          if (isTrue(isReactivated)) {\n            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n          }\n          return true\n        }\n      }\n    }\n\n    function initComponent (vnode, insertedVnodeQueue) {\n      if (isDef(vnode.data.pendingInsert)) {\n        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n        vnode.data.pendingInsert = null;\n      }\n      vnode.elm = vnode.componentInstance.$el;\n      if (isPatchable(vnode)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n        setScope(vnode);\n      } else {\n        // empty component root.\n        // skip all element-related modules except for ref (#3455)\n        registerRef(vnode);\n        // make sure to invoke the insert hook\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n\n    function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i;\n      // hack for #4339: a reactivated component with inner transition\n      // does not trigger because the inner node's created hooks are not called\n      // again. It's not ideal to involve module-specific logic in here but\n      // there doesn't seem to be a better way to do it.\n      var innerNode = vnode;\n      while (innerNode.componentInstance) {\n        innerNode = innerNode.componentInstance._vnode;\n        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n          for (i = 0; i < cbs.activate.length; ++i) {\n            cbs.activate[i](emptyNode, innerNode);\n          }\n          insertedVnodeQueue.push(innerNode);\n          break\n        }\n      }\n      // unlike a newly created component,\n      // a reactivated keep-alive component doesn't insert itself\n      insert(parentElm, vnode.elm, refElm);\n    }\n\n    function insert (parent, elm, ref$$1) {\n      if (isDef(parent)) {\n        if (isDef(ref$$1)) {\n          if (nodeOps.parentNode(ref$$1) === parent) {\n            nodeOps.insertBefore(parent, elm, ref$$1);\n          }\n        } else {\n          nodeOps.appendChild(parent, elm);\n        }\n      }\n    }\n\n    function createChildren (vnode, children, insertedVnodeQueue) {\n      if (Array.isArray(children)) {\n        {\n          checkDuplicateKeys(children);\n        }\n        for (var i = 0; i < children.length; ++i) {\n          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n        }\n      } else if (isPrimitive(vnode.text)) {\n        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n      }\n    }\n\n    function isPatchable (vnode) {\n      while (vnode.componentInstance) {\n        vnode = vnode.componentInstance._vnode;\n      }\n      return isDef(vnode.tag)\n    }\n\n    function invokeCreateHooks (vnode, insertedVnodeQueue) {\n      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n        cbs.create[i$1](emptyNode, vnode);\n      }\n      i = vnode.data.hook; // Reuse variable\n      if (isDef(i)) {\n        if (isDef(i.create)) { i.create(emptyNode, vnode); }\n        if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n      }\n    }\n\n    // set scope id attribute for scoped CSS.\n    // this is implemented as a special case to avoid the overhead\n    // of going through the normal attribute patching process.\n    function setScope (vnode) {\n      var i;\n      if (isDef(i = vnode.fnScopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      } else {\n        var ancestor = vnode;\n        while (ancestor) {\n          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n            nodeOps.setStyleScope(vnode.elm, i);\n          }\n          ancestor = ancestor.parent;\n        }\n      }\n      // for slot content they should also get the scopeId from the host instance.\n      if (isDef(i = activeInstance) &&\n        i !== vnode.context &&\n        i !== vnode.fnContext &&\n        isDef(i = i.$options._scopeId)\n      ) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      }\n    }\n\n    function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n      }\n    }\n\n    function invokeDestroyHook (vnode) {\n      var i, j;\n      var data = vnode.data;\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n        for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n      }\n      if (isDef(i = vnode.children)) {\n        for (j = 0; j < vnode.children.length; ++j) {\n          invokeDestroyHook(vnode.children[j]);\n        }\n      }\n    }\n\n    function removeVnodes (vnodes, startIdx, endIdx) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        var ch = vnodes[startIdx];\n        if (isDef(ch)) {\n          if (isDef(ch.tag)) {\n            removeAndInvokeRemoveHook(ch);\n            invokeDestroyHook(ch);\n          } else { // Text node\n            removeNode(ch.elm);\n          }\n        }\n      }\n    }\n\n    function removeAndInvokeRemoveHook (vnode, rm) {\n      if (isDef(rm) || isDef(vnode.data)) {\n        var i;\n        var listeners = cbs.remove.length + 1;\n        if (isDef(rm)) {\n          // we have a recursively passed down rm callback\n          // increase the listeners count\n          rm.listeners += listeners;\n        } else {\n          // directly removing\n          rm = createRmCb(vnode.elm, listeners);\n        }\n        // recursively invoke hooks on child component root node\n        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n          removeAndInvokeRemoveHook(i, rm);\n        }\n        for (i = 0; i < cbs.remove.length; ++i) {\n          cbs.remove[i](vnode, rm);\n        }\n        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n          i(vnode, rm);\n        } else {\n          rm();\n        }\n      } else {\n        removeNode(vnode.elm);\n      }\n    }\n\n    function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n      var oldStartIdx = 0;\n      var newStartIdx = 0;\n      var oldEndIdx = oldCh.length - 1;\n      var oldStartVnode = oldCh[0];\n      var oldEndVnode = oldCh[oldEndIdx];\n      var newEndIdx = newCh.length - 1;\n      var newStartVnode = newCh[0];\n      var newEndVnode = newCh[newEndIdx];\n      var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n      // removeOnly is a special flag used only by <transition-group>\n      // to ensure removed elements stay in correct relative positions\n      // during leaving transitions\n      var canMove = !removeOnly;\n\n      {\n        checkDuplicateKeys(newCh);\n      }\n\n      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (isUndef(oldStartVnode)) {\n          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n        } else if (isUndef(oldEndVnode)) {\n          oldEndVnode = oldCh[--oldEndIdx];\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          oldStartVnode = oldCh[++oldStartIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n          oldStartVnode = oldCh[++oldStartIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n          idxInOld = isDef(newStartVnode.key)\n            ? oldKeyToIdx[newStartVnode.key]\n            : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n          if (isUndef(idxInOld)) { // New element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          } else {\n            vnodeToMove = oldCh[idxInOld];\n            if (sameVnode(vnodeToMove, newStartVnode)) {\n              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n              oldCh[idxInOld] = undefined;\n              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n            } else {\n              // same key but different element. treat as new element\n              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n            }\n          }\n          newStartVnode = newCh[++newStartIdx];\n        }\n      }\n      if (oldStartIdx > oldEndIdx) {\n        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n      } else if (newStartIdx > newEndIdx) {\n        removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n\n    function checkDuplicateKeys (children) {\n      var seenKeys = {};\n      for (var i = 0; i < children.length; i++) {\n        var vnode = children[i];\n        var key = vnode.key;\n        if (isDef(key)) {\n          if (seenKeys[key]) {\n            warn(\n              (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n              vnode.context\n            );\n          } else {\n            seenKeys[key] = true;\n          }\n        }\n      }\n    }\n\n    function findIdxInOld (node, oldCh, start, end) {\n      for (var i = start; i < end; i++) {\n        var c = oldCh[i];\n        if (isDef(c) && sameVnode(node, c)) { return i }\n      }\n    }\n\n    function patchVnode (\n      oldVnode,\n      vnode,\n      insertedVnodeQueue,\n      ownerArray,\n      index,\n      removeOnly\n    ) {\n      if (oldVnode === vnode) {\n        return\n      }\n\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // clone reused vnode\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      var elm = vnode.elm = oldVnode.elm;\n\n      if (isTrue(oldVnode.isAsyncPlaceholder)) {\n        if (isDef(vnode.asyncFactory.resolved)) {\n          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n        } else {\n          vnode.isAsyncPlaceholder = true;\n        }\n        return\n      }\n\n      // reuse element for static trees.\n      // note we only do this if the vnode is cloned -\n      // if the new node is not cloned it means the render functions have been\n      // reset by the hot-reload-api and we need to do a proper re-render.\n      if (isTrue(vnode.isStatic) &&\n        isTrue(oldVnode.isStatic) &&\n        vnode.key === oldVnode.key &&\n        (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n      ) {\n        vnode.componentInstance = oldVnode.componentInstance;\n        return\n      }\n\n      var i;\n      var data = vnode.data;\n      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n        i(oldVnode, vnode);\n      }\n\n      var oldCh = oldVnode.children;\n      var ch = vnode.children;\n      if (isDef(data) && isPatchable(vnode)) {\n        for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n        if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n      }\n      if (isUndef(vnode.text)) {\n        if (isDef(oldCh) && isDef(ch)) {\n          if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n        } else if (isDef(ch)) {\n          {\n            checkDuplicateKeys(ch);\n          }\n          if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n        } else if (isDef(oldCh)) {\n          removeVnodes(oldCh, 0, oldCh.length - 1);\n        } else if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n      } else if (oldVnode.text !== vnode.text) {\n        nodeOps.setTextContent(elm, vnode.text);\n      }\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n      }\n    }\n\n    function invokeInsertHook (vnode, queue, initial) {\n      // delay insert hooks for component root nodes, invoke them after the\n      // element is really inserted\n      if (isTrue(initial) && isDef(vnode.parent)) {\n        vnode.parent.data.pendingInsert = queue;\n      } else {\n        for (var i = 0; i < queue.length; ++i) {\n          queue[i].data.hook.insert(queue[i]);\n        }\n      }\n    }\n\n    var hydrationBailed = false;\n    // list of modules that can skip create hook during hydration because they\n    // are already rendered on the client or has no need for initialization\n    // Note: style is excluded because it relies on initial clone for future\n    // deep updates (#7063).\n    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n    // Note: this is a browser-only function so we can assume elms are DOM nodes.\n    function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n      var i;\n      var tag = vnode.tag;\n      var data = vnode.data;\n      var children = vnode.children;\n      inVPre = inVPre || (data && data.pre);\n      vnode.elm = elm;\n\n      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n        vnode.isAsyncPlaceholder = true;\n        return true\n      }\n      // assert node match\n      {\n        if (!assertNodeMatch(elm, vnode, inVPre)) {\n          return false\n        }\n      }\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n        if (isDef(i = vnode.componentInstance)) {\n          // child component. it should have hydrated its own tree.\n          initComponent(vnode, insertedVnodeQueue);\n          return true\n        }\n      }\n      if (isDef(tag)) {\n        if (isDef(children)) {\n          // empty element, allow client to pick up and populate children\n          if (!elm.hasChildNodes()) {\n            createChildren(vnode, children, insertedVnodeQueue);\n          } else {\n            // v-html and domProps: innerHTML\n            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n              if (i !== elm.innerHTML) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' &&\n                  !hydrationBailed\n                ) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('server innerHTML: ', i);\n                  console.warn('client innerHTML: ', elm.innerHTML);\n                }\n                return false\n              }\n            } else {\n              // iterate and compare children lists\n              var childrenMatch = true;\n              var childNode = elm.firstChild;\n              for (var i$1 = 0; i$1 < children.length; i$1++) {\n                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                  childrenMatch = false;\n                  break\n                }\n                childNode = childNode.nextSibling;\n              }\n              // if childNode is not null, it means the actual childNodes list is\n              // longer than the virtual children list.\n              if (!childrenMatch || childNode) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' &&\n                  !hydrationBailed\n                ) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n                }\n                return false\n              }\n            }\n          }\n        }\n        if (isDef(data)) {\n          var fullInvoke = false;\n          for (var key in data) {\n            if (!isRenderedModule(key)) {\n              fullInvoke = true;\n              invokeCreateHooks(vnode, insertedVnodeQueue);\n              break\n            }\n          }\n          if (!fullInvoke && data['class']) {\n            // ensure collecting deps for deep class bindings for future updates\n            traverse(data['class']);\n          }\n        }\n      } else if (elm.data !== vnode.text) {\n        elm.data = vnode.text;\n      }\n      return true\n    }\n\n    function assertNodeMatch (node, vnode, inVPre) {\n      if (isDef(vnode.tag)) {\n        return vnode.tag.indexOf('vue-component') === 0 || (\n          !isUnknownElement$$1(vnode, inVPre) &&\n          vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n        )\n      } else {\n        return node.nodeType === (vnode.isComment ? 8 : 3)\n      }\n    }\n\n    return function patch (oldVnode, vnode, hydrating, removeOnly) {\n      if (isUndef(vnode)) {\n        if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n        return\n      }\n\n      var isInitialPatch = false;\n      var insertedVnodeQueue = [];\n\n      if (isUndef(oldVnode)) {\n        // empty mount (likely as component), create new root element\n        isInitialPatch = true;\n        createElm(vnode, insertedVnodeQueue);\n      } else {\n        var isRealElement = isDef(oldVnode.nodeType);\n        if (!isRealElement && sameVnode(oldVnode, vnode)) {\n          // patch existing root node\n          patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n        } else {\n          if (isRealElement) {\n            // mounting to a real element\n            // check if this is server-rendered content and if we can perform\n            // a successful hydration.\n            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n              oldVnode.removeAttribute(SSR_ATTR);\n              hydrating = true;\n            }\n            if (isTrue(hydrating)) {\n              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                invokeInsertHook(vnode, insertedVnodeQueue, true);\n                return oldVnode\n              } else {\n                warn(\n                  'The client-side rendered virtual DOM tree is not matching ' +\n                  'server-rendered content. This is likely caused by incorrect ' +\n                  'HTML markup, for example nesting block-level elements inside ' +\n                  '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                  'full client-side render.'\n                );\n              }\n            }\n            // either not server-rendered, or hydration failed.\n            // create an empty node and replace it\n            oldVnode = emptyNodeAt(oldVnode);\n          }\n\n          // replacing existing element\n          var oldElm = oldVnode.elm;\n          var parentElm = nodeOps.parentNode(oldElm);\n\n          // create new node\n          createElm(\n            vnode,\n            insertedVnodeQueue,\n            // extremely rare edge case: do not insert if old element is in a\n            // leaving transition. Only happens when combining transition +\n            // keep-alive + HOCs. (#4590)\n            oldElm._leaveCb ? null : parentElm,\n            nodeOps.nextSibling(oldElm)\n          );\n\n          // update parent placeholder node element, recursively\n          if (isDef(vnode.parent)) {\n            var ancestor = vnode.parent;\n            var patchable = isPatchable(vnode);\n            while (ancestor) {\n              for (var i = 0; i < cbs.destroy.length; ++i) {\n                cbs.destroy[i](ancestor);\n              }\n              ancestor.elm = vnode.elm;\n              if (patchable) {\n                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                  cbs.create[i$1](emptyNode, ancestor);\n                }\n                // #6513\n                // invoke insert hooks that may have been merged by create hooks.\n                // e.g. for directives that uses the \"inserted\" hook.\n                var insert = ancestor.data.hook.insert;\n                if (insert.merged) {\n                  // start at index 1 to avoid re-invoking component mounted hook\n                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                    insert.fns[i$2]();\n                  }\n                }\n              } else {\n                registerRef(ancestor);\n              }\n              ancestor = ancestor.parent;\n            }\n          }\n\n          // destroy old node\n          if (isDef(parentElm)) {\n            removeVnodes([oldVnode], 0, 0);\n          } else if (isDef(oldVnode.tag)) {\n            invokeDestroyHook(oldVnode);\n          }\n        }\n      }\n\n      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n      return vnode.elm\n    }\n  }\n\n  /*  */\n\n  var directives = {\n    create: updateDirectives,\n    update: updateDirectives,\n    destroy: function unbindDirectives (vnode) {\n      updateDirectives(vnode, emptyNode);\n    }\n  };\n\n  function updateDirectives (oldVnode, vnode) {\n    if (oldVnode.data.directives || vnode.data.directives) {\n      _update(oldVnode, vnode);\n    }\n  }\n\n  function _update (oldVnode, vnode) {\n    var isCreate = oldVnode === emptyNode;\n    var isDestroy = vnode === emptyNode;\n    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n    var dirsWithInsert = [];\n    var dirsWithPostpatch = [];\n\n    var key, oldDir, dir;\n    for (key in newDirs) {\n      oldDir = oldDirs[key];\n      dir = newDirs[key];\n      if (!oldDir) {\n        // new directive, bind\n        callHook$1(dir, 'bind', vnode, oldVnode);\n        if (dir.def && dir.def.inserted) {\n          dirsWithInsert.push(dir);\n        }\n      } else {\n        // existing directive, update\n        dir.oldValue = oldDir.value;\n        dir.oldArg = oldDir.arg;\n        callHook$1(dir, 'update', vnode, oldVnode);\n        if (dir.def && dir.def.componentUpdated) {\n          dirsWithPostpatch.push(dir);\n        }\n      }\n    }\n\n    if (dirsWithInsert.length) {\n      var callInsert = function () {\n        for (var i = 0; i < dirsWithInsert.length; i++) {\n          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n        }\n      };\n      if (isCreate) {\n        mergeVNodeHook(vnode, 'insert', callInsert);\n      } else {\n        callInsert();\n      }\n    }\n\n    if (dirsWithPostpatch.length) {\n      mergeVNodeHook(vnode, 'postpatch', function () {\n        for (var i = 0; i < dirsWithPostpatch.length; i++) {\n          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n        }\n      });\n    }\n\n    if (!isCreate) {\n      for (key in oldDirs) {\n        if (!newDirs[key]) {\n          // no longer present, unbind\n          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n        }\n      }\n    }\n  }\n\n  var emptyModifiers = Object.create(null);\n\n  function normalizeDirectives$1 (\n    dirs,\n    vm\n  ) {\n    var res = Object.create(null);\n    if (!dirs) {\n      // $flow-disable-line\n      return res\n    }\n    var i, dir;\n    for (i = 0; i < dirs.length; i++) {\n      dir = dirs[i];\n      if (!dir.modifiers) {\n        // $flow-disable-line\n        dir.modifiers = emptyModifiers;\n      }\n      res[getRawDirName(dir)] = dir;\n      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n    }\n    // $flow-disable-line\n    return res\n  }\n\n  function getRawDirName (dir) {\n    return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n  }\n\n  function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n    var fn = dir.def && dir.def[hook];\n    if (fn) {\n      try {\n        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n      } catch (e) {\n        handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n      }\n    }\n  }\n\n  var baseModules = [\n    ref,\n    directives\n  ];\n\n  /*  */\n\n  function updateAttrs (oldVnode, vnode) {\n    var opts = vnode.componentOptions;\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n      return\n    }\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n      return\n    }\n    var key, cur, old;\n    var elm = vnode.elm;\n    var oldAttrs = oldVnode.data.attrs || {};\n    var attrs = vnode.data.attrs || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(attrs.__ob__)) {\n      attrs = vnode.data.attrs = extend({}, attrs);\n    }\n\n    for (key in attrs) {\n      cur = attrs[key];\n      old = oldAttrs[key];\n      if (old !== cur) {\n        setAttr(elm, key, cur);\n      }\n    }\n    // #4391: in IE9, setting type can reset value for input[type=radio]\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\n    /* istanbul ignore if */\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n      setAttr(elm, 'value', attrs.value);\n    }\n    for (key in oldAttrs) {\n      if (isUndef(attrs[key])) {\n        if (isXlink(key)) {\n          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        } else if (!isEnumeratedAttr(key)) {\n          elm.removeAttribute(key);\n        }\n      }\n    }\n  }\n\n  function setAttr (el, key, value) {\n    if (el.tagName.indexOf('-') > -1) {\n      baseSetAttr(el, key, value);\n    } else if (isBooleanAttr(key)) {\n      // set attribute for blank value\n      // e.g. <option disabled>Select one</option>\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        // technically allowfullscreen is a boolean attribute for <iframe>,\n        // but Flash expects a value of \"true\" when used on <embed> tag\n        value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n          ? 'true'\n          : key;\n        el.setAttribute(key, value);\n      }\n    } else if (isEnumeratedAttr(key)) {\n      el.setAttribute(key, convertEnumeratedValue(key, value));\n    } else if (isXlink(key)) {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else {\n        el.setAttributeNS(xlinkNS, key, value);\n      }\n    } else {\n      baseSetAttr(el, key, value);\n    }\n  }\n\n  function baseSetAttr (el, key, value) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // #7138: IE10 & 11 fires input event when setting placeholder on\n      // <textarea>... block the first input event and remove the blocker\n      // immediately.\n      /* istanbul ignore if */\n      if (\n        isIE && !isIE9 &&\n        el.tagName === 'TEXTAREA' &&\n        key === 'placeholder' && value !== '' && !el.__ieph\n      ) {\n        var blocker = function (e) {\n          e.stopImmediatePropagation();\n          el.removeEventListener('input', blocker);\n        };\n        el.addEventListener('input', blocker);\n        // $flow-disable-line\n        el.__ieph = true; /* IE placeholder patched */\n      }\n      el.setAttribute(key, value);\n    }\n  }\n\n  var attrs = {\n    create: updateAttrs,\n    update: updateAttrs\n  };\n\n  /*  */\n\n  function updateClass (oldVnode, vnode) {\n    var el = vnode.elm;\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n    if (\n      isUndef(data.staticClass) &&\n      isUndef(data.class) && (\n        isUndef(oldData) || (\n          isUndef(oldData.staticClass) &&\n          isUndef(oldData.class)\n        )\n      )\n    ) {\n      return\n    }\n\n    var cls = genClassForVnode(vnode);\n\n    // handle transition classes\n    var transitionClass = el._transitionClasses;\n    if (isDef(transitionClass)) {\n      cls = concat(cls, stringifyClass(transitionClass));\n    }\n\n    // set the class\n    if (cls !== el._prevClass) {\n      el.setAttribute('class', cls);\n      el._prevClass = cls;\n    }\n  }\n\n  var klass = {\n    create: updateClass,\n    update: updateClass\n  };\n\n  /*  */\n\n  var validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n  function parseFilters (exp) {\n    var inSingle = false;\n    var inDouble = false;\n    var inTemplateString = false;\n    var inRegex = false;\n    var curly = 0;\n    var square = 0;\n    var paren = 0;\n    var lastFilterIndex = 0;\n    var c, prev, i, expression, filters;\n\n    for (i = 0; i < exp.length; i++) {\n      prev = c;\n      c = exp.charCodeAt(i);\n      if (inSingle) {\n        if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n      } else if (inDouble) {\n        if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n      } else if (inTemplateString) {\n        if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n      } else if (inRegex) {\n        if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n      } else if (\n        c === 0x7C && // pipe\n        exp.charCodeAt(i + 1) !== 0x7C &&\n        exp.charCodeAt(i - 1) !== 0x7C &&\n        !curly && !square && !paren\n      ) {\n        if (expression === undefined) {\n          // first filter, end of expression\n          lastFilterIndex = i + 1;\n          expression = exp.slice(0, i).trim();\n        } else {\n          pushFilter();\n        }\n      } else {\n        switch (c) {\n          case 0x22: inDouble = true; break         // \"\n          case 0x27: inSingle = true; break         // '\n          case 0x60: inTemplateString = true; break // `\n          case 0x28: paren++; break                 // (\n          case 0x29: paren--; break                 // )\n          case 0x5B: square++; break                // [\n          case 0x5D: square--; break                // ]\n          case 0x7B: curly++; break                 // {\n          case 0x7D: curly--; break                 // }\n        }\n        if (c === 0x2f) { // /\n          var j = i - 1;\n          var p = (void 0);\n          // find first non-whitespace prev char\n          for (; j >= 0; j--) {\n            p = exp.charAt(j);\n            if (p !== ' ') { break }\n          }\n          if (!p || !validDivisionCharRE.test(p)) {\n            inRegex = true;\n          }\n        }\n      }\n    }\n\n    if (expression === undefined) {\n      expression = exp.slice(0, i).trim();\n    } else if (lastFilterIndex !== 0) {\n      pushFilter();\n    }\n\n    function pushFilter () {\n      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n      lastFilterIndex = i + 1;\n    }\n\n    if (filters) {\n      for (i = 0; i < filters.length; i++) {\n        expression = wrapFilter(expression, filters[i]);\n      }\n    }\n\n    return expression\n  }\n\n  function wrapFilter (exp, filter) {\n    var i = filter.indexOf('(');\n    if (i < 0) {\n      // _f: resolveFilter\n      return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n    } else {\n      var name = filter.slice(0, i);\n      var args = filter.slice(i + 1);\n      return (\"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args))\n    }\n  }\n\n  /*  */\n\n\n\n  /* eslint-disable no-unused-vars */\n  function baseWarn (msg, range) {\n    console.error((\"[Vue compiler]: \" + msg));\n  }\n  /* eslint-enable no-unused-vars */\n\n  function pluckModuleFunction (\n    modules,\n    key\n  ) {\n    return modules\n      ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n      : []\n  }\n\n  function addProp (el, name, value, range, dynamic) {\n    (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n    el.plain = false;\n  }\n\n  function addAttr (el, name, value, range, dynamic) {\n    var attrs = dynamic\n      ? (el.dynamicAttrs || (el.dynamicAttrs = []))\n      : (el.attrs || (el.attrs = []));\n    attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n    el.plain = false;\n  }\n\n  // add a raw attr (use this in preTransforms)\n  function addRawAttr (el, name, value, range) {\n    el.attrsMap[name] = value;\n    el.attrsList.push(rangeSetItem({ name: name, value: value }, range));\n  }\n\n  function addDirective (\n    el,\n    name,\n    rawName,\n    value,\n    arg,\n    isDynamicArg,\n    modifiers,\n    range\n  ) {\n    (el.directives || (el.directives = [])).push(rangeSetItem({\n      name: name,\n      rawName: rawName,\n      value: value,\n      arg: arg,\n      isDynamicArg: isDynamicArg,\n      modifiers: modifiers\n    }, range));\n    el.plain = false;\n  }\n\n  function prependModifierMarker (symbol, name, dynamic) {\n    return dynamic\n      ? (\"_p(\" + name + \",\\\"\" + symbol + \"\\\")\")\n      : symbol + name // mark the event as captured\n  }\n\n  function addHandler (\n    el,\n    name,\n    value,\n    modifiers,\n    important,\n    warn,\n    range,\n    dynamic\n  ) {\n    modifiers = modifiers || emptyObject;\n    // warn prevent and passive modifier\n    /* istanbul ignore if */\n    if (\n      warn &&\n      modifiers.prevent && modifiers.passive\n    ) {\n      warn(\n        'passive and prevent can\\'t be used together. ' +\n        'Passive handler can\\'t prevent default event.',\n        range\n      );\n    }\n\n    // normalize click.right and click.middle since they don't actually fire\n    // this is technically browser-specific, but at least for now browsers are\n    // the only target envs that have right/middle clicks.\n    if (modifiers.right) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'contextmenu';\n        delete modifiers.right;\n      }\n    } else if (modifiers.middle) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'mouseup';\n      }\n    }\n\n    // check capture modifier\n    if (modifiers.capture) {\n      delete modifiers.capture;\n      name = prependModifierMarker('!', name, dynamic);\n    }\n    if (modifiers.once) {\n      delete modifiers.once;\n      name = prependModifierMarker('~', name, dynamic);\n    }\n    /* istanbul ignore if */\n    if (modifiers.passive) {\n      delete modifiers.passive;\n      name = prependModifierMarker('&', name, dynamic);\n    }\n\n    var events;\n    if (modifiers.native) {\n      delete modifiers.native;\n      events = el.nativeEvents || (el.nativeEvents = {});\n    } else {\n      events = el.events || (el.events = {});\n    }\n\n    var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);\n    if (modifiers !== emptyObject) {\n      newHandler.modifiers = modifiers;\n    }\n\n    var handlers = events[name];\n    /* istanbul ignore if */\n    if (Array.isArray(handlers)) {\n      important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n    } else if (handlers) {\n      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n    } else {\n      events[name] = newHandler;\n    }\n\n    el.plain = false;\n  }\n\n  function getRawBindingAttr (\n    el,\n    name\n  ) {\n    return el.rawAttrsMap[':' + name] ||\n      el.rawAttrsMap['v-bind:' + name] ||\n      el.rawAttrsMap[name]\n  }\n\n  function getBindingAttr (\n    el,\n    name,\n    getStatic\n  ) {\n    var dynamicValue =\n      getAndRemoveAttr(el, ':' + name) ||\n      getAndRemoveAttr(el, 'v-bind:' + name);\n    if (dynamicValue != null) {\n      return parseFilters(dynamicValue)\n    } else if (getStatic !== false) {\n      var staticValue = getAndRemoveAttr(el, name);\n      if (staticValue != null) {\n        return JSON.stringify(staticValue)\n      }\n    }\n  }\n\n  // note: this only removes the attr from the Array (attrsList) so that it\n  // doesn't get processed by processAttrs.\n  // By default it does NOT remove it from the map (attrsMap) because the map is\n  // needed during codegen.\n  function getAndRemoveAttr (\n    el,\n    name,\n    removeFromMap\n  ) {\n    var val;\n    if ((val = el.attrsMap[name]) != null) {\n      var list = el.attrsList;\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i].name === name) {\n          list.splice(i, 1);\n          break\n        }\n      }\n    }\n    if (removeFromMap) {\n      delete el.attrsMap[name];\n    }\n    return val\n  }\n\n  function getAndRemoveAttrByRegex (\n    el,\n    name\n  ) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      var attr = list[i];\n      if (name.test(attr.name)) {\n        list.splice(i, 1);\n        return attr\n      }\n    }\n  }\n\n  function rangeSetItem (\n    item,\n    range\n  ) {\n    if (range) {\n      if (range.start != null) {\n        item.start = range.start;\n      }\n      if (range.end != null) {\n        item.end = range.end;\n      }\n    }\n    return item\n  }\n\n  /*  */\n\n  /**\n   * Cross-platform code generation for component v-model\n   */\n  function genComponentModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var ref = modifiers || {};\n    var number = ref.number;\n    var trim = ref.trim;\n\n    var baseValueExpression = '$$v';\n    var valueExpression = baseValueExpression;\n    if (trim) {\n      valueExpression =\n        \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n    }\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n    var assignment = genAssignmentCode(value, valueExpression);\n\n    el.model = {\n      value: (\"(\" + value + \")\"),\n      expression: JSON.stringify(value),\n      callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n    };\n  }\n\n  /**\n   * Cross-platform codegen helper for generating v-model value assignment code.\n   */\n  function genAssignmentCode (\n    value,\n    assignment\n  ) {\n    var res = parseModel(value);\n    if (res.key === null) {\n      return (value + \"=\" + assignment)\n    } else {\n      return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\")\n    }\n  }\n\n  /**\n   * Parse a v-model expression into a base path and a final key segment.\n   * Handles both dot-path and possible square brackets.\n   *\n   * Possible cases:\n   *\n   * - test\n   * - test[key]\n   * - test[test1[key]]\n   * - test[\"a\"][key]\n   * - xxx.test[a[a].test1[key]]\n   * - test.xxx.a[\"asa\"][test1[key]]\n   *\n   */\n\n  var len, str, chr, index$1, expressionPos, expressionEndPos;\n\n\n\n  function parseModel (val) {\n    // Fix https://github.com/vuejs/vue/pull/7730\n    // allow v-model=\"obj.val \" (trailing whitespace)\n    val = val.trim();\n    len = val.length;\n\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n      index$1 = val.lastIndexOf('.');\n      if (index$1 > -1) {\n        return {\n          exp: val.slice(0, index$1),\n          key: '\"' + val.slice(index$1 + 1) + '\"'\n        }\n      } else {\n        return {\n          exp: val,\n          key: null\n        }\n      }\n    }\n\n    str = val;\n    index$1 = expressionPos = expressionEndPos = 0;\n\n    while (!eof()) {\n      chr = next();\n      /* istanbul ignore if */\n      if (isStringStart(chr)) {\n        parseString(chr);\n      } else if (chr === 0x5B) {\n        parseBracket(chr);\n      }\n    }\n\n    return {\n      exp: val.slice(0, expressionPos),\n      key: val.slice(expressionPos + 1, expressionEndPos)\n    }\n  }\n\n  function next () {\n    return str.charCodeAt(++index$1)\n  }\n\n  function eof () {\n    return index$1 >= len\n  }\n\n  function isStringStart (chr) {\n    return chr === 0x22 || chr === 0x27\n  }\n\n  function parseBracket (chr) {\n    var inBracket = 1;\n    expressionPos = index$1;\n    while (!eof()) {\n      chr = next();\n      if (isStringStart(chr)) {\n        parseString(chr);\n        continue\n      }\n      if (chr === 0x5B) { inBracket++; }\n      if (chr === 0x5D) { inBracket--; }\n      if (inBracket === 0) {\n        expressionEndPos = index$1;\n        break\n      }\n    }\n  }\n\n  function parseString (chr) {\n    var stringQuote = chr;\n    while (!eof()) {\n      chr = next();\n      if (chr === stringQuote) {\n        break\n      }\n    }\n  }\n\n  /*  */\n\n  var warn$1;\n\n  // in some cases, the event used has to be determined at runtime\n  // so we used some reserved tokens during compile.\n  var RANGE_TOKEN = '__r';\n  var CHECKBOX_RADIO_TOKEN = '__c';\n\n  function model (\n    el,\n    dir,\n    _warn\n  ) {\n    warn$1 = _warn;\n    var value = dir.value;\n    var modifiers = dir.modifiers;\n    var tag = el.tag;\n    var type = el.attrsMap.type;\n\n    {\n      // inputs with type=\"file\" are read only and setting the input's\n      // value will throw an error.\n      if (tag === 'input' && type === 'file') {\n        warn$1(\n          \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n          \"File inputs are read only. Use a v-on:change listener instead.\",\n          el.rawAttrsMap['v-model']\n        );\n      }\n    }\n\n    if (el.component) {\n      genComponentModel(el, value, modifiers);\n      // component v-model doesn't need extra runtime\n      return false\n    } else if (tag === 'select') {\n      genSelect(el, value, modifiers);\n    } else if (tag === 'input' && type === 'checkbox') {\n      genCheckboxModel(el, value, modifiers);\n    } else if (tag === 'input' && type === 'radio') {\n      genRadioModel(el, value, modifiers);\n    } else if (tag === 'input' || tag === 'textarea') {\n      genDefaultModel(el, value, modifiers);\n    } else if (!config.isReservedTag(tag)) {\n      genComponentModel(el, value, modifiers);\n      // component v-model doesn't need extra runtime\n      return false\n    } else {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"v-model is not supported on this element type. \" +\n        'If you are working with contenteditable, it\\'s recommended to ' +\n        'wrap a library dedicated for that purpose inside a custom component.',\n        el.rawAttrsMap['v-model']\n      );\n    }\n\n    // ensure runtime directive metadata\n    return true\n  }\n\n  function genCheckboxModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n    addProp(el, 'checked',\n      \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n    );\n    addHandler(el, 'change',\n      \"var $$a=\" + value + \",\" +\n          '$$el=$event.target,' +\n          \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n      'if(Array.isArray($$a)){' +\n        \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n            '$$i=_i($$a,$$v);' +\n        \"if($$el.checked){$$i<0&&(\" + (genAssignmentCode(value, '$$a.concat([$$v])')) + \")}\" +\n        \"else{$$i>-1&&(\" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + \")}\" +\n      \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n      null, true\n    );\n  }\n\n  function genRadioModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n    addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n  }\n\n  function genSelect (\n    el,\n    value,\n    modifiers\n  ) {\n    var number = modifiers && modifiers.number;\n    var selectedVal = \"Array.prototype.filter\" +\n      \".call($event.target.options,function(o){return o.selected})\" +\n      \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n      \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n    var code = \"var $$selectedVal = \" + selectedVal + \";\";\n    code = code + \" \" + (genAssignmentCode(value, assignment));\n    addHandler(el, 'change', code, null, true);\n  }\n\n  function genDefaultModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var type = el.attrsMap.type;\n\n    // warn if v-bind:value conflicts with v-model\n    // except for inputs with v-bind:type\n    {\n      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n      if (value$1 && !typeBinding) {\n        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n        warn$1(\n          binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" +\n          'because the latter already expands to a value binding internally',\n          el.rawAttrsMap[binding]\n        );\n      }\n    }\n\n    var ref = modifiers || {};\n    var lazy = ref.lazy;\n    var number = ref.number;\n    var trim = ref.trim;\n    var needCompositionGuard = !lazy && type !== 'range';\n    var event = lazy\n      ? 'change'\n      : type === 'range'\n        ? RANGE_TOKEN\n        : 'input';\n\n    var valueExpression = '$event.target.value';\n    if (trim) {\n      valueExpression = \"$event.target.value.trim()\";\n    }\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var code = genAssignmentCode(value, valueExpression);\n    if (needCompositionGuard) {\n      code = \"if($event.target.composing)return;\" + code;\n    }\n\n    addProp(el, 'value', (\"(\" + value + \")\"));\n    addHandler(el, event, code, null, true);\n    if (trim || number) {\n      addHandler(el, 'blur', '$forceUpdate()');\n    }\n  }\n\n  /*  */\n\n  // normalize v-model event tokens that can only be determined at runtime.\n  // it's important to place the event as the first in the array because\n  // the whole point is ensuring the v-model callback gets called before\n  // user-attached handlers.\n  function normalizeEvents (on) {\n    /* istanbul ignore if */\n    if (isDef(on[RANGE_TOKEN])) {\n      // IE input[type=range] only supports `change` event\n      var event = isIE ? 'change' : 'input';\n      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n      delete on[RANGE_TOKEN];\n    }\n    // This was originally intended to fix #4521 but no longer necessary\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n    /* istanbul ignore if */\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n      delete on[CHECKBOX_RADIO_TOKEN];\n    }\n  }\n\n  var target$1;\n\n  function createOnceHandler$1 (event, handler, capture) {\n    var _target = target$1; // save current target element in closure\n    return function onceHandler () {\n      var res = handler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, onceHandler, capture, _target);\n      }\n    }\n  }\n\n  // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n  // implementation and does not fire microtasks in between event propagation, so\n  // safe to exclude.\n  var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\n  function add$1 (\n    name,\n    handler,\n    capture,\n    passive\n  ) {\n    // async edge case #6566: inner click event triggers patch, event handler\n    // attached to outer element during patch, and triggered again. This\n    // happens because browsers fire microtask ticks between event propagation.\n    // the solution is simple: we save the timestamp when a handler is attached,\n    // and the handler would only fire if the event passed to it was fired\n    // AFTER it was attached.\n    if (useMicrotaskFix) {\n      var attachedTimestamp = currentFlushTimestamp;\n      var original = handler;\n      handler = original._wrapper = function (e) {\n        if (\n          // no bubbling, should always fire.\n          // this is just a safety net in case event.timeStamp is unreliable in\n          // certain weird environments...\n          e.target === e.currentTarget ||\n          // event is fired after handler attachment\n          e.timeStamp >= attachedTimestamp ||\n          // bail for environments that have buggy event.timeStamp implementations\n          // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n          // #9681 QtWebEngine event.timeStamp is negative value\n          e.timeStamp <= 0 ||\n          // #9448 bail if event is fired in another document in a multi-page\n          // electron/nw.js app, since event.timeStamp will be using a different\n          // starting reference\n          e.target.ownerDocument !== document\n        ) {\n          return original.apply(this, arguments)\n        }\n      };\n    }\n    target$1.addEventListener(\n      name,\n      handler,\n      supportsPassive\n        ? { capture: capture, passive: passive }\n        : capture\n    );\n  }\n\n  function remove$2 (\n    name,\n    handler,\n    capture,\n    _target\n  ) {\n    (_target || target$1).removeEventListener(\n      name,\n      handler._wrapper || handler,\n      capture\n    );\n  }\n\n  function updateDOMListeners (oldVnode, vnode) {\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n      return\n    }\n    var on = vnode.data.on || {};\n    var oldOn = oldVnode.data.on || {};\n    target$1 = vnode.elm;\n    normalizeEvents(on);\n    updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n    target$1 = undefined;\n  }\n\n  var events = {\n    create: updateDOMListeners,\n    update: updateDOMListeners\n  };\n\n  /*  */\n\n  var svgContainer;\n\n  function updateDOMProps (oldVnode, vnode) {\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n      return\n    }\n    var key, cur;\n    var elm = vnode.elm;\n    var oldProps = oldVnode.data.domProps || {};\n    var props = vnode.data.domProps || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(props.__ob__)) {\n      props = vnode.data.domProps = extend({}, props);\n    }\n\n    for (key in oldProps) {\n      if (!(key in props)) {\n        elm[key] = '';\n      }\n    }\n\n    for (key in props) {\n      cur = props[key];\n      // ignore children if the node has textContent or innerHTML,\n      // as these will throw away existing DOM nodes and cause removal errors\n      // on subsequent patches (#3360)\n      if (key === 'textContent' || key === 'innerHTML') {\n        if (vnode.children) { vnode.children.length = 0; }\n        if (cur === oldProps[key]) { continue }\n        // #6601 work around Chrome version <= 55 bug where single textNode\n        // replaced by innerHTML/textContent retains its parentNode property\n        if (elm.childNodes.length === 1) {\n          elm.removeChild(elm.childNodes[0]);\n        }\n      }\n\n      if (key === 'value' && elm.tagName !== 'PROGRESS') {\n        // store value as _value as well since\n        // non-string values will be stringified\n        elm._value = cur;\n        // avoid resetting cursor position when value is the same\n        var strCur = isUndef(cur) ? '' : String(cur);\n        if (shouldUpdateValue(elm, strCur)) {\n          elm.value = strCur;\n        }\n      } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n        // IE doesn't support innerHTML for SVG elements\n        svgContainer = svgContainer || document.createElement('div');\n        svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n        var svg = svgContainer.firstChild;\n        while (elm.firstChild) {\n          elm.removeChild(elm.firstChild);\n        }\n        while (svg.firstChild) {\n          elm.appendChild(svg.firstChild);\n        }\n      } else if (\n        // skip the update if old and new VDOM state is the same.\n        // `value` is handled separately because the DOM value may be temporarily\n        // out of sync with VDOM state due to focus, composition and modifiers.\n        // This  #4521 by skipping the unnecessary `checked` update.\n        cur !== oldProps[key]\n      ) {\n        // some property updates can throw\n        // e.g. `value` on <progress> w/ non-finite value\n        try {\n          elm[key] = cur;\n        } catch (e) {}\n      }\n    }\n  }\n\n  // check platforms/web/util/attrs.js acceptValue\n\n\n  function shouldUpdateValue (elm, checkVal) {\n    return (!elm.composing && (\n      elm.tagName === 'OPTION' ||\n      isNotInFocusAndDirty(elm, checkVal) ||\n      isDirtyWithModifiers(elm, checkVal)\n    ))\n  }\n\n  function isNotInFocusAndDirty (elm, checkVal) {\n    // return true when textbox (.number and .trim) loses focus and its value is\n    // not equal to the updated value\n    var notInFocus = true;\n    // #6157\n    // work around IE bug when accessing document.activeElement in an iframe\n    try { notInFocus = document.activeElement !== elm; } catch (e) {}\n    return notInFocus && elm.value !== checkVal\n  }\n\n  function isDirtyWithModifiers (elm, newVal) {\n    var value = elm.value;\n    var modifiers = elm._vModifiers; // injected by v-model runtime\n    if (isDef(modifiers)) {\n      if (modifiers.number) {\n        return toNumber(value) !== toNumber(newVal)\n      }\n      if (modifiers.trim) {\n        return value.trim() !== newVal.trim()\n      }\n    }\n    return value !== newVal\n  }\n\n  var domProps = {\n    create: updateDOMProps,\n    update: updateDOMProps\n  };\n\n  /*  */\n\n  var parseStyleText = cached(function (cssText) {\n    var res = {};\n    var listDelimiter = /;(?![^(]*\\))/g;\n    var propertyDelimiter = /:(.+)/;\n    cssText.split(listDelimiter).forEach(function (item) {\n      if (item) {\n        var tmp = item.split(propertyDelimiter);\n        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n      }\n    });\n    return res\n  });\n\n  // merge static and dynamic style data on the same vnode\n  function normalizeStyleData (data) {\n    var style = normalizeStyleBinding(data.style);\n    // static style is pre-processed into an object during compilation\n    // and is always a fresh object, so it's safe to merge into it\n    return data.staticStyle\n      ? extend(data.staticStyle, style)\n      : style\n  }\n\n  // normalize possible array / string values into Object\n  function normalizeStyleBinding (bindingStyle) {\n    if (Array.isArray(bindingStyle)) {\n      return toObject(bindingStyle)\n    }\n    if (typeof bindingStyle === 'string') {\n      return parseStyleText(bindingStyle)\n    }\n    return bindingStyle\n  }\n\n  /**\n   * parent component style should be after child's\n   * so that parent component's style could override it\n   */\n  function getStyle (vnode, checkChild) {\n    var res = {};\n    var styleData;\n\n    if (checkChild) {\n      var childNode = vnode;\n      while (childNode.componentInstance) {\n        childNode = childNode.componentInstance._vnode;\n        if (\n          childNode && childNode.data &&\n          (styleData = normalizeStyleData(childNode.data))\n        ) {\n          extend(res, styleData);\n        }\n      }\n    }\n\n    if ((styleData = normalizeStyleData(vnode.data))) {\n      extend(res, styleData);\n    }\n\n    var parentNode = vnode;\n    while ((parentNode = parentNode.parent)) {\n      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n        extend(res, styleData);\n      }\n    }\n    return res\n  }\n\n  /*  */\n\n  var cssVarRE = /^--/;\n  var importantRE = /\\s*!important$/;\n  var setProp = function (el, name, val) {\n    /* istanbul ignore if */\n    if (cssVarRE.test(name)) {\n      el.style.setProperty(name, val);\n    } else if (importantRE.test(val)) {\n      el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n    } else {\n      var normalizedName = normalize(name);\n      if (Array.isArray(val)) {\n        // Support values array created by autoprefixer, e.g.\n        // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n        // Set them one by one, and the browser will only set those it can recognize\n        for (var i = 0, len = val.length; i < len; i++) {\n          el.style[normalizedName] = val[i];\n        }\n      } else {\n        el.style[normalizedName] = val;\n      }\n    }\n  };\n\n  var vendorNames = ['Webkit', 'Moz', 'ms'];\n\n  var emptyStyle;\n  var normalize = cached(function (prop) {\n    emptyStyle = emptyStyle || document.createElement('div').style;\n    prop = camelize(prop);\n    if (prop !== 'filter' && (prop in emptyStyle)) {\n      return prop\n    }\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n    for (var i = 0; i < vendorNames.length; i++) {\n      var name = vendorNames[i] + capName;\n      if (name in emptyStyle) {\n        return name\n      }\n    }\n  });\n\n  function updateStyle (oldVnode, vnode) {\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticStyle) && isUndef(data.style) &&\n      isUndef(oldData.staticStyle) && isUndef(oldData.style)\n    ) {\n      return\n    }\n\n    var cur, name;\n    var el = vnode.elm;\n    var oldStaticStyle = oldData.staticStyle;\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n    // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n    var oldStyle = oldStaticStyle || oldStyleBinding;\n\n    var style = normalizeStyleBinding(vnode.data.style) || {};\n\n    // store normalized style under a different key for next diff\n    // make sure to clone it if it's reactive, since the user likely wants\n    // to mutate it.\n    vnode.data.normalizedStyle = isDef(style.__ob__)\n      ? extend({}, style)\n      : style;\n\n    var newStyle = getStyle(vnode, true);\n\n    for (name in oldStyle) {\n      if (isUndef(newStyle[name])) {\n        setProp(el, name, '');\n      }\n    }\n    for (name in newStyle) {\n      cur = newStyle[name];\n      if (cur !== oldStyle[name]) {\n        // ie9 setting to null has no effect, must use empty string\n        setProp(el, name, cur == null ? '' : cur);\n      }\n    }\n  }\n\n  var style = {\n    create: updateStyle,\n    update: updateStyle\n  };\n\n  /*  */\n\n  var whitespaceRE = /\\s+/;\n\n  /**\n   * Add class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function addClass (el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return\n    }\n\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\n      } else {\n        el.classList.add(cls);\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\n        el.setAttribute('class', (cur + cls).trim());\n      }\n    }\n  }\n\n  /**\n   * Remove class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function removeClass (el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return\n    }\n\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\n      } else {\n        el.classList.remove(cls);\n      }\n      if (!el.classList.length) {\n        el.removeAttribute('class');\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      var tar = ' ' + cls + ' ';\n      while (cur.indexOf(tar) >= 0) {\n        cur = cur.replace(tar, ' ');\n      }\n      cur = cur.trim();\n      if (cur) {\n        el.setAttribute('class', cur);\n      } else {\n        el.removeAttribute('class');\n      }\n    }\n  }\n\n  /*  */\n\n  function resolveTransition (def$$1) {\n    if (!def$$1) {\n      return\n    }\n    /* istanbul ignore else */\n    if (typeof def$$1 === 'object') {\n      var res = {};\n      if (def$$1.css !== false) {\n        extend(res, autoCssTransition(def$$1.name || 'v'));\n      }\n      extend(res, def$$1);\n      return res\n    } else if (typeof def$$1 === 'string') {\n      return autoCssTransition(def$$1)\n    }\n  }\n\n  var autoCssTransition = cached(function (name) {\n    return {\n      enterClass: (name + \"-enter\"),\n      enterToClass: (name + \"-enter-to\"),\n      enterActiveClass: (name + \"-enter-active\"),\n      leaveClass: (name + \"-leave\"),\n      leaveToClass: (name + \"-leave-to\"),\n      leaveActiveClass: (name + \"-leave-active\")\n    }\n  });\n\n  var hasTransition = inBrowser && !isIE9;\n  var TRANSITION = 'transition';\n  var ANIMATION = 'animation';\n\n  // Transition property/event sniffing\n  var transitionProp = 'transition';\n  var transitionEndEvent = 'transitionend';\n  var animationProp = 'animation';\n  var animationEndEvent = 'animationend';\n  if (hasTransition) {\n    /* istanbul ignore if */\n    if (window.ontransitionend === undefined &&\n      window.onwebkittransitionend !== undefined\n    ) {\n      transitionProp = 'WebkitTransition';\n      transitionEndEvent = 'webkitTransitionEnd';\n    }\n    if (window.onanimationend === undefined &&\n      window.onwebkitanimationend !== undefined\n    ) {\n      animationProp = 'WebkitAnimation';\n      animationEndEvent = 'webkitAnimationEnd';\n    }\n  }\n\n  // binding to window is necessary to make hot reload work in IE in strict mode\n  var raf = inBrowser\n    ? window.requestAnimationFrame\n      ? window.requestAnimationFrame.bind(window)\n      : setTimeout\n    : /* istanbul ignore next */ function (fn) { return fn(); };\n\n  function nextFrame (fn) {\n    raf(function () {\n      raf(fn);\n    });\n  }\n\n  function addTransitionClass (el, cls) {\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n    if (transitionClasses.indexOf(cls) < 0) {\n      transitionClasses.push(cls);\n      addClass(el, cls);\n    }\n  }\n\n  function removeTransitionClass (el, cls) {\n    if (el._transitionClasses) {\n      remove(el._transitionClasses, cls);\n    }\n    removeClass(el, cls);\n  }\n\n  function whenTransitionEnds (\n    el,\n    expectedType,\n    cb\n  ) {\n    var ref = getTransitionInfo(el, expectedType);\n    var type = ref.type;\n    var timeout = ref.timeout;\n    var propCount = ref.propCount;\n    if (!type) { return cb() }\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n    var ended = 0;\n    var end = function () {\n      el.removeEventListener(event, onEnd);\n      cb();\n    };\n    var onEnd = function (e) {\n      if (e.target === el) {\n        if (++ended >= propCount) {\n          end();\n        }\n      }\n    };\n    setTimeout(function () {\n      if (ended < propCount) {\n        end();\n      }\n    }, timeout + 1);\n    el.addEventListener(event, onEnd);\n  }\n\n  var transformRE = /\\b(transform|all)(,|$)/;\n\n  function getTransitionInfo (el, expectedType) {\n    var styles = window.getComputedStyle(el);\n    // JSDOM may return undefined for transition properties\n    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n    var type;\n    var timeout = 0;\n    var propCount = 0;\n    /* istanbul ignore if */\n    if (expectedType === TRANSITION) {\n      if (transitionTimeout > 0) {\n        type = TRANSITION;\n        timeout = transitionTimeout;\n        propCount = transitionDurations.length;\n      }\n    } else if (expectedType === ANIMATION) {\n      if (animationTimeout > 0) {\n        type = ANIMATION;\n        timeout = animationTimeout;\n        propCount = animationDurations.length;\n      }\n    } else {\n      timeout = Math.max(transitionTimeout, animationTimeout);\n      type = timeout > 0\n        ? transitionTimeout > animationTimeout\n          ? TRANSITION\n          : ANIMATION\n        : null;\n      propCount = type\n        ? type === TRANSITION\n          ? transitionDurations.length\n          : animationDurations.length\n        : 0;\n    }\n    var hasTransform =\n      type === TRANSITION &&\n      transformRE.test(styles[transitionProp + 'Property']);\n    return {\n      type: type,\n      timeout: timeout,\n      propCount: propCount,\n      hasTransform: hasTransform\n    }\n  }\n\n  function getTimeout (delays, durations) {\n    /* istanbul ignore next */\n    while (delays.length < durations.length) {\n      delays = delays.concat(delays);\n    }\n\n    return Math.max.apply(null, durations.map(function (d, i) {\n      return toMs(d) + toMs(delays[i])\n    }))\n  }\n\n  // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n  // in a locale-dependent way, using a comma instead of a dot.\n  // If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n  // as a floor function) causing unexpected behaviors\n  function toMs (s) {\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000\n  }\n\n  /*  */\n\n  function enter (vnode, toggleDisplay) {\n    var el = vnode.elm;\n\n    // call leave callback now\n    if (isDef(el._leaveCb)) {\n      el._leaveCb.cancelled = true;\n      el._leaveCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data)) {\n      return\n    }\n\n    /* istanbul ignore if */\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\n      return\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var enterClass = data.enterClass;\n    var enterToClass = data.enterToClass;\n    var enterActiveClass = data.enterActiveClass;\n    var appearClass = data.appearClass;\n    var appearToClass = data.appearToClass;\n    var appearActiveClass = data.appearActiveClass;\n    var beforeEnter = data.beforeEnter;\n    var enter = data.enter;\n    var afterEnter = data.afterEnter;\n    var enterCancelled = data.enterCancelled;\n    var beforeAppear = data.beforeAppear;\n    var appear = data.appear;\n    var afterAppear = data.afterAppear;\n    var appearCancelled = data.appearCancelled;\n    var duration = data.duration;\n\n    // activeInstance will always be the <transition> component managing this\n    // transition. One edge case to check is when the <transition> is placed\n    // as the root node of a child component. In that case we need to check\n    // <transition>'s parent for appear check.\n    var context = activeInstance;\n    var transitionNode = activeInstance.$vnode;\n    while (transitionNode && transitionNode.parent) {\n      context = transitionNode.context;\n      transitionNode = transitionNode.parent;\n    }\n\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n    if (isAppear && !appear && appear !== '') {\n      return\n    }\n\n    var startClass = isAppear && appearClass\n      ? appearClass\n      : enterClass;\n    var activeClass = isAppear && appearActiveClass\n      ? appearActiveClass\n      : enterActiveClass;\n    var toClass = isAppear && appearToClass\n      ? appearToClass\n      : enterToClass;\n\n    var beforeEnterHook = isAppear\n      ? (beforeAppear || beforeEnter)\n      : beforeEnter;\n    var enterHook = isAppear\n      ? (typeof appear === 'function' ? appear : enter)\n      : enter;\n    var afterEnterHook = isAppear\n      ? (afterAppear || afterEnter)\n      : afterEnter;\n    var enterCancelledHook = isAppear\n      ? (appearCancelled || enterCancelled)\n      : enterCancelled;\n\n    var explicitEnterDuration = toNumber(\n      isObject(duration)\n        ? duration.enter\n        : duration\n    );\n\n    if (explicitEnterDuration != null) {\n      checkDuration(explicitEnterDuration, 'enter', vnode);\n    }\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(enterHook);\n\n    var cb = el._enterCb = once(function () {\n      if (expectsCSS) {\n        removeTransitionClass(el, toClass);\n        removeTransitionClass(el, activeClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, startClass);\n        }\n        enterCancelledHook && enterCancelledHook(el);\n      } else {\n        afterEnterHook && afterEnterHook(el);\n      }\n      el._enterCb = null;\n    });\n\n    if (!vnode.data.show) {\n      // remove pending leave element on enter by injecting an insert hook\n      mergeVNodeHook(vnode, 'insert', function () {\n        var parent = el.parentNode;\n        var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n        if (pendingNode &&\n          pendingNode.tag === vnode.tag &&\n          pendingNode.elm._leaveCb\n        ) {\n          pendingNode.elm._leaveCb();\n        }\n        enterHook && enterHook(el, cb);\n      });\n    }\n\n    // start enter transition\n    beforeEnterHook && beforeEnterHook(el);\n    if (expectsCSS) {\n      addTransitionClass(el, startClass);\n      addTransitionClass(el, activeClass);\n      nextFrame(function () {\n        removeTransitionClass(el, startClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, toClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitEnterDuration)) {\n              setTimeout(cb, explicitEnterDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n\n    if (vnode.data.show) {\n      toggleDisplay && toggleDisplay();\n      enterHook && enterHook(el, cb);\n    }\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n\n  function leave (vnode, rm) {\n    var el = vnode.elm;\n\n    // call enter callback now\n    if (isDef(el._enterCb)) {\n      el._enterCb.cancelled = true;\n      el._enterCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data) || el.nodeType !== 1) {\n      return rm()\n    }\n\n    /* istanbul ignore if */\n    if (isDef(el._leaveCb)) {\n      return\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var leaveClass = data.leaveClass;\n    var leaveToClass = data.leaveToClass;\n    var leaveActiveClass = data.leaveActiveClass;\n    var beforeLeave = data.beforeLeave;\n    var leave = data.leave;\n    var afterLeave = data.afterLeave;\n    var leaveCancelled = data.leaveCancelled;\n    var delayLeave = data.delayLeave;\n    var duration = data.duration;\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(leave);\n\n    var explicitLeaveDuration = toNumber(\n      isObject(duration)\n        ? duration.leave\n        : duration\n    );\n\n    if (isDef(explicitLeaveDuration)) {\n      checkDuration(explicitLeaveDuration, 'leave', vnode);\n    }\n\n    var cb = el._leaveCb = once(function () {\n      if (el.parentNode && el.parentNode._pending) {\n        el.parentNode._pending[vnode.key] = null;\n      }\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveActiveClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, leaveClass);\n        }\n        leaveCancelled && leaveCancelled(el);\n      } else {\n        rm();\n        afterLeave && afterLeave(el);\n      }\n      el._leaveCb = null;\n    });\n\n    if (delayLeave) {\n      delayLeave(performLeave);\n    } else {\n      performLeave();\n    }\n\n    function performLeave () {\n      // the delayed leave may have already been cancelled\n      if (cb.cancelled) {\n        return\n      }\n      // record leaving element\n      if (!vnode.data.show && el.parentNode) {\n        (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n      }\n      beforeLeave && beforeLeave(el);\n      if (expectsCSS) {\n        addTransitionClass(el, leaveClass);\n        addTransitionClass(el, leaveActiveClass);\n        nextFrame(function () {\n          removeTransitionClass(el, leaveClass);\n          if (!cb.cancelled) {\n            addTransitionClass(el, leaveToClass);\n            if (!userWantsControl) {\n              if (isValidDuration(explicitLeaveDuration)) {\n                setTimeout(cb, explicitLeaveDuration);\n              } else {\n                whenTransitionEnds(el, type, cb);\n              }\n            }\n          }\n        });\n      }\n      leave && leave(el, cb);\n      if (!expectsCSS && !userWantsControl) {\n        cb();\n      }\n    }\n  }\n\n  // only used in dev mode\n  function checkDuration (val, name, vnode) {\n    if (typeof val !== 'number') {\n      warn(\n        \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n        \"got \" + (JSON.stringify(val)) + \".\",\n        vnode.context\n      );\n    } else if (isNaN(val)) {\n      warn(\n        \"<transition> explicit \" + name + \" duration is NaN - \" +\n        'the duration expression might be incorrect.',\n        vnode.context\n      );\n    }\n  }\n\n  function isValidDuration (val) {\n    return typeof val === 'number' && !isNaN(val)\n  }\n\n  /**\n   * Normalize a transition hook's argument length. The hook may be:\n   * - a merged hook (invoker) with the original in .fns\n   * - a wrapped component method (check ._length)\n   * - a plain function (.length)\n   */\n  function getHookArgumentsLength (fn) {\n    if (isUndef(fn)) {\n      return false\n    }\n    var invokerFns = fn.fns;\n    if (isDef(invokerFns)) {\n      // invoker\n      return getHookArgumentsLength(\n        Array.isArray(invokerFns)\n          ? invokerFns[0]\n          : invokerFns\n      )\n    } else {\n      return (fn._length || fn.length) > 1\n    }\n  }\n\n  function _enter (_, vnode) {\n    if (vnode.data.show !== true) {\n      enter(vnode);\n    }\n  }\n\n  var transition = inBrowser ? {\n    create: _enter,\n    activate: _enter,\n    remove: function remove$$1 (vnode, rm) {\n      /* istanbul ignore else */\n      if (vnode.data.show !== true) {\n        leave(vnode, rm);\n      } else {\n        rm();\n      }\n    }\n  } : {};\n\n  var platformModules = [\n    attrs,\n    klass,\n    events,\n    domProps,\n    style,\n    transition\n  ];\n\n  /*  */\n\n  // the directive module should be applied last, after all\n  // built-in modules have been applied.\n  var modules = platformModules.concat(baseModules);\n\n  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n  /**\n   * Not type checking this file because flow doesn't like attaching\n   * properties to Elements.\n   */\n\n  /* istanbul ignore if */\n  if (isIE9) {\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\n    document.addEventListener('selectionchange', function () {\n      var el = document.activeElement;\n      if (el && el.vmodel) {\n        trigger(el, 'input');\n      }\n    });\n  }\n\n  var directive = {\n    inserted: function inserted (el, binding, vnode, oldVnode) {\n      if (vnode.tag === 'select') {\n        // #6903\n        if (oldVnode.elm && !oldVnode.elm._vOptions) {\n          mergeVNodeHook(vnode, 'postpatch', function () {\n            directive.componentUpdated(el, binding, vnode);\n          });\n        } else {\n          setSelected(el, binding, vnode.context);\n        }\n        el._vOptions = [].map.call(el.options, getValue);\n      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n        el._vModifiers = binding.modifiers;\n        if (!binding.modifiers.lazy) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n          // Safari < 10.2 & UIWebView doesn't fire compositionend when\n          // switching focus before confirming composition choice\n          // this also fixes the issue where some browsers e.g. iOS Chrome\n          // fires \"change\" instead of \"input\" on autocomplete.\n          el.addEventListener('change', onCompositionEnd);\n          /* istanbul ignore if */\n          if (isIE9) {\n            el.vmodel = true;\n          }\n        }\n      }\n    },\n\n    componentUpdated: function componentUpdated (el, binding, vnode) {\n      if (vnode.tag === 'select') {\n        setSelected(el, binding, vnode.context);\n        // in case the options rendered by v-for have changed,\n        // it's possible that the value is out-of-sync with the rendered options.\n        // detect such cases and filter out values that no longer has a matching\n        // option in the DOM.\n        var prevOptions = el._vOptions;\n        var curOptions = el._vOptions = [].map.call(el.options, getValue);\n        if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n          // trigger change event if\n          // no matching option found for at least one value\n          var needReset = el.multiple\n            ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n            : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n          if (needReset) {\n            trigger(el, 'change');\n          }\n        }\n      }\n    }\n  };\n\n  function setSelected (el, binding, vm) {\n    actuallySetSelected(el, binding, vm);\n    /* istanbul ignore if */\n    if (isIE || isEdge) {\n      setTimeout(function () {\n        actuallySetSelected(el, binding, vm);\n      }, 0);\n    }\n  }\n\n  function actuallySetSelected (el, binding, vm) {\n    var value = binding.value;\n    var isMultiple = el.multiple;\n    if (isMultiple && !Array.isArray(value)) {\n      warn(\n        \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n        \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n        vm\n      );\n      return\n    }\n    var selected, option;\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      option = el.options[i];\n      if (isMultiple) {\n        selected = looseIndexOf(value, getValue(option)) > -1;\n        if (option.selected !== selected) {\n          option.selected = selected;\n        }\n      } else {\n        if (looseEqual(getValue(option), value)) {\n          if (el.selectedIndex !== i) {\n            el.selectedIndex = i;\n          }\n          return\n        }\n      }\n    }\n    if (!isMultiple) {\n      el.selectedIndex = -1;\n    }\n  }\n\n  function hasNoMatchingOption (value, options) {\n    return options.every(function (o) { return !looseEqual(o, value); })\n  }\n\n  function getValue (option) {\n    return '_value' in option\n      ? option._value\n      : option.value\n  }\n\n  function onCompositionStart (e) {\n    e.target.composing = true;\n  }\n\n  function onCompositionEnd (e) {\n    // prevent triggering an input event for no reason\n    if (!e.target.composing) { return }\n    e.target.composing = false;\n    trigger(e.target, 'input');\n  }\n\n  function trigger (el, type) {\n    var e = document.createEvent('HTMLEvents');\n    e.initEvent(type, true, true);\n    el.dispatchEvent(e);\n  }\n\n  /*  */\n\n  // recursively search for possible transition defined inside the component root\n  function locateNode (vnode) {\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n      ? locateNode(vnode.componentInstance._vnode)\n      : vnode\n  }\n\n  var show = {\n    bind: function bind (el, ref, vnode) {\n      var value = ref.value;\n\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      var originalDisplay = el.__vOriginalDisplay =\n        el.style.display === 'none' ? '' : el.style.display;\n      if (value && transition$$1) {\n        vnode.data.show = true;\n        enter(vnode, function () {\n          el.style.display = originalDisplay;\n        });\n      } else {\n        el.style.display = value ? originalDisplay : 'none';\n      }\n    },\n\n    update: function update (el, ref, vnode) {\n      var value = ref.value;\n      var oldValue = ref.oldValue;\n\n      /* istanbul ignore if */\n      if (!value === !oldValue) { return }\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      if (transition$$1) {\n        vnode.data.show = true;\n        if (value) {\n          enter(vnode, function () {\n            el.style.display = el.__vOriginalDisplay;\n          });\n        } else {\n          leave(vnode, function () {\n            el.style.display = 'none';\n          });\n        }\n      } else {\n        el.style.display = value ? el.__vOriginalDisplay : 'none';\n      }\n    },\n\n    unbind: function unbind (\n      el,\n      binding,\n      vnode,\n      oldVnode,\n      isDestroy\n    ) {\n      if (!isDestroy) {\n        el.style.display = el.__vOriginalDisplay;\n      }\n    }\n  };\n\n  var platformDirectives = {\n    model: directive,\n    show: show\n  };\n\n  /*  */\n\n  var transitionProps = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterToClass: String,\n    leaveToClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    duration: [Number, String, Object]\n  };\n\n  // in case the child is also an abstract component, e.g. <keep-alive>\n  // we want to recursively retrieve the real component to be rendered\n  function getRealChild (vnode) {\n    var compOptions = vnode && vnode.componentOptions;\n    if (compOptions && compOptions.Ctor.options.abstract) {\n      return getRealChild(getFirstComponentChild(compOptions.children))\n    } else {\n      return vnode\n    }\n  }\n\n  function extractTransitionData (comp) {\n    var data = {};\n    var options = comp.$options;\n    // props\n    for (var key in options.propsData) {\n      data[key] = comp[key];\n    }\n    // events.\n    // extract listeners and pass them directly to the transition methods\n    var listeners = options._parentListeners;\n    for (var key$1 in listeners) {\n      data[camelize(key$1)] = listeners[key$1];\n    }\n    return data\n  }\n\n  function placeholder (h, rawChild) {\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\n      return h('keep-alive', {\n        props: rawChild.componentOptions.propsData\n      })\n    }\n  }\n\n  function hasParentTransition (vnode) {\n    while ((vnode = vnode.parent)) {\n      if (vnode.data.transition) {\n        return true\n      }\n    }\n  }\n\n  function isSameChild (child, oldChild) {\n    return oldChild.key === child.key && oldChild.tag === child.tag\n  }\n\n  var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\n\n  var isVShowDirective = function (d) { return d.name === 'show'; };\n\n  var Transition = {\n    name: 'transition',\n    props: transitionProps,\n    abstract: true,\n\n    render: function render (h) {\n      var this$1 = this;\n\n      var children = this.$slots.default;\n      if (!children) {\n        return\n      }\n\n      // filter out text nodes (possible whitespaces)\n      children = children.filter(isNotTextNode);\n      /* istanbul ignore if */\n      if (!children.length) {\n        return\n      }\n\n      // warn multiple elements\n      if (children.length > 1) {\n        warn(\n          '<transition> can only be used on a single element. Use ' +\n          '<transition-group> for lists.',\n          this.$parent\n        );\n      }\n\n      var mode = this.mode;\n\n      // warn invalid mode\n      if (mode && mode !== 'in-out' && mode !== 'out-in'\n      ) {\n        warn(\n          'invalid <transition> mode: ' + mode,\n          this.$parent\n        );\n      }\n\n      var rawChild = children[0];\n\n      // if this is a component root node and the component's\n      // parent container node also has transition, skip.\n      if (hasParentTransition(this.$vnode)) {\n        return rawChild\n      }\n\n      // apply transition data to child\n      // use getRealChild() to ignore abstract components e.g. keep-alive\n      var child = getRealChild(rawChild);\n      /* istanbul ignore if */\n      if (!child) {\n        return rawChild\n      }\n\n      if (this._leaving) {\n        return placeholder(h, rawChild)\n      }\n\n      // ensure a key that is unique to the vnode type and to this transition\n      // component instance. This key will be used to remove pending leaving nodes\n      // during entering.\n      var id = \"__transition-\" + (this._uid) + \"-\";\n      child.key = child.key == null\n        ? child.isComment\n          ? id + 'comment'\n          : id + child.tag\n        : isPrimitive(child.key)\n          ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n          : child.key;\n\n      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n      var oldRawChild = this._vnode;\n      var oldChild = getRealChild(oldRawChild);\n\n      // mark v-show\n      // so that the transition module can hand over the control to the directive\n      if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n        child.data.show = true;\n      }\n\n      if (\n        oldChild &&\n        oldChild.data &&\n        !isSameChild(child, oldChild) &&\n        !isAsyncPlaceholder(oldChild) &&\n        // #6687 component root is a comment node\n        !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n      ) {\n        // replace old child transition data with fresh one\n        // important for dynamic transitions!\n        var oldData = oldChild.data.transition = extend({}, data);\n        // handle transition mode\n        if (mode === 'out-in') {\n          // return placeholder node and queue update when leave finishes\n          this._leaving = true;\n          mergeVNodeHook(oldData, 'afterLeave', function () {\n            this$1._leaving = false;\n            this$1.$forceUpdate();\n          });\n          return placeholder(h, rawChild)\n        } else if (mode === 'in-out') {\n          if (isAsyncPlaceholder(child)) {\n            return oldRawChild\n          }\n          var delayedLeave;\n          var performLeave = function () { delayedLeave(); };\n          mergeVNodeHook(data, 'afterEnter', performLeave);\n          mergeVNodeHook(data, 'enterCancelled', performLeave);\n          mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n        }\n      }\n\n      return rawChild\n    }\n  };\n\n  /*  */\n\n  var props = extend({\n    tag: String,\n    moveClass: String\n  }, transitionProps);\n\n  delete props.mode;\n\n  var TransitionGroup = {\n    props: props,\n\n    beforeMount: function beforeMount () {\n      var this$1 = this;\n\n      var update = this._update;\n      this._update = function (vnode, hydrating) {\n        var restoreActiveInstance = setActiveInstance(this$1);\n        // force removing pass\n        this$1.__patch__(\n          this$1._vnode,\n          this$1.kept,\n          false, // hydrating\n          true // removeOnly (!important, avoids unnecessary moves)\n        );\n        this$1._vnode = this$1.kept;\n        restoreActiveInstance();\n        update.call(this$1, vnode, hydrating);\n      };\n    },\n\n    render: function render (h) {\n      var tag = this.tag || this.$vnode.data.tag || 'span';\n      var map = Object.create(null);\n      var prevChildren = this.prevChildren = this.children;\n      var rawChildren = this.$slots.default || [];\n      var children = this.children = [];\n      var transitionData = extractTransitionData(this);\n\n      for (var i = 0; i < rawChildren.length; i++) {\n        var c = rawChildren[i];\n        if (c.tag) {\n          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n            children.push(c);\n            map[c.key] = c\n            ;(c.data || (c.data = {})).transition = transitionData;\n          } else {\n            var opts = c.componentOptions;\n            var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n            warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n          }\n        }\n      }\n\n      if (prevChildren) {\n        var kept = [];\n        var removed = [];\n        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n          var c$1 = prevChildren[i$1];\n          c$1.data.transition = transitionData;\n          c$1.data.pos = c$1.elm.getBoundingClientRect();\n          if (map[c$1.key]) {\n            kept.push(c$1);\n          } else {\n            removed.push(c$1);\n          }\n        }\n        this.kept = h(tag, null, kept);\n        this.removed = removed;\n      }\n\n      return h(tag, null, children)\n    },\n\n    updated: function updated () {\n      var children = this.prevChildren;\n      var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n        return\n      }\n\n      // we divide the work into three loops to avoid mixing DOM reads and writes\n      // in each iteration - which helps prevent layout thrashing.\n      children.forEach(callPendingCbs);\n      children.forEach(recordPosition);\n      children.forEach(applyTranslation);\n\n      // force reflow to put everything in position\n      // assign to this to avoid being removed in tree-shaking\n      // $flow-disable-line\n      this._reflow = document.body.offsetHeight;\n\n      children.forEach(function (c) {\n        if (c.data.moved) {\n          var el = c.elm;\n          var s = el.style;\n          addTransitionClass(el, moveClass);\n          s.transform = s.WebkitTransform = s.transitionDuration = '';\n          el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n            if (e && e.target !== el) {\n              return\n            }\n            if (!e || /transform$/.test(e.propertyName)) {\n              el.removeEventListener(transitionEndEvent, cb);\n              el._moveCb = null;\n              removeTransitionClass(el, moveClass);\n            }\n          });\n        }\n      });\n    },\n\n    methods: {\n      hasMove: function hasMove (el, moveClass) {\n        /* istanbul ignore if */\n        if (!hasTransition) {\n          return false\n        }\n        /* istanbul ignore if */\n        if (this._hasMove) {\n          return this._hasMove\n        }\n        // Detect whether an element with the move class applied has\n        // CSS transitions. Since the element may be inside an entering\n        // transition at this very moment, we make a clone of it and remove\n        // all other transition classes applied to ensure only the move class\n        // is applied.\n        var clone = el.cloneNode();\n        if (el._transitionClasses) {\n          el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n        }\n        addClass(clone, moveClass);\n        clone.style.display = 'none';\n        this.$el.appendChild(clone);\n        var info = getTransitionInfo(clone);\n        this.$el.removeChild(clone);\n        return (this._hasMove = info.hasTransform)\n      }\n    }\n  };\n\n  function callPendingCbs (c) {\n    /* istanbul ignore if */\n    if (c.elm._moveCb) {\n      c.elm._moveCb();\n    }\n    /* istanbul ignore if */\n    if (c.elm._enterCb) {\n      c.elm._enterCb();\n    }\n  }\n\n  function recordPosition (c) {\n    c.data.newPos = c.elm.getBoundingClientRect();\n  }\n\n  function applyTranslation (c) {\n    var oldPos = c.data.pos;\n    var newPos = c.data.newPos;\n    var dx = oldPos.left - newPos.left;\n    var dy = oldPos.top - newPos.top;\n    if (dx || dy) {\n      c.data.moved = true;\n      var s = c.elm.style;\n      s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n      s.transitionDuration = '0s';\n    }\n  }\n\n  var platformComponents = {\n    Transition: Transition,\n    TransitionGroup: TransitionGroup\n  };\n\n  /*  */\n\n  // install platform specific utils\n  Vue.config.mustUseProp = mustUseProp;\n  Vue.config.isReservedTag = isReservedTag;\n  Vue.config.isReservedAttr = isReservedAttr;\n  Vue.config.getTagNamespace = getTagNamespace;\n  Vue.config.isUnknownElement = isUnknownElement;\n\n  // install platform runtime directives & components\n  extend(Vue.options.directives, platformDirectives);\n  extend(Vue.options.components, platformComponents);\n\n  // install platform patch function\n  Vue.prototype.__patch__ = inBrowser ? patch : noop;\n\n  // public mount method\n  Vue.prototype.$mount = function (\n    el,\n    hydrating\n  ) {\n    el = el && inBrowser ? query(el) : undefined;\n    return mountComponent(this, el, hydrating)\n  };\n\n  // devtools global hook\n  /* istanbul ignore next */\n  if (inBrowser) {\n    setTimeout(function () {\n      if (config.devtools) {\n        if (devtools) {\n          devtools.emit('init', Vue);\n        } else {\n          console[console.info ? 'info' : 'log'](\n            'Download the Vue Devtools extension for a better development experience:\\n' +\n            'https://github.com/vuejs/vue-devtools'\n          );\n        }\n      }\n      if (config.productionTip !== false &&\n        typeof console !== 'undefined'\n      ) {\n        console[console.info ? 'info' : 'log'](\n          \"You are running Vue in development mode.\\n\" +\n          \"Make sure to turn on production mode when deploying for production.\\n\" +\n          \"See more tips at https://vuejs.org/guide/deployment.html\"\n        );\n      }\n    }, 0);\n  }\n\n  /*  */\n\n  var defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\n  var buildRegex = cached(function (delimiters) {\n    var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n    var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n  });\n\n\n\n  function parseText (\n    text,\n    delimiters\n  ) {\n    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n    if (!tagRE.test(text)) {\n      return\n    }\n    var tokens = [];\n    var rawTokens = [];\n    var lastIndex = tagRE.lastIndex = 0;\n    var match, index, tokenValue;\n    while ((match = tagRE.exec(text))) {\n      index = match.index;\n      // push text token\n      if (index > lastIndex) {\n        rawTokens.push(tokenValue = text.slice(lastIndex, index));\n        tokens.push(JSON.stringify(tokenValue));\n      }\n      // tag token\n      var exp = parseFilters(match[1].trim());\n      tokens.push((\"_s(\" + exp + \")\"));\n      rawTokens.push({ '@binding': exp });\n      lastIndex = index + match[0].length;\n    }\n    if (lastIndex < text.length) {\n      rawTokens.push(tokenValue = text.slice(lastIndex));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    return {\n      expression: tokens.join('+'),\n      tokens: rawTokens\n    }\n  }\n\n  /*  */\n\n  function transformNode (el, options) {\n    var warn = options.warn || baseWarn;\n    var staticClass = getAndRemoveAttr(el, 'class');\n    if (staticClass) {\n      var res = parseText(staticClass, options.delimiters);\n      if (res) {\n        warn(\n          \"class=\\\"\" + staticClass + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.',\n          el.rawAttrsMap['class']\n        );\n      }\n    }\n    if (staticClass) {\n      el.staticClass = JSON.stringify(staticClass);\n    }\n    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n    if (classBinding) {\n      el.classBinding = classBinding;\n    }\n  }\n\n  function genData (el) {\n    var data = '';\n    if (el.staticClass) {\n      data += \"staticClass:\" + (el.staticClass) + \",\";\n    }\n    if (el.classBinding) {\n      data += \"class:\" + (el.classBinding) + \",\";\n    }\n    return data\n  }\n\n  var klass$1 = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode,\n    genData: genData\n  };\n\n  /*  */\n\n  function transformNode$1 (el, options) {\n    var warn = options.warn || baseWarn;\n    var staticStyle = getAndRemoveAttr(el, 'style');\n    if (staticStyle) {\n      /* istanbul ignore if */\n      {\n        var res = parseText(staticStyle, options.delimiters);\n        if (res) {\n          warn(\n            \"style=\\\"\" + staticStyle + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.',\n            el.rawAttrsMap['style']\n          );\n        }\n      }\n      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n    }\n\n    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n    if (styleBinding) {\n      el.styleBinding = styleBinding;\n    }\n  }\n\n  function genData$1 (el) {\n    var data = '';\n    if (el.staticStyle) {\n      data += \"staticStyle:\" + (el.staticStyle) + \",\";\n    }\n    if (el.styleBinding) {\n      data += \"style:(\" + (el.styleBinding) + \"),\";\n    }\n    return data\n  }\n\n  var style$1 = {\n    staticKeys: ['staticStyle'],\n    transformNode: transformNode$1,\n    genData: genData$1\n  };\n\n  /*  */\n\n  var decoder;\n\n  var he = {\n    decode: function decode (html) {\n      decoder = decoder || document.createElement('div');\n      decoder.innerHTML = html;\n      return decoder.textContent\n    }\n  };\n\n  /*  */\n\n  var isUnaryTag = makeMap(\n    'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n    'link,meta,param,source,track,wbr'\n  );\n\n  // Elements that you can, intentionally, leave open\n  // (and which close themselves)\n  var canBeLeftOpenTag = makeMap(\n    'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n  );\n\n  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n  var isNonPhrasingTag = makeMap(\n    'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n    'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n    'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n    'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n    'title,tr,track'\n  );\n\n  /**\n   * Not type-checking this file because it's mostly vendor code.\n   */\n\n  // Regular Expressions for parsing tags and attributes\n  var attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + (unicodeRegExp.source) + \"]*\";\n  var qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\n  var startTagOpen = new RegExp((\"^<\" + qnameCapture));\n  var startTagClose = /^\\s*(\\/?)>/;\n  var endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\n  var doctype = /^<!DOCTYPE [^>]+>/i;\n  // #7298: escape - to avoid being passed as HTML comment when inlined in page\n  var comment = /^<!\\--/;\n  var conditionalComment = /^<!\\[/;\n\n  // Special Elements (can contain anything)\n  var isPlainTextElement = makeMap('script,style,textarea', true);\n  var reCache = {};\n\n  var decodingMap = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&amp;': '&',\n    '&#10;': '\\n',\n    '&#9;': '\\t',\n    '&#39;': \"'\"\n  };\n  var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\n  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\n\n  // #5992\n  var isIgnoreNewlineTag = makeMap('pre,textarea', true);\n  var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\n  function decodeAttr (value, shouldDecodeNewlines) {\n    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n    return value.replace(re, function (match) { return decodingMap[match]; })\n  }\n\n  function parseHTML (html, options) {\n    var stack = [];\n    var expectHTML = options.expectHTML;\n    var isUnaryTag$$1 = options.isUnaryTag || no;\n    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n    var index = 0;\n    var last, lastTag;\n    while (html) {\n      last = html;\n      // Make sure we're not in a plaintext content element like script/style\n      if (!lastTag || !isPlainTextElement(lastTag)) {\n        var textEnd = html.indexOf('<');\n        if (textEnd === 0) {\n          // Comment:\n          if (comment.test(html)) {\n            var commentEnd = html.indexOf('-->');\n\n            if (commentEnd >= 0) {\n              if (options.shouldKeepComment) {\n                options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n              }\n              advance(commentEnd + 3);\n              continue\n            }\n          }\n\n          // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n          if (conditionalComment.test(html)) {\n            var conditionalEnd = html.indexOf(']>');\n\n            if (conditionalEnd >= 0) {\n              advance(conditionalEnd + 2);\n              continue\n            }\n          }\n\n          // Doctype:\n          var doctypeMatch = html.match(doctype);\n          if (doctypeMatch) {\n            advance(doctypeMatch[0].length);\n            continue\n          }\n\n          // End tag:\n          var endTagMatch = html.match(endTag);\n          if (endTagMatch) {\n            var curIndex = index;\n            advance(endTagMatch[0].length);\n            parseEndTag(endTagMatch[1], curIndex, index);\n            continue\n          }\n\n          // Start tag:\n          var startTagMatch = parseStartTag();\n          if (startTagMatch) {\n            handleStartTag(startTagMatch);\n            if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n              advance(1);\n            }\n            continue\n          }\n        }\n\n        var text = (void 0), rest = (void 0), next = (void 0);\n        if (textEnd >= 0) {\n          rest = html.slice(textEnd);\n          while (\n            !endTag.test(rest) &&\n            !startTagOpen.test(rest) &&\n            !comment.test(rest) &&\n            !conditionalComment.test(rest)\n          ) {\n            // < in plain text, be forgiving and treat it as text\n            next = rest.indexOf('<', 1);\n            if (next < 0) { break }\n            textEnd += next;\n            rest = html.slice(textEnd);\n          }\n          text = html.substring(0, textEnd);\n        }\n\n        if (textEnd < 0) {\n          text = html;\n        }\n\n        if (text) {\n          advance(text.length);\n        }\n\n        if (options.chars && text) {\n          options.chars(text, index - text.length, index);\n        }\n      } else {\n        var endTagLength = 0;\n        var stackedTag = lastTag.toLowerCase();\n        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n          endTagLength = endTag.length;\n          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n            text = text\n              .replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n              .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n          }\n          if (shouldIgnoreFirstNewline(stackedTag, text)) {\n            text = text.slice(1);\n          }\n          if (options.chars) {\n            options.chars(text);\n          }\n          return ''\n        });\n        index += html.length - rest$1.length;\n        html = rest$1;\n        parseEndTag(stackedTag, index - endTagLength, index);\n      }\n\n      if (html === last) {\n        options.chars && options.chars(html);\n        if (!stack.length && options.warn) {\n          options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"), { start: index + html.length });\n        }\n        break\n      }\n    }\n\n    // Clean up any remaining tags\n    parseEndTag();\n\n    function advance (n) {\n      index += n;\n      html = html.substring(n);\n    }\n\n    function parseStartTag () {\n      var start = html.match(startTagOpen);\n      if (start) {\n        var match = {\n          tagName: start[1],\n          attrs: [],\n          start: index\n        };\n        advance(start[0].length);\n        var end, attr;\n        while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n          attr.start = index;\n          advance(attr[0].length);\n          attr.end = index;\n          match.attrs.push(attr);\n        }\n        if (end) {\n          match.unarySlash = end[1];\n          advance(end[0].length);\n          match.end = index;\n          return match\n        }\n      }\n    }\n\n    function handleStartTag (match) {\n      var tagName = match.tagName;\n      var unarySlash = match.unarySlash;\n\n      if (expectHTML) {\n        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n          parseEndTag(lastTag);\n        }\n        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n          parseEndTag(tagName);\n        }\n      }\n\n      var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n      var l = match.attrs.length;\n      var attrs = new Array(l);\n      for (var i = 0; i < l; i++) {\n        var args = match.attrs[i];\n        var value = args[3] || args[4] || args[5] || '';\n        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n          ? options.shouldDecodeNewlinesForHref\n          : options.shouldDecodeNewlines;\n        attrs[i] = {\n          name: args[1],\n          value: decodeAttr(value, shouldDecodeNewlines)\n        };\n        if (options.outputSourceRange) {\n          attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n          attrs[i].end = args.end;\n        }\n      }\n\n      if (!unary) {\n        stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });\n        lastTag = tagName;\n      }\n\n      if (options.start) {\n        options.start(tagName, attrs, unary, match.start, match.end);\n      }\n    }\n\n    function parseEndTag (tagName, start, end) {\n      var pos, lowerCasedTagName;\n      if (start == null) { start = index; }\n      if (end == null) { end = index; }\n\n      // Find the closest opened tag of the same type\n      if (tagName) {\n        lowerCasedTagName = tagName.toLowerCase();\n        for (pos = stack.length - 1; pos >= 0; pos--) {\n          if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n            break\n          }\n        }\n      } else {\n        // If no tag name is provided, clean shop\n        pos = 0;\n      }\n\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (var i = stack.length - 1; i >= pos; i--) {\n          if (i > pos || !tagName &&\n            options.warn\n          ) {\n            options.warn(\n              (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\"),\n              { start: stack[i].start, end: stack[i].end }\n            );\n          }\n          if (options.end) {\n            options.end(stack[i].tag, start, end);\n          }\n        }\n\n        // Remove the open elements from the stack\n        stack.length = pos;\n        lastTag = pos && stack[pos - 1].tag;\n      } else if (lowerCasedTagName === 'br') {\n        if (options.start) {\n          options.start(tagName, [], true, start, end);\n        }\n      } else if (lowerCasedTagName === 'p') {\n        if (options.start) {\n          options.start(tagName, [], false, start, end);\n        }\n        if (options.end) {\n          options.end(tagName, start, end);\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  var onRE = /^@|^v-on:/;\n  var dirRE = /^v-|^@|^:|^#/;\n  var forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  var forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  var stripParensRE = /^\\(|\\)$/g;\n  var dynamicArgRE = /^\\[.*\\]$/;\n\n  var argRE = /:(.*)$/;\n  var bindRE = /^:|^\\.|^v-bind:/;\n  var modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\n\n  var slotRE = /^v-slot(:|$)|^#/;\n\n  var lineBreakRE = /[\\r\\n]/;\n  var whitespaceRE$1 = /\\s+/g;\n\n  var invalidAttributeRE = /[\\s\"'<>\\/=]/;\n\n  var decodeHTMLCached = cached(he.decode);\n\n  var emptySlotScopeToken = \"_empty_\";\n\n  // configurable state\n  var warn$2;\n  var delimiters;\n  var transforms;\n  var preTransforms;\n  var postTransforms;\n  var platformIsPreTag;\n  var platformMustUseProp;\n  var platformGetTagNamespace;\n  var maybeComponent;\n\n  function createASTElement (\n    tag,\n    attrs,\n    parent\n  ) {\n    return {\n      type: 1,\n      tag: tag,\n      attrsList: attrs,\n      attrsMap: makeAttrsMap(attrs),\n      rawAttrsMap: {},\n      parent: parent,\n      children: []\n    }\n  }\n\n  /**\n   * Convert HTML string to AST.\n   */\n  function parse (\n    template,\n    options\n  ) {\n    warn$2 = options.warn || baseWarn;\n\n    platformIsPreTag = options.isPreTag || no;\n    platformMustUseProp = options.mustUseProp || no;\n    platformGetTagNamespace = options.getTagNamespace || no;\n    var isReservedTag = options.isReservedTag || no;\n    maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n    delimiters = options.delimiters;\n\n    var stack = [];\n    var preserveWhitespace = options.preserveWhitespace !== false;\n    var whitespaceOption = options.whitespace;\n    var root;\n    var currentParent;\n    var inVPre = false;\n    var inPre = false;\n    var warned = false;\n\n    function warnOnce (msg, range) {\n      if (!warned) {\n        warned = true;\n        warn$2(msg, range);\n      }\n    }\n\n    function closeElement (element) {\n      trimEndingWhitespace(element);\n      if (!inVPre && !element.processed) {\n        element = processElement(element, options);\n      }\n      // tree management\n      if (!stack.length && element !== root) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          {\n            checkRootConstraints(element);\n          }\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\",\n            { start: element.start }\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else {\n          if (element.slotScope) {\n            // scoped slot\n            // keep it in the children list so that v-else(-if) conditions can\n            // find it as the prev node.\n            var name = element.slotTarget || '\"default\"'\n            ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n          }\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n\n      // final children cleanup\n      // filter out scoped slots\n      element.children = element.children.filter(function (c) { return !(c).slotScope; });\n      // remove trailing whitespace node again\n      trimEndingWhitespace(element);\n\n      // check pre state\n      if (element.pre) {\n        inVPre = false;\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      }\n      // apply post-transforms\n      for (var i = 0; i < postTransforms.length; i++) {\n        postTransforms[i](element, options);\n      }\n    }\n\n    function trimEndingWhitespace (el) {\n      // remove trailing whitespace node\n      if (!inPre) {\n        var lastNode;\n        while (\n          (lastNode = el.children[el.children.length - 1]) &&\n          lastNode.type === 3 &&\n          lastNode.text === ' '\n        ) {\n          el.children.pop();\n        }\n      }\n    }\n\n    function checkRootConstraints (el) {\n      if (el.tag === 'slot' || el.tag === 'template') {\n        warnOnce(\n          \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n          'contain multiple nodes.',\n          { start: el.start }\n        );\n      }\n      if (el.attrsMap.hasOwnProperty('v-for')) {\n        warnOnce(\n          'Cannot use v-for on stateful component root element because ' +\n          'it renders multiple elements.',\n          el.rawAttrsMap['v-for']\n        );\n      }\n    }\n\n    parseHTML(template, {\n      warn: warn$2,\n      expectHTML: options.expectHTML,\n      isUnaryTag: options.isUnaryTag,\n      canBeLeftOpenTag: options.canBeLeftOpenTag,\n      shouldDecodeNewlines: options.shouldDecodeNewlines,\n      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n      shouldKeepComment: options.comments,\n      outputSourceRange: options.outputSourceRange,\n      start: function start (tag, attrs, unary, start$1, end) {\n        // check namespace.\n        // inherit parent ns if there is one\n        var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n        // handle IE svg bug\n        /* istanbul ignore if */\n        if (isIE && ns === 'svg') {\n          attrs = guardIESVGBug(attrs);\n        }\n\n        var element = createASTElement(tag, attrs, currentParent);\n        if (ns) {\n          element.ns = ns;\n        }\n\n        {\n          if (options.outputSourceRange) {\n            element.start = start$1;\n            element.end = end;\n            element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n              cumulated[attr.name] = attr;\n              return cumulated\n            }, {});\n          }\n          attrs.forEach(function (attr) {\n            if (invalidAttributeRE.test(attr.name)) {\n              warn$2(\n                \"Invalid dynamic argument expression: attribute names cannot contain \" +\n                \"spaces, quotes, <, >, / or =.\",\n                {\n                  start: attr.start + attr.name.indexOf(\"[\"),\n                  end: attr.start + attr.name.length\n                }\n              );\n            }\n          });\n        }\n\n        if (isForbiddenTag(element) && !isServerRendering()) {\n          element.forbidden = true;\n          warn$2(\n            'Templates should only be responsible for mapping the state to the ' +\n            'UI. Avoid placing tags with side-effects in your templates, such as ' +\n            \"<\" + tag + \">\" + ', as they will not be parsed.',\n            { start: element.start }\n          );\n        }\n\n        // apply pre-transforms\n        for (var i = 0; i < preTransforms.length; i++) {\n          element = preTransforms[i](element, options) || element;\n        }\n\n        if (!inVPre) {\n          processPre(element);\n          if (element.pre) {\n            inVPre = true;\n          }\n        }\n        if (platformIsPreTag(element.tag)) {\n          inPre = true;\n        }\n        if (inVPre) {\n          processRawAttrs(element);\n        } else if (!element.processed) {\n          // structural directives\n          processFor(element);\n          processIf(element);\n          processOnce(element);\n        }\n\n        if (!root) {\n          root = element;\n          {\n            checkRootConstraints(root);\n          }\n        }\n\n        if (!unary) {\n          currentParent = element;\n          stack.push(element);\n        } else {\n          closeElement(element);\n        }\n      },\n\n      end: function end (tag, start, end$1) {\n        var element = stack[stack.length - 1];\n        // pop stack\n        stack.length -= 1;\n        currentParent = stack[stack.length - 1];\n        if (options.outputSourceRange) {\n          element.end = end$1;\n        }\n        closeElement(element);\n      },\n\n      chars: function chars (text, start, end) {\n        if (!currentParent) {\n          {\n            if (text === template) {\n              warnOnce(\n                'Component template requires a root element, rather than just text.',\n                { start: start }\n              );\n            } else if ((text = text.trim())) {\n              warnOnce(\n                (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\"),\n                { start: start }\n              );\n            }\n          }\n          return\n        }\n        // IE textarea placeholder bug\n        /* istanbul ignore if */\n        if (isIE &&\n          currentParent.tag === 'textarea' &&\n          currentParent.attrsMap.placeholder === text\n        ) {\n          return\n        }\n        var children = currentParent.children;\n        if (inPre || text.trim()) {\n          text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n        } else if (!children.length) {\n          // remove the whitespace-only node right after an opening tag\n          text = '';\n        } else if (whitespaceOption) {\n          if (whitespaceOption === 'condense') {\n            // in condense mode, remove the whitespace node if it contains\n            // line break, otherwise condense to a single space\n            text = lineBreakRE.test(text) ? '' : ' ';\n          } else {\n            text = ' ';\n          }\n        } else {\n          text = preserveWhitespace ? ' ' : '';\n        }\n        if (text) {\n          if (!inPre && whitespaceOption === 'condense') {\n            // condense consecutive whitespaces into single space\n            text = text.replace(whitespaceRE$1, ' ');\n          }\n          var res;\n          var child;\n          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n            child = {\n              type: 2,\n              expression: res.expression,\n              tokens: res.tokens,\n              text: text\n            };\n          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n            child = {\n              type: 3,\n              text: text\n            };\n          }\n          if (child) {\n            if (options.outputSourceRange) {\n              child.start = start;\n              child.end = end;\n            }\n            children.push(child);\n          }\n        }\n      },\n      comment: function comment (text, start, end) {\n        // adding anything as a sibling to the root node is forbidden\n        // comments should still be allowed, but ignored\n        if (currentParent) {\n          var child = {\n            type: 3,\n            text: text,\n            isComment: true\n          };\n          if (options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n          currentParent.children.push(child);\n        }\n      }\n    });\n    return root\n  }\n\n  function processPre (el) {\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\n      el.pre = true;\n    }\n  }\n\n  function processRawAttrs (el) {\n    var list = el.attrsList;\n    var len = list.length;\n    if (len) {\n      var attrs = el.attrs = new Array(len);\n      for (var i = 0; i < len; i++) {\n        attrs[i] = {\n          name: list[i].name,\n          value: JSON.stringify(list[i].value)\n        };\n        if (list[i].start != null) {\n          attrs[i].start = list[i].start;\n          attrs[i].end = list[i].end;\n        }\n      }\n    } else if (!el.pre) {\n      // non root node in pre blocks with no attributes\n      el.plain = true;\n    }\n  }\n\n  function processElement (\n    element,\n    options\n  ) {\n    processKey(element);\n\n    // determine whether this is a plain element after\n    // removing structural attributes\n    element.plain = (\n      !element.key &&\n      !element.scopedSlots &&\n      !element.attrsList.length\n    );\n\n    processRef(element);\n    processSlotContent(element);\n    processSlotOutlet(element);\n    processComponent(element);\n    for (var i = 0; i < transforms.length; i++) {\n      element = transforms[i](element, options) || element;\n    }\n    processAttrs(element);\n    return element\n  }\n\n  function processKey (el) {\n    var exp = getBindingAttr(el, 'key');\n    if (exp) {\n      {\n        if (el.tag === 'template') {\n          warn$2(\n            \"<template> cannot be keyed. Place the key on real elements instead.\",\n            getRawBindingAttr(el, 'key')\n          );\n        }\n        if (el.for) {\n          var iterator = el.iterator2 || el.iterator1;\n          var parent = el.parent;\n          if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n            warn$2(\n              \"Do not use v-for index as key on <transition-group> children, \" +\n              \"this is the same as not using keys.\",\n              getRawBindingAttr(el, 'key'),\n              true /* tip */\n            );\n          }\n        }\n      }\n      el.key = exp;\n    }\n  }\n\n  function processRef (el) {\n    var ref = getBindingAttr(el, 'ref');\n    if (ref) {\n      el.ref = ref;\n      el.refInFor = checkInFor(el);\n    }\n  }\n\n  function processFor (el) {\n    var exp;\n    if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n      var res = parseFor(exp);\n      if (res) {\n        extend(el, res);\n      } else {\n        warn$2(\n          (\"Invalid v-for expression: \" + exp),\n          el.rawAttrsMap['v-for']\n        );\n      }\n    }\n  }\n\n\n\n  function parseFor (exp) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) { return }\n    var res = {};\n    res.for = inMatch[2].trim();\n    var alias = inMatch[1].trim().replace(stripParensRE, '');\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      res.alias = alias.replace(forIteratorRE, '').trim();\n      res.iterator1 = iteratorMatch[1].trim();\n      if (iteratorMatch[2]) {\n        res.iterator2 = iteratorMatch[2].trim();\n      }\n    } else {\n      res.alias = alias;\n    }\n    return res\n  }\n\n  function processIf (el) {\n    var exp = getAndRemoveAttr(el, 'v-if');\n    if (exp) {\n      el.if = exp;\n      addIfCondition(el, {\n        exp: exp,\n        block: el\n      });\n    } else {\n      if (getAndRemoveAttr(el, 'v-else') != null) {\n        el.else = true;\n      }\n      var elseif = getAndRemoveAttr(el, 'v-else-if');\n      if (elseif) {\n        el.elseif = elseif;\n      }\n    }\n  }\n\n  function processIfConditions (el, parent) {\n    var prev = findPrevElement(parent.children);\n    if (prev && prev.if) {\n      addIfCondition(prev, {\n        exp: el.elseif,\n        block: el\n      });\n    } else {\n      warn$2(\n        \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n        \"used on element <\" + (el.tag) + \"> without corresponding v-if.\",\n        el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']\n      );\n    }\n  }\n\n  function findPrevElement (children) {\n    var i = children.length;\n    while (i--) {\n      if (children[i].type === 1) {\n        return children[i]\n      } else {\n        if (children[i].text !== ' ') {\n          warn$2(\n            \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n            \"will be ignored.\",\n            children[i]\n          );\n        }\n        children.pop();\n      }\n    }\n  }\n\n  function addIfCondition (el, condition) {\n    if (!el.ifConditions) {\n      el.ifConditions = [];\n    }\n    el.ifConditions.push(condition);\n  }\n\n  function processOnce (el) {\n    var once$$1 = getAndRemoveAttr(el, 'v-once');\n    if (once$$1 != null) {\n      el.once = true;\n    }\n  }\n\n  // handle content being passed to a component as slot,\n  // e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\n  function processSlotContent (el) {\n    var slotScope;\n    if (el.tag === 'template') {\n      slotScope = getAndRemoveAttr(el, 'scope');\n      /* istanbul ignore if */\n      if (slotScope) {\n        warn$2(\n          \"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" +\n          \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" +\n          \"can also be used on plain elements in addition to <template> to \" +\n          \"denote scoped slots.\",\n          el.rawAttrsMap['scope'],\n          true\n        );\n      }\n      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n    } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n      /* istanbul ignore if */\n      if (el.attrsMap['v-for']) {\n        warn$2(\n          \"Ambiguous combined usage of slot-scope and v-for on <\" + (el.tag) + \"> \" +\n          \"(v-for takes higher priority). Use a wrapper <template> for the \" +\n          \"scoped slot to make it clearer.\",\n          el.rawAttrsMap['slot-scope'],\n          true\n        );\n      }\n      el.slotScope = slotScope;\n    }\n\n    // slot=\"xxx\"\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n      el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\n      // preserve slot as an attribute for native shadow DOM compat\n      // only for non-scoped slots.\n      if (el.tag !== 'template' && !el.slotScope) {\n        addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n      }\n    }\n\n    // 2.6 v-slot syntax\n    {\n      if (el.tag === 'template') {\n        // v-slot on <template>\n        var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n        if (slotBinding) {\n          {\n            if (el.slotTarget || el.slotScope) {\n              warn$2(\n                \"Unexpected mixed usage of different slot syntaxes.\",\n                el\n              );\n            }\n            if (el.parent && !maybeComponent(el.parent)) {\n              warn$2(\n                \"<template v-slot> can only appear at the root level inside \" +\n                \"the receiving component\",\n                el\n              );\n            }\n          }\n          var ref = getSlotName(slotBinding);\n          var name = ref.name;\n          var dynamic = ref.dynamic;\n          el.slotTarget = name;\n          el.slotTargetDynamic = dynamic;\n          el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n        }\n      } else {\n        // v-slot on component, denotes default slot\n        var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n        if (slotBinding$1) {\n          {\n            if (!maybeComponent(el)) {\n              warn$2(\n                \"v-slot can only be used on components or <template>.\",\n                slotBinding$1\n              );\n            }\n            if (el.slotScope || el.slotTarget) {\n              warn$2(\n                \"Unexpected mixed usage of different slot syntaxes.\",\n                el\n              );\n            }\n            if (el.scopedSlots) {\n              warn$2(\n                \"To avoid scope ambiguity, the default slot should also use \" +\n                \"<template> syntax when there are other named slots.\",\n                slotBinding$1\n              );\n            }\n          }\n          // add the component's children to its default slot\n          var slots = el.scopedSlots || (el.scopedSlots = {});\n          var ref$1 = getSlotName(slotBinding$1);\n          var name$1 = ref$1.name;\n          var dynamic$1 = ref$1.dynamic;\n          var slotContainer = slots[name$1] = createASTElement('template', [], el);\n          slotContainer.slotTarget = name$1;\n          slotContainer.slotTargetDynamic = dynamic$1;\n          slotContainer.children = el.children.filter(function (c) {\n            if (!c.slotScope) {\n              c.parent = slotContainer;\n              return true\n            }\n          });\n          slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;\n          // remove children as they are returned from scopedSlots now\n          el.children = [];\n          // mark el non-plain so data gets generated\n          el.plain = false;\n        }\n      }\n    }\n  }\n\n  function getSlotName (binding) {\n    var name = binding.name.replace(slotRE, '');\n    if (!name) {\n      if (binding.name[0] !== '#') {\n        name = 'default';\n      } else {\n        warn$2(\n          \"v-slot shorthand syntax requires a slot name.\",\n          binding\n        );\n      }\n    }\n    return dynamicArgRE.test(name)\n      // dynamic [name]\n      ? { name: name.slice(1, -1), dynamic: true }\n      // static name\n      : { name: (\"\\\"\" + name + \"\\\"\"), dynamic: false }\n  }\n\n  // handle <slot/> outlets\n  function processSlotOutlet (el) {\n    if (el.tag === 'slot') {\n      el.slotName = getBindingAttr(el, 'name');\n      if (el.key) {\n        warn$2(\n          \"`key` does not work on <slot> because slots are abstract outlets \" +\n          \"and can possibly expand into multiple elements. \" +\n          \"Use the key on a wrapping element instead.\",\n          getRawBindingAttr(el, 'key')\n        );\n      }\n    }\n  }\n\n  function processComponent (el) {\n    var binding;\n    if ((binding = getBindingAttr(el, 'is'))) {\n      el.component = binding;\n    }\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\n      el.inlineTemplate = true;\n    }\n  }\n\n  function processAttrs (el) {\n    var list = el.attrsList;\n    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n    for (i = 0, l = list.length; i < l; i++) {\n      name = rawName = list[i].name;\n      value = list[i].value;\n      if (dirRE.test(name)) {\n        // mark element as dynamic\n        el.hasBindings = true;\n        // modifiers\n        modifiers = parseModifiers(name.replace(dirRE, ''));\n        // support .foo shorthand syntax for the .prop modifier\n        if (modifiers) {\n          name = name.replace(modifierRE, '');\n        }\n        if (bindRE.test(name)) { // v-bind\n          name = name.replace(bindRE, '');\n          value = parseFilters(value);\n          isDynamic = dynamicArgRE.test(name);\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n          if (\n            value.trim().length === 0\n          ) {\n            warn$2(\n              (\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\")\n            );\n          }\n          if (modifiers) {\n            if (modifiers.prop && !isDynamic) {\n              name = camelize(name);\n              if (name === 'innerHtml') { name = 'innerHTML'; }\n            }\n            if (modifiers.camel && !isDynamic) {\n              name = camelize(name);\n            }\n            if (modifiers.sync) {\n              syncGen = genAssignmentCode(value, \"$event\");\n              if (!isDynamic) {\n                addHandler(\n                  el,\n                  (\"update:\" + (camelize(name))),\n                  syncGen,\n                  null,\n                  false,\n                  warn$2,\n                  list[i]\n                );\n                if (hyphenate(name) !== camelize(name)) {\n                  addHandler(\n                    el,\n                    (\"update:\" + (hyphenate(name))),\n                    syncGen,\n                    null,\n                    false,\n                    warn$2,\n                    list[i]\n                  );\n                }\n              } else {\n                // handler w/ dynamic event name\n                addHandler(\n                  el,\n                  (\"\\\"update:\\\"+(\" + name + \")\"),\n                  syncGen,\n                  null,\n                  false,\n                  warn$2,\n                  list[i],\n                  true // dynamic\n                );\n              }\n            }\n          }\n          if ((modifiers && modifiers.prop) || (\n            !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n          )) {\n            addProp(el, name, value, list[i], isDynamic);\n          } else {\n            addAttr(el, name, value, list[i], isDynamic);\n          }\n        } else if (onRE.test(name)) { // v-on\n          name = name.replace(onRE, '');\n          isDynamic = dynamicArgRE.test(name);\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n          addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n        } else { // normal directives\n          name = name.replace(dirRE, '');\n          // parse arg\n          var argMatch = name.match(argRE);\n          var arg = argMatch && argMatch[1];\n          isDynamic = false;\n          if (arg) {\n            name = name.slice(0, -(arg.length + 1));\n            if (dynamicArgRE.test(arg)) {\n              arg = arg.slice(1, -1);\n              isDynamic = true;\n            }\n          }\n          addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n          if (name === 'model') {\n            checkForAliasModel(el, value);\n          }\n        }\n      } else {\n        // literal attribute\n        {\n          var res = parseText(value, delimiters);\n          if (res) {\n            warn$2(\n              name + \"=\\\"\" + value + \"\\\": \" +\n              'Interpolation inside attributes has been removed. ' +\n              'Use v-bind or the colon shorthand instead. For example, ' +\n              'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.',\n              list[i]\n            );\n          }\n        }\n        addAttr(el, name, JSON.stringify(value), list[i]);\n        // #6887 firefox doesn't update muted state if set via attribute\n        // even immediately after element creation\n        if (!el.component &&\n            name === 'muted' &&\n            platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, 'true', list[i]);\n        }\n      }\n    }\n  }\n\n  function checkInFor (el) {\n    var parent = el;\n    while (parent) {\n      if (parent.for !== undefined) {\n        return true\n      }\n      parent = parent.parent;\n    }\n    return false\n  }\n\n  function parseModifiers (name) {\n    var match = name.match(modifierRE);\n    if (match) {\n      var ret = {};\n      match.forEach(function (m) { ret[m.slice(1)] = true; });\n      return ret\n    }\n  }\n\n  function makeAttrsMap (attrs) {\n    var map = {};\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      if (\n        map[attrs[i].name] && !isIE && !isEdge\n      ) {\n        warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n      }\n      map[attrs[i].name] = attrs[i].value;\n    }\n    return map\n  }\n\n  // for script (e.g. type=\"x/template\") or style, do not decode content\n  function isTextTag (el) {\n    return el.tag === 'script' || el.tag === 'style'\n  }\n\n  function isForbiddenTag (el) {\n    return (\n      el.tag === 'style' ||\n      (el.tag === 'script' && (\n        !el.attrsMap.type ||\n        el.attrsMap.type === 'text/javascript'\n      ))\n    )\n  }\n\n  var ieNSBug = /^xmlns:NS\\d+/;\n  var ieNSPrefix = /^NS\\d+:/;\n\n  /* istanbul ignore next */\n  function guardIESVGBug (attrs) {\n    var res = [];\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n      if (!ieNSBug.test(attr.name)) {\n        attr.name = attr.name.replace(ieNSPrefix, '');\n        res.push(attr);\n      }\n    }\n    return res\n  }\n\n  function checkForAliasModel (el, value) {\n    var _el = el;\n    while (_el) {\n      if (_el.for && _el.alias === value) {\n        warn$2(\n          \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n          \"You are binding v-model directly to a v-for iteration alias. \" +\n          \"This will not be able to modify the v-for source array because \" +\n          \"writing to the alias is like modifying a function local variable. \" +\n          \"Consider using an array of objects and use v-model on an object property instead.\",\n          el.rawAttrsMap['v-model']\n        );\n      }\n      _el = _el.parent;\n    }\n  }\n\n  /*  */\n\n  function preTransformNode (el, options) {\n    if (el.tag === 'input') {\n      var map = el.attrsMap;\n      if (!map['v-model']) {\n        return\n      }\n\n      var typeBinding;\n      if (map[':type'] || map['v-bind:type']) {\n        typeBinding = getBindingAttr(el, 'type');\n      }\n      if (!map.type && !typeBinding && map['v-bind']) {\n        typeBinding = \"(\" + (map['v-bind']) + \").type\";\n      }\n\n      if (typeBinding) {\n        var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n        var ifConditionExtra = ifCondition ? (\"&&(\" + ifCondition + \")\") : \"\";\n        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n        // 1. checkbox\n        var branch0 = cloneASTElement(el);\n        // process for on the main node\n        processFor(branch0);\n        addRawAttr(branch0, 'type', 'checkbox');\n        processElement(branch0, options);\n        branch0.processed = true; // prevent it from double-processed\n        branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n        addIfCondition(branch0, {\n          exp: branch0.if,\n          block: branch0\n        });\n        // 2. add radio else-if condition\n        var branch1 = cloneASTElement(el);\n        getAndRemoveAttr(branch1, 'v-for', true);\n        addRawAttr(branch1, 'type', 'radio');\n        processElement(branch1, options);\n        addIfCondition(branch0, {\n          exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n          block: branch1\n        });\n        // 3. other\n        var branch2 = cloneASTElement(el);\n        getAndRemoveAttr(branch2, 'v-for', true);\n        addRawAttr(branch2, ':type', typeBinding);\n        processElement(branch2, options);\n        addIfCondition(branch0, {\n          exp: ifCondition,\n          block: branch2\n        });\n\n        if (hasElse) {\n          branch0.else = true;\n        } else if (elseIfCondition) {\n          branch0.elseif = elseIfCondition;\n        }\n\n        return branch0\n      }\n    }\n  }\n\n  function cloneASTElement (el) {\n    return createASTElement(el.tag, el.attrsList.slice(), el.parent)\n  }\n\n  var model$1 = {\n    preTransformNode: preTransformNode\n  };\n\n  var modules$1 = [\n    klass$1,\n    style$1,\n    model$1\n  ];\n\n  /*  */\n\n  function text (el, dir) {\n    if (dir.value) {\n      addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"), dir);\n    }\n  }\n\n  /*  */\n\n  function html (el, dir) {\n    if (dir.value) {\n      addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"), dir);\n    }\n  }\n\n  var directives$1 = {\n    model: model,\n    text: text,\n    html: html\n  };\n\n  /*  */\n\n  var baseOptions = {\n    expectHTML: true,\n    modules: modules$1,\n    directives: directives$1,\n    isPreTag: isPreTag,\n    isUnaryTag: isUnaryTag,\n    mustUseProp: mustUseProp,\n    canBeLeftOpenTag: canBeLeftOpenTag,\n    isReservedTag: isReservedTag,\n    getTagNamespace: getTagNamespace,\n    staticKeys: genStaticKeys(modules$1)\n  };\n\n  /*  */\n\n  var isStaticKey;\n  var isPlatformReservedTag;\n\n  var genStaticKeysCached = cached(genStaticKeys$1);\n\n  /**\n   * Goal of the optimizer: walk the generated template AST tree\n   * and detect sub-trees that are purely static, i.e. parts of\n   * the DOM that never needs to change.\n   *\n   * Once we detect these sub-trees, we can:\n   *\n   * 1. Hoist them into constants, so that we no longer need to\n   *    create fresh nodes for them on each re-render;\n   * 2. Completely skip them in the patching process.\n   */\n  function optimize (root, options) {\n    if (!root) { return }\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\n    isPlatformReservedTag = options.isReservedTag || no;\n    // first pass: mark all non-static nodes.\n    markStatic$1(root);\n    // second pass: mark static roots.\n    markStaticRoots(root, false);\n  }\n\n  function genStaticKeys$1 (keys) {\n    return makeMap(\n      'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +\n      (keys ? ',' + keys : '')\n    )\n  }\n\n  function markStatic$1 (node) {\n    node.static = isStatic(node);\n    if (node.type === 1) {\n      // do not make component slot content static. this avoids\n      // 1. components not able to mutate slot nodes\n      // 2. static slot content fails for hot-reloading\n      if (\n        !isPlatformReservedTag(node.tag) &&\n        node.tag !== 'slot' &&\n        node.attrsMap['inline-template'] == null\n      ) {\n        return\n      }\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        var child = node.children[i];\n        markStatic$1(child);\n        if (!child.static) {\n          node.static = false;\n        }\n      }\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          var block = node.ifConditions[i$1].block;\n          markStatic$1(block);\n          if (!block.static) {\n            node.static = false;\n          }\n        }\n      }\n    }\n  }\n\n  function markStaticRoots (node, isInFor) {\n    if (node.type === 1) {\n      if (node.static || node.once) {\n        node.staticInFor = isInFor;\n      }\n      // For a node to qualify as a static root, it should have children that\n      // are not just static text. Otherwise the cost of hoisting out will\n      // outweigh the benefits and it's better off to just always render it fresh.\n      if (node.static && node.children.length && !(\n        node.children.length === 1 &&\n        node.children[0].type === 3\n      )) {\n        node.staticRoot = true;\n        return\n      } else {\n        node.staticRoot = false;\n      }\n      if (node.children) {\n        for (var i = 0, l = node.children.length; i < l; i++) {\n          markStaticRoots(node.children[i], isInFor || !!node.for);\n        }\n      }\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          markStaticRoots(node.ifConditions[i$1].block, isInFor);\n        }\n      }\n    }\n  }\n\n  function isStatic (node) {\n    if (node.type === 2) { // expression\n      return false\n    }\n    if (node.type === 3) { // text\n      return true\n    }\n    return !!(node.pre || (\n      !node.hasBindings && // no dynamic bindings\n      !node.if && !node.for && // not v-if or v-for or v-else\n      !isBuiltInTag(node.tag) && // not a built-in\n      isPlatformReservedTag(node.tag) && // not a component\n      !isDirectChildOfTemplateFor(node) &&\n      Object.keys(node).every(isStaticKey)\n    ))\n  }\n\n  function isDirectChildOfTemplateFor (node) {\n    while (node.parent) {\n      node = node.parent;\n      if (node.tag !== 'template') {\n        return false\n      }\n      if (node.for) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /*  */\n\n  var fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function(?:\\s+[\\w$]+)?\\s*\\(/;\n  var fnInvokeRE = /\\([^)]*?\\);*$/;\n  var simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n\n  // KeyboardEvent.keyCode aliases\n  var keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    'delete': [8, 46]\n  };\n\n  // KeyboardEvent.key aliases\n  var keyNames = {\n    // #7880: IE11 and Edge use `Esc` for Escape key name.\n    esc: ['Esc', 'Escape'],\n    tab: 'Tab',\n    enter: 'Enter',\n    // #9112: IE11 uses `Spacebar` for Space key name.\n    space: [' ', 'Spacebar'],\n    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n    up: ['Up', 'ArrowUp'],\n    left: ['Left', 'ArrowLeft'],\n    right: ['Right', 'ArrowRight'],\n    down: ['Down', 'ArrowDown'],\n    // #9112: IE11 uses `Del` for Delete key name.\n    'delete': ['Backspace', 'Delete', 'Del']\n  };\n\n  // #4868: modifiers that prevent the execution of the listener\n  // need to explicitly return null so that we can determine whether to remove\n  // the listener for .once\n  var genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\n  var modifierCode = {\n    stop: '$event.stopPropagation();',\n    prevent: '$event.preventDefault();',\n    self: genGuard(\"$event.target !== $event.currentTarget\"),\n    ctrl: genGuard(\"!$event.ctrlKey\"),\n    shift: genGuard(\"!$event.shiftKey\"),\n    alt: genGuard(\"!$event.altKey\"),\n    meta: genGuard(\"!$event.metaKey\"),\n    left: genGuard(\"'button' in $event && $event.button !== 0\"),\n    middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n    right: genGuard(\"'button' in $event && $event.button !== 2\")\n  };\n\n  function genHandlers (\n    events,\n    isNative\n  ) {\n    var prefix = isNative ? 'nativeOn:' : 'on:';\n    var staticHandlers = \"\";\n    var dynamicHandlers = \"\";\n    for (var name in events) {\n      var handlerCode = genHandler(events[name]);\n      if (events[name] && events[name].dynamic) {\n        dynamicHandlers += name + \",\" + handlerCode + \",\";\n      } else {\n        staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n      }\n    }\n    staticHandlers = \"{\" + (staticHandlers.slice(0, -1)) + \"}\";\n    if (dynamicHandlers) {\n      return prefix + \"_d(\" + staticHandlers + \",[\" + (dynamicHandlers.slice(0, -1)) + \"])\"\n    } else {\n      return prefix + staticHandlers\n    }\n  }\n\n  function genHandler (handler) {\n    if (!handler) {\n      return 'function(){}'\n    }\n\n    if (Array.isArray(handler)) {\n      return (\"[\" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + \"]\")\n    }\n\n    var isMethodPath = simplePathRE.test(handler.value);\n    var isFunctionExpression = fnExpRE.test(handler.value);\n    var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n    if (!handler.modifiers) {\n      if (isMethodPath || isFunctionExpression) {\n        return handler.value\n      }\n      return (\"function($event){\" + (isFunctionInvocation ? (\"return \" + (handler.value)) : handler.value) + \"}\") // inline statement\n    } else {\n      var code = '';\n      var genModifierCode = '';\n      var keys = [];\n      for (var key in handler.modifiers) {\n        if (modifierCode[key]) {\n          genModifierCode += modifierCode[key];\n          // left/right\n          if (keyCodes[key]) {\n            keys.push(key);\n          }\n        } else if (key === 'exact') {\n          var modifiers = (handler.modifiers);\n          genModifierCode += genGuard(\n            ['ctrl', 'shift', 'alt', 'meta']\n              .filter(function (keyModifier) { return !modifiers[keyModifier]; })\n              .map(function (keyModifier) { return (\"$event.\" + keyModifier + \"Key\"); })\n              .join('||')\n          );\n        } else {\n          keys.push(key);\n        }\n      }\n      if (keys.length) {\n        code += genKeyFilter(keys);\n      }\n      // Make sure modifiers like prevent and stop get executed after key filtering\n      if (genModifierCode) {\n        code += genModifierCode;\n      }\n      var handlerCode = isMethodPath\n        ? (\"return \" + (handler.value) + \"($event)\")\n        : isFunctionExpression\n          ? (\"return (\" + (handler.value) + \")($event)\")\n          : isFunctionInvocation\n            ? (\"return \" + (handler.value))\n            : handler.value;\n      return (\"function($event){\" + code + handlerCode + \"}\")\n    }\n  }\n\n  function genKeyFilter (keys) {\n    return (\n      // make sure the key filters only apply to KeyboardEvents\n      // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n      // key events that do not have keyCode property...\n      \"if(!$event.type.indexOf('key')&&\" +\n      (keys.map(genFilterCode).join('&&')) + \")return null;\"\n    )\n  }\n\n  function genFilterCode (key) {\n    var keyVal = parseInt(key, 10);\n    if (keyVal) {\n      return (\"$event.keyCode!==\" + keyVal)\n    }\n    var keyCode = keyCodes[key];\n    var keyName = keyNames[key];\n    return (\n      \"_k($event.keyCode,\" +\n      (JSON.stringify(key)) + \",\" +\n      (JSON.stringify(keyCode)) + \",\" +\n      \"$event.key,\" +\n      \"\" + (JSON.stringify(keyName)) +\n      \")\"\n    )\n  }\n\n  /*  */\n\n  function on (el, dir) {\n    if (dir.modifiers) {\n      warn(\"v-on without argument does not support modifiers.\");\n    }\n    el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n  }\n\n  /*  */\n\n  function bind$1 (el, dir) {\n    el.wrapData = function (code) {\n      return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n    };\n  }\n\n  /*  */\n\n  var baseDirectives = {\n    on: on,\n    bind: bind$1,\n    cloak: noop\n  };\n\n  /*  */\n\n\n\n\n\n  var CodegenState = function CodegenState (options) {\n    this.options = options;\n    this.warn = options.warn || baseWarn;\n    this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n    this.directives = extend(extend({}, baseDirectives), options.directives);\n    var isReservedTag = options.isReservedTag || no;\n    this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n    this.onceId = 0;\n    this.staticRenderFns = [];\n    this.pre = false;\n  };\n\n\n\n  function generate (\n    ast,\n    options\n  ) {\n    var state = new CodegenState(options);\n    var code = ast ? genElement(ast, state) : '_c(\"div\")';\n    return {\n      render: (\"with(this){return \" + code + \"}\"),\n      staticRenderFns: state.staticRenderFns\n    }\n  }\n\n  function genElement (el, state) {\n    if (el.parent) {\n      el.pre = el.pre || el.parent.pre;\n    }\n\n    if (el.staticRoot && !el.staticProcessed) {\n      return genStatic(el, state)\n    } else if (el.once && !el.onceProcessed) {\n      return genOnce(el, state)\n    } else if (el.for && !el.forProcessed) {\n      return genFor(el, state)\n    } else if (el.if && !el.ifProcessed) {\n      return genIf(el, state)\n    } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n      return genChildren(el, state) || 'void 0'\n    } else if (el.tag === 'slot') {\n      return genSlot(el, state)\n    } else {\n      // component or element\n      var code;\n      if (el.component) {\n        code = genComponent(el.component, el, state);\n      } else {\n        var data;\n        if (!el.plain || (el.pre && state.maybeComponent(el))) {\n          data = genData$2(el, state);\n        }\n\n        var children = el.inlineTemplate ? null : genChildren(el, state, true);\n        code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n      }\n      // module transforms\n      for (var i = 0; i < state.transforms.length; i++) {\n        code = state.transforms[i](el, code);\n      }\n      return code\n    }\n  }\n\n  // hoist static sub-trees out\n  function genStatic (el, state) {\n    el.staticProcessed = true;\n    // Some elements (templates) need to behave differently inside of a v-pre\n    // node.  All pre nodes are static roots, so we can use this as a location to\n    // wrap a state change and reset it upon exiting the pre node.\n    var originalPreState = state.pre;\n    if (el.pre) {\n      state.pre = el.pre;\n    }\n    state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n    state.pre = originalPreState;\n    return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n  }\n\n  // v-once\n  function genOnce (el, state) {\n    el.onceProcessed = true;\n    if (el.if && !el.ifProcessed) {\n      return genIf(el, state)\n    } else if (el.staticInFor) {\n      var key = '';\n      var parent = el.parent;\n      while (parent) {\n        if (parent.for) {\n          key = parent.key;\n          break\n        }\n        parent = parent.parent;\n      }\n      if (!key) {\n        state.warn(\n          \"v-once can only be used inside v-for that is keyed. \",\n          el.rawAttrsMap['v-once']\n        );\n        return genElement(el, state)\n      }\n      return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\n    } else {\n      return genStatic(el, state)\n    }\n  }\n\n  function genIf (\n    el,\n    state,\n    altGen,\n    altEmpty\n  ) {\n    el.ifProcessed = true; // avoid recursion\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n  }\n\n  function genIfConditions (\n    conditions,\n    state,\n    altGen,\n    altEmpty\n  ) {\n    if (!conditions.length) {\n      return altEmpty || '_e()'\n    }\n\n    var condition = conditions.shift();\n    if (condition.exp) {\n      return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n    } else {\n      return (\"\" + (genTernaryExp(condition.block)))\n    }\n\n    // v-if with v-once should generate code like (a)?_m(0):_m(1)\n    function genTernaryExp (el) {\n      return altGen\n        ? altGen(el, state)\n        : el.once\n          ? genOnce(el, state)\n          : genElement(el, state)\n    }\n  }\n\n  function genFor (\n    el,\n    state,\n    altGen,\n    altHelper\n  ) {\n    var exp = el.for;\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n    var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n    if (state.maybeComponent(el) &&\n      el.tag !== 'slot' &&\n      el.tag !== 'template' &&\n      !el.key\n    ) {\n      state.warn(\n        \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n        \"v-for should have explicit keys. \" +\n        \"See https://vuejs.org/guide/list.html#key for more info.\",\n        el.rawAttrsMap['v-for'],\n        true /* tip */\n      );\n    }\n\n    el.forProcessed = true; // avoid recursion\n    return (altHelper || '_l') + \"((\" + exp + \"),\" +\n      \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n        \"return \" + ((altGen || genElement)(el, state)) +\n      '})'\n  }\n\n  function genData$2 (el, state) {\n    var data = '{';\n\n    // directives first.\n    // directives may mutate the el's other properties before they are generated.\n    var dirs = genDirectives(el, state);\n    if (dirs) { data += dirs + ','; }\n\n    // key\n    if (el.key) {\n      data += \"key:\" + (el.key) + \",\";\n    }\n    // ref\n    if (el.ref) {\n      data += \"ref:\" + (el.ref) + \",\";\n    }\n    if (el.refInFor) {\n      data += \"refInFor:true,\";\n    }\n    // pre\n    if (el.pre) {\n      data += \"pre:true,\";\n    }\n    // record original tag name for components using \"is\" attribute\n    if (el.component) {\n      data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n    }\n    // module data generation functions\n    for (var i = 0; i < state.dataGenFns.length; i++) {\n      data += state.dataGenFns[i](el);\n    }\n    // attributes\n    if (el.attrs) {\n      data += \"attrs:\" + (genProps(el.attrs)) + \",\";\n    }\n    // DOM props\n    if (el.props) {\n      data += \"domProps:\" + (genProps(el.props)) + \",\";\n    }\n    // event handlers\n    if (el.events) {\n      data += (genHandlers(el.events, false)) + \",\";\n    }\n    if (el.nativeEvents) {\n      data += (genHandlers(el.nativeEvents, true)) + \",\";\n    }\n    // slot target\n    // only for non-scoped slots\n    if (el.slotTarget && !el.slotScope) {\n      data += \"slot:\" + (el.slotTarget) + \",\";\n    }\n    // scoped slots\n    if (el.scopedSlots) {\n      data += (genScopedSlots(el, el.scopedSlots, state)) + \",\";\n    }\n    // component v-model\n    if (el.model) {\n      data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n    }\n    // inline-template\n    if (el.inlineTemplate) {\n      var inlineTemplate = genInlineTemplate(el, state);\n      if (inlineTemplate) {\n        data += inlineTemplate + \",\";\n      }\n    }\n    data = data.replace(/,$/, '') + '}';\n    // v-bind dynamic argument wrap\n    // v-bind with dynamic arguments must be applied using the same v-bind object\n    // merge helper so that class/style/mustUseProp attrs are handled correctly.\n    if (el.dynamicAttrs) {\n      data = \"_b(\" + data + \",\\\"\" + (el.tag) + \"\\\",\" + (genProps(el.dynamicAttrs)) + \")\";\n    }\n    // v-bind data wrap\n    if (el.wrapData) {\n      data = el.wrapData(data);\n    }\n    // v-on data wrap\n    if (el.wrapListeners) {\n      data = el.wrapListeners(data);\n    }\n    return data\n  }\n\n  function genDirectives (el, state) {\n    var dirs = el.directives;\n    if (!dirs) { return }\n    var res = 'directives:[';\n    var hasRuntime = false;\n    var i, l, dir, needRuntime;\n    for (i = 0, l = dirs.length; i < l; i++) {\n      dir = dirs[i];\n      needRuntime = true;\n      var gen = state.directives[dir.name];\n      if (gen) {\n        // compile-time directive that manipulates AST.\n        // returns true if it also needs a runtime counterpart.\n        needRuntime = !!gen(el, dir, state.warn);\n      }\n      if (needRuntime) {\n        hasRuntime = true;\n        res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\" + (dir.isDynamicArg ? dir.arg : (\"\\\"\" + (dir.arg) + \"\\\"\"))) : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n      }\n    }\n    if (hasRuntime) {\n      return res.slice(0, -1) + ']'\n    }\n  }\n\n  function genInlineTemplate (el, state) {\n    var ast = el.children[0];\n    if (el.children.length !== 1 || ast.type !== 1) {\n      state.warn(\n        'Inline-template components must have exactly one child element.',\n        { start: el.start }\n      );\n    }\n    if (ast && ast.type === 1) {\n      var inlineRenderFns = generate(ast, state.options);\n      return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n    }\n  }\n\n  function genScopedSlots (\n    el,\n    slots,\n    state\n  ) {\n    // by default scoped slots are considered \"stable\", this allows child\n    // components with only scoped slots to skip forced updates from parent.\n    // but in some cases we have to bail-out of this optimization\n    // for example if the slot contains dynamic names, has v-if or v-for on them...\n    var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {\n      var slot = slots[key];\n      return (\n        slot.slotTargetDynamic ||\n        slot.if ||\n        slot.for ||\n        containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n      )\n    });\n\n    // #9534: if a component with scoped slots is inside a conditional branch,\n    // it's possible for the same component to be reused but with different\n    // compiled slot content. To avoid that, we generate a unique key based on\n    // the generated code of all the slot contents.\n    var needsKey = !!el.if;\n\n    // OR when it is inside another scoped slot or v-for (the reactivity may be\n    // disconnected due to the intermediate scope variable)\n    // #9438, #9506\n    // TODO: this can be further optimized by properly analyzing in-scope bindings\n    // and skip force updating ones that do not actually use scope variables.\n    if (!needsForceUpdate) {\n      var parent = el.parent;\n      while (parent) {\n        if (\n          (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||\n          parent.for\n        ) {\n          needsForceUpdate = true;\n          break\n        }\n        if (parent.if) {\n          needsKey = true;\n        }\n        parent = parent.parent;\n      }\n    }\n\n    var generatedSlots = Object.keys(slots)\n      .map(function (key) { return genScopedSlot(slots[key], state); })\n      .join(',');\n\n    return (\"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? (\",null,false,\" + (hash(generatedSlots))) : \"\") + \")\")\n  }\n\n  function hash(str) {\n    var hash = 5381;\n    var i = str.length;\n    while(i) {\n      hash = (hash * 33) ^ str.charCodeAt(--i);\n    }\n    return hash >>> 0\n  }\n\n  function containsSlotChild (el) {\n    if (el.type === 1) {\n      if (el.tag === 'slot') {\n        return true\n      }\n      return el.children.some(containsSlotChild)\n    }\n    return false\n  }\n\n  function genScopedSlot (\n    el,\n    state\n  ) {\n    var isLegacySyntax = el.attrsMap['slot-scope'];\n    if (el.if && !el.ifProcessed && !isLegacySyntax) {\n      return genIf(el, state, genScopedSlot, \"null\")\n    }\n    if (el.for && !el.forProcessed) {\n      return genFor(el, state, genScopedSlot)\n    }\n    var slotScope = el.slotScope === emptySlotScopeToken\n      ? \"\"\n      : String(el.slotScope);\n    var fn = \"function(\" + slotScope + \"){\" +\n      \"return \" + (el.tag === 'template'\n        ? el.if && isLegacySyntax\n          ? (\"(\" + (el.if) + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\")\n          : genChildren(el, state) || 'undefined'\n        : genElement(el, state)) + \"}\";\n    // reverse proxy v-slot without scope on this.$slots\n    var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n    return (\"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\")\n  }\n\n  function genChildren (\n    el,\n    state,\n    checkSkip,\n    altGenElement,\n    altGenNode\n  ) {\n    var children = el.children;\n    if (children.length) {\n      var el$1 = children[0];\n      // optimize single v-for\n      if (children.length === 1 &&\n        el$1.for &&\n        el$1.tag !== 'template' &&\n        el$1.tag !== 'slot'\n      ) {\n        var normalizationType = checkSkip\n          ? state.maybeComponent(el$1) ? \",1\" : \",0\"\n          : \"\";\n        return (\"\" + ((altGenElement || genElement)(el$1, state)) + normalizationType)\n      }\n      var normalizationType$1 = checkSkip\n        ? getNormalizationType(children, state.maybeComponent)\n        : 0;\n      var gen = altGenNode || genNode;\n      return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType$1 ? (\",\" + normalizationType$1) : ''))\n    }\n  }\n\n  // determine the normalization needed for the children array.\n  // 0: no normalization needed\n  // 1: simple normalization needed (possible 1-level deep nested array)\n  // 2: full normalization needed\n  function getNormalizationType (\n    children,\n    maybeComponent\n  ) {\n    var res = 0;\n    for (var i = 0; i < children.length; i++) {\n      var el = children[i];\n      if (el.type !== 1) {\n        continue\n      }\n      if (needsNormalization(el) ||\n          (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n        res = 2;\n        break\n      }\n      if (maybeComponent(el) ||\n          (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n        res = 1;\n      }\n    }\n    return res\n  }\n\n  function needsNormalization (el) {\n    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n  }\n\n  function genNode (node, state) {\n    if (node.type === 1) {\n      return genElement(node, state)\n    } else if (node.type === 3 && node.isComment) {\n      return genComment(node)\n    } else {\n      return genText(node)\n    }\n  }\n\n  function genText (text) {\n    return (\"_v(\" + (text.type === 2\n      ? text.expression // no need for () because already wrapped in _s()\n      : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n  }\n\n  function genComment (comment) {\n    return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n  }\n\n  function genSlot (el, state) {\n    var slotName = el.slotName || '\"default\"';\n    var children = genChildren(el, state);\n    var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n    var attrs = el.attrs || el.dynamicAttrs\n      ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({\n          // slot props are camelized\n          name: camelize(attr.name),\n          value: attr.value,\n          dynamic: attr.dynamic\n        }); }))\n      : null;\n    var bind$$1 = el.attrsMap['v-bind'];\n    if ((attrs || bind$$1) && !children) {\n      res += \",null\";\n    }\n    if (attrs) {\n      res += \",\" + attrs;\n    }\n    if (bind$$1) {\n      res += (attrs ? '' : ',null') + \",\" + bind$$1;\n    }\n    return res + ')'\n  }\n\n  // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n  function genComponent (\n    componentName,\n    el,\n    state\n  ) {\n    var children = el.inlineTemplate ? null : genChildren(el, state, true);\n    return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n  }\n\n  function genProps (props) {\n    var staticProps = \"\";\n    var dynamicProps = \"\";\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      var value = transformSpecialNewlines(prop.value);\n      if (prop.dynamic) {\n        dynamicProps += (prop.name) + \",\" + value + \",\";\n      } else {\n        staticProps += \"\\\"\" + (prop.name) + \"\\\":\" + value + \",\";\n      }\n    }\n    staticProps = \"{\" + (staticProps.slice(0, -1)) + \"}\";\n    if (dynamicProps) {\n      return (\"_d(\" + staticProps + \",[\" + (dynamicProps.slice(0, -1)) + \"])\")\n    } else {\n      return staticProps\n    }\n  }\n\n  // #3895, #4268\n  function transformSpecialNewlines (text) {\n    return text\n      .replace(/\\u2028/g, '\\\\u2028')\n      .replace(/\\u2029/g, '\\\\u2029')\n  }\n\n  /*  */\n\n\n\n  // these keywords should not appear inside expressions, but operators like\n  // typeof, instanceof and in are allowed\n  var prohibitedKeywordRE = new RegExp('\\\\b' + (\n    'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n    'super,throw,while,yield,delete,export,import,return,switch,default,' +\n    'extends,finally,continue,debugger,function,arguments'\n  ).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n  // these unary operators should not be used as property/method names\n  var unaryOperatorsRE = new RegExp('\\\\b' + (\n    'delete,typeof,void'\n  ).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n  // strip strings in expressions\n  var stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n  // detect problematic expressions in a template\n  function detectErrors (ast, warn) {\n    if (ast) {\n      checkNode(ast, warn);\n    }\n  }\n\n  function checkNode (node, warn) {\n    if (node.type === 1) {\n      for (var name in node.attrsMap) {\n        if (dirRE.test(name)) {\n          var value = node.attrsMap[name];\n          if (value) {\n            var range = node.rawAttrsMap[name];\n            if (name === 'v-for') {\n              checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), warn, range);\n            } else if (name === 'v-slot' || name[0] === '#') {\n              checkFunctionParameterExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n            } else if (onRE.test(name)) {\n              checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n            } else {\n              checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n            }\n          }\n        }\n      }\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          checkNode(node.children[i], warn);\n        }\n      }\n    } else if (node.type === 2) {\n      checkExpression(node.expression, node.text, warn, node);\n    }\n  }\n\n  function checkEvent (exp, text, warn, range) {\n    var stripped = exp.replace(stripStringRE, '');\n    var keywordMatch = stripped.match(unaryOperatorsRE);\n    if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {\n      warn(\n        \"avoid using JavaScript unary operator as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim()),\n        range\n      );\n    }\n    checkExpression(exp, text, warn, range);\n  }\n\n  function checkFor (node, text, warn, range) {\n    checkExpression(node.for || '', text, warn, range);\n    checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n  }\n\n  function checkIdentifier (\n    ident,\n    type,\n    text,\n    warn,\n    range\n  ) {\n    if (typeof ident === 'string') {\n      try {\n        new Function((\"var \" + ident + \"=_\"));\n      } catch (e) {\n        warn((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())), range);\n      }\n    }\n  }\n\n  function checkExpression (exp, text, warn, range) {\n    try {\n      new Function((\"return \" + exp));\n    } catch (e) {\n      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n      if (keywordMatch) {\n        warn(\n          \"avoid using JavaScript keyword as property name: \" +\n          \"\\\"\" + (keywordMatch[0]) + \"\\\"\\n  Raw expression: \" + (text.trim()),\n          range\n        );\n      } else {\n        warn(\n          \"invalid expression: \" + (e.message) + \" in\\n\\n\" +\n          \"    \" + exp + \"\\n\\n\" +\n          \"  Raw expression: \" + (text.trim()) + \"\\n\",\n          range\n        );\n      }\n    }\n  }\n\n  function checkFunctionParameterExpression (exp, text, warn, range) {\n    try {\n      new Function(exp, '');\n    } catch (e) {\n      warn(\n        \"invalid function parameter expression: \" + (e.message) + \" in\\n\\n\" +\n        \"    \" + exp + \"\\n\\n\" +\n        \"  Raw expression: \" + (text.trim()) + \"\\n\",\n        range\n      );\n    }\n  }\n\n  /*  */\n\n  var range = 2;\n\n  function generateCodeFrame (\n    source,\n    start,\n    end\n  ) {\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = source.length;\n\n    var lines = source.split(/\\r?\\n/);\n    var count = 0;\n    var res = [];\n    for (var i = 0; i < lines.length; i++) {\n      count += lines[i].length + 1;\n      if (count >= start) {\n        for (var j = i - range; j <= i + range || end > count; j++) {\n          if (j < 0 || j >= lines.length) { continue }\n          res.push((\"\" + (j + 1) + (repeat$1(\" \", 3 - String(j + 1).length)) + \"|  \" + (lines[j])));\n          var lineLength = lines[j].length;\n          if (j === i) {\n            // push underline\n            var pad = start - (count - lineLength) + 1;\n            var length = end > count ? lineLength - pad : end - start;\n            res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n          } else if (j > i) {\n            if (end > count) {\n              var length$1 = Math.min(end - count, lineLength);\n              res.push(\"   |  \" + repeat$1(\"^\", length$1));\n            }\n            count += lineLength + 1;\n          }\n        }\n        break\n      }\n    }\n    return res.join('\\n')\n  }\n\n  function repeat$1 (str, n) {\n    var result = '';\n    if (n > 0) {\n      while (true) { // eslint-disable-line\n        if (n & 1) { result += str; }\n        n >>>= 1;\n        if (n <= 0) { break }\n        str += str;\n      }\n    }\n    return result\n  }\n\n  /*  */\n\n\n\n  function createFunction (code, errors) {\n    try {\n      return new Function(code)\n    } catch (err) {\n      errors.push({ err: err, code: code });\n      return noop\n    }\n  }\n\n  function createCompileToFunctionFn (compile) {\n    var cache = Object.create(null);\n\n    return function compileToFunctions (\n      template,\n      options,\n      vm\n    ) {\n      options = extend({}, options);\n      var warn$$1 = options.warn || warn;\n      delete options.warn;\n\n      /* istanbul ignore if */\n      {\n        // detect possible CSP restriction\n        try {\n          new Function('return 1');\n        } catch (e) {\n          if (e.toString().match(/unsafe-eval|CSP/)) {\n            warn$$1(\n              'It seems you are using the standalone build of Vue.js in an ' +\n              'environment with Content Security Policy that prohibits unsafe-eval. ' +\n              'The template compiler cannot work in this environment. Consider ' +\n              'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n              'templates into render functions.'\n            );\n          }\n        }\n      }\n\n      // check cache\n      var key = options.delimiters\n        ? String(options.delimiters) + template\n        : template;\n      if (cache[key]) {\n        return cache[key]\n      }\n\n      // compile\n      var compiled = compile(template, options);\n\n      // check compilation errors/tips\n      {\n        if (compiled.errors && compiled.errors.length) {\n          if (options.outputSourceRange) {\n            compiled.errors.forEach(function (e) {\n              warn$$1(\n                \"Error compiling template:\\n\\n\" + (e.msg) + \"\\n\\n\" +\n                generateCodeFrame(template, e.start, e.end),\n                vm\n              );\n            });\n          } else {\n            warn$$1(\n              \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n              compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n              vm\n            );\n          }\n        }\n        if (compiled.tips && compiled.tips.length) {\n          if (options.outputSourceRange) {\n            compiled.tips.forEach(function (e) { return tip(e.msg, vm); });\n          } else {\n            compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n          }\n        }\n      }\n\n      // turn code into functions\n      var res = {};\n      var fnGenErrors = [];\n      res.render = createFunction(compiled.render, fnGenErrors);\n      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n        return createFunction(code, fnGenErrors)\n      });\n\n      // check function generation errors.\n      // this should only happen if there is a bug in the compiler itself.\n      // mostly for codegen development use\n      /* istanbul ignore if */\n      {\n        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n          warn$$1(\n            \"Failed to generate render function:\\n\\n\" +\n            fnGenErrors.map(function (ref) {\n              var err = ref.err;\n              var code = ref.code;\n\n              return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n          }).join('\\n'),\n            vm\n          );\n        }\n      }\n\n      return (cache[key] = res)\n    }\n  }\n\n  /*  */\n\n  function createCompilerCreator (baseCompile) {\n    return function createCompiler (baseOptions) {\n      function compile (\n        template,\n        options\n      ) {\n        var finalOptions = Object.create(baseOptions);\n        var errors = [];\n        var tips = [];\n\n        var warn = function (msg, range, tip) {\n          (tip ? tips : errors).push(msg);\n        };\n\n        if (options) {\n          if (options.outputSourceRange) {\n            // $flow-disable-line\n            var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n            warn = function (msg, range, tip) {\n              var data = { msg: msg };\n              if (range) {\n                if (range.start != null) {\n                  data.start = range.start + leadingSpaceLength;\n                }\n                if (range.end != null) {\n                  data.end = range.end + leadingSpaceLength;\n                }\n              }\n              (tip ? tips : errors).push(data);\n            };\n          }\n          // merge custom modules\n          if (options.modules) {\n            finalOptions.modules =\n              (baseOptions.modules || []).concat(options.modules);\n          }\n          // merge custom directives\n          if (options.directives) {\n            finalOptions.directives = extend(\n              Object.create(baseOptions.directives || null),\n              options.directives\n            );\n          }\n          // copy other options\n          for (var key in options) {\n            if (key !== 'modules' && key !== 'directives') {\n              finalOptions[key] = options[key];\n            }\n          }\n        }\n\n        finalOptions.warn = warn;\n\n        var compiled = baseCompile(template.trim(), finalOptions);\n        {\n          detectErrors(compiled.ast, warn);\n        }\n        compiled.errors = errors;\n        compiled.tips = tips;\n        return compiled\n      }\n\n      return {\n        compile: compile,\n        compileToFunctions: createCompileToFunctionFn(compile)\n      }\n    }\n  }\n\n  /*  */\n\n  // `createCompilerCreator` allows creating compilers that use alternative\n  // parser/optimizer/codegen, e.g the SSR optimizing compiler.\n  // Here we just export a default compiler using the default parts.\n  var createCompiler = createCompilerCreator(function baseCompile (\n    template,\n    options\n  ) {\n    var ast = parse(template.trim(), options);\n    if (options.optimize !== false) {\n      optimize(ast, options);\n    }\n    var code = generate(ast, options);\n    return {\n      ast: ast,\n      render: code.render,\n      staticRenderFns: code.staticRenderFns\n    }\n  });\n\n  /*  */\n\n  var ref$1 = createCompiler(baseOptions);\n  var compile = ref$1.compile;\n  var compileToFunctions = ref$1.compileToFunctions;\n\n  /*  */\n\n  // check whether current browser encodes a char inside attribute values\n  var div;\n  function getShouldDecode (href) {\n    div = div || document.createElement('div');\n    div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n    return div.innerHTML.indexOf('&#10;') > 0\n  }\n\n  // #3663: IE encodes newlines inside attribute values while other browsers don't\n  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n  // #6828: chrome encodes content in a[href]\n  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n  /*  */\n\n  var idToTemplate = cached(function (id) {\n    var el = query(id);\n    return el && el.innerHTML\n  });\n\n  var mount = Vue.prototype.$mount;\n  Vue.prototype.$mount = function (\n    el,\n    hydrating\n  ) {\n    el = el && query(el);\n\n    /* istanbul ignore if */\n    if (el === document.body || el === document.documentElement) {\n      warn(\n        \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n      );\n      return this\n    }\n\n    var options = this.$options;\n    // resolve template/el and convert to render function\n    if (!options.render) {\n      var template = options.template;\n      if (template) {\n        if (typeof template === 'string') {\n          if (template.charAt(0) === '#') {\n            template = idToTemplate(template);\n            /* istanbul ignore if */\n            if (!template) {\n              warn(\n                (\"Template element not found or is empty: \" + (options.template)),\n                this\n              );\n            }\n          }\n        } else if (template.nodeType) {\n          template = template.innerHTML;\n        } else {\n          {\n            warn('invalid template option:' + template, this);\n          }\n          return this\n        }\n      } else if (el) {\n        template = getOuterHTML(el);\n      }\n      if (template) {\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          mark('compile');\n        }\n\n        var ref = compileToFunctions(template, {\n          outputSourceRange: \"development\" !== 'production',\n          shouldDecodeNewlines: shouldDecodeNewlines,\n          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n          delimiters: options.delimiters,\n          comments: options.comments\n        }, this);\n        var render = ref.render;\n        var staticRenderFns = ref.staticRenderFns;\n        options.render = render;\n        options.staticRenderFns = staticRenderFns;\n\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          mark('compile end');\n          measure((\"vue \" + (this._name) + \" compile\"), 'compile', 'compile end');\n        }\n      }\n    }\n    return mount.call(this, el, hydrating)\n  };\n\n  /**\n   * Get outerHTML of elements, taking care\n   * of SVG elements in IE as well.\n   */\n  function getOuterHTML (el) {\n    if (el.outerHTML) {\n      return el.outerHTML\n    } else {\n      var container = document.createElement('div');\n      container.appendChild(el.cloneNode(true));\n      return container.innerHTML\n    }\n  }\n\n  Vue.compile = compileToFunctions;\n\n  return Vue;\n\n}));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(20).setImmediate))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmpzP2UxYjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RDtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7O0FBRXJCOztBQUVBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQkFBK0I7QUFDdkQsd0JBQXdCLGlCQUFpQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxpQ0FBaUMsRUFBRTtBQUN2RixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVTs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRztBQUNWO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHlDQUF5Qyx3QkFBd0IsRUFBRTtBQUNuRSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEMsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsMENBQTBDLEVBQUU7QUFDNUM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0JBQW9CLEVBQUU7QUFDdkQ7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsU0FBUyxxQkFBcUI7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdUJBQXVCO0FBQzNELG1DQUFtQyxzQkFBc0I7QUFDekQ7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDLGlDQUFpQztBQUNqQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQyxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxxQ0FBcUMsRUFBRTtBQUN0Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLHlDQUF5QyxFQUFFO0FBQ2pGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzREFBc0QsRUFBRTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUNBQWlDO0FBQ3JFLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlDQUFpQztBQUNyRSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUMsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHVGQUF1RjtBQUM5RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CLEVBQUU7O0FBRXREO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hELHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkI7QUFDM0I7QUFDQSx3QkFBd0IsaUNBQWlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsMkJBQTJCLEVBQUU7QUFDekUsT0FBTztBQUNQO0FBQ0EsNENBQTRDLDRCQUE0QixFQUFFO0FBQzFFLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsc0JBQXNCOztBQUV2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFELDhCQUE4QixnQ0FBZ0M7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFVBQVU7QUFDckUsbUJBQW1CLHdCQUF3QixPQUFPLHVCQUF1QjtBQUN6RTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0RBQWtEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrREFBa0Q7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUNBQXFDLGdFQUFnRTtBQUNyRztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCLE9BQU8sZ0NBQWdDO0FBQ2pGLDBEQUEwRCxvQkFBb0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdFQUFnRTtBQUM3RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlDQUFpQztBQUN0RTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxvQkFBb0I7QUFDakY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnQ0FBZ0M7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qiw2QkFBNkI7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3QkFBd0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseUJBQXlCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseUJBQXlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qiw4QkFBOEI7QUFDckQ7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEVBQThFO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RCxPQUFPO0FBQ1AsMENBQTBDLGtCQUFrQjtBQUM1RCxPQUFPO0FBQ1AsMENBQTBDLDBCQUEwQjtBQUNwRSxPQUFPO0FBQ1AsMENBQTBDLGlCQUFpQjtBQUMzRCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLDZDQUE2QztBQUM3Qyw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxlQUFlLEVBQUUsdUJBQXVCLFVBQVUsRUFBRTtBQUN0RjtBQUNBOztBQUVBO0FBQ0EscURBQXFELDZDQUE2QztBQUNsRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZDQUE2QztBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyQkFBMkI7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELEtBQUs7QUFDTCwyQ0FBMkM7QUFDM0M7O0FBRUEsbUNBQW1DLHdDQUF3QztBQUMzRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMERBQTBELG1CQUFtQjtBQUM3RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRiw4QkFBOEI7QUFDOUI7QUFDQSw2QkFBNkI7QUFDN0IsMEJBQTBCLGlFQUFpRTtBQUMzRixjQUFjLDBGQUEwRjtBQUN4RyxRQUFRLEtBQUssMENBQTBDO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGtCQUFrQjtBQUNqRSx3QkFBd0IsK0NBQStDO0FBQ3ZFLG1EQUFtRDs7QUFFbkQ7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJCQUEyQjtBQUN4RCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkNBQTZDLEVBQUU7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw0QkFBNEIsRUFBRTtBQUNwRixPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwrQkFBK0IsRUFBRTtBQUN2RixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMscUNBQXFDOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBLHdCQUF3QixFQUFFLGlCQUFpQixFQUFFO0FBQzdDLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7O0FBSUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUyw0QkFBNEI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0IsRUFBRTtBQUM1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBWdWUuanMgdjIuNi4xMlxuICogKGMpIDIwMTQtMjAyMCBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLlZ1ZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qICAqL1xuXG4gIHZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4gIC8vIFRoZXNlIGhlbHBlcnMgcHJvZHVjZSBiZXR0ZXIgVk0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuICAvLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nLlxuICBmdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBpc0RlZiAodikge1xuICAgIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gICAgcmV0dXJuIHYgPT09IHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmUuXG4gICAqL1xuICBmdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAgICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICAgKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gICAqL1xuICBmdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUsIGUuZy4sIFtvYmplY3QgT2JqZWN0XS5cbiAgICovXG4gIHZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gIGZ1bmN0aW9uIHRvUmF3VHlwZSAodmFsdWUpIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAgICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAgICovXG4gIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xuICB9XG5cbiAgZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gICAqL1xuICBmdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCAodmFsKSB7XG4gICAgdmFyIG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcbiAgICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQcm9taXNlICh2YWwpIHtcbiAgICByZXR1cm4gKFxuICAgICAgaXNEZWYodmFsKSAmJlxuICAgICAgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2YgdmFsLmNhdGNoID09PSAnZnVuY3Rpb24nXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICAgKi9cbiAgZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT0gbnVsbFxuICAgICAgPyAnJ1xuICAgICAgOiBBcnJheS5pc0FycmF5KHZhbCkgfHwgKGlzUGxhaW5PYmplY3QodmFsKSAmJiB2YWwudG9TdHJpbmcgPT09IF90b1N0cmluZylcbiAgICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICAgIDogU3RyaW5nKHZhbClcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAgICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gICAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICAgKiBpcyBpbiB0aGF0IG1hcC5cbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VNYXAgKFxuICAgIHN0cixcbiAgICBleHBlY3RzTG93ZXJDYXNlXG4gICkge1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gICAqL1xuICB2YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICAgKi9cbiAgdmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgICBpZiAoYXJyLmxlbmd0aCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBhbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAgICovXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIGZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gICAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICAgKi9cbiAgdmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG4gIHZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICAgKi9cbiAgdmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gICAqL1xuICB2YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xuICB2YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTaW1wbGUgYmluZCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQsXG4gICAqIGUuZy4sIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5LCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxuICAgKiBzaW5jZSBuYXRpdmUgYmluZCBpcyBub3cgcGVyZm9ybWFudCBlbm91Z2ggaW4gbW9zdCBicm93c2Vycy5cbiAgICogQnV0IHJlbW92aW5nIGl0IHdvdWxkIG1lYW4gYnJlYWtpbmcgY29kZSB0aGF0IHdhcyBhYmxlIHRvIHJ1biBpblxuICAgKiBQaGFudG9tSlMgMS54LCBzbyB0aGlzIG11c3QgYmUga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICovXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZnVuY3Rpb24gcG9seWZpbGxCaW5kIChmbiwgY3R4KSB7XG4gICAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxcbiAgICAgICAgPyBsID4gMVxuICAgICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgICAgOiBmbi5jYWxsKGN0eClcbiAgICB9XG5cbiAgICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gICAgcmV0dXJuIGJvdW5kRm5cbiAgfVxuXG4gIGZ1bmN0aW9uIG5hdGl2ZUJpbmQgKGZuLCBjdHgpIHtcbiAgICByZXR1cm4gZm4uYmluZChjdHgpXG4gIH1cblxuICB2YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gICAgPyBuYXRpdmVCaW5kXG4gICAgOiBwb2x5ZmlsbEJpbmQ7XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICAgIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICAvKipcbiAgICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gdG9cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycltpXSkge1xuICAgICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAgICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gICAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKS5cbiAgICovXG4gIGZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XG5cbiAgLyoqXG4gICAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gICAqL1xuICB2YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XG5cbiAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHNhbWUgdmFsdWUuXG4gICAqL1xuICB2YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBzdHJpbmcgY29udGFpbmluZyBzdGF0aWMga2V5cyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gICAqL1xuICBmdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gICAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XG4gICAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuICAgIH0sIFtdKS5qb2luKCcsJylcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAgICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICAgKi9cbiAgZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gICAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICAgIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKClcbiAgICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgICAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgbG9vc2VseSBlcXVhbCB2YWx1ZSBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIGFycmF5IChpZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgdGhlIGFycmF5IG11c3RcbiAgICogY29udGFpbiBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc2hhcGUpLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAgICovXG4gIGZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAgICovXG4gIGZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbiAgdmFyIEFTU0VUX1RZUEVTID0gW1xuICAgICdjb21wb25lbnQnLFxuICAgICdkaXJlY3RpdmUnLFxuICAgICdmaWx0ZXInXG4gIF07XG5cbiAgdmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgICAnYmVmb3JlQ3JlYXRlJyxcbiAgICAnY3JlYXRlZCcsXG4gICAgJ2JlZm9yZU1vdW50JyxcbiAgICAnbW91bnRlZCcsXG4gICAgJ2JlZm9yZVVwZGF0ZScsXG4gICAgJ3VwZGF0ZWQnLFxuICAgICdiZWZvcmVEZXN0cm95JyxcbiAgICAnZGVzdHJveWVkJyxcbiAgICAnYWN0aXZhdGVkJyxcbiAgICAnZGVhY3RpdmF0ZWQnLFxuICAgICdlcnJvckNhcHR1cmVkJyxcbiAgICAnc2VydmVyUHJlZmV0Y2gnXG4gIF07XG5cbiAgLyogICovXG5cblxuXG4gIHZhciBjb25maWcgPSAoe1xuICAgIC8qKlxuICAgICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgICAqL1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAgICovXG4gICAgc2lsZW50OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAgICovXG4gICAgcHJvZHVjdGlvblRpcDogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgICAqL1xuICAgIGRldnRvb2xzOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICAgKi9cbiAgICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgICAqL1xuICAgIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgICAqL1xuICAgIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAgICovXG4gICAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAgICovXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAgICovXG4gICAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAgICovXG4gICAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICAgKi9cbiAgICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgICAqL1xuICAgIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgICAqL1xuICAgIG11c3RVc2VQcm9wOiBubyxcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gdXBkYXRlcyBhc3luY2hyb25vdXNseS4gSW50ZW5kZWQgdG8gYmUgdXNlZCBieSBWdWUgVGVzdCBVdGlsc1xuICAgICAqIFRoaXMgd2lsbCBzaWduaWZpY2FudGx5IHJlZHVjZSBwZXJmb3JtYW5jZSBpZiBzZXQgdG8gZmFsc2UuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgICAqL1xuICAgIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG4gIH0pO1xuXG4gIC8qICAqL1xuXG4gIC8qKlxuICAgKiB1bmljb2RlIGxldHRlcnMgdXNlZCBmb3IgcGFyc2luZyBodG1sIHRhZ3MsIGNvbXBvbmVudCBuYW1lcyBhbmQgcHJvcGVydHkgcGF0aHMuXG4gICAqIHVzaW5nIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTMvc2VtYW50aWNzLXNjcmlwdGluZy5odG1sI3BvdGVudGlhbGN1c3RvbWVsZW1lbnRuYW1lXG4gICAqIHNraXBwaW5nIFxcdTEwMDAwLVxcdUVGRkZGIGR1ZSB0byBpdCBmcmVlemluZyB1cCBQaGFudG9tSlNcbiAgICovXG4gIHZhciB1bmljb2RlUmVnRXhwID0gL2EtekEtWlxcdTAwQjdcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDNGLVxcdTIwNDBcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkQvO1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAgICovXG4gIGZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICAgIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICAgIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAgICovXG4gIGZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbCxcbiAgICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gICAqL1xuICB2YXIgYmFpbFJFID0gbmV3IFJlZ0V4cCgoXCJbXlwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiLiRfXFxcXGRdXCIpKTtcbiAgZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gICAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqXG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG4gIHZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4gIC8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbiAgdmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgaW5XZWV4ID0gdHlwZW9mIFdYRW52aXJvbm1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhV1hFbnZpcm9ubWVudC5wbGF0Zm9ybTtcbiAgdmFyIHdlZXhQbGF0Zm9ybSA9IGluV2VleCAmJiBXWEVudmlyb25tZW50LnBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICB2YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xuICB2YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbiAgdmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xuICB2YXIgaXNBbmRyb2lkID0gKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG4gIHZhciBpc0lPUyA9IChVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpKSB8fCAod2VleFBsYXRmb3JtID09PSAnaW9zJyk7XG4gIHZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuICB2YXIgaXNQaGFudG9tSlMgPSBVQSAmJiAvcGhhbnRvbWpzLy50ZXN0KFVBKTtcbiAgdmFyIGlzRkYgPSBVQSAmJiBVQS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pO1xuXG4gIC8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbiAgdmFyIG5hdGl2ZVdhdGNoID0gKHt9KS53YXRjaDtcblxuICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG4gIGlmIChpbkJyb3dzZXIpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cblxuICAvLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbiAgLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbiAgdmFyIF9pc1NlcnZlcjtcbiAgdmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWluQnJvd3NlciAmJiAhaW5XZWV4ICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddICYmIGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2lzU2VydmVyXG4gIH07XG5cbiAgLy8gZGV0ZWN0IGRldnRvb2xzXG4gIHZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBmdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxuICB9XG5cbiAgdmFyIGhhc1N5bWJvbCA9XG4gICAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICAgIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG4gIHZhciBfU2V0O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gICAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gICAgX1NldCA9IFNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gICAgX1NldCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuICAgICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgICAgfTtcbiAgICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgICB9O1xuICAgICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIFNldDtcbiAgICB9KCkpO1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIHdhcm4gPSBub29wO1xuICB2YXIgdGlwID0gbm9vcDtcbiAgdmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbiAgdmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobm9vcCk7XG5cbiAge1xuICAgIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICAgIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICAgIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuXG4gICAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyB0cmFjZSkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuICAgICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgICB9XG4gICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5jaWQgIT0gbnVsbFxuICAgICAgICA/IHZtLm9wdGlvbnNcbiAgICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgICA/IHZtLiRvcHRpb25zIHx8IHZtLmNvbnN0cnVjdG9yLm9wdGlvbnNcbiAgICAgICAgICA6IHZtO1xuICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgICAgdmFyIGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcbiAgICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgICAgKVxuICAgIH07XG5cbiAgICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgICAgdmFyIHJlcyA9ICcnO1xuICAgICAgd2hpbGUgKG4pIHtcbiAgICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgICAgbiA+Pj0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNcbiAgICB9O1xuXG4gICAgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICAgIHZhciB0cmVlID0gW107XG4gICAgICAgIHZhciBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgICA/ICgoZm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSkpICsgXCIuLi4gKFwiICsgKHZtWzFdKSArIFwiIHJlY3Vyc2l2ZSBjYWxscylcIilcbiAgICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAgIC5qb2luKCdcXG4nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIHVpZCA9IDA7XG5cbiAgLyoqXG4gICAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICAgKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICAgKi9cbiAgdmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gICAgdGhpcy5pZCA9IHVpZCsrO1xuICAgIHRoaXMuc3VicyA9IFtdO1xuICB9O1xuXG4gIERlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgICB0aGlzLnN1YnMucHVzaChzdWIpO1xuICB9O1xuXG4gIERlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xuICB9O1xuXG4gIERlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIERlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICAgIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gICAgaWYgKCFjb25maWcuYXN5bmMpIHtcbiAgICAgIC8vIHN1YnMgYXJlbid0IHNvcnRlZCBpbiBzY2hlZHVsZXIgaWYgbm90IHJ1bm5pbmcgYXN5bmNcbiAgICAgIC8vIHdlIG5lZWQgdG8gc29ydCB0aGVtIG5vdyB0byBtYWtlIHN1cmUgdGhleSBmaXJlIGluIGNvcnJlY3RcbiAgICAgIC8vIG9yZGVyXG4gICAgICBzdWJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuICAvLyBUaGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIG9ubHkgb25lIHdhdGNoZXJcbiAgLy8gY2FuIGJlIGV2YWx1YXRlZCBhdCBhIHRpbWUuXG4gIERlcC50YXJnZXQgPSBudWxsO1xuICB2YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuICBmdW5jdGlvbiBwdXNoVGFyZ2V0ICh0YXJnZXQpIHtcbiAgICB0YXJnZXRTdGFjay5wdXNoKHRhcmdldCk7XG4gICAgRGVwLnRhcmdldCA9IHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gICAgdGFyZ2V0U3RhY2sucG9wKCk7XG4gICAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrW3RhcmdldFN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICAgIHRhZyxcbiAgICBkYXRhLFxuICAgIGNoaWxkcmVuLFxuICAgIHRleHQsXG4gICAgZWxtLFxuICAgIGNvbnRleHQsXG4gICAgY29tcG9uZW50T3B0aW9ucyxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKSB7XG4gICAgdGhpcy50YWcgPSB0YWc7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLmVsbSA9IGVsbTtcbiAgICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5mbkNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICAgIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gICAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJhdyA9IGZhbHNlO1xuICAgIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gICAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gICAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbiAgICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBwcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbiAgdmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xuXG4gICAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgICBub2RlLnRleHQgPSB0ZXh0O1xuICAgIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbiAgfVxuXG4gIC8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4gIC8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3NcbiAgLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4gIC8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG4gIGZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gICAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICAgIHZub2RlLnRhZyxcbiAgICAgIHZub2RlLmRhdGEsXG4gICAgICAvLyAjNzk3NVxuICAgICAgLy8gY2xvbmUgY2hpbGRyZW4gYXJyYXkgdG8gYXZvaWQgbXV0YXRpbmcgb3JpZ2luYWwgaW4gY2FzZSBvZiBjbG9uaW5nXG4gICAgICAvLyBhIGNoaWxkLlxuICAgICAgdm5vZGUuY2hpbGRyZW4gJiYgdm5vZGUuY2hpbGRyZW4uc2xpY2UoKSxcbiAgICAgIHZub2RlLnRleHQsXG4gICAgICB2bm9kZS5lbG0sXG4gICAgICB2bm9kZS5jb250ZXh0LFxuICAgICAgdm5vZGUuY29tcG9uZW50T3B0aW9ucyxcbiAgICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICAgICk7XG4gICAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gICAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gICAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICAgIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gICAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgICBjbG9uZWQuZm5TY29wZUlkID0gdm5vZGUuZm5TY29wZUlkO1xuICAgIGNsb25lZC5hc3luY01ldGEgPSB2bm9kZS5hc3luY01ldGE7XG4gICAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gY2xvbmVkXG4gIH1cblxuICAvKlxuICAgKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAgICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gICAqL1xuXG4gIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuICB2YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtcblxuICB2YXIgbWV0aG9kc1RvUGF0Y2ggPSBbXG4gICAgJ3B1c2gnLFxuICAgICdwb3AnLFxuICAgICdzaGlmdCcsXG4gICAgJ3Vuc2hpZnQnLFxuICAgICdzcGxpY2UnLFxuICAgICdzb3J0JyxcbiAgICAncmV2ZXJzZSdcbiAgXTtcblxuICAvKipcbiAgICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gICAqL1xuICBtZXRob2RzVG9QYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gICAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICAgIHZhciBpbnNlcnRlZDtcbiAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qICAqL1xuXG4gIHZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4gIC8qKlxuICAgKiBJbiBzb21lIGNhc2VzIHdlIG1heSB3YW50IHRvIGRpc2FibGUgb2JzZXJ2YXRpb24gaW5zaWRlIGEgY29tcG9uZW50J3NcbiAgICogdXBkYXRlIGNvbXB1dGF0aW9uLlxuICAgKi9cbiAgdmFyIHNob3VsZE9ic2VydmUgPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIHRvZ2dsZU9ic2VydmluZyAodmFsdWUpIHtcbiAgICBzaG91bGRPYnNlcnZlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBpcyBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gICAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAgICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAgICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoIHVwZGF0ZXMuXG4gICAqL1xuICB2YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gICAgdGhpcy52bUNvdW50ID0gMDtcbiAgICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmIChoYXNQcm90bykge1xuICAgICAgICBwcm90b0F1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3B5QXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndhbGsodmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2FsayB0aHJvdWdoIGFsbCBwcm9wZXJ0aWVzIGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICAgKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAgICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gICAqL1xuICBPYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAgICovXG4gIE9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBoZWxwZXJzXG5cbiAgLyoqXG4gICAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICAgKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICAgKi9cbiAgZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gICAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG4gIH1cblxuICAvKipcbiAgICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAgICogaGlkZGVuIHByb3BlcnRpZXMuXG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBmdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAgICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAgICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gICAqL1xuICBmdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgb2I7XG4gICAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc2hvdWxkT2JzZXJ2ZSAmJlxuICAgICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgICAhdmFsdWUuX2lzVnVlXG4gICAgKSB7XG4gICAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgICBvYi52bUNvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiBvYlxuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgICBvYmosXG4gICAga2V5LFxuICAgIHZhbCxcbiAgICBjdXN0b21TZXR0ZXIsXG4gICAgc2hhbGxvd1xuICApIHtcbiAgICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gICAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICAgIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gICAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcbiAgICBpZiAoKCFnZXR0ZXIgfHwgc2V0dGVyKSAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YWwgPSBvYmpba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICAgIGlmIChjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAjNzk4MTogZm9yIGFjY2Vzc29yIHByb3BlcnRpZXMgd2l0aG91dCBzZXR0ZXJcbiAgICAgICAgaWYgKGdldHRlciAmJiAhc2V0dGVyKSB7IHJldHVybiB9XG4gICAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAgICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICAgKiBhbHJlYWR5IGV4aXN0LlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gICAgaWYgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpXG4gICAgKSB7XG4gICAgICB3YXJuKChcIkNhbm5vdCBzZXQgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICAgIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG4gICAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICAgIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICAgKTtcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG4gICAgaWYgKCFvYikge1xuICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICAgIGlmIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KVxuICAgICkge1xuICAgICAgd2FybigoXCJDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICAgIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICAgKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBkZWxldGUgdGFyZ2V0W2tleV07XG4gICAgaWYgKCFvYikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICAgKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAgICovXG4gIGZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICAgIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGUgPSB2YWx1ZVtpXTtcbiAgICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgLyoqXG4gICAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAgICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAgICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gICAqL1xuICB2YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuICAvKipcbiAgICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICAgKi9cbiAge1xuICAgIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgICAgaWYgKCF2bSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gICAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gICAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG5cbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgPyBSZWZsZWN0Lm93bktleXMoZnJvbSlcbiAgICAgIDogT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBvYnNlcnZlZC4uLlxuICAgICAgaWYgKGtleSA9PT0gJ19fb2JfXycpIHsgY29udGludWUgfVxuICAgICAgdG9WYWwgPSB0b1trZXldO1xuICAgICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHRvVmFsICE9PSBmcm9tVmFsICYmXG4gICAgICAgIGlzUGxhaW5PYmplY3QodG9WYWwpICYmXG4gICAgICAgIGlzUGxhaW5PYmplY3QoZnJvbVZhbClcbiAgICAgICkge1xuICAgICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9cbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRhXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgICBwYXJlbnRWYWwsXG4gICAgY2hpbGRWYWwsXG4gICAgdm1cbiAgKSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgICAgfVxuICAgICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgICB9XG4gICAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcywgdGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgICBwYXJlbnRWYWwsXG4gICAgY2hpbGRWYWwsXG4gICAgdm1cbiAgKSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgICB9XG5cbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcbiAgfTtcblxuICAvKipcbiAgICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgICBwYXJlbnRWYWwsXG4gICAgY2hpbGRWYWxcbiAgKSB7XG4gICAgdmFyIHJlcyA9IGNoaWxkVmFsXG4gICAgICA/IHBhcmVudFZhbFxuICAgICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgICA6IHBhcmVudFZhbDtcbiAgICByZXR1cm4gcmVzXG4gICAgICA/IGRlZHVwZUhvb2tzKHJlcylcbiAgICAgIDogcmVzXG4gIH1cblxuICBmdW5jdGlvbiBkZWR1cGVIb29rcyAoaG9va3MpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlcy5pbmRleE9mKGhvb2tzW2ldKSA9PT0gLTEpIHtcbiAgICAgICAgcmVzLnB1c2goaG9va3NbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBMSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFzc2V0c1xuICAgKlxuICAgKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gICAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAgICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZUFzc2V0cyAoXG4gICAgcGFyZW50VmFsLFxuICAgIGNoaWxkVmFsLFxuICAgIHZtLFxuICAgIGtleVxuICApIHtcbiAgICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gICAgaWYgKGNoaWxkVmFsKSB7XG4gICAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgfVxuXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFdhdGNoZXJzLlxuICAgKlxuICAgKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gICAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICAgKi9cbiAgc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKFxuICAgIHBhcmVudFZhbCxcbiAgICBjaGlsZFZhbCxcbiAgICB2bSxcbiAgICBrZXlcbiAgKSB7XG4gICAgLy8gd29yayBhcm91bmQgRmlyZWZveCdzIE9iamVjdC5wcm90b3R5cGUud2F0Y2guLi5cbiAgICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICAgIHtcbiAgICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICAgIHZhciByZXQgPSB7fTtcbiAgICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICAgIGZvciAodmFyIGtleSQxIGluIGNoaWxkVmFsKSB7XG4gICAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcbiAgICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICAgIH1cbiAgICAgIHJldFtrZXkkMV0gPSBwYXJlbnRcbiAgICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH07XG5cbiAgLyoqXG4gICAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gICAqL1xuICBzdHJhdHMucHJvcHMgPVxuICBzdHJhdHMubWV0aG9kcyA9XG4gIHN0cmF0cy5pbmplY3QgPVxuICBzdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAoXG4gICAgcGFyZW50VmFsLFxuICAgIGNoaWxkVmFsLFxuICAgIHZtLFxuICAgIGtleVxuICApIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICAgIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gICAgaWYgKGNoaWxkVmFsKSB7IGV4dGVuZChyZXQsIGNoaWxkVmFsKTsgfVxuICAgIHJldHVybiByZXRcbiAgfTtcbiAgc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICAgKi9cbiAgdmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICAgID8gcGFyZW50VmFsXG4gICAgICA6IGNoaWxkVmFsXG4gIH07XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICAgKi9cbiAgZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gICAgaWYgKCFuZXcgUmVnRXhwKChcIl5bYS16QS1aXVtcXFxcLVxcXFwuMC05X1wiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiXSokXCIpKS50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgICAnc2hvdWxkIGNvbmZvcm0gdG8gdmFsaWQgY3VzdG9tIGVsZW1lbnQgbmFtZSBpbiBodG1sNSBzcGVjaWZpY2F0aW9uLidcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAnaWQ6ICcgKyBuYW1lXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAgICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICAgIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gICAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgaSwgdmFsLCBuYW1lO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgICAgPyB2YWxcbiAgICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJwcm9wc1xcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHByb3BzKSkgKyBcIi5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIG9wdGlvbnMucHJvcHMgPSByZXM7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICAgKi9cbiAgZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zLCB2bSkge1xuICAgIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgICBpZiAoIWluamVjdCkgeyByZXR1cm4gfVxuICAgIHZhciBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChpbmplY3QpKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgICAgPyBleHRlbmQoeyBmcm9tOiBrZXkgfSwgdmFsKVxuICAgICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcImluamVjdFxcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICAgKi9cbiAgZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICAgIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICAgIGlmIChkaXJzKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgICB2YXIgZGVmJCQxID0gZGlyc1trZXldO1xuICAgICAgICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmJCQxLCB1cGRhdGU6IGRlZiQkMSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIiArXG4gICAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUodmFsdWUpKSArIFwiLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICAgKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgICBwYXJlbnQsXG4gICAgY2hpbGQsXG4gICAgdm1cbiAgKSB7XG4gICAge1xuICAgICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcblxuICAgIC8vIEFwcGx5IGV4dGVuZHMgYW5kIG1peGlucyBvbiB0aGUgY2hpbGQgb3B0aW9ucyxcbiAgICAvLyBidXQgb25seSBpZiBpdCBpcyBhIHJhdyBvcHRpb25zIG9iamVjdCB0aGF0IGlzbid0XG4gICAgLy8gdGhlIHJlc3VsdCBvZiBhbm90aGVyIG1lcmdlT3B0aW9ucyBjYWxsLlxuICAgIC8vIE9ubHkgbWVyZ2VkIG9wdGlvbnMgaGFzIHRoZSBfYmFzZSBwcm9wZXJ0eS5cbiAgICBpZiAoIWNoaWxkLl9iYXNlKSB7XG4gICAgICBpZiAoY2hpbGQuZXh0ZW5kcykge1xuICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5leHRlbmRzLCB2bSk7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIga2V5O1xuICAgIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSBhbiBhc3NldC5cbiAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gICAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAgICovXG4gIGZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gICAgb3B0aW9ucyxcbiAgICB0eXBlLFxuICAgIGlkLFxuICAgIHdhcm5NaXNzaW5nXG4gICkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gICAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gICAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gICAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICAgIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gICAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gICAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgICBpZiAod2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyogICovXG5cblxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gICAga2V5LFxuICAgIHByb3BPcHRpb25zLFxuICAgIHByb3BzRGF0YSxcbiAgICB2bVxuICApIHtcbiAgICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gICAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAgIC8vIGJvb2xlYW4gY2FzdGluZ1xuICAgIHZhciBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcbiAgICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpIHtcbiAgICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXG4gICAgICAgIC8vIGJvb2xlYW4gaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgICAgICB2YXIgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xuICAgICAgICBpZiAoc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4KSB7XG4gICAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgICB2YXIgcHJldlNob3VsZE9ic2VydmUgPSBzaG91bGRPYnNlcnZlO1xuICAgICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgICB0b2dnbGVPYnNlcnZpbmcocHJldlNob3VsZE9ic2VydmUpO1xuICAgIH1cbiAgICB7XG4gICAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAgIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICAgIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gICAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICAgIGlmIChpc09iamVjdChkZWYpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgICB9XG4gICAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gICAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgICA/IGRlZi5jYWxsKHZtKVxuICAgICAgOiBkZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gICAqL1xuICBmdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgICBwcm9wLFxuICAgIG5hbWUsXG4gICAgdmFsdWUsXG4gICAgdm0sXG4gICAgYWJzZW50XG4gICkge1xuICAgIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gICAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdmFsaWQpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcyksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbiAgZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgICB2YXIgdmFsaWQ7XG4gICAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gICAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgICB2YXIgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdmFsaWQ6IHZhbGlkLFxuICAgICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICAgKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAgICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU2FtZVR5cGUgKGEsIGIpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VHlwZUluZGV4ICh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXhwZWN0ZWRUeXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlc1tpXSwgdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UgKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgICBcIiBFeHBlY3RlZCBcIiArIChleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpKTtcbiAgICB2YXIgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcbiAgICB2YXIgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgICB2YXIgZXhwZWN0ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSk7XG4gICAgdmFyIHJlY2VpdmVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpO1xuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSBleHBlY3RlZCB2YWx1ZVxuICAgIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxuICAgICAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xuICAgICAgbWVzc2FnZSArPSBcIiB3aXRoIHZhbHVlIFwiICsgZXhwZWN0ZWRWYWx1ZTtcbiAgICB9XG4gICAgbWVzc2FnZSArPSBcIiwgZ290IFwiICsgcmVjZWl2ZWRUeXBlICsgXCIgXCI7XG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXG4gICAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XG4gICAgICBtZXNzYWdlICs9IFwid2l0aCB2YWx1ZSBcIiArIHJlY2VpdmVkVmFsdWUgKyBcIi5cIjtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0eWxlVmFsdWUgKHZhbHVlLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgICByZXR1cm4gKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIilcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOdW1iZXInKSB7XG4gICAgICByZXR1cm4gKFwiXCIgKyAoTnVtYmVyKHZhbHVlKSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCJcIiArIHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRXhwbGljYWJsZSAodmFsdWUpIHtcbiAgICB2YXIgZXhwbGljaXRUeXBlcyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ107XG4gICAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbTsgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQm9vbGVhbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgcmV0dXJuIGFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbic7IH0pXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICAgIC8vIERlYWN0aXZhdGUgZGVwcyB0cmFja2luZyB3aGlsZSBwcm9jZXNzaW5nIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgcG9zc2libGUgaW5maW5pdGUgcmVuZGVyaW5nLlxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZXgvaXNzdWVzLzE1MDVcbiAgICBwdXNoVGFyZ2V0KCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh2bSkge1xuICAgICAgICB2YXIgY3VyID0gdm07XG4gICAgICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhcHR1cmUgPSBob29rc1tpXS5jYWxsKGN1ciwgZXJyLCB2bSwgaW5mbykgPT09IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxIYW5kbGVFcnJvcihlLCBjdXIsICdlcnJvckNhcHR1cmVkIGhvb2snKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHBvcFRhcmdldCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZVdpdGhFcnJvckhhbmRsaW5nIChcbiAgICBoYW5kbGVyLFxuICAgIGNvbnRleHQsXG4gICAgYXJncyxcbiAgICB2bSxcbiAgICBpbmZvXG4gICkge1xuICAgIHZhciByZXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IGFyZ3MgPyBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpIDogaGFuZGxlci5jYWxsKGNvbnRleHQpO1xuICAgICAgaWYgKHJlcyAmJiAhcmVzLl9pc1Z1ZSAmJiBpc1Byb21pc2UocmVzKSAmJiAhcmVzLl9oYW5kbGVkKSB7XG4gICAgICAgIHJlcy5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8gKyBcIiAoUHJvbWlzZS9hc3luYylcIik7IH0pO1xuICAgICAgICAvLyBpc3N1ZSAjOTUxMVxuICAgICAgICAvLyBhdm9pZCBjYXRjaCB0cmlnZ2VyaW5nIG11bHRpcGxlIHRpbWVzIHdoZW4gbmVzdGVkIGNhbGxzXG4gICAgICAgIHJlcy5faGFuZGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBnbG9iYWxIYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICAgIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpbiB0aGUgaGFuZGxlcixcbiAgICAgICAgLy8gZG8gbm90IGxvZyBpdCB0d2ljZVxuICAgICAgICBpZiAoZSAhPT0gZXJyKSB7XG4gICAgICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsb2dFcnJvcihlcnIsIHZtLCBpbmZvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gICAge1xuICAgICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICgoaW5Ccm93c2VyIHx8IGluV2VleCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBpc1VzaW5nTWljcm9UYXNrID0gZmFsc2U7XG5cbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGZsdXNoQ2FsbGJhY2tzICgpIHtcbiAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29waWVzW2ldKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBtaWNyb3Rhc2tzLlxuICAvLyBJbiAyLjUgd2UgdXNlZCAobWFjcm8pIHRhc2tzIChpbiBjb21iaW5hdGlvbiB3aXRoIG1pY3JvdGFza3MpLlxuICAvLyBIb3dldmVyLCBpdCBoYXMgc3VidGxlIHByb2JsZW1zIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludFxuICAvLyAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbiAgLy8gQWxzbywgdXNpbmcgKG1hY3JvKSB0YXNrcyBpbiBldmVudCBoYW5kbGVyIHdvdWxkIGNhdXNlIHNvbWUgd2VpcmQgYmVoYXZpb3JzXG4gIC8vIHRoYXQgY2Fubm90IGJlIGNpcmN1bXZlbnRlZCAoZS5nLiAjNzEwOSwgIzcxNTMsICM3NTQ2LCAjNzgzNCwgIzgxMDkpLlxuICAvLyBTbyB3ZSBub3cgdXNlIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYWdhaW4uXG4gIC8vIEEgbWFqb3IgZHJhd2JhY2sgb2YgdGhpcyB0cmFkZW9mZiBpcyB0aGF0IHRoZXJlIGFyZSBzb21lIHNjZW5hcmlvc1xuICAvLyB3aGVyZSBtaWNyb3Rhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZSBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcbiAgLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwLCB3aGljaCBoYXZlIHdvcmthcm91bmRzKVxuICAvLyBvciBldmVuIGJldHdlZW4gYnViYmxpbmcgb2YgdGhlIHNhbWUgZXZlbnQgKCM2NTY2KS5cbiAgdmFyIHRpbWVyRnVuYztcblxuICAvLyBUaGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuICAvLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbiAgLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4gIC8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4gIC8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbiAgLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG4gIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHAudGhlbihmbHVzaENhbGxiYWNrcyk7XG4gICAgICAvLyBJbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICAgIH07XG4gICAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG4gIH0gZWxzZSBpZiAoIWlzSUUgJiYgdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAgIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICAgIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbiAgKSkge1xuICAgIC8vIFVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gICAgLy8gZS5nLiBQaGFudG9tSlMsIGlPUzcsIEFuZHJvaWQgNC40XG4gICAgLy8gKCM2NDY2IE11dGF0aW9uT2JzZXJ2ZXIgaXMgdW5yZWxpYWJsZSBpbiBJRTExKVxuICAgIHZhciBjb3VudGVyID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmbHVzaENhbGxiYWNrcyk7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgICB9O1xuICAgIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgICAvLyBGYWxsYmFjayB0byBzZXRJbW1lZGlhdGUuXG4gICAgLy8gVGVjaG5pY2FsbHkgaXQgbGV2ZXJhZ2VzIHRoZSAobWFjcm8pIHRhc2sgcXVldWUsXG4gICAgLy8gYnV0IGl0IGlzIHN0aWxsIGEgYmV0dGVyIGNob2ljZSB0aGFuIHNldFRpbWVvdXQuXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrIHRvIHNldFRpbWVvdXQuXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gICAgdmFyIF9yZXNvbHZlO1xuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgICAgdGltZXJGdW5jKCk7XG4gICAgfVxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgbWFyaztcbiAgdmFyIG1lYXN1cmU7XG5cbiAge1xuICAgIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICBwZXJmICYmXG4gICAgICBwZXJmLm1hcmsgJiZcbiAgICAgIHBlcmYubWVhc3VyZSAmJlxuICAgICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgICApIHtcbiAgICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgICAvLyBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbiAgdmFyIGluaXRQcm94eTtcblxuICB7XG4gICAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICAgKTtcblxuICAgIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgICAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIHJlYWN0aXZlLCAnICtcbiAgICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9yZWFjdGl2aXR5Lmh0bWwjRGVjbGFyaW5nLVJlYWN0aXZlLVByb3BlcnRpZXMuJyxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgd2FyblJlc2VydmVkUHJlZml4ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIlByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBtdXN0IGJlIGFjY2Vzc2VkIHdpdGggXFxcIiRkYXRhLlwiICsga2V5ICsgXCJcXFwiIGJlY2F1c2UgXCIgK1xuICAgICAgICAncHJvcGVydGllcyBzdGFydGluZyB3aXRoIFwiJFwiIG9yIFwiX1wiIGFyZSBub3QgcHJveGllZCBpbiB0aGUgVnVlIGluc3RhbmNlIHRvICcgK1xuICAgICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzLiAnICtcbiAgICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvYXBpLyNkYXRhJyxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgaGFzUHJveHkgPVxuICAgICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgICAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5LmNoYXJBdCgwKSA9PT0gJ18nICYmICEoa2V5IGluIHRhcmdldC4kZGF0YSkpO1xuICAgICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxuICAgICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgICAgZWxzZSB7IHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gICAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gICAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gICAqL1xuICBmdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gICAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICAgIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICAgIHZhciBpLCBrZXlzO1xuICAgIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gICAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh2YWwuX19vYl9fKSB7XG4gICAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBzZWVuLmFkZChkZXBJZCk7XG4gICAgfVxuICAgIGlmIChpc0EpIHtcbiAgICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gICAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICAgIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgb25jZTogb25jZSQkMSxcbiAgICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgICBwYXNzaXZlOiBwYXNzaXZlXG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucywgdm0pIHtcbiAgICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2xvbmVkW2ldLCBudWxsLCBhcmd1bWVudHMkMSwgdm0sIFwidi1vbiBoYW5kbGVyXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBcInYtb24gaGFuZGxlclwiKVxuICAgICAgfVxuICAgIH1cbiAgICBpbnZva2VyLmZucyA9IGZucztcbiAgICByZXR1cm4gaW52b2tlclxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgICBvbixcbiAgICBvbGRPbixcbiAgICBhZGQsXG4gICAgcmVtb3ZlJCQxLFxuICAgIGNyZWF0ZU9uY2VIYW5kbGVyLFxuICAgIHZtXG4gICkge1xuICAgIHZhciBuYW1lLCBkZWYkJDEsIGN1ciwgb2xkLCBldmVudDtcbiAgICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICAgIGRlZiQkMSA9IGN1ciA9IG9uW25hbWVdO1xuICAgICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xuICAgICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RydWUoZXZlbnQub25jZSkpIHtcbiAgICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICAgIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgICB9XG4gICAgdmFyIGludm9rZXI7XG4gICAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICAgIGRlZltob29rS2V5XSA9IGludm9rZXI7XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgICBkYXRhLFxuICAgIEN0b3IsXG4gICAgdGFnXG4gICkge1xuICAgIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAgIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAgIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gICAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICAgIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICAgIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gICAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGlwKFxuICAgICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Byb3AgKFxuICAgIHJlcyxcbiAgICBoYXNoLFxuICAgIGtleSxcbiAgICBhbHRLZXksXG4gICAgcHJlc2VydmVcbiAgKSB7XG4gICAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuICAvLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuICAvL1xuICAvLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuICAvLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4gIC8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuICAvLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIC8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4gIC8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuICAvLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG4gIGZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlblxuICB9XG5cbiAgLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbiAgLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4gIC8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbiAgLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICAgIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgICAgOiB1bmRlZmluZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xuICAgICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgICAgLy8gIG5lc3RlZFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICAgIGMuc2hpZnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgICBpc0RlZihjLnRhZykgJiZcbiAgICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gICAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICAgIGlmIChwcm92aWRlKSB7XG4gICAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgICAgOiBwcm92aWRlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICAgIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICB7XG4gICAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICAgIGlmIChpbmplY3QpIHtcbiAgICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cbiAgICAgICAgaWYgKGtleSA9PT0gJ19fb2JfXycpIHsgY29udGludWUgfVxuICAgICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZURlZmF1bHQgPSBpbmplY3Rba2V5XS5kZWZhdWx0O1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YXJuKChcIkluamVjdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbm90IGZvdW5kXCIpLCB2bSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cblxuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0XG4gICkge1xuICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHt9XG4gICAgfVxuICAgIHZhciBzbG90cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgICB9XG4gICAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICAgICkge1xuICAgICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKHNsb3RzLmRlZmF1bHQgfHwgKHNsb3RzLmRlZmF1bHQgPSBbXSkpLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcbiAgICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICAgIGlmIChzbG90c1tuYW1lJDFdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICAgICAgZGVsZXRlIHNsb3RzW25hbWUkMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbG90c1xuICB9XG5cbiAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90cyAoXG4gICAgc2xvdHMsXG4gICAgbm9ybWFsU2xvdHMsXG4gICAgcHJldlNsb3RzXG4gICkge1xuICAgIHZhciByZXM7XG4gICAgdmFyIGhhc05vcm1hbFNsb3RzID0gT2JqZWN0LmtleXMobm9ybWFsU2xvdHMpLmxlbmd0aCA+IDA7XG4gICAgdmFyIGlzU3RhYmxlID0gc2xvdHMgPyAhIXNsb3RzLiRzdGFibGUgOiAhaGFzTm9ybWFsU2xvdHM7XG4gICAgdmFyIGtleSA9IHNsb3RzICYmIHNsb3RzLiRrZXk7XG4gICAgaWYgKCFzbG90cykge1xuICAgICAgcmVzID0ge307XG4gICAgfSBlbHNlIGlmIChzbG90cy5fbm9ybWFsaXplZCkge1xuICAgICAgLy8gZmFzdCBwYXRoIDE6IGNoaWxkIGNvbXBvbmVudCByZS1yZW5kZXIgb25seSwgcGFyZW50IGRpZCBub3QgY2hhbmdlXG4gICAgICByZXR1cm4gc2xvdHMuX25vcm1hbGl6ZWRcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgaXNTdGFibGUgJiZcbiAgICAgIHByZXZTbG90cyAmJlxuICAgICAgcHJldlNsb3RzICE9PSBlbXB0eU9iamVjdCAmJlxuICAgICAga2V5ID09PSBwcmV2U2xvdHMuJGtleSAmJlxuICAgICAgIWhhc05vcm1hbFNsb3RzICYmXG4gICAgICAhcHJldlNsb3RzLiRoYXNOb3JtYWxcbiAgICApIHtcbiAgICAgIC8vIGZhc3QgcGF0aCAyOiBzdGFibGUgc2NvcGVkIHNsb3RzIHcvIG5vIG5vcm1hbCBzbG90cyB0byBwcm94eSxcbiAgICAgIC8vIG9ubHkgbmVlZCB0byBub3JtYWxpemUgb25jZVxuICAgICAgcmV0dXJuIHByZXZTbG90c1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSQxIGluIHNsb3RzKSB7XG4gICAgICAgIGlmIChzbG90c1trZXkkMV0gJiYga2V5JDFbMF0gIT09ICckJykge1xuICAgICAgICAgIHJlc1trZXkkMV0gPSBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXkkMSwgc2xvdHNba2V5JDFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBleHBvc2Ugbm9ybWFsIHNsb3RzIG9uIHNjb3BlZFNsb3RzXG4gICAgZm9yICh2YXIga2V5JDIgaW4gbm9ybWFsU2xvdHMpIHtcbiAgICAgIGlmICghKGtleSQyIGluIHJlcykpIHtcbiAgICAgICAgcmVzW2tleSQyXSA9IHByb3h5Tm9ybWFsU2xvdChub3JtYWxTbG90cywga2V5JDIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBhdm9yaWF6IHNlZW1zIHRvIG1vY2sgYSBub24tZXh0ZW5zaWJsZSAkc2NvcGVkU2xvdHMgb2JqZWN0XG4gICAgLy8gYW5kIHdoZW4gdGhhdCBpcyBwYXNzZWQgZG93biB0aGlzIHdvdWxkIGNhdXNlIGFuIGVycm9yXG4gICAgaWYgKHNsb3RzICYmIE9iamVjdC5pc0V4dGVuc2libGUoc2xvdHMpKSB7XG4gICAgICAoc2xvdHMpLl9ub3JtYWxpemVkID0gcmVzO1xuICAgIH1cbiAgICBkZWYocmVzLCAnJHN0YWJsZScsIGlzU3RhYmxlKTtcbiAgICBkZWYocmVzLCAnJGtleScsIGtleSk7XG4gICAgZGVmKHJlcywgJyRoYXNOb3JtYWwnLCBoYXNOb3JtYWxTbG90cyk7XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5LCBmbikge1xuICAgIHZhciBub3JtYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPyBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpIDogZm4oe30pO1xuICAgICAgcmVzID0gcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcylcbiAgICAgICAgPyBbcmVzXSAvLyBzaW5nbGUgdm5vZGVcbiAgICAgICAgOiBub3JtYWxpemVDaGlsZHJlbihyZXMpO1xuICAgICAgcmV0dXJuIHJlcyAmJiAoXG4gICAgICAgIHJlcy5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgKHJlcy5sZW5ndGggPT09IDEgJiYgcmVzWzBdLmlzQ29tbWVudCkgLy8gIzk2NThcbiAgICAgICkgPyB1bmRlZmluZWRcbiAgICAgICAgOiByZXNcbiAgICB9O1xuICAgIC8vIHRoaXMgaXMgYSBzbG90IHVzaW5nIHRoZSBuZXcgdi1zbG90IHN5bnRheCB3aXRob3V0IHNjb3BlLiBhbHRob3VnaCBpdCBpc1xuICAgIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAgIC8vIG9uIHRoaXMuJHNsb3RzIGJlY2F1c2UgdGhlIHVzYWdlIGlzIHNlbWFudGljYWxseSBhIG5vcm1hbCBzbG90LlxuICAgIGlmIChmbi5wcm94eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgICAgZ2V0OiBub3JtYWxpemVkLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZFxuICB9XG5cbiAgZnVuY3Rpb24gcHJveHlOb3JtYWxTbG90KHNsb3RzLCBrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2xvdHNba2V5XTsgfVxuICB9XG5cbiAgLyogICovXG5cbiAgLyoqXG4gICAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gICAqL1xuICBmdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgICB2YWwsXG4gICAgcmVuZGVyXG4gICkge1xuICAgIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgaWYgKGhhc1N5bWJvbCAmJiB2YWxbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICAgIHJldC5wdXNoKHJlbmRlcihyZXN1bHQudmFsdWUsIHJldC5sZW5ndGgpKTtcbiAgICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzRGVmKHJldCkpIHtcbiAgICAgIHJldCA9IFtdO1xuICAgIH1cbiAgICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgLyogICovXG5cbiAgLyoqXG4gICAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gICAqL1xuICBmdW5jdGlvbiByZW5kZXJTbG90IChcbiAgICBuYW1lLFxuICAgIGZhbGxiYWNrLFxuICAgIHByb3BzLFxuICAgIGJpbmRPYmplY3RcbiAgKSB7XG4gICAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICAgIHZhciBub2RlcztcbiAgICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChiaW5kT2JqZWN0KSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgICB9XG4gICAgICBub2RlcyA9IHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV0gfHwgZmFsbGJhY2s7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJywgeyBzbG90OiB0YXJnZXQgfSwgbm9kZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2Rlc1xuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAgICovXG4gIGZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG4gICAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaXNLZXlOb3RNYXRjaCAoZXhwZWN0LCBhY3R1YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgICByZXR1cm4gZXhwZWN0LmluZGV4T2YoYWN0dWFsKSA9PT0gLTFcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAgICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXG4gICAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgKi9cbiAgZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gICAgZXZlbnRLZXlDb2RlLFxuICAgIGtleSxcbiAgICBidWlsdEluS2V5Q29kZSxcbiAgICBldmVudEtleU5hbWUsXG4gICAgYnVpbHRJbktleU5hbWVcbiAgKSB7XG4gICAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgICBpZiAoYnVpbHRJbktleU5hbWUgJiYgZXZlbnRLZXlOYW1lICYmICFjb25maWcua2V5Q29kZXNba2V5XSkge1xuICAgICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2goYnVpbHRJbktleU5hbWUsIGV2ZW50S2V5TmFtZSlcbiAgICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICAgIHJldHVybiBpc0tleU5vdE1hdGNoKG1hcHBlZEtleUNvZGUsIGV2ZW50S2V5Q29kZSlcbiAgICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICAvKipcbiAgICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAgICovXG4gIGZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyAoXG4gICAgZGF0YSxcbiAgICB0YWcsXG4gICAgdmFsdWUsXG4gICAgYXNQcm9wLFxuICAgIGlzU3luY1xuICApIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzaDtcbiAgICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgICAgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICAgIGlmICghKGNhbWVsaXplZEtleSBpbiBoYXNoKSAmJiAhKGh5cGhlbmF0ZWRLZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gICAgaW5kZXgsXG4gICAgaXNJbkZvclxuICApIHtcbiAgICB2YXIgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xuICAgIHZhciB0cmVlID0gY2FjaGVkW2luZGV4XTtcbiAgICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZS5cbiAgICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgICAgcmV0dXJuIHRyZWVcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICAgIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwoXG4gICAgICB0aGlzLl9yZW5kZXJQcm94eSxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICAgKTtcbiAgICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICAgIHJldHVybiB0cmVlXG4gIH1cblxuICAvKipcbiAgICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAgICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gICAqL1xuICBmdW5jdGlvbiBtYXJrT25jZSAoXG4gICAgdHJlZSxcbiAgICBpbmRleCxcbiAgICBrZXlcbiAgKSB7XG4gICAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRyZWVcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICAgIHRyZWUsXG4gICAga2V5LFxuICAgIGlzT25jZVxuICApIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgICBub2RlLmtleSA9IGtleTtcbiAgICBub2RlLmlzT25jZSA9IGlzT25jZTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XG4gICAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICAgIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbiAgICByZXMsXG4gICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgYWRkZWQgaW4gMi42XG4gICAgaGFzRHluYW1pY0tleXMsXG4gICAgY29udGVudEhhc2hLZXlcbiAgKSB7XG4gICAgcmVzID0gcmVzIHx8IHsgJHN0YWJsZTogIWhhc0R5bmFtaWNLZXlzIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzbG90ID0gZm5zW2ldO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2xvdCkpIHtcbiAgICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKHNsb3QsIHJlcywgaGFzRHluYW1pY0tleXMpO1xuICAgICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICAgIC8vIG1hcmtlciBmb3IgcmV2ZXJzZSBwcm94eWluZyB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xuICAgICAgICBpZiAoc2xvdC5wcm94eSkge1xuICAgICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc1tzbG90LmtleV0gPSBzbG90LmZuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGVudEhhc2hLZXkpIHtcbiAgICAgIChyZXMpLiRrZXkgPSBjb250ZW50SGFzaEtleTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gYmluZER5bmFtaWNLZXlzIChiYXNlT2JqLCB2YWx1ZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIGtleSA9IHZhbHVlc1tpXTtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkpIHtcbiAgICAgICAgYmFzZU9ialt2YWx1ZXNbaV1dID0gdmFsdWVzW2kgKyAxXTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ICE9PSAnJyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgICAgLy8gbnVsbCBpcyBhIHNwZWNpYWwgdmFsdWUgZm9yIGV4cGxpY2l0bHkgcmVtb3ZpbmcgYSBiaW5kaW5nXG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiSW52YWxpZCB2YWx1ZSBmb3IgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgKGV4cGVjdGVkIHN0cmluZyBvciBudWxsKTogXCIgKyBrZXkpLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhc2VPYmpcbiAgfVxuXG4gIC8vIGhlbHBlciB0byBkeW5hbWljYWxseSBhcHBlbmQgbW9kaWZpZXIgcnVudGltZSBtYXJrZXJzIHRvIGV2ZW50IG5hbWVzLlxuICAvLyBlbnN1cmUgb25seSBhcHBlbmQgd2hlbiB2YWx1ZSBpcyBhbHJlYWR5IHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FzdFxuICAvLyB0byBzdHJpbmcgYW5kIGNhdXNlIHRoZSB0eXBlIGNoZWNrIHRvIG1pc3MuXG4gIGZ1bmN0aW9uIHByZXBlbmRNb2RpZmllciAodmFsdWUsIHN5bWJvbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3ltYm9sICsgdmFsdWUgOiB2YWx1ZVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICAgIHRhcmdldC5fbyA9IG1hcmtPbmNlO1xuICAgIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xuICAgIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICAgIHRhcmdldC5fbCA9IHJlbmRlckxpc3Q7XG4gICAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcbiAgICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICAgIHRhcmdldC5faSA9IGxvb3NlSW5kZXhPZjtcbiAgICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XG4gICAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgICB0YXJnZXQuX2sgPSBjaGVja0tleUNvZGVzO1xuICAgIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gICAgdGFyZ2V0Ll9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gICAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbiAgICB0YXJnZXQuX2QgPSBiaW5kRHluYW1pY0tleXM7XG4gICAgdGFyZ2V0Ll9wID0gcHJlcGVuZE1vZGlmaWVyO1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgKFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgcGFyZW50LFxuICAgIEN0b3JcbiAgKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gICAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICAgIHZhciBjb250ZXh0Vm07XG4gICAgaWYgKGhhc093bihwYXJlbnQsICdfdWlkJykpIHtcbiAgICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgY29udGV4dFZtLl9vcmlnaW5hbCA9IHBhcmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlIGNvbnRleHQgdm0gcGFzc2VkIGluIGlzIGEgZnVuY3Rpb25hbCBjb250ZXh0IGFzIHdlbGwuXG4gICAgICAvLyBpbiB0aGlzIGNhc2Ugd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgYXJlIGFibGUgdG8gZ2V0IGEgaG9sZCB0byB0aGVcbiAgICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICAgIGNvbnRleHRWbSA9IHBhcmVudDtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgICB9XG4gICAgdmFyIGlzQ29tcGlsZWQgPSBpc1RydWUob3B0aW9ucy5fY29tcGlsZWQpO1xuICAgIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMubGlzdGVuZXJzID0gZGF0YS5vbiB8fCBlbXB0eU9iamVjdDtcbiAgICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICAgIHRoaXMuc2xvdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMkMS4kc2xvdHMpIHtcbiAgICAgICAgbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgICAgZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgICB0aGlzJDEuJHNsb3RzID0gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcyQxLiRzbG90c1xuICAgIH07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Njb3BlZFNsb3RzJywgKHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLnNsb3RzKCkpXG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICAgIGlmIChpc0NvbXBpbGVkKSB7XG4gICAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgLy8gcHJlLXJlc29sdmUgc2xvdHMgZm9yIHJlbmRlclNsb3QoKVxuICAgICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgICB0aGlzLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuJHNsb3RzKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICAgIHZhciB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICAgIGlmICh2bm9kZSAmJiAhQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICAgIHZub2RlLmZuQ29udGV4dCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgICB9XG4gIH1cblxuICBpbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICAgIEN0b3IsXG4gICAgcHJvcHNEYXRhLFxuICAgIGRhdGEsXG4gICAgY29udGV4dFZtLFxuICAgIGNoaWxkcmVuXG4gICkge1xuICAgIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBwcm9wT3B0aW9ucyA9IG9wdGlvbnMucHJvcHM7XG4gICAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyQ29udGV4dCA9IG5ldyBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dChcbiAgICAgIGRhdGEsXG4gICAgICBwcm9wcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgY29udGV4dFZtLFxuICAgICAgQ3RvclxuICAgICk7XG5cbiAgICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gICAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICAgIHJldHVybiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2RlLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dClcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheSh2bm9kZXMubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCkge1xuICAgIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXG4gICAgLy8gKGUuZy4gaXQgd2FzIGZyb20gYSBjYWNoZWQgbm9ybWFsIHNsb3QpIHRoZSBmbkNvbnRleHQgY2F1c2VzIG5hbWVkIHNsb3RzXG4gICAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gICAgdmFyIGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgY2xvbmUuZm5Db250ZXh0ID0gY29udGV4dFZtO1xuICAgIGNsb25lLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAge1xuICAgICAgKGNsb25lLmRldnRvb2xzTWV0YSA9IGNsb25lLmRldnRvb2xzTWV0YSB8fCB7fSkucmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHQ7XG4gICAgfVxuICAgIGlmIChkYXRhLnNsb3QpIHtcbiAgICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmVcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qICAqL1xuXG4gIC8qICAqL1xuXG4gIC8qICAqL1xuXG4gIC8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG4gIHZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQgKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiZcbiAgICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxuICAgICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICAgKSB7XG4gICAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgYWN0aXZlSW5zdGFuY2VcbiAgICAgICAgKTtcbiAgICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gICAgQ3RvcixcbiAgICBkYXRhLFxuICAgIGNvbnRleHQsXG4gICAgY2hpbGRyZW4sXG4gICAgdGFnXG4gICkge1xuICAgIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gICAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gICAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICAgIH1cblxuICAgIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgICAvLyByZWplY3QuXG4gICAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gYXN5bmMgY29tcG9uZW50XG4gICAgdmFyIGFzeW5jRmFjdG9yeTtcbiAgICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IpO1xuICAgICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxuICAgICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICAgIGFzeW5jRmFjdG9yeSxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgdGFnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAgIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gICAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICAgIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBleHRyYWN0IHByb3BzXG4gICAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAgIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gICAgfVxuXG4gICAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICAgIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAgIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gICAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gICAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XG5cbiAgICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgICAgZGF0YSA9IHt9O1xuICAgICAgaWYgKHNsb3QpIHtcbiAgICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgICBpbnN0YWxsQ29tcG9uZW50SG9va3MoZGF0YSk7XG5cbiAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICAgIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICAgIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXG4gICAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICAgIGFzeW5jRmFjdG9yeVxuICAgICk7XG5cbiAgICByZXR1cm4gdm5vZGVcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICAgIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgICBwYXJlbnQgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gICkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICAgIHBhcmVudDogcGFyZW50XG4gICAgfTtcbiAgICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gICAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3RhbGxDb21wb25lbnRIb29rcyAoZGF0YSkge1xuICAgIHZhciBob29rcyA9IGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgICAgdmFyIGV4aXN0aW5nID0gaG9va3Nba2V5XTtcbiAgICAgIHZhciB0b01lcmdlID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgICAgaWYgKGV4aXN0aW5nICE9PSB0b01lcmdlICYmICEoZXhpc3RpbmcgJiYgZXhpc3RpbmcuX21lcmdlZCkpIHtcbiAgICAgICAgaG9va3Nba2V5XSA9IGV4aXN0aW5nID8gbWVyZ2VIb29rJDEodG9NZXJnZSwgZXhpc3RpbmcpIDogdG9NZXJnZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUhvb2skMSAoZjEsIGYyKSB7XG4gICAgdmFyIG1lcmdlZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAvLyBmbG93IGNvbXBsYWlucyBhYm91dCBleHRyYSBhcmdzIHdoaWNoIGlzIHdoeSB3ZSB1c2UgYW55XG4gICAgICBmMShhLCBiKTtcbiAgICAgIGYyKGEsIGIpO1xuICAgIH07XG4gICAgbWVyZ2VkLl9tZXJnZWQgPSB0cnVlO1xuICAgIHJldHVybiBtZXJnZWRcbiAgfVxuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbiAgLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gICAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gICAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0J1xuICAgIDsoZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgdmFyIGV4aXN0aW5nID0gb25bZXZlbnRdO1xuICAgIHZhciBjYWxsYmFjayA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gICAgaWYgKGlzRGVmKGV4aXN0aW5nKSkge1xuICAgICAgaWYgKFxuICAgICAgICBBcnJheS5pc0FycmF5KGV4aXN0aW5nKVxuICAgICAgICAgID8gZXhpc3RpbmcuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xXG4gICAgICAgICAgOiBleGlzdGluZyAhPT0gY2FsbGJhY2tcbiAgICAgICkge1xuICAgICAgICBvbltldmVudF0gPSBbY2FsbGJhY2tdLmNvbmNhdChleGlzdGluZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uW2V2ZW50XSA9IGNhbGxiYWNrO1xuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbiAgdmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4gIC8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4gIC8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgICBjb250ZXh0LFxuICAgIHRhZyxcbiAgICBkYXRhLFxuICAgIGNoaWxkcmVuLFxuICAgIG5vcm1hbGl6YXRpb25UeXBlLFxuICAgIGFsd2F5c05vcm1hbGl6ZVxuICApIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gICAgY29udGV4dCxcbiAgICB0YWcsXG4gICAgZGF0YSxcbiAgICBjaGlsZHJlbixcbiAgICBub3JtYWxpemF0aW9uVHlwZVxuICApIHtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICAgIH1cbiAgICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgICAgdGFnID0gZGF0YS5pcztcbiAgICB9XG4gICAgaWYgKCF0YWcpIHtcbiAgICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgICB9XG4gICAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICAgKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIH1cbiAgICB2YXIgdm5vZGUsIG5zO1xuICAgIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIEN0b3I7XG4gICAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEubmF0aXZlT24pKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIChcIlRoZSAubmF0aXZlIG1vZGlmaWVyIGZvciB2LW9uIGlzIG9ubHkgdmFsaWQgb24gY29tcG9uZW50cyBidXQgaXQgd2FzIHVzZWQgb24gPFwiICsgdGFnICsgXCI+LlwiKSxcbiAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJiBpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgIHJldHVybiB2bm9kZVxuICAgIH0gZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYobnMpKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7IHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpOyB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgICB2bm9kZS5ucyA9IG5zO1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgICBucyA9IHVuZGVmaW5lZDtcbiAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIChcbiAgICAgICAgICBpc1VuZGVmKGNoaWxkLm5zKSB8fCAoaXNUcnVlKGZvcmNlKSAmJiBjaGlsZC50YWcgIT09ICdzdmcnKSkpIHtcbiAgICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmVmICM1MzE4XG4gIC8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4gIC8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRGVlcEJpbmRpbmdzIChkYXRhKSB7XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XG4gICAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XG4gICAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICAgIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gICAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gICAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gICAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gICAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gICAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gICAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gICAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gICAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gICAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cbiAgICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAgIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICAgIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gICAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgICAgaWYgKF9wYXJlbnRWbm9kZSkge1xuICAgICAgICB2bS4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgICBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgICB2bS4kc2xvdHMsXG4gICAgICAgICAgdm0uJHNjb3BlZFNsb3RzXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgICAgLy8gcmVuZGVyIHNlbGZcbiAgICAgIHZhciB2bm9kZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBtYWludGFpbiBhIHN0YWNrIGJlY2F1c2UgYWxsIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgICAvLyBzZXBhcmF0ZWx5IGZyb20gb25lIGFub3RoZXIuIE5lc3RlZCBjb21wb25lbnQncyByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgICAgLy8gd2hlbiBwYXJlbnQgY29tcG9uZW50IGlzIHBhdGNoZWQuXG4gICAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IHZtO1xuICAgICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuICAgICAgfVxuICAgICAgLy8gaWYgdGhlIHJldHVybmVkIGFycmF5IGNvbnRhaW5zIG9ubHkgYSBzaW5nbGUgbm9kZSwgYWxsb3cgaXRcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSAmJiB2bm9kZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdm5vZGUgPSB2bm9kZVswXTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgICB9XG4gICAgICAvLyBzZXQgcGFyZW50XG4gICAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICAgIGlmIChcbiAgICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxuICAgICkge1xuICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgICB9XG4gICAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgICA6IGNvbXBcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICAgIGZhY3RvcnksXG4gICAgZGF0YSxcbiAgICBjb250ZXh0LFxuICAgIGNoaWxkcmVuLFxuICAgIHRhZ1xuICApIHtcbiAgICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgICBmYWN0b3J5LFxuICAgIGJhc2VDdG9yXG4gICkge1xuICAgIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgICB9XG5cbiAgICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gICAgfVxuXG4gICAgdmFyIG93bmVyID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICAgIGlmIChvd25lciAmJiBpc0RlZihmYWN0b3J5Lm93bmVycykgJiYgZmFjdG9yeS5vd25lcnMuaW5kZXhPZihvd25lcikgPT09IC0xKSB7XG4gICAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICAgIGZhY3Rvcnkub3duZXJzLnB1c2gob3duZXIpO1xuICAgIH1cblxuICAgIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICB9XG5cbiAgICBpZiAob3duZXIgJiYgIWlzRGVmKGZhY3Rvcnkub3duZXJzKSkge1xuICAgICAgdmFyIG93bmVycyA9IGZhY3Rvcnkub3duZXJzID0gW293bmVyXTtcbiAgICAgIHZhciBzeW5jID0gdHJ1ZTtcbiAgICAgIHZhciB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgdmFyIHRpbWVyVGltZW91dCA9IG51bGxcblxuICAgICAgOyhvd25lcikuJG9uKCdob29rOmRlc3Ryb3llZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbW92ZShvd25lcnMsIG93bmVyKTsgfSk7XG5cbiAgICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uIChyZW5kZXJDb21wbGV0ZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgKG93bmVyc1tpXSkuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgaWYgKHRpbWVyTG9hZGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyTG9hZGluZyk7XG4gICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGltZXJUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJUaW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVyVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgICApO1xuICAgICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgICBpZiAoaXNQcm9taXNlKHJlcykpIHtcbiAgICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShyZXMuY29tcG9uZW50KSkge1xuICAgICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGltZXJMb2FkaW5nID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgICAgdGltZXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRpbWVyVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgICAgXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzeW5jID0gZmFsc2U7XG4gICAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3RvcnlcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgICAgcmV0dXJuIGNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAgIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICAgIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdGFyZ2V0O1xuXG4gIGZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuKSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICAgIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgICBfdGFyZ2V0LiRvZmYoZXZlbnQsIG9uY2VIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICAgIHZtLFxuICAgIGxpc3RlbmVycyxcbiAgICBvbGRMaXN0ZW5lcnNcbiAgKSB7XG4gICAgdGFyZ2V0ID0gdm07XG4gICAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCBjcmVhdGVPbmNlSGFuZGxlciwgdm0pO1xuICAgIHRhcmdldCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gICAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdm0uJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9O1xuXG4gICAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBvbi5mbiA9IGZuO1xuICAgICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgICByZXR1cm4gdm1cbiAgICB9O1xuXG4gICAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIC8vIGFsbFxuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICByZXR1cm4gdm1cbiAgICAgIH1cbiAgICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkkMSA8IGw7IGkkMSsrKSB7XG4gICAgICAgICAgdm0uJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZtXG4gICAgICB9XG4gICAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgICAgaWYgKCFjYnMpIHtcbiAgICAgICAgcmV0dXJuIHZtXG4gICAgICB9XG4gICAgICBpZiAoIWZuKSB7XG4gICAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZtXG4gICAgICB9XG4gICAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgICB2YXIgY2I7XG4gICAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICB7XG4gICAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICAgIGlmIChjYnMpIHtcbiAgICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgICB2YXIgaW5mbyA9IFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2JzW2ldLCB2bSwgYXJncywgdm0sIGluZm8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9O1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbiAgdmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHNldEFjdGl2ZUluc3RhbmNlKHZtKSB7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAgIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICAgIH1cblxuICAgIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gICAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICAgIHZtLiRjaGlsZHJlbiA9IFtdO1xuICAgIHZtLiRyZWZzID0ge307XG5cbiAgICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gICAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gICAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHZtKTtcbiAgICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyh2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXBkYXRlc1xuICAgICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgICB9XG4gICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgICAgaWYgKHByZXZFbCkge1xuICAgICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodm0uJGVsKSB7XG4gICAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgICB9XG4gICAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICAgIH1cbiAgICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gICAgfTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICAgIH1cbiAgICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgICB9XG4gICAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgICB2bS4kb2ZmKCk7XG4gICAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICAgIGlmICh2bS4kZWwpIHtcbiAgICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgICAgfVxuICAgICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgICB2bS4kdm5vZGUucGFyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICAgIHZtLFxuICAgIGVsLFxuICAgIGh5ZHJhdGluZ1xuICApIHtcbiAgICB2bS4kZWwgPSBlbDtcbiAgICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICAgIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gICAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgICAvLyBzaW5jZSB0aGUgd2F0Y2hlcidzIGluaXRpYWwgcGF0Y2ggbWF5IGNhbGwgJGZvcmNlVXBkYXRlIChlLmcuIGluc2lkZSBjaGlsZFxuICAgIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcbiAgICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCB7XG4gICAgICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZSAoKSB7XG4gICAgICAgIGlmICh2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICAgIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gICAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICAgIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gICAgdm0sXG4gICAgcHJvcHNEYXRhLFxuICAgIGxpc3RlbmVycyxcbiAgICBwYXJlbnRWbm9kZSxcbiAgICByZW5kZXJDaGlsZHJlblxuICApIHtcbiAgICB7XG4gICAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAgIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLlxuXG4gICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGR5bmFtaWMgc2NvcGVkU2xvdHMgKGhhbmQtd3JpdHRlbiBvciBjb21waWxlZCBidXQgd2l0aFxuICAgIC8vIGR5bmFtaWMgc2xvdCBuYW1lcykuIFN0YXRpYyBzY29wZWQgc2xvdHMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZSBoYXMgdGhlXG4gICAgLy8gXCIkc3RhYmxlXCIgbWFya2VyLlxuICAgIHZhciBuZXdTY29wZWRTbG90cyA9IHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHM7XG4gICAgdmFyIG9sZFNjb3BlZFNsb3RzID0gdm0uJHNjb3BlZFNsb3RzO1xuICAgIHZhciBoYXNEeW5hbWljU2NvcGVkU2xvdCA9ICEhKFxuICAgICAgKG5ld1Njb3BlZFNsb3RzICYmICFuZXdTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgICAgKG9sZFNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAmJiAhb2xkU2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAgIChuZXdTY29wZWRTbG90cyAmJiB2bS4kc2NvcGVkU2xvdHMuJGtleSAhPT0gbmV3U2NvcGVkU2xvdHMuJGtleSlcbiAgICApO1xuXG4gICAgLy8gQW55IHN0YXRpYyBzbG90IGNoaWxkcmVuIGZyb20gdGhlIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGR1cmluZyBwYXJlbnQnc1xuICAgIC8vIHVwZGF0ZS4gRHluYW1pYyBzY29wZWQgc2xvdHMgbWF5IGFsc28gaGF2ZSBjaGFuZ2VkLiBJbiBzdWNoIGNhc2VzLCBhIGZvcmNlZFxuICAgIC8vIHVwZGF0ZSBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIGNvcnJlY3RuZXNzLlxuICAgIHZhciBuZWVkc0ZvcmNlVXBkYXRlID0gISEoXG4gICAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgICBoYXNEeW5hbWljU2NvcGVkU2xvdFxuICAgICk7XG5cbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gICAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICAgIH1cbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAgIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAgIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAgIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXG4gICAgdm0uJGF0dHJzID0gcGFyZW50Vm5vZGUuZGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdDtcbiAgICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gICAgLy8gdXBkYXRlIHByb3BzXG4gICAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgICB2YXIgcHJvcE9wdGlvbnMgPSB2bS4kb3B0aW9ucy5wcm9wczsgLy8gd3RmIGZsb3c/XG4gICAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgICB9XG4gICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcbiAgICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuXG4gICAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgICBpZiAobmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gICAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gICAgaWYgKGRpcmVjdCkge1xuICAgICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICAgIGlmIChkaXJlY3QpIHtcbiAgICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gICAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGxpZmVjeWNsZSBob29rc1xuICAgIHB1c2hUYXJnZXQoKTtcbiAgICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgICB2YXIgaW5mbyA9IGhvb2sgKyBcIiBob29rXCI7XG4gICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhoYW5kbGVyc1tpXSwgdm0sIG51bGwsIHZtLCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxuICB2YXIgcXVldWUgPSBbXTtcbiAgdmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG4gIHZhciBoYXMgPSB7fTtcbiAgdmFyIGNpcmN1bGFyID0ge307XG4gIHZhciB3YWl0aW5nID0gZmFsc2U7XG4gIHZhciBmbHVzaGluZyA9IGZhbHNlO1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gICAqL1xuICBmdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgaGFzID0ge307XG4gICAge1xuICAgICAgY2lyY3VsYXIgPSB7fTtcbiAgICB9XG4gICAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG4gIH1cblxuICAvLyBBc3luYyBlZGdlIGNhc2UgIzY1NjYgcmVxdWlyZXMgc2F2aW5nIHRoZSB0aW1lc3RhbXAgd2hlbiBldmVudCBsaXN0ZW5lcnMgYXJlXG4gIC8vIGF0dGFjaGVkLiBIb3dldmVyLCBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpIGhhcyBhIHBlcmYgb3ZlcmhlYWQgZXNwZWNpYWxseVxuICAvLyBpZiB0aGUgcGFnZSBoYXMgdGhvdXNhbmRzIG9mIGV2ZW50IGxpc3RlbmVycy4gSW5zdGVhZCwgd2UgdGFrZSBhIHRpbWVzdGFtcFxuICAvLyBldmVyeSB0aW1lIHRoZSBzY2hlZHVsZXIgZmx1c2hlcyBhbmQgdXNlIHRoYXQgZm9yIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgLy8gYXR0YWNoZWQgZHVyaW5nIHRoYXQgZmx1c2guXG4gIHZhciBjdXJyZW50Rmx1c2hUaW1lc3RhbXAgPSAwO1xuXG4gIC8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXG4gIHZhciBnZXROb3cgPSBEYXRlLm5vdztcblxuICAvLyBEZXRlcm1pbmUgd2hhdCBldmVudCB0aW1lc3RhbXAgdGhlIGJyb3dzZXIgaXMgdXNpbmcuIEFubm95aW5nbHksIHRoZVxuICAvLyB0aW1lc3RhbXAgY2FuIGVpdGhlciBiZSBoaS1yZXMgKHJlbGF0aXZlIHRvIHBhZ2UgbG9hZCkgb3IgbG93LXJlc1xuICAvLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcbiAgLy8gc2FtZSB0aW1lc3RhbXAgdHlwZSB3aGVuIHNhdmluZyB0aGUgZmx1c2ggdGltZXN0YW1wLlxuICAvLyBBbGwgSUUgdmVyc2lvbnMgdXNlIGxvdy1yZXMgZXZlbnQgdGltZXN0YW1wcywgYW5kIGhhdmUgcHJvYmxlbWF0aWMgY2xvY2tcbiAgLy8gaW1wbGVtZW50YXRpb25zICgjOTYzMilcbiAgaWYgKGluQnJvd3NlciAmJiAhaXNJRSkge1xuICAgIHZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgICBpZiAoXG4gICAgICBwZXJmb3JtYW5jZSAmJlxuICAgICAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgZ2V0Tm93KCkgPiBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKS50aW1lU3RhbXBcbiAgICApIHtcbiAgICAgIC8vIGlmIHRoZSBldmVudCB0aW1lc3RhbXAsIGFsdGhvdWdoIGV2YWx1YXRlZCBBRlRFUiB0aGUgRGF0ZS5ub3coKSwgaXNcbiAgICAgIC8vIHNtYWxsZXIgdGhhbiBpdCwgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcbiAgICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHVzZSB0aGUgaGktcmVzIHZlcnNpb24gZm9yIGV2ZW50IGxpc3RlbmVyIHRpbWVzdGFtcHMgYXNcbiAgICAgIC8vIHdlbGwuXG4gICAgICBnZXROb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gICAqL1xuICBmdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgICBjdXJyZW50Rmx1c2hUaW1lc3RhbXAgPSBnZXROb3coKTtcbiAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gICAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gICAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAgIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gICAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAgIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gICAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICAgIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAgIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAgIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICAgIGlmICh3YXRjaGVyLmJlZm9yZSkge1xuICAgICAgICB3YXRjaGVyLmJlZm9yZSgpO1xuICAgICAgfVxuICAgICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgICAgaGFzW2lkXSA9IG51bGw7XG4gICAgICB3YXRjaGVyLnJ1bigpO1xuICAgICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgICAgaWYgKGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IE1BWF9VUERBVEVfQ09VTlQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgICB3YXRjaGVyLnVzZXJcbiAgICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gICAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgICB2YXIgdXBkYXRlZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcblxuICAgIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAgIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICAgIGNhbGxBY3RpdmF0ZWRIb29rcyhhY3RpdmF0ZWRRdWV1ZSk7XG4gICAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gICAgLy8gZGV2dG9vbCBob29rXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICAgIHZhciBpID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgICB2YXIgdm0gPSB3YXRjaGVyLnZtO1xuICAgICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICAgKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gICAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAgICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gICAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gICAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgICAgfVxuICAgICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgICAgd2FpdGluZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFjb25maWcuYXN5bmMpIHtcbiAgICAgICAgICBmbHVzaFNjaGVkdWxlclF1ZXVlKCk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cblxuXG4gIHZhciB1aWQkMiA9IDA7XG5cbiAgLyoqXG4gICAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICAgKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICAgKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAgICovXG4gIHZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gICAgdm0sXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zLFxuICAgIGlzUmVuZGVyV2F0Y2hlclxuICApIHtcbiAgICB0aGlzLnZtID0gdm07XG4gICAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xuICAgIH1cbiAgICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgICAvLyBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICAgICAgdGhpcy5iZWZvcmUgPSBvcHRpb25zLmJlZm9yZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuY2IgPSBjYjtcbiAgICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICAgIHRoaXMuZGVwcyA9IFtdO1xuICAgIHRoaXMubmV3RGVwcyA9IFtdO1xuICAgIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gICAgdGhpcy5leHByZXNzaW9uID0gZXhwT3JGbi50b1N0cmluZygpO1xuICAgIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICAgIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiB0aGlzLmdldCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBXYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICAgIHB1c2hUYXJnZXQodGhpcyk7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciB2bSA9IHRoaXMudm07XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlXG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgICAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gICAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHBvcFRhcmdldCgpO1xuICAgICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAgICovXG4gIFdhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG4gICAgdmFyIGlkID0gZGVwLmlkO1xuICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gICAqL1xuICBXYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIGRlcCA9IHRoaXMuZGVwc1tpXTtcbiAgICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICAgIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gICAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gICAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgICB0bXAgPSB0aGlzLmRlcHM7XG4gICAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICAgIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbiAgfTtcblxuICAvKipcbiAgICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gICAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gICAqL1xuICBXYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHRoaXMubGF6eSkge1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICAgIHRoaXMucnVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICAgKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICAgKi9cbiAgV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICAgIHRoaXMuZGVlcFxuICAgICAgKSB7XG4gICAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAgICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICAgKi9cbiAgV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gICAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAgICovXG4gIFdhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuZGVwc1tpXS5kZXBlbmQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICAgKi9cbiAgV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgICB9XG4gICAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvKiAgKi9cblxuICB2YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogbm9vcCxcbiAgICBzZXQ6IG5vb3BcbiAgfTtcblxuICBmdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgICB9O1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICAgIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gICAgaWYgKG9wdHMuZGF0YSkge1xuICAgICAgaW5pdERhdGEodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gICAgfVxuICAgIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAgIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gICAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gICAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gICAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gICAgaWYgKCFpc1Jvb3QpIHtcbiAgICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgfVxuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAge1xuICAgICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShoeXBoZW5hdGVkS2V5KSB8fFxuICAgICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIChcIlxcXCJcIiArIGh5cGhlbmF0ZWRLZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaXNSb290ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcbiAgICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gICAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICAgIDogZGF0YSB8fCB7fTtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgIGRhdGEgPSB7fTtcbiAgICAgIHdhcm4oXG4gICAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gICAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHtcbiAgICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBvYnNlcnZlIGRhdGFcbiAgICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICAgIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgICBwdXNoVGFyZ2V0KCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICAgIHJldHVybiB7fVxuICAgIH0gZmluYWxseSB7XG4gICAgICBwb3BUYXJnZXQoKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG4gIGZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXG4gICAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcblxuICAgIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgICAgaWYgKGdldHRlciA9PSBudWxsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1NTUikge1xuICAgICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgICAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIoXG4gICAgICAgICAgdm0sXG4gICAgICAgICAgZ2V0dGVyIHx8IG5vb3AsXG4gICAgICAgICAgbm9vcCxcbiAgICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcbiAgICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkIChcbiAgICB0YXJnZXQsXG4gICAga2V5LFxuICAgIHVzZXJEZWZcbiAgKSB7XG4gICAgdmFyIHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gICAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmKTtcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmLmdldClcbiAgICAgICAgOiBub29wO1xuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0IHx8IG5vb3A7XG4gICAgfVxuICAgIGlmIChzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUdldHRlckludm9rZXIoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgdGhpcylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIHR5cGUgXFxcIlwiICsgKHR5cGVvZiBtZXRob2RzW2tleV0pICsgXCJcXFwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGtleSBpbiB2bSkgJiYgaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIiArXG4gICAgICAgICAgICBcIkF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICAgIHZtLFxuICAgIGV4cE9yRm4sXG4gICAgaGFuZGxlcixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgICB9XG4gICAgcmV0dXJuIHZtLiR3YXRjaChleHBPckZuLCBoYW5kbGVyLCBvcHRpb25zKVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gICAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gICAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gICAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICAgIHZhciBkYXRhRGVmID0ge307XG4gICAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gICAgdmFyIHByb3BzRGVmID0ge307XG4gICAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgICB7XG4gICAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgICB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gICAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gICAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgICBleHBPckZuLFxuICAgICAgY2IsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGVycm9yLCB2bSwgKFwiY2FsbGJhY2sgZm9yIGltbWVkaWF0ZSB3YXRjaGVyIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIHVpZCQzID0gMDtcblxuICBmdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIC8vIGEgdWlkXG4gICAgICB2bS5fdWlkID0gdWlkJDMrKztcblxuICAgICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIH1cblxuICAgICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIHtcbiAgICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICAgIH1cbiAgICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICAgIHZtLl9zZWxmID0gdm07XG4gICAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICAgIGluaXRFdmVudHModm0pO1xuICAgICAgaW5pdFJlbmRlcih2bSk7XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gICAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gICAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgICB2YXIgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICAgIG9wdHMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG5cbiAgICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBvcHRzLnByb3BzRGF0YSA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGE7XG4gICAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycztcbiAgICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcbiAgICBvcHRzLl9jb21wb25lbnRUYWcgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnO1xuXG4gICAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gICAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICAgIHZhciBtb2RpZmllZDtcbiAgICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICAgIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gICAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgICAgbW9kaWZpZWRba2V5XSA9IGxhdGVzdFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbW9kaWZpZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIFZ1ZSAob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBWdWUpXG4gICAgKSB7XG4gICAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gICAgfVxuICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gIH1cblxuICBpbml0TWl4aW4oVnVlKTtcbiAgc3RhdGVNaXhpbihWdWUpO1xuICBldmVudHNNaXhpbihWdWUpO1xuICBsaWZlY3ljbGVNaXhpbihWdWUpO1xuICByZW5kZXJNaXhpbihWdWUpO1xuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICAgIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG5cbiAgICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH07XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gICAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH07XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgICAvKipcbiAgICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAgICovXG4gICAgVnVlLmNpZCA9IDA7XG4gICAgdmFyIGNpZCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgICAqL1xuICAgIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgICBleHRlbmRPcHRpb25zXG4gICAgICApO1xuICAgICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgICB9XG4gICAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgICAgfSk7XG4gICAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgICAgfVxuXG4gICAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgICAgcmV0dXJuIFN1YlxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICAgIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICAgIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAgICovXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgICBpZCxcbiAgICAgICAgZGVmaW5pdGlvblxuICAgICAgKSB7XG4gICAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKiAgKi9cblxuXG5cbiAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICAgIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gICAgdmFyIGNhY2hlID0ga2VlcEFsaXZlSW5zdGFuY2UuY2FjaGU7XG4gICAgdmFyIGtleXMgPSBrZWVwQWxpdmVJbnN0YW5jZS5rZXlzO1xuICAgIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gICAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5IChcbiAgICBjYWNoZSxcbiAgICBrZXksXG4gICAga2V5cyxcbiAgICBjdXJyZW50XG4gICkge1xuICAgIHZhciBjYWNoZWQkJDEgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgICAgY2FjaGVkJCQxLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgfVxuICAgIGNhY2hlW2tleV0gPSBudWxsO1xuICAgIHJlbW92ZShrZXlzLCBrZXkpO1xuICB9XG5cbiAgdmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG4gIHZhciBLZWVwQWxpdmUgPSB7XG4gICAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICAgIGFic3RyYWN0OiB0cnVlLFxuXG4gICAgcHJvcHM6IHtcbiAgICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICAgIH0sXG5cbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5rZXlzID0gW107XG4gICAgfSxcblxuICAgIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzLmNhY2hlLCBrZXksIHRoaXMua2V5cyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJHdhdGNoKCdpbmNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuJHdhdGNoKCdleGNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICAgIHZhciBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XG4gICAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICAgIHZhciBpbmNsdWRlID0gcmVmLmluY2x1ZGU7XG4gICAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBub3QgaW5jbHVkZWRcbiAgICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICAgIHZhciBjYWNoZSA9IHJlZiQxLmNhY2hlO1xuICAgICAgICB2YXIga2V5cyA9IHJlZiQxLmtleXM7XG4gICAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XG4gICAgICAgICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICAgIGlmICh0aGlzLm1heCAmJiBrZXlzLmxlbmd0aCA+IHBhcnNlSW50KHRoaXMubWF4KSkge1xuICAgICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlIHx8IChzbG90ICYmIHNsb3RbMF0pXG4gICAgfVxuICB9O1xuXG4gIHZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAgIC8vIGNvbmZpZ1xuICAgIHZhciBjb25maWdEZWYgPSB7fTtcbiAgICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICAgIHtcbiAgICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICAgIFZ1ZS51dGlsID0ge1xuICAgICAgd2Fybjogd2FybixcbiAgICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgICB9O1xuXG4gICAgVnVlLnNldCA9IHNldDtcbiAgICBWdWUuZGVsZXRlID0gZGVsO1xuICAgIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gICAgLy8gMi42IGV4cGxpY2l0IG9ic2VydmFibGUgQVBJXG4gICAgVnVlLm9ic2VydmFibGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICBvYnNlcnZlKG9iaik7XG4gICAgICByZXR1cm4gb2JqXG4gICAgfTtcblxuICAgIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfSk7XG5cbiAgICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gICAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gICAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gICAgaW5pdFVzZShWdWUpO1xuICAgIGluaXRNaXhpbiQxKFZ1ZSk7XG4gICAgaW5pdEV4dGVuZChWdWUpO1xuICAgIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xuICB9XG5cbiAgaW5pdEdsb2JhbEFQSShWdWUpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICAgIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGV4cG9zZSBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCBmb3Igc3NyIHJ1bnRpbWUgaGVscGVyIGluc3RhbGxhdGlvblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnRnVuY3Rpb25hbFJlbmRlckNvbnRleHQnLCB7XG4gICAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XG4gIH0pO1xuXG4gIFZ1ZS52ZXJzaW9uID0gJzIuNi4xMic7XG5cbiAgLyogICovXG5cbiAgLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4gIC8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxuICB2YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4gIC8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbiAgdmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xuICB2YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gICAgKVxuICB9O1xuXG4gIHZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbiAgdmFyIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSA9IG1ha2VNYXAoJ2V2ZW50cyxjYXJldCx0eXBpbmcscGxhaW50ZXh0LW9ubHknKTtcblxuICB2YXIgY29udmVydEVudW1lcmF0ZWRWYWx1ZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnXG4gICAgICA/ICdmYWxzZSdcbiAgICAgIC8vIGFsbG93IGFyYml0cmFyeSBzdHJpbmcgdmFsdWUgZm9yIGNvbnRlbnRlZGl0YWJsZVxuICAgICAgOiBrZXkgPT09ICdjb250ZW50ZWRpdGFibGUnICYmIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6ICd0cnVlJ1xuICB9O1xuXG4gIHZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAgICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAgICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAgICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAgICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuICApO1xuXG4gIHZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG4gIHZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG4gIH07XG5cbiAgdmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG4gIH07XG5cbiAgdmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2VcbiAgfTtcblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgICA6IHBhcmVudC5jbGFzc1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgICBzdGF0aWNDbGFzcyxcbiAgICBkeW5hbWljQ2xhc3NcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICAgIH1cbiAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgdmFyIHN0cmluZ2lmaWVkO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QgKHZhbHVlKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlW2tleV0pIHtcbiAgICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICAgIHJlcyArPSBrZXk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBuYW1lc3BhY2VNYXAgPSB7XG4gICAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xuICB9O1xuXG4gIHZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAgICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAgICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAgICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAgICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAgICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAgICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4gICk7XG5cbiAgLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4gIC8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG4gIHZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICAgIHRydWVcbiAgKTtcblxuICB2YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG4gIHZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICAgIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgICBpZiAoaXNTVkcodGFnKSkge1xuICAgICAgcmV0dXJuICdzdmcnXG4gICAgfVxuICAgIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAgIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICAgIHJldHVybiAnbWF0aCdcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gICAgfVxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICAgKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xuXG4gIC8qICAqL1xuXG4gIC8qKlxuICAgKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAgICovXG4gIGZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdGVkXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbFxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICAgIHJldHVybiBlbG1cbiAgICB9XG4gICAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsbVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICAgIHJldHVybiBub2RlLnBhcmVudE5vZGVcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbiAgfVxuXG4gIGZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50YWdOYW1lXG4gIH1cblxuICBmdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICAgIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U3R5bGVTY29wZSAobm9kZSwgc2NvcGVJZCkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcbiAgfVxuXG4gIHZhciBub2RlT3BzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcbiAgICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcbiAgICBjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG4gICAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgICByZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG4gICAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICAgIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gICAgbmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuICAgIHNldFN0eWxlU2NvcGU6IHNldFN0eWxlU2NvcGVcbiAgfSk7XG5cbiAgLyogICovXG5cbiAgdmFyIHJlZiA9IHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICAgIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgICBpZiAoIWlzRGVmKGtleSkpIHsgcmV0dXJuIH1cblxuICAgIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICAgIGlmIChpc1JlbW92YWwpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAgICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gICAqXG4gICAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICAgKlxuICAgKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gICAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICAgKi9cblxuICB2YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG4gIHZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG4gIGZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICAgIHJldHVybiAoXG4gICAgICBhLmtleSA9PT0gYi5rZXkgJiYgKFxuICAgICAgICAoXG4gICAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICAgKSB8fCAoXG4gICAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICAgIGlzVW5kZWYoYi5hc3luY0ZhY3RvcnkuZXJyb3IpXG4gICAgICAgIClcbiAgICAgIClcbiAgICApXG4gIH1cblxuICBmdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gICAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgICB2YXIgaTtcbiAgICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICAgIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gICAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQilcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICAgIHZhciBpLCBrZXk7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcFxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBjYnMgPSB7fTtcblxuICAgIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICAgIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgICBpZiAoLS1yZW1vdmUkJDEubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgICByZXR1cm4gcmVtb3ZlJCQxXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICFpblZQcmUgJiZcbiAgICAgICAgIXZub2RlLm5zICYmXG4gICAgICAgICEoXG4gICAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzUmVnRXhwKGlnbm9yZSlcbiAgICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgICB9KVxuICAgICAgICApICYmXG4gICAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICAgIClcbiAgICB9XG5cbiAgICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRWxtIChcbiAgICAgIHZub2RlLFxuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgcGFyZW50RWxtLFxuICAgICAgcmVmRWxtLFxuICAgICAgbmVzdGVkLFxuICAgICAgb3duZXJBcnJheSxcbiAgICAgIGluZGV4XG4gICAgKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgICAvLyBUaGlzIHZub2RlIHdhcyB1c2VkIGluIGEgcHJldmlvdXMgcmVuZGVyIVxuICAgICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgICAgLy8gcG90ZW50aWFsIHBhdGNoIGVycm9ycyBkb3duIHRoZSByb2FkIHdoZW4gaXQncyB1c2VkIGFzIGFuIGluc2VydGlvblxuICAgICAgICAvLyByZWZlcmVuY2Ugbm9kZS4gSW5zdGVhZCwgd2UgY2xvbmUgdGhlIG5vZGUgb24tZGVtYW5kIGJlZm9yZSBjcmVhdGluZ1xuICAgICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgICAgfVxuXG4gICAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGNyZWF0aW5nRWxtSW5WUHJlKSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICAgIHZhciBpO1xuICAgICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xuICAgICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgICBpZiAobm9kZU9wcy5wYXJlbnROb2RlKHJlZiQkMSkgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUsIGNoaWxkcmVuLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZShTdHJpbmcodm5vZGUudGV4dCkpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgICB9XG4gICAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAgIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gICAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICAgIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgICAgdmFyIGk7XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmZuU2NvcGVJZCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgICApIHtcbiAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIGZhbHNlLCB2bm9kZXMsIHN0YXJ0SWR4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICAgIHZhciBpLCBqO1xuICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBybSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCB2bm9kZVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgICB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cbiAgICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAgIGlmIChzYW1lVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICAgIHBhdGNoVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgdm5vZGVUb01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzIChjaGlsZHJlbikge1xuICAgICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2bm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICAgIGlmIChzZWVuS2V5c1trZXldKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJ1wiICsga2V5ICsgXCInLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuXCIpLFxuICAgICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQgKG5vZGUsIG9sZENoLCBzdGFydCwgZW5kKSB7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSB7IHJldHVybiBpIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXRjaFZub2RlIChcbiAgICAgIG9sZFZub2RlLFxuICAgICAgdm5vZGUsXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICBvd25lckFycmF5LFxuICAgICAgaW5kZXgsXG4gICAgICByZW1vdmVPbmx5XG4gICAgKSB7XG4gICAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgICAvLyBjbG9uZSByZXVzZWQgdm5vZGVcbiAgICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICAgKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICB9XG4gICAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAgIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gICAgLy8gZGVlcCB1cGRhdGVzICgjNzA2MykuXG4gICAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAgIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gICAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICAgIHZub2RlLmVsbSA9IGVsbTtcblxuICAgICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgICB7XG4gICAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEpICYmIGlzRGVmKGkgPSBpLmRvbVByb3BzKSAmJiBpc0RlZihpID0gaS5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZXJ2ZXIgaW5uZXJIVE1MOiAnLCBpKTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBpdGVyYXRlIGFuZCBjb21wYXJlIGNoaWxkcmVuIGxpc3RzXG4gICAgICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgdmFyIGZ1bGxJbnZva2UgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgICAgZnVsbEludm9rZSA9IHRydWU7XG4gICAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUsIGluVlByZSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgICAgcmV0dXJuIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHwgKFxuICAgICAgICAgICFpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBpblZQcmUpICYmXG4gICAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSkge1xuICAgICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVtb3ZlT25seSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgICAgdmFyIHBhcmVudEVsbSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuXG4gICAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSxcbiAgICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAjNjUxM1xuICAgICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXG4gICAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICAgIHZhciBpbnNlcnQgPSBhbmNlc3Rvci5kYXRhLmhvb2suaW5zZXJ0O1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDE7IGkkMiA8IGluc2VydC5mbnMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2kkMl0oKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGRlc3Ryb3kgb2xkIG5vZGVcbiAgICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtKSkge1xuICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICAgIHJldHVybiB2bm9kZS5lbG1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgZGlyZWN0aXZlcyA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gICAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gICAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gICAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gICAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gICAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgICBpZiAoIW9sZERpcikge1xuICAgICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgICAgZGlyLm9sZEFyZyA9IG9sZERpci5hcmc7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghaXNDcmVhdGUpIHtcbiAgICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gICAgZGlycyxcbiAgICB2bVxuICApIHtcbiAgICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoIWRpcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgICB2YXIgaSwgZGlyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkaXIgPSBkaXJzW2ldO1xuICAgICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgICB9XG4gICAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICAgIH1cbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICAgIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZU1vZHVsZXMgPSBbXG4gICAgcmVmLFxuICAgIGRpcmVjdGl2ZXNcbiAgXTtcblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBrZXksIGN1ciwgb2xkO1xuICAgIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gICAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAgIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICAgIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgICB9XG5cbiAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICAgIHZhbHVlID0ga2V5ID09PSAnYWxsb3dmdWxsc2NyZWVuJyAmJiBlbC50YWdOYW1lID09PSAnRU1CRUQnXG4gICAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgICA6IGtleTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBjb252ZXJ0RW51bWVyYXRlZFZhbHVlKGtleSwgdmFsdWUpKTtcbiAgICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmFzZVNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cbiAgICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoXG4gICAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcbiAgICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmIHZhbHVlICE9PSAnJyAmJiAhZWwuX19pZXBoXG4gICAgICApIHtcbiAgICAgICAgdmFyIGJsb2NrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICAgIH1cbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXR0cnMgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG4gIH07XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICAgIGlmIChcbiAgICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgICApXG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gICAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSBjbGFzc1xuICAgIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgICB9XG4gIH1cblxuICB2YXIga2xhc3MgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbiAgZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcbiAgICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICAgIHZhciBpblJlZ2V4ID0gZmFsc2U7XG4gICAgdmFyIGN1cmx5ID0gMDtcbiAgICB2YXIgc3F1YXJlID0gMDtcbiAgICB2YXIgcGFyZW4gPSAwO1xuICAgIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICAgIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgICAgcHJldiA9IGM7XG4gICAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxuICAgICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICAgKSB7XG4gICAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgICBwdXNoRmlsdGVyKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgfVxuXG4gICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHByZXNzaW9uXG4gIH1cblxuICBmdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICAgIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cblxuXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gIGZ1bmN0aW9uIGJhc2VXYXJuIChtc2csIHJhbmdlKSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gICAgbW9kdWxlcyxcbiAgICBrZXlcbiAgKSB7XG4gICAgcmV0dXJuIG1vZHVsZXNcbiAgICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgICAgOiBbXVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSwgZHluYW1pYykge1xuICAgIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgICB2YXIgYXR0cnMgPSBkeW5hbWljXG4gICAgICA/IChlbC5keW5hbWljQXR0cnMgfHwgKGVsLmR5bmFtaWNBdHRycyA9IFtdKSlcbiAgICAgIDogKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSk7XG4gICAgYXR0cnMucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpKTtcbiAgICBlbC5wbGFpbiA9IGZhbHNlO1xuICB9XG5cbiAgLy8gYWRkIGEgcmF3IGF0dHIgKHVzZSB0aGlzIGluIHByZVRyYW5zZm9ybXMpXG4gIGZ1bmN0aW9uIGFkZFJhd0F0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UpIHtcbiAgICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICAgIGVsLmF0dHJzTGlzdC5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9LCByYW5nZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgICBlbCxcbiAgICBuYW1lLFxuICAgIHJhd05hbWUsXG4gICAgdmFsdWUsXG4gICAgYXJnLFxuICAgIGlzRHluYW1pY0FyZyxcbiAgICBtb2RpZmllcnMsXG4gICAgcmFuZ2VcbiAgKSB7XG4gICAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICByYXdOYW1lOiByYXdOYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgYXJnOiBhcmcsXG4gICAgICBpc0R5bmFtaWNBcmc6IGlzRHluYW1pY0FyZyxcbiAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzXG4gICAgfSwgcmFuZ2UpKTtcbiAgICBlbC5wbGFpbiA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyTWFya2VyIChzeW1ib2wsIG5hbWUsIGR5bmFtaWMpIHtcbiAgICByZXR1cm4gZHluYW1pY1xuICAgICAgPyAoXCJfcChcIiArIG5hbWUgKyBcIixcXFwiXCIgKyBzeW1ib2wgKyBcIlxcXCIpXCIpXG4gICAgICA6IHN5bWJvbCArIG5hbWUgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICAgIGVsLFxuICAgIG5hbWUsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzLFxuICAgIGltcG9ydGFudCxcbiAgICB3YXJuLFxuICAgIHJhbmdlLFxuICAgIGR5bmFtaWNcbiAgKSB7XG4gICAgbW9kaWZpZXJzID0gbW9kaWZpZXJzIHx8IGVtcHR5T2JqZWN0O1xuICAgIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIHdhcm4gJiZcbiAgICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgICAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LicsXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxuICAgIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gICAgLy8gdGhlIG9ubHkgdGFyZ2V0IGVudnMgdGhhdCBoYXZlIHJpZ2h0L21pZGRsZSBjbGlja3MuXG4gICAgaWYgKG1vZGlmaWVycy5yaWdodCkge1xuICAgICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgbmFtZSA9IFwiKFwiICsgbmFtZSArIFwiKT09PSdjbGljayc/J2NvbnRleHRtZW51JzooXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICAgIGRlbGV0ZSBtb2RpZmllcnMucmlnaHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgICBpZiAoZHluYW1pYykge1xuICAgICAgICBuYW1lID0gXCIoXCIgKyBuYW1lICsgXCIpPT09J2NsaWNrJz8nbW91c2V1cCc6KFwiICsgbmFtZSArIFwiKVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICAgIG5hbWUgPSAnbW91c2V1cCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICAgIGlmIChtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignIScsIG5hbWUsIGR5bmFtaWMpO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLm9uY2UpIHtcbiAgICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJ34nLCBuYW1lLCBkeW5hbWljKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCcmJywgbmFtZSwgZHluYW1pYyk7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50cztcbiAgICBpZiAobW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gICAgfVxuXG4gICAgdmFyIG5ld0hhbmRsZXIgPSByYW5nZVNldEl0ZW0oeyB2YWx1ZTogdmFsdWUudHJpbSgpLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKTtcbiAgICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xuICAgICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gICAgfVxuXG4gICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJhd0JpbmRpbmdBdHRyIChcbiAgICBlbCxcbiAgICBuYW1lXG4gICkge1xuICAgIHJldHVybiBlbC5yYXdBdHRyc01hcFsnOicgKyBuYW1lXSB8fFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcbiAgICAgIGVsLnJhd0F0dHJzTWFwW25hbWVdXG4gIH1cblxuICBmdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gICAgZWwsXG4gICAgbmFtZSxcbiAgICBnZXRTdGF0aWNcbiAgKSB7XG4gICAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gICAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbiAgLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbiAgLy8gQnkgZGVmYXVsdCBpdCBkb2VzIE5PVCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwIChhdHRyc01hcCkgYmVjYXVzZSB0aGUgbWFwIGlzXG4gIC8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cbiAgZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoXG4gICAgZWwsXG4gICAgbmFtZSxcbiAgICByZW1vdmVGcm9tTWFwXG4gICkge1xuICAgIHZhciB2YWw7XG4gICAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgICBkZWxldGUgZWwuYXR0cnNNYXBbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4IChcbiAgICBlbCxcbiAgICBuYW1lXG4gICkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhdHRyID0gbGlzdFtpXTtcbiAgICAgIGlmIChuYW1lLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIGF0dHJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByYW5nZVNldEl0ZW0gKFxuICAgIGl0ZW0sXG4gICAgcmFuZ2VcbiAgKSB7XG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBpdGVtLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgICAgaXRlbS5lbmQgPSByYW5nZS5lbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVtXG4gIH1cblxuICAvKiAgKi9cblxuICAvKipcbiAgICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICAgKi9cbiAgZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuICApIHtcbiAgICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICAgIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICAgIHZhciB0cmltID0gcmVmLnRyaW07XG5cbiAgICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICAgIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICAgIGlmICh0cmltKSB7XG4gICAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgICBcIj8gXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuICAgICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gICAgfVxuICAgIGlmIChudW1iZXIpIHtcbiAgICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgICB9XG4gICAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICAgIGVsLm1vZGVsID0ge1xuICAgICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgICAgZXhwcmVzc2lvbjogSlNPTi5zdHJpbmdpZnkodmFsdWUpLFxuICAgICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gICAqL1xuICBmdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gICAgdmFsdWUsXG4gICAgYXNzaWdubWVudFxuICApIHtcbiAgICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gICAgaWYgKHJlcy5rZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCIkc2V0KFwiICsgKHJlcy5leHApICsgXCIsIFwiICsgKHJlcy5rZXkpICsgXCIsIFwiICsgYXNzaWdubWVudCArIFwiKVwiKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICAgKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAgICpcbiAgICogUG9zc2libGUgY2FzZXM6XG4gICAqXG4gICAqIC0gdGVzdFxuICAgKiAtIHRlc3Rba2V5XVxuICAgKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAgICogLSB0ZXN0W1wiYVwiXVtrZXldXG4gICAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICAgKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAgICpcbiAgICovXG5cbiAgdmFyIGxlbiwgc3RyLCBjaHIsIGluZGV4JDEsIGV4cHJlc3Npb25Qb3MsIGV4cHJlc3Npb25FbmRQb3M7XG5cblxuXG4gIGZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICAgIC8vIEZpeCBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL3B1bGwvNzczMFxuICAgIC8vIGFsbG93IHYtbW9kZWw9XCJvYmoudmFsIFwiICh0cmFpbGluZyB3aGl0ZXNwYWNlKVxuICAgIHZhbCA9IHZhbC50cmltKCk7XG4gICAgbGVuID0gdmFsLmxlbmd0aDtcblxuICAgIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICAgIGluZGV4JDEgPSB2YWwubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgIGlmIChpbmRleCQxID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBleHA6IHZhbC5zbGljZSgwLCBpbmRleCQxKSxcbiAgICAgICAgICBrZXk6ICdcIicgKyB2YWwuc2xpY2UoaW5kZXgkMSArIDEpICsgJ1wiJ1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGV4cDogdmFsLFxuICAgICAgICAgIGtleTogbnVsbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RyID0gdmFsO1xuICAgIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgICB3aGlsZSAoIWVvZigpKSB7XG4gICAgICBjaHIgPSBuZXh0KCk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBleHA6IHZhbC5zbGljZSgwLCBleHByZXNzaW9uUG9zKSxcbiAgICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQgKCkge1xuICAgIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG4gIH1cblxuICBmdW5jdGlvbiBlb2YgKCkge1xuICAgIHJldHVybiBpbmRleCQxID49IGxlblxuICB9XG5cbiAgZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gICAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4MjdcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gICAgdmFyIGluQnJhY2tldCA9IDE7XG4gICAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gICAgd2hpbGUgKCFlb2YoKSkge1xuICAgICAgY2hyID0gbmV4dCgpO1xuICAgICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gICAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICAgIHdoaWxlICghZW9mKCkpIHtcbiAgICAgIGNociA9IG5leHQoKTtcbiAgICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIHdhcm4kMTtcblxuICAvLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4gIC8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG4gIHZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xuICB2YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuICBmdW5jdGlvbiBtb2RlbCAoXG4gICAgZWwsXG4gICAgZGlyLFxuICAgIF93YXJuXG4gICkge1xuICAgIHdhcm4kMSA9IF93YXJuO1xuICAgIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgICB2YXIgdGFnID0gZWwudGFnO1xuICAgIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAgIHtcbiAgICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIixcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gXCIgK1xuICAgICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuICApIHtcbiAgICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gICAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gICAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gICAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gICAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgICApXG4gICAgKTtcbiAgICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJyxcbiAgICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgICBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5jb25jYXQoWyQkdl0pJykpICsgXCIpfVwiICtcbiAgICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKSkgKyBcIil9XCIgK1xuICAgICAgXCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxuICAgICAgbnVsbCwgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbiAgKSB7XG4gICAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICAgIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICAgIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICAgIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbiAgKSB7XG4gICAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICAgIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gICAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gICAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICAgIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4gICkge1xuICAgIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAgIC8vIHdhcm4gaWYgdi1iaW5kOnZhbHVlIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWxcbiAgICAvLyBleGNlcHQgZm9yIGlucHV0cyB3aXRoIHYtYmluZDp0eXBlXG4gICAge1xuICAgICAgdmFyIHZhbHVlJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gfHwgZWwuYXR0cnNNYXBbJzp2YWx1ZSddO1xuICAgICAgdmFyIHR5cGVCaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgICBpZiAodmFsdWUkMSAmJiAhdHlwZUJpbmRpbmcpIHtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gPyAndi1iaW5kOnZhbHVlJyA6ICc6dmFsdWUnO1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYmluZGluZyArIFwiPVxcXCJcIiArIHZhbHVlJDEgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggdi1tb2RlbCBvbiB0aGUgc2FtZSBlbGVtZW50IFwiICtcbiAgICAgICAgICAnYmVjYXVzZSB0aGUgbGF0dGVyIGFscmVhZHkgZXhwYW5kcyB0byBhIHZhbHVlIGJpbmRpbmcgaW50ZXJuYWxseScsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbYmluZGluZ11cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICAgIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gICAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gICAgdmFyIHRyaW0gPSByZWYudHJpbTtcbiAgICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICAgIHZhciBldmVudCA9IGxhenlcbiAgICAgID8gJ2NoYW5nZSdcbiAgICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICAgIDogJ2lucHV0JztcblxuICAgIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gICAgaWYgKHRyaW0pIHtcbiAgICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgICB9XG4gICAgaWYgKG51bWJlcikge1xuICAgICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICAgIH1cblxuICAgIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gICAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuICAgIH1cblxuICAgIGFkZFByb3AoZWwsICd2YWx1ZScsIChcIihcIiArIHZhbHVlICsgXCIpXCIpKTtcbiAgICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gICAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbiAgLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuICAvLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4gIC8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgICAgdmFyIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICAgIH1cbiAgICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAgIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gICAgfVxuICB9XG5cbiAgdmFyIHRhcmdldCQxO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyJDEgKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAjOTQ0NjogRmlyZWZveCA8PSA1MyAoaW4gcGFydGljdWxhciwgRVNSIDUyKSBoYXMgaW5jb3JyZWN0IEV2ZW50LnRpbWVTdGFtcFxuICAvLyBpbXBsZW1lbnRhdGlvbiBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvXG4gIC8vIHNhZmUgdG8gZXhjbHVkZS5cbiAgdmFyIHVzZU1pY3JvdGFza0ZpeCA9IGlzVXNpbmdNaWNyb1Rhc2sgJiYgIShpc0ZGICYmIE51bWJlcihpc0ZGWzFdKSA8PSA1Myk7XG5cbiAgZnVuY3Rpb24gYWRkJDEgKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlcixcbiAgICBjYXB0dXJlLFxuICAgIHBhc3NpdmVcbiAgKSB7XG4gICAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxuICAgIC8vIGF0dGFjaGVkIHRvIG91dGVyIGVsZW1lbnQgZHVyaW5nIHBhdGNoLCBhbmQgdHJpZ2dlcmVkIGFnYWluLiBUaGlzXG4gICAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXG4gICAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxuICAgIC8vIGFuZCB0aGUgaGFuZGxlciB3b3VsZCBvbmx5IGZpcmUgaWYgdGhlIGV2ZW50IHBhc3NlZCB0byBpdCB3YXMgZmlyZWRcbiAgICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXG4gICAgaWYgKHVzZU1pY3JvdGFza0ZpeCkge1xuICAgICAgdmFyIGF0dGFjaGVkVGltZXN0YW1wID0gY3VycmVudEZsdXNoVGltZXN0YW1wO1xuICAgICAgdmFyIG9yaWdpbmFsID0gaGFuZGxlcjtcbiAgICAgIGhhbmRsZXIgPSBvcmlnaW5hbC5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBubyBidWJibGluZywgc2hvdWxkIGFsd2F5cyBmaXJlLlxuICAgICAgICAgIC8vIHRoaXMgaXMganVzdCBhIHNhZmV0eSBuZXQgaW4gY2FzZSBldmVudC50aW1lU3RhbXAgaXMgdW5yZWxpYWJsZSBpblxuICAgICAgICAgIC8vIGNlcnRhaW4gd2VpcmQgZW52aXJvbm1lbnRzLi4uXG4gICAgICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCB8fFxuICAgICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxuICAgICAgICAgIGUudGltZVN0YW1wID49IGF0dGFjaGVkVGltZXN0YW1wIHx8XG4gICAgICAgICAgLy8gYmFpbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgaGF2ZSBidWdneSBldmVudC50aW1lU3RhbXAgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAgLy8gIzk0NjIgaU9TIDkgYnVnOiBldmVudC50aW1lU3RhbXAgaXMgMCBhZnRlciBoaXN0b3J5LnB1c2hTdGF0ZVxuICAgICAgICAgIC8vICM5NjgxIFF0V2ViRW5naW5lIGV2ZW50LnRpbWVTdGFtcCBpcyBuZWdhdGl2ZSB2YWx1ZVxuICAgICAgICAgIGUudGltZVN0YW1wIDw9IDAgfHxcbiAgICAgICAgICAvLyAjOTQ0OCBiYWlsIGlmIGV2ZW50IGlzIGZpcmVkIGluIGFub3RoZXIgZG9jdW1lbnQgaW4gYSBtdWx0aS1wYWdlXG4gICAgICAgICAgLy8gZWxlY3Ryb24vbncuanMgYXBwLCBzaW5jZSBldmVudC50aW1lU3RhbXAgd2lsbCBiZSB1c2luZyBhIGRpZmZlcmVudFxuICAgICAgICAgIC8vIHN0YXJ0aW5nIHJlZmVyZW5jZVxuICAgICAgICAgIGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50XG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBuYW1lLFxuICAgICAgaGFuZGxlcixcbiAgICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICAgIDogY2FwdHVyZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUkMiAoXG4gICAgbmFtZSxcbiAgICBoYW5kbGVyLFxuICAgIGNhcHR1cmUsXG4gICAgX3RhcmdldFxuICApIHtcbiAgICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIG5hbWUsXG4gICAgICBoYW5kbGVyLl93cmFwcGVyIHx8IGhhbmRsZXIsXG4gICAgICBjYXB0dXJlXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gICAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgICBub3JtYWxpemVFdmVudHMob24pO1xuICAgIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgY3JlYXRlT25jZUhhbmRsZXIkMSwgdm5vZGUuY29udGV4dCk7XG4gICAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgZXZlbnRzID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICAgIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIHN2Z0NvbnRhaW5lcjtcblxuICBmdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBrZXksIGN1cjtcbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICAgIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gICAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gICAgfVxuXG4gICAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcbiAgICAgICAgZWxtW2tleV0gPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcbiAgICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgICAgaWYgKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGtleSA9PT0gJ3ZhbHVlJyAmJiBlbG0udGFnTmFtZSAhPT0gJ1BST0dSRVNTJykge1xuICAgICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdpbm5lckhUTUwnICYmIGlzU1ZHKGVsbS50YWdOYW1lKSAmJiBpc1VuZGVmKGVsbS5pbm5lckhUTUwpKSB7XG4gICAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lckhUTUwgZm9yIFNWRyBlbGVtZW50c1xuICAgICAgICBzdmdDb250YWluZXIgPSBzdmdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHN2Z0NvbnRhaW5lci5pbm5lckhUTUwgPSBcIjxzdmc+XCIgKyBjdXIgKyBcIjwvc3ZnPlwiO1xuICAgICAgICB2YXIgc3ZnID0gc3ZnQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChlbG0uZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN2Zy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgZWxtLmFwcGVuZENoaWxkKHN2Zy5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgLy8gc2tpcCB0aGUgdXBkYXRlIGlmIG9sZCBhbmQgbmV3IFZET00gc3RhdGUgaXMgdGhlIHNhbWUuXG4gICAgICAgIC8vIGB2YWx1ZWAgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5IGJlY2F1c2UgdGhlIERPTSB2YWx1ZSBtYXkgYmUgdGVtcG9yYXJpbHlcbiAgICAgICAgLy8gb3V0IG9mIHN5bmMgd2l0aCBWRE9NIHN0YXRlIGR1ZSB0byBmb2N1cywgY29tcG9zaXRpb24gYW5kIG1vZGlmaWVycy5cbiAgICAgICAgLy8gVGhpcyAgIzQ1MjEgYnkgc2tpcHBpbmcgdGhlIHVubmVjZXNzYXJ5IGBjaGVja2VkYCB1cGRhdGUuXG4gICAgICAgIGN1ciAhPT0gb2xkUHJvcHNba2V5XVxuICAgICAgKSB7XG4gICAgICAgIC8vIHNvbWUgcHJvcGVydHkgdXBkYXRlcyBjYW4gdGhyb3dcbiAgICAgICAgLy8gZS5nLiBgdmFsdWVgIG9uIDxwcm9ncmVzcz4gdy8gbm9uLWZpbml0ZSB2YWx1ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbiAgZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcbiAgICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXG4gICAgKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gICAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAgIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICAgIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgICAvLyAjNjE1N1xuICAgIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICAgIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxuICB9XG5cbiAgZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gICAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICAgIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICAgIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gICAgICB9XG4gICAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxuICB9XG5cbiAgdmFyIGRvbVByb3BzID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gICAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gICAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXNcbiAgfSk7XG5cbiAgLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbiAgZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gICAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAgIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAgIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gICAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgICAgOiBzdHlsZVxuICB9XG5cbiAgLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuICBmdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgICB9XG4gICAgcmV0dXJuIGJpbmRpbmdTdHlsZVxuICB9XG5cbiAgLyoqXG4gICAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAgICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgc3R5bGVEYXRhO1xuXG4gICAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKVxuICAgICAgICApIHtcbiAgICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGNzc1ZhclJFID0gL14tLS87XG4gIHZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xuICB2YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShuYW1lKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXG4gICAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG4gIHZhciBlbXB0eVN0eWxlO1xuICB2YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gICAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICAgIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgICAgcmV0dXJuIHByb3BcbiAgICB9XG4gICAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gICAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxuICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgY3VyLCBuYW1lO1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICAgIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gICAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gICAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAgIC8vIHRvIG11dGF0ZSBpdC5cbiAgICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICAgIDogc3R5bGU7XG5cbiAgICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgc3R5bGUgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIHdoaXRlc3BhY2VSRSA9IC9cXHMrLztcblxuICAvKipcbiAgICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gICAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICAgKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgICAgfVxuICAgICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICAgIH1cbiAgICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgICBpZiAoY3VyKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgICBpZiAoIWRlZiQkMSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgcmVzID0ge307XG4gICAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgICB9XG4gICAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xuICAgICAgcmV0dXJuIHJlc1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG4gICAgfVxuICB9XG5cbiAgdmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xuICB2YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbiAgdmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4gIC8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbiAgdmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xuICB2YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xuICB2YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xuICB2YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbiAgaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICAgIH1cbiAgICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICAgIH1cbiAgfVxuXG4gIC8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxuICB2YXIgcmFmID0gaW5Ccm93c2VyXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gICAgICA6IHNldFRpbWVvdXRcbiAgICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuICBmdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gICAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJhZihmbik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgICB9XG4gICAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG4gIH1cblxuICBmdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICAgIGVsLFxuICAgIGV4cGVjdGVkVHlwZSxcbiAgICBjYlxuICApIHtcbiAgICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gICAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICAgIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICAgIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gICAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICAgIHZhciBlbmRlZCA9IDA7XG4gICAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICAgIGNiKCk7XG4gICAgfTtcbiAgICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgICBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfSwgdGltZW91dCArIDEpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgfVxuXG4gIHZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbiAgZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIC8vIEpTRE9NIG1heSByZXR1cm4gdW5kZWZpbmVkIGZvciB0cmFuc2l0aW9uIHByb3BlcnRpZXNcbiAgICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gICAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgICB2YXIgdHlwZTtcbiAgICB2YXIgdGltZW91dCA9IDA7XG4gICAgdmFyIHByb3BDb3VudCA9IDA7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgICA6IG51bGw7XG4gICAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiAwO1xuICAgIH1cbiAgICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgdGltZW91dDogdGltZW91dCxcbiAgICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gICAgfSkpXG4gIH1cblxuICAvLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlciBudW1iZXJzXG4gIC8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cbiAgLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93biAoaS5lLiBhY3RpbmdcbiAgLy8gYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xuICBmdW5jdGlvbiB0b01zIChzKSB7XG4gICAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKS5yZXBsYWNlKCcsJywgJy4nKSkgKiAxMDAwXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICAgIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICBlbC5fbGVhdmVDYigpO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICAgIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICAgIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICAgIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICAgIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICAgIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICAgIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICAgIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gICAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICAgIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICAgIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gICAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAgIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAgIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gICAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gICAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gICAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gICAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICB9XG5cbiAgICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgICA/IGFwcGVhckNsYXNzXG4gICAgICA6IGVudGVyQ2xhc3M7XG4gICAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICAgID8gYXBwZWFyVG9DbGFzc1xuICAgICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICAgIDogYmVmb3JlRW50ZXI7XG4gICAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgICA6IGVudGVyO1xuICAgIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgICAgOiBhZnRlckVudGVyO1xuICAgIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICAgIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICAgIDogZHVyYXRpb25cbiAgICApO1xuXG4gICAgaWYgKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gICAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICAgIH1cbiAgICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgICB9KTtcblxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgICApIHtcbiAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gICAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9XG5cbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAgIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gICAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgIGVsLl9lbnRlckNiKCk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICAgIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICByZXR1cm4gcm0oKVxuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gICAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICAgIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICAgIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gICAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gICAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAgIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gICAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICAgIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICAgIDogZHVyYXRpb25cbiAgICApO1xuXG4gICAgaWYgKGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgICB9XG4gICAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gICAgfSk7XG5cbiAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgICAgfVxuICAgICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgIGNiKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG4gIGZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gICAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICAgKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAgICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAgIC8vIGludm9rZXJcbiAgICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBlbnRlcih2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gICAgY3JlYXRlOiBfZW50ZXIsXG4gICAgYWN0aXZhdGU6IF9lbnRlcixcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gOiB7fTtcblxuICB2YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICAgIGF0dHJzLFxuICAgIGtsYXNzLFxuICAgIGV2ZW50cyxcbiAgICBkb21Qcm9wcyxcbiAgICBzdHlsZSxcbiAgICB0cmFuc2l0aW9uXG4gIF07XG5cbiAgLyogICovXG5cbiAgLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4gIC8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG4gIHZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbiAgdmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbiAgLyoqXG4gICAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICAgKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICAgKi9cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUU5KSB7XG4gICAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgZGlyZWN0aXZlID0ge1xuICAgIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSkge1xuICAgICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgLy8gIzY5MDNcbiAgICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xuICAgICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgICB2YXIgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XG4gICAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxuICAgICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7IH0pXG4gICAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gICAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICAgIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG4gIH1cblxuICBmdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gICAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgICA6IG9wdGlvbi52YWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gICAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICAgIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gICAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xuICB9XG5cbiAgLyogICovXG5cbiAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuICBmdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICAgIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgICA6IHZub2RlXG4gIH1cblxuICB2YXIgc2hvdyA9IHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgICAgZWwsXG4gICAgICBiaW5kaW5nLFxuICAgICAgdm5vZGUsXG4gICAgICBvbGRWbm9kZSxcbiAgICAgIGlzRGVzdHJveVxuICAgICkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgICBtb2RlbDogZGlyZWN0aXZlLFxuICAgIHNob3c6IHNob3dcbiAgfTtcblxuICAvKiAgKi9cblxuICB2YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICAgIG5hbWU6IFN0cmluZyxcbiAgICBhcHBlYXI6IEJvb2xlYW4sXG4gICAgY3NzOiBCb29sZWFuLFxuICAgIG1vZGU6IFN0cmluZyxcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgZW50ZXJDbGFzczogU3RyaW5nLFxuICAgIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gICAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gICAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxuICB9O1xuXG4gIC8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuICAvLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuICBmdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgICB2YXIgZGF0YSA9IHt9O1xuICAgIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgICAvLyBwcm9wc1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICAgIH1cbiAgICAvLyBldmVudHMuXG4gICAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gICAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gICAgfVxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gICAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gICAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG4gIH1cblxuICB2YXIgaXNOb3RUZXh0Tm9kZSA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH07XG5cbiAgdmFyIGlzVlNob3dEaXJlY3RpdmUgPSBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH07XG5cbiAgdmFyIFRyYW5zaXRpb24gPSB7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICAgIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gICAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoaXNOb3RUZXh0Tm9kZSk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgICBpZiAobW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICAgKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfVxuXG4gICAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgICAvLyBtYXJrIHYtc2hvd1xuICAgICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGlzVlNob3dEaXJlY3RpdmUpKSB7XG4gICAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXG4gICAgICApIHtcbiAgICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgICB0YWc6IFN0cmluZyxcbiAgICBtb3ZlQ2xhc3M6IFN0cmluZ1xuICB9LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG4gIGRlbGV0ZSBwcm9wcy5tb2RlO1xuXG4gIHZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uIGJlZm9yZU1vdW50ICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHRoaXMkMSk7XG4gICAgICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICAgICAgdGhpcyQxLl9fcGF0Y2hfXyhcbiAgICAgICAgICB0aGlzJDEuX3Zub2RlLFxuICAgICAgICAgIHRoaXMkMS5rZXB0LFxuICAgICAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcyQxLl92bm9kZSA9IHRoaXMkMS5rZXB0O1xuICAgICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAgICAgdXBkYXRlLmNhbGwodGhpcyQxLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgICB9LFxuXG4gICAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG4gICAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgICB9XG4gICAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgICAgYy5lbG0uX21vdmVDYigpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gICAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gICAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gICAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgICBpZiAoZHggfHwgZHkpIHtcbiAgICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gICAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxuICB9O1xuXG4gIC8qICAqL1xuXG4gIC8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcbiAgVnVlLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuICBWdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuICBWdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG4gIFZ1ZS5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuICBWdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4gIC8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuICBleHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbiAgLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuICBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuICAvLyBwdWJsaWMgbW91bnQgbWV0aG9kXG4gIFZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICAgIGVsLFxuICAgIGh5ZHJhdGluZ1xuICApIHtcbiAgICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbiAgfTtcblxuICAvLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sIDApO1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXHI/XFxuKSs/KVxcfVxcfS9nO1xuICB2YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbiAgdmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gICAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxuICB9KTtcblxuXG5cbiAgZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgICB0ZXh0LFxuICAgIGRlbGltaXRlcnNcbiAgKSB7XG4gICAgdmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG4gICAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHRva2VucyA9IFtdO1xuICAgIHZhciByYXdUb2tlbnMgPSBbXTtcbiAgICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICAgIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKTtcbiAgICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgICAgfVxuICAgICAgLy8gdGFnIHRva2VuXG4gICAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG4gICAgICByYXdUb2tlbnMucHVzaCh7ICdAYmluZGluZyc6IGV4cCB9KTtcbiAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZXhwcmVzc2lvbjogdG9rZW5zLmpvaW4oJysnKSxcbiAgICAgIHRva2VuczogcmF3VG9rZW5zXG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydjbGFzcyddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0aWNDbGFzcykge1xuICAgICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gICAgfVxuICAgIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgICB2YXIgZGF0YSA9ICcnO1xuICAgIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICAgIH1cbiAgICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgdmFyIGtsYXNzJDEgPSB7XG4gICAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICAgIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gICAgZ2VuRGF0YTogZ2VuRGF0YVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJyxcbiAgICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzdHlsZSddXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICAgIH1cblxuICAgIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICAgIHZhciBkYXRhID0gJyc7XG4gICAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gICAgfVxuICAgIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIHZhciBzdHlsZSQxID0ge1xuICAgIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gICAgZ2VuRGF0YTogZ2VuRGF0YSQxXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIGRlY29kZXI7XG5cbiAgdmFyIGhlID0ge1xuICAgIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gICAgfVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBpc1VuYXJ5VGFnID0gbWFrZU1hcChcbiAgICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuICApO1xuXG4gIC8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuICAvLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcbiAgICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbiAgKTtcblxuICAvLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXG4gIC8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxuICB2YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcbiAgICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAgICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgICAnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xuICAgICd0aXRsZSx0cix0cmFjaydcbiAgKTtcblxuICAvKipcbiAgICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gICAqL1xuXG4gIC8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xuICB2YXIgYXR0cmlidXRlID0gL15cXHMqKFteXFxzXCInPD5cXC89XSspKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG4gIHZhciBkeW5hbWljQXJnQXR0cmlidXRlID0gL15cXHMqKCg/OnYtW1xcdy1dKzp8QHw6fCMpXFxbW149XStcXF1bXlxcc1wiJzw+XFwvPV0qKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xuICB2YXIgbmNuYW1lID0gXCJbYS16QS1aX11bXFxcXC1cXFxcLjAtOV9hLXpBLVpcIiArICh1bmljb2RlUmVnRXhwLnNvdXJjZSkgKyBcIl0qXCI7XG4gIHZhciBxbmFtZUNhcHR1cmUgPSBcIigoPzpcIiArIG5jbmFtZSArIFwiXFxcXDopP1wiICsgbmNuYW1lICsgXCIpXCI7XG4gIHZhciBzdGFydFRhZ09wZW4gPSBuZXcgUmVnRXhwKChcIl48XCIgKyBxbmFtZUNhcHR1cmUpKTtcbiAgdmFyIHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+LztcbiAgdmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoKFwiXjxcXFxcL1wiICsgcW5hbWVDYXB0dXJlICsgXCJbXj5dKj5cIikpO1xuICB2YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xuICAvLyAjNzI5ODogZXNjYXBlIC0gdG8gYXZvaWQgYmVpbmcgcGFzc2VkIGFzIEhUTUwgY29tbWVudCB3aGVuIGlubGluZWQgaW4gcGFnZVxuICB2YXIgY29tbWVudCA9IC9ePCFcXC0tLztcbiAgdmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG4gIC8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxuICB2YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG4gIHZhciByZUNhY2hlID0ge307XG5cbiAgdmFyIGRlY29kaW5nTWFwID0ge1xuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmYW1wOyc6ICcmJyxcbiAgICAnJiMxMDsnOiAnXFxuJyxcbiAgICAnJiM5Oyc6ICdcXHQnLFxuICAgICcmIzM5Oyc6IFwiJ1wiXG4gIH07XG4gIHZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5KTsvZztcbiAgdmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzl8IzEwfCM5KTsvZztcblxuICAvLyAjNTk5MlxuICB2YXIgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG4gIHZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbiAgZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gICAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICAgIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICAgIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gICAgd2hpbGUgKGh0bWwpIHtcbiAgICAgIGxhc3QgPSBodG1sO1xuICAgICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkS2VlcENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCksIGluZGV4LCBpbmRleCArIGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFydFRhZ01hdGNoLnRhZ05hbWUsIGh0bWwpKSB7XG4gICAgICAgICAgICAgIGFkdmFuY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgIGFkdmFuY2UodGV4dC5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCwgaW5kZXggLSB0ZXh0Lmxlbmd0aCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgICAgdmFyIHJlc3QkMSA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFwtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKSAvLyAjNzI5OFxuICAgICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnLCB0ZXh0KSkge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfSk7XG4gICAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdCQxLmxlbmd0aDtcbiAgICAgICAgaHRtbCA9IHJlc3QkMTtcbiAgICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpLCB7IHN0YXJ0OiBpbmRleCArIGh0bWwubGVuZ3RoIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gICAgcGFyc2VFbmRUYWcoKTtcblxuICAgIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICAgIGluZGV4ICs9IG47XG4gICAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgICAgfTtcbiAgICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goZHluYW1pY0FyZ0F0dHJpYnV0ZSkgfHwgaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICAgIGF0dHIuc3RhcnQgPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBhdHRyLmVuZCA9IGluZGV4O1xuICAgICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgICAgdmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICAgIHZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IHRhZ05hbWUgPT09ICdhJyAmJiBhcmdzWzFdID09PSAnaHJlZidcbiAgICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgICAgOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzO1xuICAgICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGFyZ3Muc3RhcnQgKyBhcmdzWzBdLm1hdGNoKC9eXFxzKi8pLmxlbmd0aDtcbiAgICAgICAgICBhdHRyc1tpXS5lbmQgPSBhcmdzLmVuZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzLCBzdGFydDogbWF0Y2guc3RhcnQsIGVuZDogbWF0Y2guZW5kIH0pO1xuICAgICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgICBwb3MgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgICBpZiAoaSA+IHBvcyB8fCAhdGFnTmFtZSAmJlxuICAgICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIiksXG4gICAgICAgICAgICAgIHsgc3RhcnQ6IHN0YWNrW2ldLnN0YXJ0LCBlbmQ6IHN0YWNrW2ldLmVuZCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBvblJFID0gL15AfF52LW9uOi87XG4gIHZhciBkaXJSRSA9IC9edi18XkB8Xjp8XiMvO1xuICB2YXIgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbiAgdmFyIGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XG4gIHZhciBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xuICB2YXIgZHluYW1pY0FyZ1JFID0gL15cXFsuKlxcXSQvO1xuXG4gIHZhciBhcmdSRSA9IC86KC4qKSQvO1xuICB2YXIgYmluZFJFID0gL146fF5cXC58XnYtYmluZDovO1xuICB2YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nO1xuXG4gIHZhciBzbG90UkUgPSAvXnYtc2xvdCg6fCQpfF4jLztcblxuICB2YXIgbGluZUJyZWFrUkUgPSAvW1xcclxcbl0vO1xuICB2YXIgd2hpdGVzcGFjZVJFJDEgPSAvXFxzKy9nO1xuXG4gIHZhciBpbnZhbGlkQXR0cmlidXRlUkUgPSAvW1xcc1wiJzw+XFwvPV0vO1xuXG4gIHZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGhlLmRlY29kZSk7XG5cbiAgdmFyIGVtcHR5U2xvdFNjb3BlVG9rZW4gPSBcIl9lbXB0eV9cIjtcblxuICAvLyBjb25maWd1cmFibGUgc3RhdGVcbiAgdmFyIHdhcm4kMjtcbiAgdmFyIGRlbGltaXRlcnM7XG4gIHZhciB0cmFuc2Zvcm1zO1xuICB2YXIgcHJlVHJhbnNmb3JtcztcbiAgdmFyIHBvc3RUcmFuc2Zvcm1zO1xuICB2YXIgcGxhdGZvcm1Jc1ByZVRhZztcbiAgdmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XG4gIHZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcbiAgdmFyIG1heWJlQ29tcG9uZW50O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFTVEVsZW1lbnQgKFxuICAgIHRhZyxcbiAgICBhdHRycyxcbiAgICBwYXJlbnRcbiAgKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IDEsXG4gICAgICB0YWc6IHRhZyxcbiAgICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICAgIHJhd0F0dHJzTWFwOiB7fSxcbiAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2UgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXG4gICAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gICAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gICAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcbiAgICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgICBtYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcblxuICAgIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XG4gICAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XG5cbiAgICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgICB2YXIgd2hpdGVzcGFjZU9wdGlvbiA9IG9wdGlvbnMud2hpdGVzcGFjZTtcbiAgICB2YXIgcm9vdDtcbiAgICB2YXIgY3VycmVudFBhcmVudDtcbiAgICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gICAgdmFyIGluUHJlID0gZmFsc2U7XG4gICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZywgcmFuZ2UpIHtcbiAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgIHdhcm4kMihtc2csIHJhbmdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuICAgICAgaWYgKCFpblZQcmUgJiYgIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICAgIGVsZW1lbnQgPSBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgICAgaWYgKCFzdGFjay5sZW5ndGggJiYgZWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBcIkNvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQuIFwiICtcbiAgICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgICBcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChlbGVtZW50LnNsb3RTY29wZSkge1xuICAgICAgICAgICAgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICAgIC8vIGtlZXAgaXQgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgc28gdGhhdCB2LWVsc2UoLWlmKSBjb25kaXRpb25zIGNhblxuICAgICAgICAgICAgLy8gZmluZCBpdCBhcyB0aGUgcHJldiBub2RlLlxuICAgICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJ1xuICAgICAgICAgICAgOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZmluYWwgY2hpbGRyZW4gY2xlYW51cFxuICAgICAgLy8gZmlsdGVyIG91dCBzY29wZWQgc2xvdHNcbiAgICAgIGVsZW1lbnQuY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gIShjKS5zbG90U2NvcGU7IH0pO1xuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZSBhZ2FpblxuICAgICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XG5cbiAgICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcG9zdFRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpbUVuZGluZ1doaXRlc3BhY2UgKGVsKSB7XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlXG4gICAgICBpZiAoIWluUHJlKSB7XG4gICAgICAgIHZhciBsYXN0Tm9kZTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgIChsYXN0Tm9kZSA9IGVsLmNoaWxkcmVuW2VsLmNoaWxkcmVuLmxlbmd0aCAtIDFdKSAmJlxuICAgICAgICAgIGxhc3ROb2RlLnR5cGUgPT09IDMgJiZcbiAgICAgICAgICBsYXN0Tm9kZS50ZXh0ID09PSAnICdcbiAgICAgICAgKSB7XG4gICAgICAgICAgZWwuY2hpbGRyZW4ucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLicsXG4gICAgICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgICB3YXJuOiB3YXJuJDIsXG4gICAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgICBjYW5CZUxlZnRPcGVuVGFnOiBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcsXG4gICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgICBzaG91bGRLZWVwQ29tbWVudDogb3B0aW9ucy5jb21tZW50cyxcbiAgICAgIG91dHB1dFNvdXJjZVJhbmdlOiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlLFxuICAgICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSwgc3RhcnQkMSwgZW5kKSB7XG4gICAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgY3VycmVudFBhcmVudCk7XG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdGFydCA9IHN0YXJ0JDE7XG4gICAgICAgICAgICBlbGVtZW50LmVuZCA9IGVuZDtcbiAgICAgICAgICAgIGVsZW1lbnQucmF3QXR0cnNNYXAgPSBlbGVtZW50LmF0dHJzTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKGN1bXVsYXRlZCwgYXR0cikge1xuICAgICAgICAgICAgICBjdW11bGF0ZWRbYXR0ci5uYW1lXSA9IGF0dHI7XG4gICAgICAgICAgICAgIHJldHVybiBjdW11bGF0ZWRcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgaWYgKGludmFsaWRBdHRyaWJ1dGVSRS50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAgIFwiSW52YWxpZCBkeW5hbWljIGFyZ3VtZW50IGV4cHJlc3Npb246IGF0dHJpYnV0ZSBuYW1lcyBjYW5ub3QgY29udGFpbiBcIiArXG4gICAgICAgICAgICAgICAgXCJzcGFjZXMsIHF1b3RlcywgPCwgPiwgLyBvciA9LlwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmluZGV4T2YoXCJbXCIpLFxuICAgICAgICAgICAgICAgICAgZW5kOiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmxlbmd0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcbiAgICAgICAgICAgIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nLFxuICAgICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVsZW1lbnQgPSBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcbiAgICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcm9vdCkge1xuICAgICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZW5kOiBmdW5jdGlvbiBlbmQgKHRhZywgc3RhcnQsIGVuZCQxKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGVsZW1lbnQuZW5kID0gZW5kJDE7XG4gICAgICAgIH1cbiAgICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfSxcblxuICAgICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJyxcbiAgICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFydCB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAgIChcInRleHQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpLFxuICAgICAgICAgICAgICAgIHsgc3RhcnQ6IHN0YXJ0IH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRSAmJlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgICBpZiAoaW5QcmUgfHwgdGV4dC50cmltKCkpIHtcbiAgICAgICAgICB0ZXh0ID0gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIC8vIHJlbW92ZSB0aGUgd2hpdGVzcGFjZS1vbmx5IG5vZGUgcmlnaHQgYWZ0ZXIgYW4gb3BlbmluZyB0YWdcbiAgICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAod2hpdGVzcGFjZU9wdGlvbikge1xuICAgICAgICAgIGlmICh3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgICAvLyBpbiBjb25kZW5zZSBtb2RlLCByZW1vdmUgdGhlIHdoaXRlc3BhY2Ugbm9kZSBpZiBpdCBjb250YWluc1xuICAgICAgICAgICAgLy8gbGluZSBicmVhaywgb3RoZXJ3aXNlIGNvbmRlbnNlIHRvIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgICAgICB0ZXh0ID0gbGluZUJyZWFrUkUudGVzdCh0ZXh0KSA/ICcnIDogJyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0ID0gJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gcHJlc2VydmVXaGl0ZXNwYWNlID8gJyAnIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICBpZiAoIWluUHJlICYmIHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAgIC8vIGNvbmRlbnNlIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2VzIGludG8gc2luZ2xlIHNwYWNlXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzO1xuICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKHJlcyA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICAgIGNoaWxkID0ge1xuICAgICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgICBleHByZXNzaW9uOiByZXMuZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgdG9rZW5zOiByZXMudG9rZW5zLFxuICAgICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIC8vIGFkZGluZyBhbnl0aGluZyBhcyBhIHNpYmxpbmcgdG8gdGhlIHJvb3Qgbm9kZSBpcyBmb3JiaWRkZW5cbiAgICAgICAgLy8gY29tbWVudHMgc2hvdWxkIHN0aWxsIGJlIGFsbG93ZWQsIGJ1dCBpZ25vcmVkXG4gICAgICAgIGlmIChjdXJyZW50UGFyZW50KSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0ge1xuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICBpc0NvbW1lbnQ6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJvb3RcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcbiAgICAgIGVsLnByZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICBpZiAobGVuKSB7XG4gICAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgICBuYW1lOiBsaXN0W2ldLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGxpc3RbaV0udmFsdWUpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChsaXN0W2ldLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGxpc3RbaV0uc3RhcnQ7XG4gICAgICAgICAgYXR0cnNbaV0uZW5kID0gbGlzdFtpXS5lbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICAgIGVsLnBsYWluID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzRWxlbWVudCAoXG4gICAgZWxlbWVudCxcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAgIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xuICAgIGVsZW1lbnQucGxhaW4gPSAoXG4gICAgICAhZWxlbWVudC5rZXkgJiZcbiAgICAgICFlbGVtZW50LnNjb3BlZFNsb3RzICYmXG4gICAgICAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoXG4gICAgKTtcblxuICAgIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gICAgcHJvY2Vzc1Nsb3RDb250ZW50KGVsZW1lbnQpO1xuICAgIHByb2Nlc3NTbG90T3V0bGV0KGVsZW1lbnQpO1xuICAgIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlbGVtZW50ID0gdHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICAgIH1cbiAgICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gICAgcmV0dXJuIGVsZW1lbnRcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gICAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gICAgaWYgKGV4cCkge1xuICAgICAge1xuICAgICAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIsXG4gICAgICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwuZm9yKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gZWwuaXRlcmF0b3IyIHx8IGVsLml0ZXJhdG9yMTtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgICAgIGlmIChpdGVyYXRvciAmJiBpdGVyYXRvciA9PT0gZXhwICYmIHBhcmVudCAmJiBwYXJlbnQudGFnID09PSAndHJhbnNpdGlvbi1ncm91cCcpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJEbyBub3QgdXNlIHYtZm9yIGluZGV4IGFzIGtleSBvbiA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4sIFwiICtcbiAgICAgICAgICAgICAgXCJ0aGlzIGlzIHRoZSBzYW1lIGFzIG5vdCB1c2luZyBrZXlzLlwiLFxuICAgICAgICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpLFxuICAgICAgICAgICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsLmtleSA9IGV4cDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xuICAgIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICAgIGlmIChyZWYpIHtcbiAgICAgIGVsLnJlZiA9IHJlZjtcbiAgICAgIGVsLnJlZkluRm9yID0gY2hlY2tJbkZvcihlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgICB2YXIgZXhwO1xuICAgIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgICB2YXIgcmVzID0gcGFyc2VGb3IoZXhwKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgZXh0ZW5kKGVsLCByZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuXG4gIGZ1bmN0aW9uIHBhcnNlRm9yIChleHApIHtcbiAgICB2YXIgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcbiAgICBpZiAoIWluTWF0Y2gpIHsgcmV0dXJuIH1cbiAgICB2YXIgcmVzID0ge307XG4gICAgcmVzLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICAgIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpO1xuICAgIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgIHJlcy5hbGlhcyA9IGFsaWFzLnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpLnRyaW0oKTtcbiAgICAgIHJlcy5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICAgIHJlcy5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLmFsaWFzID0gYWxpYXM7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgICBpZiAoZXhwKSB7XG4gICAgICBlbC5pZiA9IGV4cDtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICAgIGV4cDogZXhwLFxuICAgICAgICBibG9jazogZWxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xuICAgICAgaWYgKGVsc2VpZikge1xuICAgICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xuICAgIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gICAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgICAgYmxvY2s6IGVsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcInYtXCIgKyAoZWwuZWxzZWlmID8gKCdlbHNlLWlmPVwiJyArIGVsLmVsc2VpZiArICdcIicpIDogJ2Vsc2UnKSArIFwiIFwiICtcbiAgICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwW2VsLmVsc2VpZiA/ICd2LWVsc2UtaWYnIDogJ3YtZWxzZSddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcbiAgICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiLFxuICAgICAgICAgICAgY2hpbGRyZW5baV1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XG4gICAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICAgIH1cbiAgICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XG4gICAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gICAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgICAgZWwub25jZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gaGFuZGxlIGNvbnRlbnQgYmVpbmcgcGFzc2VkIHRvIGEgY29tcG9uZW50IGFzIHNsb3QsXG4gIC8vIGUuZy4gPHRlbXBsYXRlIHNsb3Q9XCJ4eHhcIj4sIDxkaXYgc2xvdC1zY29wZT1cInh4eFwiPlxuICBmdW5jdGlvbiBwcm9jZXNzU2xvdENvbnRlbnQgKGVsKSB7XG4gICAgdmFyIHNsb3RTY29wZTtcbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICBzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHNsb3RTY29wZSkge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0aGUgXFxcInNjb3BlXFxcIiBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBzbG90cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhbmQgXCIgK1xuICAgICAgICAgIFwicmVwbGFjZWQgYnkgXFxcInNsb3Qtc2NvcGVcXFwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcXFwic2xvdC1zY29wZVxcXCIgYXR0cmlidXRlIFwiICtcbiAgICAgICAgICBcImNhbiBhbHNvIGJlIHVzZWQgb24gcGxhaW4gZWxlbWVudHMgaW4gYWRkaXRpb24gdG8gPHRlbXBsYXRlPiB0byBcIiArXG4gICAgICAgICAgXCJkZW5vdGUgc2NvcGVkIHNsb3RzLlwiLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzY29wZSddLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpO1xuICAgIH0gZWxzZSBpZiAoKHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJykpKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChlbC5hdHRyc01hcFsndi1mb3InXSkge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJBbWJpZ3VvdXMgY29tYmluZWQgdXNhZ2Ugb2Ygc2xvdC1zY29wZSBhbmQgdi1mb3Igb24gPFwiICsgKGVsLnRhZykgKyBcIj4gXCIgK1xuICAgICAgICAgIFwiKHYtZm9yIHRha2VzIGhpZ2hlciBwcmlvcml0eSkuIFVzZSBhIHdyYXBwZXIgPHRlbXBsYXRlPiBmb3IgdGhlIFwiICtcbiAgICAgICAgICBcInNjb3BlZCBzbG90IHRvIG1ha2UgaXQgY2xlYXJlci5cIixcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsnc2xvdC1zY29wZSddLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZTtcbiAgICB9XG5cbiAgICAvLyBzbG90PVwieHh4XCJcbiAgICB2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICAgIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgICBlbC5zbG90VGFyZ2V0ID0gc2xvdFRhcmdldCA9PT0gJ1wiXCInID8gJ1wiZGVmYXVsdFwiJyA6IHNsb3RUYXJnZXQ7XG4gICAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9ICEhKGVsLmF0dHJzTWFwWyc6c2xvdCddIHx8IGVsLmF0dHJzTWFwWyd2LWJpbmQ6c2xvdCddKTtcbiAgICAgIC8vIHByZXNlcnZlIHNsb3QgYXMgYW4gYXR0cmlidXRlIGZvciBuYXRpdmUgc2hhZG93IERPTSBjb21wYXRcbiAgICAgIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHMuXG4gICAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgYWRkQXR0cihlbCwgJ3Nsb3QnLCBzbG90VGFyZ2V0LCBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMi42IHYtc2xvdCBzeW50YXhcbiAgICB7XG4gICAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIC8vIHYtc2xvdCBvbiA8dGVtcGxhdGU+XG4gICAgICAgIHZhciBzbG90QmluZGluZyA9IGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4KGVsLCBzbG90UkUpO1xuICAgICAgICBpZiAoc2xvdEJpbmRpbmcpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZWwuc2xvdFRhcmdldCB8fCBlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5cIixcbiAgICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsLnBhcmVudCAmJiAhbWF5YmVDb21wb25lbnQoZWwucGFyZW50KSkge1xuICAgICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgICAgXCI8dGVtcGxhdGUgdi1zbG90PiBjYW4gb25seSBhcHBlYXIgYXQgdGhlIHJvb3QgbGV2ZWwgaW5zaWRlIFwiICtcbiAgICAgICAgICAgICAgICBcInRoZSByZWNlaXZpbmcgY29tcG9uZW50XCIsXG4gICAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlZiA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuICAgICAgICAgIHZhciBkeW5hbWljID0gcmVmLmR5bmFtaWM7XG4gICAgICAgICAgZWwuc2xvdFRhcmdldCA9IG5hbWU7XG4gICAgICAgICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47IC8vIGZvcmNlIGl0IGludG8gYSBzY29wZWQgc2xvdCBmb3IgcGVyZlxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB2LXNsb3Qgb24gY29tcG9uZW50LCBkZW5vdGVzIGRlZmF1bHQgc2xvdFxuICAgICAgICB2YXIgc2xvdEJpbmRpbmckMSA9IGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4KGVsLCBzbG90UkUpO1xuICAgICAgICBpZiAoc2xvdEJpbmRpbmckMSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghbWF5YmVDb21wb25lbnQoZWwpKSB7XG4gICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICBcInYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPi5cIixcbiAgICAgICAgICAgICAgICBzbG90QmluZGluZyQxXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWwuc2xvdFNjb3BlIHx8IGVsLnNsb3RUYXJnZXQpIHtcbiAgICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5cIixcbiAgICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICBcIlRvIGF2b2lkIHNjb3BlIGFtYmlndWl0eSwgdGhlIGRlZmF1bHQgc2xvdCBzaG91bGQgYWxzbyB1c2UgXCIgK1xuICAgICAgICAgICAgICAgIFwiPHRlbXBsYXRlPiBzeW50YXggd2hlbiB0aGVyZSBhcmUgb3RoZXIgbmFtZWQgc2xvdHMuXCIsXG4gICAgICAgICAgICAgICAgc2xvdEJpbmRpbmckMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhZGQgdGhlIGNvbXBvbmVudCdzIGNoaWxkcmVuIHRvIGl0cyBkZWZhdWx0IHNsb3RcbiAgICAgICAgICB2YXIgc2xvdHMgPSBlbC5zY29wZWRTbG90cyB8fCAoZWwuc2NvcGVkU2xvdHMgPSB7fSk7XG4gICAgICAgICAgdmFyIHJlZiQxID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmckMSk7XG4gICAgICAgICAgdmFyIG5hbWUkMSA9IHJlZiQxLm5hbWU7XG4gICAgICAgICAgdmFyIGR5bmFtaWMkMSA9IHJlZiQxLmR5bmFtaWM7XG4gICAgICAgICAgdmFyIHNsb3RDb250YWluZXIgPSBzbG90c1tuYW1lJDFdID0gY3JlYXRlQVNURWxlbWVudCgndGVtcGxhdGUnLCBbXSwgZWwpO1xuICAgICAgICAgIHNsb3RDb250YWluZXIuc2xvdFRhcmdldCA9IG5hbWUkMTtcbiAgICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYyQxO1xuICAgICAgICAgIHNsb3RDb250YWluZXIuY2hpbGRyZW4gPSBlbC5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGlmICghYy5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgICAgYy5wYXJlbnQgPSBzbG90Q29udGFpbmVyO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNsb3RDb250YWluZXIuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmckMS52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuO1xuICAgICAgICAgIC8vIHJlbW92ZSBjaGlsZHJlbiBhcyB0aGV5IGFyZSByZXR1cm5lZCBmcm9tIHNjb3BlZFNsb3RzIG5vd1xuICAgICAgICAgIGVsLmNoaWxkcmVuID0gW107XG4gICAgICAgICAgLy8gbWFyayBlbCBub24tcGxhaW4gc28gZGF0YSBnZXRzIGdlbmVyYXRlZFxuICAgICAgICAgIGVsLnBsYWluID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTbG90TmFtZSAoYmluZGluZykge1xuICAgIHZhciBuYW1lID0gYmluZGluZy5uYW1lLnJlcGxhY2Uoc2xvdFJFLCAnJyk7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBpZiAoYmluZGluZy5uYW1lWzBdICE9PSAnIycpIHtcbiAgICAgICAgbmFtZSA9ICdkZWZhdWx0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInYtc2xvdCBzaG9ydGhhbmQgc3ludGF4IHJlcXVpcmVzIGEgc2xvdCBuYW1lLlwiLFxuICAgICAgICAgIGJpbmRpbmdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpXG4gICAgICAvLyBkeW5hbWljIFtuYW1lXVxuICAgICAgPyB7IG5hbWU6IG5hbWUuc2xpY2UoMSwgLTEpLCBkeW5hbWljOiB0cnVlIH1cbiAgICAgIC8vIHN0YXRpYyBuYW1lXG4gICAgICA6IHsgbmFtZTogKFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSwgZHluYW1pYzogZmFsc2UgfVxuICB9XG5cbiAgLy8gaGFuZGxlIDxzbG90Lz4gb3V0bGV0c1xuICBmdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldCAoZWwpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgICBpZiAoZWwua2V5KSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCIsXG4gICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gICAgdmFyIGJpbmRpbmc7XG4gICAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgICB9XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBzeW5jR2VuLCBpc0R5bmFtaWM7XG4gICAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUucmVwbGFjZShkaXJSRSwgJycpKTtcbiAgICAgICAgLy8gc3VwcG9ydCAuZm9vIHNob3J0aGFuZCBzeW50YXggZm9yIHRoZSAucHJvcCBtb2RpZmllclxuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAoXCJUaGUgdmFsdWUgZm9yIGEgdi1iaW5kIGV4cHJlc3Npb24gY2Fubm90IGJlIGVtcHR5LiBGb3VuZCBpbiBcXFwidi1iaW5kOlwiICsgbmFtZSArIFwiXFxcIlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICAgIHN5bmNHZW4gPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIik7XG4gICAgICAgICAgICAgIGlmICghaXNEeW5hbWljKSB7XG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGNhbWVsaXplKG5hbWUpKSksXG4gICAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGh5cGhlbmF0ZShuYW1lKSAhPT0gY2FtZWxpemUobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoaHlwaGVuYXRlKG5hbWUpKSksXG4gICAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZXIgdy8gZHluYW1pYyBldmVudCBuYW1lXG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgKFwiXFxcInVwZGF0ZTpcXFwiKyhcIiArIG5hbWUgKyBcIilcIiksXG4gICAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgICAgbGlzdFtpXSxcbiAgICAgICAgICAgICAgICAgIHRydWUgLy8gZHluYW1pY1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnByb3ApIHx8IChcbiAgICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXG4gICAgICAgICAgKSkge1xuICAgICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMiwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgICAgdmFyIGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICAgIGlzRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgICAgIGlmIChkeW5hbWljQXJnUkUudGVzdChhcmcpKSB7XG4gICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgIGlzRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgaXNEeW5hbWljLCBtb2RpZmllcnMsIGxpc3RbaV0pO1xuICAgICAgICAgIGlmIChuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nLFxuICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSksIGxpc3RbaV0pO1xuICAgICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAgIC8vIGV2ZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgZWxlbWVudCBjcmVhdGlvblxuICAgICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxuICAgICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgICAgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnLCBsaXN0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IGVsO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICAgIHJldHVybiByZXRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgICApIHtcbiAgICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSwgYXR0cnNbaV0pO1xuICAgICAgfVxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBtYXBcbiAgfVxuXG4gIC8vIGZvciBzY3JpcHQgKGUuZy4gdHlwZT1cIngvdGVtcGxhdGVcIikgb3Igc3R5bGUsIGRvIG5vdCBkZWNvZGUgY29udGVudFxuICBmdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gICAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG4gIH1cblxuICBmdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgICByZXR1cm4gKFxuICAgICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgICApKVxuICAgIClcbiAgfVxuXG4gIHZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xuICB2YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgICByZXMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgICB2YXIgX2VsID0gZWw7XG4gICAgd2hpbGUgKF9lbCkge1xuICAgICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCIsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgX2VsID0gX2VsLnBhcmVudDtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICAgIGlmIChlbC50YWcgPT09ICdpbnB1dCcpIHtcbiAgICAgIHZhciBtYXAgPSBlbC5hdHRyc01hcDtcbiAgICAgIGlmICghbWFwWyd2LW1vZGVsJ10pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlQmluZGluZztcbiAgICAgIGlmIChtYXBbJzp0eXBlJ10gfHwgbWFwWyd2LWJpbmQ6dHlwZSddKSB7XG4gICAgICAgIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgICB9XG4gICAgICBpZiAoIW1hcC50eXBlICYmICF0eXBlQmluZGluZyAmJiBtYXBbJ3YtYmluZCddKSB7XG4gICAgICAgIHR5cGVCaW5kaW5nID0gXCIoXCIgKyAobWFwWyd2LWJpbmQnXSkgKyBcIikudHlwZVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZUJpbmRpbmcpIHtcbiAgICAgICAgdmFyIGlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnLCB0cnVlKTtcbiAgICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgICB2YXIgaGFzRWxzZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnLCB0cnVlKSAhPSBudWxsO1xuICAgICAgICB2YXIgZWxzZUlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicsIHRydWUpO1xuICAgICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgICB2YXIgYnJhbmNoMCA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAgIC8vIHByb2Nlc3MgZm9yIG9uIHRoZSBtYWluIG5vZGVcbiAgICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgICAgYWRkUmF3QXR0cihicmFuY2gwLCAndHlwZScsICdjaGVja2JveCcpO1xuICAgICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gwLCBvcHRpb25zKTtcbiAgICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgICBicmFuY2gwLmlmID0gXCIoXCIgKyB0eXBlQmluZGluZyArIFwiKT09PSdjaGVja2JveCdcIiArIGlmQ29uZGl0aW9uRXh0cmE7XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgICAgYmxvY2s6IGJyYW5jaDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgICB2YXIgYnJhbmNoMSA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMSwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMSwgb3B0aW9ucyk7XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICAgIGJsb2NrOiBicmFuY2gxXG4gICAgICAgIH0pO1xuICAgICAgICAvLyAzLiBvdGhlclxuICAgICAgICB2YXIgYnJhbmNoMiA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMiwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gyLCBvcHRpb25zKTtcbiAgICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgICAgYmxvY2s6IGJyYW5jaDJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgICBicmFuY2gwLmVsc2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xuICAgICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJyYW5jaDBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFTVEVsZW1lbnQoZWwudGFnLCBlbC5hdHRyc0xpc3Quc2xpY2UoKSwgZWwucGFyZW50KVxuICB9XG5cbiAgdmFyIG1vZGVsJDEgPSB7XG4gICAgcHJlVHJhbnNmb3JtTm9kZTogcHJlVHJhbnNmb3JtTm9kZVxuICB9O1xuXG4gIHZhciBtb2R1bGVzJDEgPSBbXG4gICAga2xhc3MkMSxcbiAgICBzdHlsZSQxLFxuICAgIG1vZGVsJDFcbiAgXTtcblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gICAgaWYgKGRpci52YWx1ZSkge1xuICAgICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSwgZGlyKTtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gICAgaWYgKGRpci52YWx1ZSkge1xuICAgICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIiksIGRpcik7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgICBtb2RlbDogbW9kZWwsXG4gICAgdGV4dDogdGV4dCxcbiAgICBodG1sOiBodG1sXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIGJhc2VPcHRpb25zID0ge1xuICAgIGV4cGVjdEhUTUw6IHRydWUsXG4gICAgbW9kdWxlczogbW9kdWxlcyQxLFxuICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gICAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICAgIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuICAgIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBpc1N0YXRpY0tleTtcbiAgdmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxuICB2YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4gIC8qKlxuICAgKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICAgKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gICAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gICAqXG4gICAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICAgKlxuICAgKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gICAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAgICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gICAqL1xuICBmdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICAgIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICAgIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICAgIG1hcmtTdGF0aWMkMShyb290KTtcbiAgICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gICAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuICAgIHJldHVybiBtYWtlTWFwKFxuICAgICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMsc3RhcnQsZW5kLHJhd0F0dHJzTWFwJyArXG4gICAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgICApXG4gIH1cblxuICBmdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgICAgaWYgKFxuICAgICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaztcbiAgICAgICAgICBtYXJrU3RhdGljJDEoYmxvY2spO1xuICAgICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgICB9XG4gICAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAgIC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cbiAgICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IDNcbiAgICAgICkpIHtcbiAgICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrLCBpc0luRm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICAgICkpXG4gIH1cblxuICBmdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICAgIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGZuRXhwUkUgPSAvXihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvbig/OlxccytbXFx3JF0rKT9cXHMqXFwoLztcbiAgdmFyIGZuSW52b2tlUkUgPSAvXFwoW14pXSo/XFwpOyokLztcbiAgdmFyIHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG5cbiAgLy8gS2V5Ym9hcmRFdmVudC5rZXlDb2RlIGFsaWFzZXNcbiAgdmFyIGtleUNvZGVzID0ge1xuICAgIGVzYzogMjcsXG4gICAgdGFiOiA5LFxuICAgIGVudGVyOiAxMyxcbiAgICBzcGFjZTogMzIsXG4gICAgdXA6IDM4LFxuICAgIGxlZnQ6IDM3LFxuICAgIHJpZ2h0OiAzOSxcbiAgICBkb3duOiA0MCxcbiAgICAnZGVsZXRlJzogWzgsIDQ2XVxuICB9O1xuXG4gIC8vIEtleWJvYXJkRXZlbnQua2V5IGFsaWFzZXNcbiAgdmFyIGtleU5hbWVzID0ge1xuICAgIC8vICM3ODgwOiBJRTExIGFuZCBFZGdlIHVzZSBgRXNjYCBmb3IgRXNjYXBlIGtleSBuYW1lLlxuICAgIGVzYzogWydFc2MnLCAnRXNjYXBlJ10sXG4gICAgdGFiOiAnVGFiJyxcbiAgICBlbnRlcjogJ0VudGVyJyxcbiAgICAvLyAjOTExMjogSUUxMSB1c2VzIGBTcGFjZWJhcmAgZm9yIFNwYWNlIGtleSBuYW1lLlxuICAgIHNwYWNlOiBbJyAnLCAnU3BhY2ViYXInXSxcbiAgICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxuICAgIHVwOiBbJ1VwJywgJ0Fycm93VXAnXSxcbiAgICBsZWZ0OiBbJ0xlZnQnLCAnQXJyb3dMZWZ0J10sXG4gICAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxuICAgIGRvd246IFsnRG93bicsICdBcnJvd0Rvd24nXSxcbiAgICAvLyAjOTExMjogSUUxMSB1c2VzIGBEZWxgIGZvciBEZWxldGUga2V5IG5hbWUuXG4gICAgJ2RlbGV0ZSc6IFsnQmFja3NwYWNlJywgJ0RlbGV0ZScsICdEZWwnXVxuICB9O1xuXG4gIC8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4gIC8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbiAgLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxuICB2YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcblxuICB2YXIgbW9kaWZpZXJDb2RlID0ge1xuICAgIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICAgIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxuICAgIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gICAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICAgIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxuICAgIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gICAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICAgIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXG4gIH07XG5cbiAgZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICAgIGV2ZW50cyxcbiAgICBpc05hdGl2ZVxuICApIHtcbiAgICB2YXIgcHJlZml4ID0gaXNOYXRpdmUgPyAnbmF0aXZlT246JyA6ICdvbjonO1xuICAgIHZhciBzdGF0aWNIYW5kbGVycyA9IFwiXCI7XG4gICAgdmFyIGR5bmFtaWNIYW5kbGVycyA9IFwiXCI7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICAgIHZhciBoYW5kbGVyQ29kZSA9IGdlbkhhbmRsZXIoZXZlbnRzW25hbWVdKTtcbiAgICAgIGlmIChldmVudHNbbmFtZV0gJiYgZXZlbnRzW25hbWVdLmR5bmFtaWMpIHtcbiAgICAgICAgZHluYW1pY0hhbmRsZXJzICs9IG5hbWUgKyBcIixcIiArIGhhbmRsZXJDb2RlICsgXCIsXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0aWNIYW5kbGVycyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWNIYW5kbGVycyA9IFwie1wiICsgKHN0YXRpY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgICBpZiAoZHluYW1pY0hhbmRsZXJzKSB7XG4gICAgICByZXR1cm4gcHJlZml4ICsgXCJfZChcIiArIHN0YXRpY0hhbmRsZXJzICsgXCIsW1wiICsgKGR5bmFtaWNIYW5kbGVycy5zbGljZSgwLCAtMSkpICsgXCJdKVwiXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcmVmaXggKyBzdGF0aWNIYW5kbGVyc1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gICAgfVxuXG4gICAgdmFyIGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICAgIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgICB2YXIgaXNGdW5jdGlvbkludm9jYXRpb24gPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlLnJlcGxhY2UoZm5JbnZva2VSRSwgJycpKTtcblxuICAgIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIudmFsdWVcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGlzRnVuY3Rpb25JbnZvY2F0aW9uID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKSA6IGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvZGUgPSAnJztcbiAgICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICAgIHZhciBrZXlzID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICAgIHZhciBtb2RpZmllcnMgPSAoaGFuZGxlci5tb2RpZmllcnMpO1xuICAgICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBnZW5HdWFyZChcbiAgICAgICAgICAgIFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAhbW9kaWZpZXJzW2tleU1vZGlmaWVyXTsgfSlcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuIChcIiRldmVudC5cIiArIGtleU1vZGlmaWVyICsgXCJLZXlcIik7IH0pXG4gICAgICAgICAgICAgIC5qb2luKCd8fCcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgICAgfVxuICAgICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgICB9XG4gICAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgICAgPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIigkZXZlbnQpXCIpXG4gICAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgICA/IChcInJldHVybiAoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikoJGV2ZW50KVwiKVxuICAgICAgICAgIDogaXNGdW5jdGlvbkludm9jYXRpb25cbiAgICAgICAgICAgID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKVxuICAgICAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gbWFrZSBzdXJlIHRoZSBrZXkgZmlsdGVycyBvbmx5IGFwcGx5IHRvIEtleWJvYXJkRXZlbnRzXG4gICAgICAvLyAjOTQ0MTogY2FuJ3QgdXNlICdrZXlDb2RlJyBpbiAkZXZlbnQgYmVjYXVzZSBDaHJvbWUgYXV0b2ZpbGwgZmlyZXMgZmFrZVxuICAgICAgLy8ga2V5IGV2ZW50cyB0aGF0IGRvIG5vdCBoYXZlIGtleUNvZGUgcHJvcGVydHkuLi5cbiAgICAgIFwiaWYoISRldmVudC50eXBlLmluZGV4T2YoJ2tleScpJiZcIiArXG4gICAgICAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIlxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xuICAgIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgICBpZiAoa2V5VmFsKSB7XG4gICAgICByZXR1cm4gKFwiJGV2ZW50LmtleUNvZGUhPT1cIiArIGtleVZhbClcbiAgICB9XG4gICAgdmFyIGtleUNvZGUgPSBrZXlDb2Rlc1trZXldO1xuICAgIHZhciBrZXlOYW1lID0ga2V5TmFtZXNba2V5XTtcbiAgICByZXR1cm4gKFxuICAgICAgXCJfaygkZXZlbnQua2V5Q29kZSxcIiArXG4gICAgICAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyBcIixcIiArXG4gICAgICAoSlNPTi5zdHJpbmdpZnkoa2V5Q29kZSkpICsgXCIsXCIgK1xuICAgICAgXCIkZXZlbnQua2V5LFwiICtcbiAgICAgIFwiXCIgKyAoSlNPTi5zdHJpbmdpZnkoa2V5TmFtZSkpICtcbiAgICAgIFwiKVwiXG4gICAgKVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgICBpZiAoZGlyLm1vZGlmaWVycykge1xuICAgICAgd2FybihcInYtb24gd2l0aG91dCBhcmd1bWVudCBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVycy5cIik7XG4gICAgfVxuICAgIGVsLndyYXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiX2coXCIgKyBjb2RlICsgXCIsXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKTsgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICAgIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgXCIsXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgICB9O1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICAgIG9uOiBvbixcbiAgICBiaW5kOiBiaW5kJDEsXG4gICAgY2xvYWs6IG5vb3BcbiAgfTtcblxuICAvKiAgKi9cblxuXG5cblxuXG4gIHZhciBDb2RlZ2VuU3RhdGUgPSBmdW5jdGlvbiBDb2RlZ2VuU3RhdGUgKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgICB0aGlzLmRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XG4gICAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gICAgdGhpcy5tYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcbiAgICB0aGlzLm9uY2VJZCA9IDA7XG4gICAgdGhpcy5zdGF0aWNSZW5kZXJGbnMgPSBbXTtcbiAgICB0aGlzLnByZSA9IGZhbHNlO1xuICB9O1xuXG5cblxuICBmdW5jdGlvbiBnZW5lcmF0ZSAoXG4gICAgYXN0LFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHN0YXRlID0gbmV3IENvZGVnZW5TdGF0ZShvcHRpb25zKTtcbiAgICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSkgOiAnX2MoXCJkaXZcIiknO1xuICAgIHJldHVybiB7XG4gICAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGUuc3RhdGljUmVuZGVyRm5zXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwsIHN0YXRlKSB7XG4gICAgaWYgKGVsLnBhcmVudCkge1xuICAgICAgZWwucHJlID0gZWwucHJlIHx8IGVsLnBhcmVudC5wcmU7XG4gICAgfVxuXG4gICAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQgJiYgIXN0YXRlLnByZSkge1xuICAgICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICByZXR1cm4gZ2VuU2xvdChlbCwgc3RhdGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG4gICAgICB2YXIgY29kZTtcbiAgICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKCFlbC5wbGFpbiB8fCAoZWwucHJlICYmIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSkpIHtcbiAgICAgICAgICBkYXRhID0gZ2VuRGF0YSQyKGVsLCBzdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgICAgICBjb2RlID0gXCJfYygnXCIgKyAoZWwudGFnKSArIFwiJ1wiICsgKGRhdGEgPyAoXCIsXCIgKyBkYXRhKSA6ICcnKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiO1xuICAgICAgfVxuICAgICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29kZVxuICAgIH1cbiAgfVxuXG4gIC8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG4gIGZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gICAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAvLyBTb21lIGVsZW1lbnRzICh0ZW1wbGF0ZXMpIG5lZWQgdG8gYmVoYXZlIGRpZmZlcmVudGx5IGluc2lkZSBvZiBhIHYtcHJlXG4gICAgLy8gbm9kZS4gIEFsbCBwcmUgbm9kZXMgYXJlIHN0YXRpYyByb290cywgc28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgbG9jYXRpb24gdG9cbiAgICAvLyB3cmFwIGEgc3RhdGUgY2hhbmdlIGFuZCByZXNldCBpdCB1cG9uIGV4aXRpbmcgdGhlIHByZSBub2RlLlxuICAgIHZhciBvcmlnaW5hbFByZVN0YXRlID0gc3RhdGUucHJlO1xuICAgIGlmIChlbC5wcmUpIHtcbiAgICAgIHN0YXRlLnByZSA9IGVsLnByZTtcbiAgICB9XG4gICAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiKSk7XG4gICAgc3RhdGUucHJlID0gb3JpZ2luYWxQcmVTdGF0ZTtcbiAgICByZXR1cm4gKFwiX20oXCIgKyAoc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9XG5cbiAgLy8gdi1vbmNlXG4gIGZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xuICAgIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICAgIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgICAgdmFyIGtleSA9ICcnO1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5mb3IpIHtcbiAgICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICgha2V5KSB7XG4gICAgICAgIHN0YXRlLndhcm4oXG4gICAgICAgICAgXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCIsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Ytb25jZSddXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCIsXCIgKyAoc3RhdGUub25jZUlkKyspICsgXCIsXCIgKyBrZXkgKyBcIilcIilcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuSWYgKFxuICAgIGVsLFxuICAgIHN0YXRlLFxuICAgIGFsdEdlbixcbiAgICBhbHRFbXB0eVxuICApIHtcbiAgICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICAgIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgICBjb25kaXRpb25zLFxuICAgIHN0YXRlLFxuICAgIGFsdEdlbixcbiAgICBhbHRFbXB0eVxuICApIHtcbiAgICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYWx0RW1wdHkgfHwgJ19lKCknXG4gICAgfVxuXG4gICAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgICAgcmV0dXJuIChcIihcIiArIChjb25kaXRpb24uZXhwKSArIFwiKT9cIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpICsgXCI6XCIgKyAoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICAgIH1cblxuICAgIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgICAgcmV0dXJuIGFsdEdlblxuICAgICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICAgIDogZWwub25jZVxuICAgICAgICAgID8gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5Gb3IgKFxuICAgIGVsLFxuICAgIHN0YXRlLFxuICAgIGFsdEdlbixcbiAgICBhbHRIZWxwZXJcbiAgKSB7XG4gICAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gICAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gICAgaWYgKHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSAmJlxuICAgICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgIWVsLmtleVxuICAgICkge1xuICAgICAgc3RhdGUud2FybihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgICBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddLFxuICAgICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgICByZXR1cm4gKGFsdEhlbHBlciB8fCAnX2wnKSArIFwiKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcbiAgICAgICd9KSdcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XG4gICAgdmFyIGRhdGEgPSAneyc7XG5cbiAgICAvLyBkaXJlY3RpdmVzIGZpcnN0LlxuICAgIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gICAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsLCBzdGF0ZSk7XG4gICAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cbiAgICAvLyBrZXlcbiAgICBpZiAoZWwua2V5KSB7XG4gICAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgICB9XG4gICAgLy8gcmVmXG4gICAgaWYgKGVsLnJlZikge1xuICAgICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gICAgfVxuICAgIGlmIChlbC5yZWZJbkZvcikge1xuICAgICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gICAgfVxuICAgIC8vIHByZVxuICAgIGlmIChlbC5wcmUpIHtcbiAgICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgICB9XG4gICAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgICB9XG4gICAgLy8gYXR0cmlidXRlc1xuICAgIGlmIChlbC5hdHRycykge1xuICAgICAgZGF0YSArPSBcImF0dHJzOlwiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIixcIjtcbiAgICB9XG4gICAgLy8gRE9NIHByb3BzXG4gICAgaWYgKGVsLnByb3BzKSB7XG4gICAgICBkYXRhICs9IFwiZG9tUHJvcHM6XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwiLFwiO1xuICAgIH1cbiAgICAvLyBldmVudCBoYW5kbGVyc1xuICAgIGlmIChlbC5ldmVudHMpIHtcbiAgICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UpKSArIFwiLFwiO1xuICAgIH1cbiAgICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUpKSArIFwiLFwiO1xuICAgIH1cbiAgICAvLyBzbG90IHRhcmdldFxuICAgIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcbiAgICBpZiAoZWwuc2xvdFRhcmdldCAmJiAhZWwuc2xvdFNjb3BlKSB7XG4gICAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuICAgIH1cbiAgICAvLyBzY29wZWQgc2xvdHNcbiAgICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLCBlbC5zY29wZWRTbG90cywgc3RhdGUpKSArIFwiLFwiO1xuICAgIH1cbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICAgIGlmIChlbC5tb2RlbCkge1xuICAgICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICAgIH1cbiAgICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgICAvLyB2LWJpbmQgZHluYW1pYyBhcmd1bWVudCB3cmFwXG4gICAgLy8gdi1iaW5kIHdpdGggZHluYW1pYyBhcmd1bWVudHMgbXVzdCBiZSBhcHBsaWVkIHVzaW5nIHRoZSBzYW1lIHYtYmluZCBvYmplY3RcbiAgICAvLyBtZXJnZSBoZWxwZXIgc28gdGhhdCBjbGFzcy9zdHlsZS9tdXN0VXNlUHJvcCBhdHRycyBhcmUgaGFuZGxlZCBjb3JyZWN0bHkuXG4gICAgaWYgKGVsLmR5bmFtaWNBdHRycykge1xuICAgICAgZGF0YSA9IFwiX2IoXCIgKyBkYXRhICsgXCIsXFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCIgKyAoZ2VuUHJvcHMoZWwuZHluYW1pY0F0dHJzKSkgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICAgIGlmIChlbC53cmFwRGF0YSkge1xuICAgICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICAgIH1cbiAgICAvLyB2LW9uIGRhdGEgd3JhcFxuICAgIGlmIChlbC53cmFwTGlzdGVuZXJzKSB7XG4gICAgICBkYXRhID0gZWwud3JhcExpc3RlbmVycyhkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICAgIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cbiAgICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gICAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGRpciA9IGRpcnNbaV07XG4gICAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgICBpZiAoZ2VuKSB7XG4gICAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCBzdGF0ZS53YXJuKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XCIgKyAoZGlyLmlzRHluYW1pY0FyZyA/IGRpci5hcmcgOiAoXCJcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikpKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzUnVudGltZSkge1xuICAgICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gICAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICAgIGlmIChlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDEpIHtcbiAgICAgIHN0YXRlLndhcm4oXG4gICAgICAgICdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nLFxuICAgICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoYXN0ICYmIGFzdC50eXBlID09PSAxKSB7XG4gICAgICB2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBzdGF0ZS5vcHRpb25zKTtcbiAgICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICAgIGVsLFxuICAgIHNsb3RzLFxuICAgIHN0YXRlXG4gICkge1xuICAgIC8vIGJ5IGRlZmF1bHQgc2NvcGVkIHNsb3RzIGFyZSBjb25zaWRlcmVkIFwic3RhYmxlXCIsIHRoaXMgYWxsb3dzIGNoaWxkXG4gICAgLy8gY29tcG9uZW50cyB3aXRoIG9ubHkgc2NvcGVkIHNsb3RzIHRvIHNraXAgZm9yY2VkIHVwZGF0ZXMgZnJvbSBwYXJlbnQuXG4gICAgLy8gYnV0IGluIHNvbWUgY2FzZXMgd2UgaGF2ZSB0byBiYWlsLW91dCBvZiB0aGlzIG9wdGltaXphdGlvblxuICAgIC8vIGZvciBleGFtcGxlIGlmIHRoZSBzbG90IGNvbnRhaW5zIGR5bmFtaWMgbmFtZXMsIGhhcyB2LWlmIG9yIHYtZm9yIG9uIHRoZW0uLi5cbiAgICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9IGVsLmZvciB8fCBPYmplY3Qua2V5cyhzbG90cykuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgc2xvdCA9IHNsb3RzW2tleV07XG4gICAgICByZXR1cm4gKFxuICAgICAgICBzbG90LnNsb3RUYXJnZXREeW5hbWljIHx8XG4gICAgICAgIHNsb3QuaWYgfHxcbiAgICAgICAgc2xvdC5mb3IgfHxcbiAgICAgICAgY29udGFpbnNTbG90Q2hpbGQoc2xvdCkgLy8gaXMgcGFzc2luZyBkb3duIHNsb3QgZnJvbSBwYXJlbnQgd2hpY2ggbWF5IGJlIGR5bmFtaWNcbiAgICAgIClcbiAgICB9KTtcblxuICAgIC8vICM5NTM0OiBpZiBhIGNvbXBvbmVudCB3aXRoIHNjb3BlZCBzbG90cyBpcyBpbnNpZGUgYSBjb25kaXRpb25hbCBicmFuY2gsXG4gICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgdGhlIHNhbWUgY29tcG9uZW50IHRvIGJlIHJldXNlZCBidXQgd2l0aCBkaWZmZXJlbnRcbiAgICAvLyBjb21waWxlZCBzbG90IGNvbnRlbnQuIFRvIGF2b2lkIHRoYXQsIHdlIGdlbmVyYXRlIGEgdW5pcXVlIGtleSBiYXNlZCBvblxuICAgIC8vIHRoZSBnZW5lcmF0ZWQgY29kZSBvZiBhbGwgdGhlIHNsb3QgY29udGVudHMuXG4gICAgdmFyIG5lZWRzS2V5ID0gISFlbC5pZjtcblxuICAgIC8vIE9SIHdoZW4gaXQgaXMgaW5zaWRlIGFub3RoZXIgc2NvcGVkIHNsb3Qgb3Igdi1mb3IgKHRoZSByZWFjdGl2aXR5IG1heSBiZVxuICAgIC8vIGRpc2Nvbm5lY3RlZCBkdWUgdG8gdGhlIGludGVybWVkaWF0ZSBzY29wZSB2YXJpYWJsZSlcbiAgICAvLyAjOTQzOCwgIzk1MDZcbiAgICAvLyBUT0RPOiB0aGlzIGNhbiBiZSBmdXJ0aGVyIG9wdGltaXplZCBieSBwcm9wZXJseSBhbmFseXppbmcgaW4tc2NvcGUgYmluZGluZ3NcbiAgICAvLyBhbmQgc2tpcCBmb3JjZSB1cGRhdGluZyBvbmVzIHRoYXQgZG8gbm90IGFjdHVhbGx5IHVzZSBzY29wZSB2YXJpYWJsZXMuXG4gICAgaWYgKCFuZWVkc0ZvcmNlVXBkYXRlKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKHBhcmVudC5zbG90U2NvcGUgJiYgcGFyZW50LnNsb3RTY29wZSAhPT0gZW1wdHlTbG90U2NvcGVUb2tlbikgfHxcbiAgICAgICAgICBwYXJlbnQuZm9yXG4gICAgICAgICkge1xuICAgICAgICAgIG5lZWRzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudC5pZikge1xuICAgICAgICAgIG5lZWRzS2V5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBnZW5lcmF0ZWRTbG90cyA9IE9iamVjdC5rZXlzKHNsb3RzKVxuICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KHNsb3RzW2tleV0sIHN0YXRlKTsgfSlcbiAgICAgIC5qb2luKCcsJyk7XG5cbiAgICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgZ2VuZXJhdGVkU2xvdHMgKyBcIl1cIiArIChuZWVkc0ZvcmNlVXBkYXRlID8gXCIsbnVsbCx0cnVlXCIgOiBcIlwiKSArICghbmVlZHNGb3JjZVVwZGF0ZSAmJiBuZWVkc0tleSA/IChcIixudWxsLGZhbHNlLFwiICsgKGhhc2goZ2VuZXJhdGVkU2xvdHMpKSkgOiBcIlwiKSArIFwiKVwiKVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzaChzdHIpIHtcbiAgICB2YXIgaGFzaCA9IDUzODE7XG4gICAgdmFyIGkgPSBzdHIubGVuZ3RoO1xuICAgIHdoaWxlKGkpIHtcbiAgICAgIGhhc2ggPSAoaGFzaCAqIDMzKSBeIHN0ci5jaGFyQ29kZUF0KC0taSk7XG4gICAgfVxuICAgIHJldHVybiBoYXNoID4+PiAwXG4gIH1cblxuICBmdW5jdGlvbiBjb250YWluc1Nsb3RDaGlsZCAoZWwpIHtcbiAgICBpZiAoZWwudHlwZSA9PT0gMSkge1xuICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gZWwuY2hpbGRyZW4uc29tZShjb250YWluc1Nsb3RDaGlsZClcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAgICBlbCxcbiAgICBzdGF0ZVxuICApIHtcbiAgICB2YXIgaXNMZWdhY3lTeW50YXggPSBlbC5hdHRyc01hcFsnc2xvdC1zY29wZSddO1xuICAgIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQgJiYgIWlzTGVnYWN5U3ludGF4KSB7XG4gICAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBcIm51bGxcIilcbiAgICB9XG4gICAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdClcbiAgICB9XG4gICAgdmFyIHNsb3RTY29wZSA9IGVsLnNsb3RTY29wZSA9PT0gZW1wdHlTbG90U2NvcGVUb2tlblxuICAgICAgPyBcIlwiXG4gICAgICA6IFN0cmluZyhlbC5zbG90U2NvcGUpO1xuICAgIHZhciBmbiA9IFwiZnVuY3Rpb24oXCIgKyBzbG90U2NvcGUgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICAgID8gZWwuaWYgJiYgaXNMZWdhY3lTeW50YXhcbiAgICAgICAgICA/IChcIihcIiArIChlbC5pZikgKyBcIik/XCIgKyAoZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJykgKyBcIjp1bmRlZmluZWRcIilcbiAgICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCI7XG4gICAgLy8gcmV2ZXJzZSBwcm94eSB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xuICAgIHZhciByZXZlcnNlUHJveHkgPSBzbG90U2NvcGUgPyBcIlwiIDogXCIscHJveHk6dHJ1ZVwiO1xuICAgIHJldHVybiAoXCJ7a2V5OlwiICsgKGVsLnNsb3RUYXJnZXQgfHwgXCJcXFwiZGVmYXVsdFxcXCJcIikgKyBcIixmbjpcIiArIGZuICsgcmV2ZXJzZVByb3h5ICsgXCJ9XCIpXG4gIH1cblxuICBmdW5jdGlvbiBnZW5DaGlsZHJlbiAoXG4gICAgZWwsXG4gICAgc3RhdGUsXG4gICAgY2hlY2tTa2lwLFxuICAgIGFsdEdlbkVsZW1lbnQsXG4gICAgYWx0R2VuTm9kZVxuICApIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGVsJDEuZm9yICYmXG4gICAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICAgIGVsJDEudGFnICE9PSAnc2xvdCdcbiAgICAgICkge1xuICAgICAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXBcbiAgICAgICAgICA/IHN0YXRlLm1heWJlQ29tcG9uZW50KGVsJDEpID8gXCIsMVwiIDogXCIsMFwiXG4gICAgICAgICAgOiBcIlwiO1xuICAgICAgICByZXR1cm4gKFwiXCIgKyAoKGFsdEdlbkVsZW1lbnQgfHwgZ2VuRWxlbWVudCkoZWwkMSwgc3RhdGUpKSArIG5vcm1hbGl6YXRpb25UeXBlKVxuICAgICAgfVxuICAgICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlJDEgPSBjaGVja1NraXBcbiAgICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXG4gICAgICAgIDogMDtcbiAgICAgIHZhciBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XG4gICAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gZ2VuKGMsIHN0YXRlKTsgfSkuam9pbignLCcpKSArIFwiXVwiICsgKG5vcm1hbGl6YXRpb25UeXBlJDEgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSQxKSA6ICcnKSlcbiAgICB9XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4gIC8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4gIC8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbiAgLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuICBmdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoXG4gICAgY2hpbGRyZW4sXG4gICAgbWF5YmVDb21wb25lbnRcbiAgKSB7XG4gICAgdmFyIHJlcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xuICAgICAgICByZXMgPSAyO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgICAgcmVzID0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICAgIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICAgIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcbiAgICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuQ29tbWVudCAoY29tbWVudCkge1xuICAgIHJldHVybiAoXCJfZShcIiArIChKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpKSArIFwiKVwiKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuU2xvdCAoZWwsIHN0YXRlKSB7XG4gICAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xuICAgIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgfHwgZWwuZHluYW1pY0F0dHJzXG4gICAgICA/IGdlblByb3BzKChlbC5hdHRycyB8fCBbXSkuY29uY2F0KGVsLmR5bmFtaWNBdHRycyB8fCBbXSkubWFwKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiAoe1xuICAgICAgICAgIC8vIHNsb3QgcHJvcHMgYXJlIGNhbWVsaXplZFxuICAgICAgICAgIG5hbWU6IGNhbWVsaXplKGF0dHIubmFtZSksXG4gICAgICAgICAgdmFsdWU6IGF0dHIudmFsdWUsXG4gICAgICAgICAgZHluYW1pYzogYXR0ci5keW5hbWljXG4gICAgICAgIH0pOyB9KSlcbiAgICAgIDogbnVsbDtcbiAgICB2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcbiAgICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgICAgcmVzICs9IFwiLG51bGxcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgICB9XG4gICAgaWYgKGJpbmQkJDEpIHtcbiAgICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzICsgJyknXG4gIH1cblxuICAvLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG4gIGZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXG4gICAgY29tcG9uZW50TmFtZSxcbiAgICBlbCxcbiAgICBzdGF0ZVxuICApIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhJDIoZWwsIHN0YXRlKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICAgIHZhciBzdGF0aWNQcm9wcyA9IFwiXCI7XG4gICAgdmFyIGR5bmFtaWNQcm9wcyA9IFwiXCI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKTtcbiAgICAgIGlmIChwcm9wLmR5bmFtaWMpIHtcbiAgICAgICAgZHluYW1pY1Byb3BzICs9IChwcm9wLm5hbWUpICsgXCIsXCIgKyB2YWx1ZSArIFwiLFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGljUHJvcHMgKz0gXCJcXFwiXCIgKyAocHJvcC5uYW1lKSArIFwiXFxcIjpcIiArIHZhbHVlICsgXCIsXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpY1Byb3BzID0gXCJ7XCIgKyAoc3RhdGljUHJvcHMuc2xpY2UoMCwgLTEpKSArIFwifVwiO1xuICAgIGlmIChkeW5hbWljUHJvcHMpIHtcbiAgICAgIHJldHVybiAoXCJfZChcIiArIHN0YXRpY1Byb3BzICsgXCIsW1wiICsgKGR5bmFtaWNQcm9wcy5zbGljZSgwLCAtMSkpICsgXCJdKVwiKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RhdGljUHJvcHNcbiAgICB9XG4gIH1cblxuICAvLyAjMzg5NSwgIzQyNjhcbiAgZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHRcbiAgICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG4gIH1cblxuICAvKiAgKi9cblxuXG5cbiAgLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2VcbiAgLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxuICB2YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuICAgICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuICApLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4gIC8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG4gIHZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAgICdkZWxldGUsdHlwZW9mLHZvaWQnXG4gICkuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4gIC8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbiAgdmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuICAvLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuICBmdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCwgd2Fybikge1xuICAgIGlmIChhc3QpIHtcbiAgICAgIGNoZWNrTm9kZShhc3QsIHdhcm4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgd2Fybikge1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBub2RlLnJhd0F0dHJzTWFwW25hbWVdO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3Ytc2xvdCcgfHwgbmFtZVswXSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCB3YXJuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIHdhcm4sIG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgICB2YXIgc3RyaXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IHN0cmlwcGVkLm1hdGNoKHVuYXJ5T3BlcmF0b3JzUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RyaXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSksXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH1cbiAgICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICAgIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICAgIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChcbiAgICBpZGVudCxcbiAgICB0eXBlLFxuICAgIHRleHQsXG4gICAgd2FybixcbiAgICByYW5nZVxuICApIHtcbiAgICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKChcInZhciBcIiArIGlkZW50ICsgXCI9X1wiKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHdhcm4oKFwiaW52YWxpZCBcIiArIHR5cGUgKyBcIiBcXFwiXCIgKyBpZGVudCArIFwiXFxcIiBpbiBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpLCByYW5nZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiXFxuICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpLFxuICAgICAgICAgIHJhbmdlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArIChlLm1lc3NhZ2UpICsgXCIgaW5cXG5cXG5cIiArXG4gICAgICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcbiAgICAgICAgICBcIiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSArIFwiXFxuXCIsXG4gICAgICAgICAgcmFuZ2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0Z1bmN0aW9uUGFyYW1ldGVyRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICAgIHRyeSB7XG4gICAgICBuZXcgRnVuY3Rpb24oZXhwLCAnJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJpbnZhbGlkIGZ1bmN0aW9uIHBhcmFtZXRlciBleHByZXNzaW9uOiBcIiArIChlLm1lc3NhZ2UpICsgXCIgaW5cXG5cXG5cIiArXG4gICAgICAgIFwiICAgIFwiICsgZXhwICsgXCJcXG5cXG5cIiArXG4gICAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIixcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIHJhbmdlID0gMjtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZSAoXG4gICAgc291cmNlLFxuICAgIHN0YXJ0LFxuICAgIGVuZFxuICApIHtcbiAgICBpZiAoIHN0YXJ0ID09PSB2b2lkIDAgKSBzdGFydCA9IDA7XG4gICAgaWYgKCBlbmQgPT09IHZvaWQgMCApIGVuZCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAxO1xuICAgICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XG4gICAgICAgIGZvciAodmFyIGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpIHsgY29udGludWUgfVxuICAgICAgICAgIHJlcy5wdXNoKChcIlwiICsgKGogKyAxKSArIChyZXBlYXQkMShcIiBcIiwgMyAtIFN0cmluZyhqICsgMSkubGVuZ3RoKSkgKyBcInwgIFwiICsgKGxpbmVzW2pdKSkpO1xuICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgICAvLyBwdXNoIHVuZGVybGluZVxuICAgICAgICAgICAgdmFyIHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgICAgcmVzLnB1c2goXCIgICB8ICBcIiArIHJlcGVhdCQxKFwiIFwiLCBwYWQpICsgcmVwZWF0JDEoXCJeXCIsIGxlbmd0aCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgICB2YXIgbGVuZ3RoJDEgPSBNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCk7XG4gICAgICAgICAgICAgIHJlcy5wdXNoKFwiICAgfCAgXCIgKyByZXBlYXQkMShcIl5cIiwgbGVuZ3RoJDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLmpvaW4oJ1xcbicpXG4gIH1cblxuICBmdW5jdGlvbiByZXBlYXQkMSAoc3RyLCBuKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGlmIChuID4gMCkge1xuICAgICAgd2hpbGUgKHRydWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBpZiAobiAmIDEpIHsgcmVzdWx0ICs9IHN0cjsgfVxuICAgICAgICBuID4+Pj0gMTtcbiAgICAgICAgaWYgKG4gPD0gMCkgeyBicmVhayB9XG4gICAgICAgIHN0ciArPSBzdHI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qICAqL1xuXG5cblxuICBmdW5jdGlvbiBjcmVhdGVGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG4gICAgICByZXR1cm4gbm9vcFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gICAgICB0ZW1wbGF0ZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICB2bVxuICAgICkge1xuICAgICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gICAgICB2YXIgd2FybiQkMSA9IG9wdGlvbnMud2FybiB8fCB3YXJuO1xuICAgICAgZGVsZXRlIG9wdGlvbnMud2FybjtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgY2FjaGVcbiAgICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICAgIDogdGVtcGxhdGU7XG4gICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICByZXR1cm4gY2FjaGVba2V5XVxuICAgICAgfVxuXG4gICAgICAvLyBjb21waWxlXG4gICAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcbiAgICAgIHtcbiAgICAgICAgaWYgKGNvbXBpbGVkLmVycm9ycyAmJiBjb21waWxlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyAoZS5tc2cpICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVDb2RlRnJhbWUodGVtcGxhdGUsIGUuc3RhcnQsIGUuZW5kKSxcbiAgICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKFwiLSBcIiArIGUpOyB9KS5qb2luKCdcXG4nKSArICdcXG4nLFxuICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aXAoZS5tc2csIHZtKTsgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7IHJldHVybiB0aXAobXNnLCB2bSk7IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgIHZhciBmbkdlbkVycm9ycyA9IFtdO1xuICAgICAgcmVzLnJlbmRlciA9IGNyZWF0ZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGZuR2VuRXJyb3JzKVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cbiAgICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xuICAgICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XG4gICAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XG5cbiAgICAgICAgICAgICAgcmV0dXJuICgoZXJyLnRvU3RyaW5nKCkpICsgXCIgaW5cXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiKTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJDcmVhdG9yIChiYXNlQ29tcGlsZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21waWxlciAoYmFzZU9wdGlvbnMpIHtcbiAgICAgIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKSB7XG4gICAgICAgIHZhciBmaW5hbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zKTtcbiAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgdGlwcyA9IFtdO1xuXG4gICAgICAgIHZhciB3YXJuID0gZnVuY3Rpb24gKG1zZywgcmFuZ2UsIHRpcCkge1xuICAgICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgICB2YXIgbGVhZGluZ1NwYWNlTGVuZ3RoID0gdGVtcGxhdGUubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgICB3YXJuID0gZnVuY3Rpb24gKG1zZywgcmFuZ2UsIHRpcCkge1xuICAgICAgICAgICAgICB2YXIgZGF0YSA9IHsgbXNnOiBtc2cgfTtcbiAgICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGRhdGEuc3RhcnQgPSByYW5nZS5zdGFydCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBkYXRhLmVuZCA9IHJhbmdlLmVuZCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2goZGF0YSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuICAgICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0aW9ucy5tb2R1bGVzID1cbiAgICAgICAgICAgICAgKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmaW5hbE9wdGlvbnMud2FybiA9IHdhcm47XG5cbiAgICAgICAgdmFyIGNvbXBpbGVkID0gYmFzZUNvbXBpbGUodGVtcGxhdGUudHJpbSgpLCBmaW5hbE9wdGlvbnMpO1xuICAgICAgICB7XG4gICAgICAgICAgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCwgd2Fybik7XG4gICAgICAgIH1cbiAgICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICBjb21waWxlZC50aXBzID0gdGlwcztcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVkXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8vIGBjcmVhdGVDb21waWxlckNyZWF0b3JgIGFsbG93cyBjcmVhdGluZyBjb21waWxlcnMgdGhhdCB1c2UgYWx0ZXJuYXRpdmVcbiAgLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuICAvLyBIZXJlIHdlIGp1c3QgZXhwb3J0IGEgZGVmYXVsdCBjb21waWxlciB1c2luZyB0aGUgZGVmYXVsdCBwYXJ0cy5cbiAgdmFyIGNyZWF0ZUNvbXBpbGVyID0gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGZ1bmN0aW9uIGJhc2VDb21waWxlIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLm9wdGltaXplICE9PSBmYWxzZSkge1xuICAgICAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgdmFyIGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xuICAgIHJldHVybiB7XG4gICAgICBhc3Q6IGFzdCxcbiAgICAgIHJlbmRlcjogY29kZS5yZW5kZXIsXG4gICAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gICAgfVxuICB9KTtcblxuICAvKiAgKi9cblxuICB2YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG4gIHZhciBjb21waWxlID0gcmVmJDEuY29tcGlsZTtcbiAgdmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuICAvKiAgKi9cblxuICAvLyBjaGVjayB3aGV0aGVyIGN1cnJlbnQgYnJvd3NlciBlbmNvZGVzIGEgY2hhciBpbnNpZGUgYXR0cmlidXRlIHZhbHVlc1xuICB2YXIgZGl2O1xuICBmdW5jdGlvbiBnZXRTaG91bGREZWNvZGUgKGhyZWYpIHtcbiAgICBkaXYgPSBkaXYgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmlubmVySFRNTCA9IGhyZWYgPyBcIjxhIGhyZWY9XFxcIlxcblxcXCIvPlwiIDogXCI8ZGl2IGE9XFxcIlxcblxcXCIvPlwiO1xuICAgIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoJyYjMTA7JykgPiAwXG4gIH1cblxuICAvLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxuICB2YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XG4gIC8vICM2ODI4OiBjaHJvbWUgZW5jb2RlcyBjb250ZW50IGluIGFbaHJlZl1cbiAgdmFyIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZSh0cnVlKSA6IGZhbHNlO1xuXG4gIC8qICAqL1xuXG4gIHZhciBpZFRvVGVtcGxhdGUgPSBjYWNoZWQoZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsID0gcXVlcnkoaWQpO1xuICAgIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbiAgfSk7XG5cbiAgdmFyIG1vdW50ID0gVnVlLnByb3RvdHlwZS4kbW91bnQ7XG4gIFZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICAgIGVsLFxuICAgIGh5ZHJhdGluZ1xuICApIHtcbiAgICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIkRvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XG4gICAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB3YXJuKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgICAgbWFyaygnY29tcGlsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICAgIG91dHB1dFNvdXJjZVJhbmdlOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcbiAgICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZylcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcbiAgICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRPdXRlckhUTUwgKGVsKSB7XG4gICAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG4gICAgfVxuICB9XG5cbiAgVnVlLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XG5cbiAgcmV0dXJuIFZ1ZTtcblxufSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MTU5ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(13)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\nvar options = null\nvar ssrIdKey = 'data-vue-ssr-id'\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction, _options) {\n  isProduction = _isProduction\n\n  options = _options || {}\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[' + ssrIdKey + '~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n  if (options.ssrId) {\n    styleElement.setAttribute(ssrIdKey, obj.id)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzP2FlMzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsRUFBZ0I7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4gIE1vZGlmaWVkIGJ5IEV2YW4gWW91IEB5eXg5OTA4MDNcbiovXG5cbnZhciBoYXNEb2N1bWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuaWYgKHR5cGVvZiBERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgREVCVUcpIHtcbiAgaWYgKCFoYXNEb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAndnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiAnICtcbiAgICBcIlVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCJcbiAgKSB9XG59XG5cbnZhciBsaXN0VG9TdHlsZXMgPSByZXF1aXJlKCcuL2xpc3RUb1N0eWxlcycpXG5cbi8qXG50eXBlIFN0eWxlT2JqZWN0ID0ge1xuICBpZDogbnVtYmVyO1xuICBwYXJ0czogQXJyYXk8U3R5bGVPYmplY3RQYXJ0PlxufVxuXG50eXBlIFN0eWxlT2JqZWN0UGFydCA9IHtcbiAgY3NzOiBzdHJpbmc7XG4gIG1lZGlhOiBzdHJpbmc7XG4gIHNvdXJjZU1hcDogP3N0cmluZ1xufVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0gey8qXG4gIFtpZDogbnVtYmVyXToge1xuICAgIGlkOiBudW1iZXIsXG4gICAgcmVmczogbnVtYmVyLFxuICAgIHBhcnRzOiBBcnJheTwob2JqPzogU3R5bGVPYmplY3RQYXJ0KSA9PiB2b2lkPlxuICB9XG4qL31cblxudmFyIGhlYWQgPSBoYXNEb2N1bWVudCAmJiAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdKVxudmFyIHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsXG52YXIgc2luZ2xldG9uQ291bnRlciA9IDBcbnZhciBpc1Byb2R1Y3Rpb24gPSBmYWxzZVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxudmFyIG9wdGlvbnMgPSBudWxsXG52YXIgc3NySWRLZXkgPSAnZGF0YS12dWUtc3NyLWlkJ1xuXG4vLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbi8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbnZhciBpc09sZElFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXJlbnRJZCwgbGlzdCwgX2lzUHJvZHVjdGlvbiwgX29wdGlvbnMpIHtcbiAgaXNQcm9kdWN0aW9uID0gX2lzUHJvZHVjdGlvblxuXG4gIG9wdGlvbnMgPSBfb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIGxpc3QpXG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG4gICAgdmFyIG1heVJlbW92ZSA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgICAgZG9tU3R5bGUucmVmcy0tXG4gICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSlcbiAgICB9XG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbmV3TGlzdClcbiAgICAgIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzID0gW11cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXVxuICAgICAgaWYgKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKClcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMgLyogQXJyYXk8U3R5bGVPYmplY3Q+ICovKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgIGlmIChkb21TdHlsZSkge1xuICAgICAgZG9tU3R5bGUucmVmcysrXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pXG4gICAgICB9XG4gICAgICBmb3IgKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIGlmIChkb21TdHlsZS5wYXJ0cy5sZW5ndGggPiBpdGVtLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5sZW5ndGggPSBpdGVtLnBhcnRzLmxlbmd0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHsgaWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0cyB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAoKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJ1xuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudClcbiAgcmV0dXJuIHN0eWxlRWxlbWVudFxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICB2YXIgdXBkYXRlLCByZW1vdmVcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlWycgKyBzc3JJZEtleSArICd+PVwiJyArIG9iai5pZCArICdcIl0nKVxuXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBhbmQgaW4gcHJvZHVjdGlvbiBtb2RlLlxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbm9vcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXG4gICAgICAvLyBmb3Igc29tZSByZWFzb24gQ2hyb21lIGNhbid0IGhhbmRsZSBzb3VyY2UgbWFwIGluIHNlcnZlci1yZW5kZXJlZFxuICAgICAgLy8gc3R5bGUgdGFncyAtIHNvdXJjZSBtYXBzIGluIDxzdHlsZT4gb25seSB3b3JrcyBpZiB0aGUgc3R5bGUgdGFnIGlzXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlcyBhbmQgaW5qZWN0IG5ldyBvbmVzLlxuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc09sZElFKSB7XG4gICAgLy8gdXNlIHNpbmdsZXRvbiBtb2RlIGZvciBJRTkuXG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKytcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpXG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KClcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICB1cGRhdGUob2JqKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG4gICAgICAgICAgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKClcbiAgICB9XG4gIH1cbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnRcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5jc3NcblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcylcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3NcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcbiAgfVxuICBpZiAob3B0aW9ucy5zc3JJZCkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoc3NySWRLZXksIG9iai5pZClcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXApIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcbiAgICAvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJ1xuICB9XG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _dialog = __webpack_require__(15);\n\nvar _dialog2 = _interopRequireDefault(_dialog);\n\nvar _dialog3 = __webpack_require__(17);\n\nvar _dialog4 = _interopRequireDefault(_dialog3);\n\n__webpack_require__(28);\n\nvar _vue = __webpack_require__(0);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _Drag = __webpack_require__(33);\n\nvar _Qflow = __webpack_require__(34);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_vue2.default.use(_dialog4.default);\n\n\nvar qflow;\n\nexports.default = {\n\tname: \"qrelation\",\n\tcomponents: {},\n\tprops: ['initWidth', 'initHeight', 'jsonData', 'saveFun'],\n\tdata: function data() {\n\t\treturn {\n\t\t\tcurr: 0,\n\t\t\tsheets: [{\n\t\t\t\tname: 'sheet1'\n\t\t\t}],\n\t\t\tnodeTitle: '',\n\t\t\tlineNodeTitle: '标题',\n\t\t\tlineType: '',\n\t\t\tlineTypeList: [{\n\t\t\t\tname: '直线',\n\t\t\t\tvalue: 'line'\n\t\t\t}, {\n\t\t\t\tname: '二次曲线',\n\t\t\t\tvalue: 'quadraticCurve'\n\t\t\t}, {\n\t\t\t\tname: '三次曲线',\n\t\t\t\tvalue: 'bezierCurve'\n\t\t\t}, {\n\t\t\t\tname: '折线(横向)',\n\t\t\t\tvalue: 'foldLine1'\n\t\t\t}, {\n\t\t\t\tname: '折线(竖向)',\n\t\t\t\tvalue: 'foldLine2'\n\t\t\t}],\n\t\t\tlineLike: '',\n\t\t\tlineStyleList: [{\n\t\t\t\tname: '-',\n\t\t\t\tvalue: '-'\n\t\t\t}, {\n\t\t\t\tname: '->',\n\t\t\t\tvalue: '->'\n\t\t\t}, {\n\t\t\t\tname: '<-',\n\t\t\t\tvalue: '<-'\n\t\t\t}, {\n\t\t\t\tname: '<->',\n\t\t\t\tvalue: '<->'\n\t\t\t}, {\n\t\t\t\tname: '--',\n\t\t\t\tvalue: '--'\n\t\t\t}, {\n\t\t\t\tname: '<--',\n\t\t\t\tvalue: '<--'\n\t\t\t}, {\n\t\t\t\tname: '-->',\n\t\t\t\tvalue: '-->'\n\t\t\t}, {\n\t\t\t\tname: '<-->',\n\t\t\t\tvalue: '<-->'\n\t\t\t}],\n\t\t\tcontainerGridColumn: 1,\n\t\t\tshow: false,\n\t\t\tjson: '',\n\t\t\ttipText: ''\n\n\t\t};\n\t},\n\n\tmethods: {\n\t\tonSubmit: function onSubmit() {\n\t\t\tqflow.contextSettingHide();\n\t\t},\n\t\tjsShow: function jsShow() {\n\t\t\tthis.json = JSON.stringify(qflow.returnSaveData());\n\t\t\tthis.show = true;\n\t\t},\n\t\tclose: function close() {\n\t\t\tthis.show = false;\n\t\t},\n\t\tdownload: function download() {\n\t\t\tqflow.download();\n\t\t},\n\t\tsave: function save() {\n\n\t\t\tthis.saveFun && this.saveFun(qflow.returnSaveData());\n\t\t},\n\t\tmodiTitle: function modiTitle() {\n\t\t\tqflow.modiTitle(this.nodeTitle);\n\t\t},\n\t\tmodiLineTitle: function modiLineTitle() {\n\t\t\tqflow.modiLineTitle(this.lineNodeTitle);\n\t\t},\n\t\tmodiLineLike: function modiLineLike() {\n\t\t\tqflow.modiLineLike(this.lineLike);\n\t\t},\n\t\tmodiLineType: function modiLineType() {\n\n\t\t\tqflow.modiLineType(this.lineType);\n\t\t},\n\t\tmodTip: function modTip(e) {\n\t\t\tvar elem = e.target;\n\t\t\telem.style.height = 'auto';\n\t\t\telem.scrollTop = 0;\n\t\t\telem.style.height = elem.scrollHeight + 'px';\n\n\t\t\tqflow.updateTipText(elem.value, parseInt(elem.style.height));\n\t\t},\n\t\tmodiContainerGridColumn: function modiContainerGridColumn() {\n\n\t\t\tif (this.containerGridColumn == '' || this.containerGridColumn == 0) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tqflow.modiContainerGridColumn(this.containerGridColumn);\n\t\t},\n\t\tinit: function init() {\n\t\t\tvar _this = this;\n\t\t\tqflow = new _Qflow.Qflow({\n\t\t\t\tid: 'qcanvas',\n\t\t\t\twidth: _this.initWidth,\n\t\t\t\theight: _this.initHeight,\n\t\t\t\tinitData: _this.jsonData[_this.curr]\n\t\t\t});\n\n\t\t\tnew _Drag.Drag({\n\t\t\t\tdragAimClass: \"drag_ele\",\n\t\t\t\tmoveFun: function moveFun(x, y) {},\n\t\t\t\tupFun: function upFun(obj) {\n\t\t\t\t\tif (obj.y > 40 && obj.x > 0) {\n\n\t\t\t\t\t\tqflow.addEle(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t},\n\tmounted: function mounted() {\n\n\t\tthis.init();\n\t},\n\tcreated: function created() {},\n\n\tcomputed: {},\n\twatch: {},\n\tdestroyed: function destroyed() {\n\t\tqflow !== null & qflow.destroy();\n\n\t\tqflow = null;\n\t}\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3FyZWxhdGlvbi52dWU/YzQ0MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtFQTs7QUFDQTs7OztBQUZBOzs7QUFLQTs7a0JBRUE7QUFDQSxrQkFEQTtBQUVBLGVBRkE7QUFHQSwwREFIQTtBQUlBLEtBSkEsa0JBSUE7QUFDQTtBQUNBLFVBREE7QUFFQSxZQUNBO0FBQ0E7QUFEQSxJQURBLENBRkE7QUFPQSxnQkFQQTtBQVFBLHNCQVJBO0FBU0EsZUFUQTtBQVVBLGtCQUNBO0FBQ0EsY0FEQTtBQUVBO0FBRkEsSUFEQSxFQUtBO0FBQ0EsZ0JBREE7QUFFQTtBQUZBLElBTEEsRUFTQTtBQUNBLGdCQURBO0FBRUE7QUFGQSxJQVRBLEVBYUE7QUFDQSxrQkFEQTtBQUVBO0FBRkEsSUFiQSxFQWlCQTtBQUNBLGtCQURBO0FBRUE7QUFGQSxJQWpCQSxDQVZBO0FBZ0NBLGVBaENBO0FBaUNBLG1CQUNBO0FBQ0EsYUFEQTtBQUVBO0FBRkEsSUFEQSxFQUtBO0FBQ0EsY0FEQTtBQUVBO0FBRkEsSUFMQSxFQVNBO0FBQ0EsY0FEQTtBQUVBO0FBRkEsSUFUQSxFQWFBO0FBQ0EsZUFEQTtBQUVBO0FBRkEsSUFiQSxFQWlCQTtBQUNBLGNBREE7QUFFQTtBQUZBLElBakJBLEVBcUJBO0FBQ0EsZUFEQTtBQUVBO0FBRkEsSUFyQkEsRUF5QkE7QUFDQSxlQURBO0FBRUE7QUFGQSxJQXpCQSxFQTZCQTtBQUNBLGdCQURBO0FBRUE7QUFGQSxJQTdCQSxDQWpDQTtBQW1FQSx5QkFuRUE7QUFvRUEsY0FwRUE7QUFxRUEsV0FyRUE7QUFzRUE7O0FBdEVBO0FBeUVBLEVBOUVBOztBQStFQTtBQUNBO0FBQ0E7QUFDQSxHQUhBO0FBSUE7QUFDQTtBQUNBO0FBQ0EsR0FQQTtBQVFBO0FBQ0E7QUFDQSxHQVZBO0FBV0E7QUFDQTtBQUNBLEdBYkE7QUFjQTs7QUFFQTtBQUNBLEdBakJBO0FBa0JBO0FBQ0E7QUFDQSxHQXBCQTtBQXFCQTtBQUNBO0FBQ0EsR0F2QkE7QUF3QkE7QUFDQTtBQUNBLEdBMUJBO0FBMkJBOztBQUVBO0FBQ0EsR0E5QkE7QUErQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQVlBLEdBakRBO0FBa0RBOztBQUVBLHlDQUNBLDZCQURBLEVBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBR0EsR0E1REE7QUE2REE7QUFDQTtBQUNBO0FBQ0EsaUJBREE7QUFFQSwwQkFGQTtBQUdBLDRCQUhBO0FBSUE7QUFKQTs7QUFRQTtBQUNBLDRCQURBO0FBRUEscUNBRUEsQ0FKQTtBQUtBO0FBQ0E7O0FBTUE7QUFDQTtBQUVBO0FBZkE7QUFpQkE7O0FBeEZBLEVBL0VBO0FBMEtBLFFBMUtBLHFCQTBLQTs7QUFJQTtBQUNBLEVBL0tBO0FBZ0xBLFFBaExBLHFCQWdMQSxDQUVBLENBbExBOztBQW1MQSxhQW5MQTtBQXNMQSxVQXRMQTtBQTBMQSxVQTFMQSx1QkEwTEE7QUFDQTs7QUFFQTtBQUNBO0FBOUxBLEMiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cblx0PGRpdiBpZD1cInFmbG93X2xheVwiPlxuXHRcdDxkaXYgY2xhc3M9XCJ0b29sXCI+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImRyYWdfZWxlXCIgZGF0YS1pZD1cIi0xXCI+XG5cdFx0XHRcdDxpbWcgc3JjPVwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJ6ZEdGdVpHRnNiMjVsUFNKdWJ5SS9QandoUkU5RFZGbFFSU0J6ZG1jZ1VGVkNURWxESUNJdEx5OVhNME12TDBSVVJDQlRWa2NnTVM0eEx5OUZUaUlnSW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTDBkeVlYQm9hV056TDFOV1J5OHhMakV2UkZSRUwzTjJaekV4TG1SMFpDSStQSE4yWnlCMFBTSXhOakF5TWprM05UazBPRGM1SWlCamJHRnpjejBpYVdOdmJpSWdkbWxsZDBKdmVEMGlNQ0F3SURFd01qUWdNVEF5TkNJZ2RtVnljMmx2YmowaU1TNHhJaUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSEF0YVdROUlqSXhORGNpSUhodGJHNXpPbmhzYVc1clBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1TDNoc2FXNXJJaUIzYVdSMGFEMGlNakF3SWlCb1pXbG5hSFE5SWpJd01DSStQR1JsWm5NK1BITjBlV3hsSUhSNWNHVTlJblJsZUhRdlkzTnpJajQ4TDNOMGVXeGxQand2WkdWbWN6NDhjR0YwYUNCa1BTSk5NalUySURJNE9HZzJOSFkyTkdndE5qUjZJRzB4TWpnZ016ZzBhRE00TkhZMk5FZ3pPRFI2VFRJMU5pQTBPREJvTmpSMk5qUm9MVFkwZWlCdE1DQXhPVEpvTmpSMk5qUm9MVFkwZWlJZ1ptbHNiRDBpSXpNek16TXpNeUlnY0MxcFpEMGlNakUwT0NJK1BDOXdZWFJvUGp4d1lYUm9JR1E5SWswNE16SWdOalJJTVRreVl5MHpOUzR5SURBdE5qUWdNamd1T0MwMk5DQTJOSFkzTmpoak1DQXpOUzR5SURJNExqZ2dOalFnTmpRZ05qUm9OalF3WXpNMUxqSWdNQ0EyTkMweU9DNDRJRFkwTFRZMFZqRXlPR013TFRNMUxqSXRNamd1T0MwMk5DMDJOQzAyTkhvZ2JUQWdPREF3WXpBZ01Ua3VNaTB4TmlBek1pMHpNaUF6TWtneU1qUmpMVEUySURBdE16SXRNVEl1T0Mwek1pMHpNbFl4TmpCak1DMHhPUzR5SURFMkxUTXlJRE15TFRNeWFEVTNObU14TmlBd0lETXlJREV5TGpnZ016SWdNekoyTnpBMGVpSWdabWxzYkQwaUl6TXpNek16TXlJZ2NDMXBaRDBpTWpFME9TSStQQzl3WVhSb1BqeHdZWFJvSUdROUlrMHpPRFFnTkRnd2FETTROSFkyTkVnek9EUjZJRzB3TFRFNU1tZ3pPRFIyTmpSSU16ZzBlaUlnWm1sc2JEMGlJek16TXpNek15SWdjQzFwWkQwaU1qRTFNQ0krUEM5d1lYUm9Qand2YzNablBnPT1cIiBoZWlnaHQ9XCIyMFwiIGFsdD1cIlwiIGRyYWdnYWJsZT1cImZhbHNlXCI+XG5cdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImRyYWdfZWxlXCIgZGF0YS1pZD1cIjFcIj5cblx0XHRcdFx0PGltZyBzcmM9XCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQnpkR0Z1WkdGc2IyNWxQU0p1YnlJL1Bqd2hSRTlEVkZsUVJTQnpkbWNnVUZWQ1RFbERJQ0l0THk5WE0wTXZMMFJVUkNCVFZrY2dNUzR4THk5RlRpSWdJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MMGR5WVhCb2FXTnpMMU5XUnk4eExqRXZSRlJFTDNOMlp6RXhMbVIwWkNJK1BITjJaeUIwUFNJeE5qQXlNamszT0RZM05EY3dJaUJqYkdGemN6MGlhV052YmlJZ2RtbGxkMEp2ZUQwaU1DQXdJREV3TWpRZ01UQXlOQ0lnZG1WeWMybHZiajBpTVM0eElpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIQXRhV1E5SWpNMU1qWWlJSGh0Ykc1ek9uaHNhVzVyUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMM2hzYVc1cklpQjNhV1IwYUQwaU1qQXdJaUJvWldsbmFIUTlJakl3TUNJK1BHUmxabk0rUEhOMGVXeGxJSFI1Y0dVOUluUmxlSFF2WTNOeklqNDhMM04wZVd4bFBqd3ZaR1ZtY3o0OGNHRjBhQ0JrUFNKTk5EVTRMaklnTXpjeFNERXhNaTQyUXpnMkxqa2dNemN4SURZMklETTFNQzR4SURZMklETXlOQzQxVmpFMk5DNDVZekF0TWpVdU55QXlNQzQ1TFRRMkxqVWdORFl1TlMwME5pNDFhRE0wTlM0Mll6STFMamNnTUNBME5pNDFJREl3TGprZ05EWXVOU0EwTmk0MWRqRTFPUzQxWXpBdU1TQXlOUzQzTFRJd0xqZ2dORFl1TmkwME5pNDBJRFEyTGpaNlRURXhNaTQySURFMU9DNHpZeTB6TGpZZ01DMDJMallnTXkwMkxqWWdOaTQyZGpFMU9TNDFZekFnTXk0MklETWdOaTQySURZdU5pQTJMalpvTXpRMUxqWmpNeTQySURBZ05pNDJMVE1nTmk0MkxUWXVObFl4TmpRdU9XTXdMVE11TmkwekxUWXVOaTAyTGpZdE5pNDJTREV4TWk0MmVrMDVNVEF1TVNBNU1EaElNalU0TGpoakxUSTFMamNnTUMwME5pNDFMVEl3TGprdE5EWXVOUzAwTmk0MVZqVXhOUzQ1WXpBdE1qVXVOeUF5TUM0NUxUUTJMalVnTkRZdU5TMDBOaTQxYURZMU1TNHpZekkxTGpjZ01DQTBOaTQxSURJd0xqa2dORFl1TlNBME5pNDFkak0wTlM0Mll6QWdNalV1TnkweU1DNDRJRFEyTGpVdE5EWXVOU0EwTmk0MWVrMHlOVGd1T0NBMU1Ea3VNbU10TXk0MklEQXROaTQySURNdE5pNDJJRFl1Tm5Zek5EVXVObU13SURNdU5pQXpJRFl1TmlBMkxqWWdOaTQyYURZMU1TNHpZek11TmlBd0lEWXVOaTB6SURZdU5pMDJMalpXTlRFMUxqbGpNQzB6TGpZdE15MDJMall0Tmk0MkxUWXVOa2d5TlRndU9Ib2lJR1pwYkd3OUlpTTBSalJHTkVZaUlIQXRhV1E5SWpNMU1qY2lQand2Y0dGMGFENDhjR0YwYUNCa1BTSk5NakkxTGpVZ05qazFMak5vTFRVNUxqTmpMVEU0TGpNZ01DMHpNeTR5TFRFMExqa3RNek11TWkwek15NHhiQzB3TGpVdE16QTFMamhqTUMweE1TQTRMamt0TWpBZ01Ua3VPUzB5TUNBeE1TQXdJREU1TGprZ09DNDVJREU1TGprZ01Ua3VPV3d3TGpVZ01qazVMakZvTlRJdU4yTXhNU0F3SURFNUxqa2dPQzQ1SURFNUxqa2dNVGt1T1hNdE9DNDRJREl3TFRFNUxqa2dNakI2SWlCbWFXeHNQU0lqTkVZMFJqUkdJaUJ3TFdsa1BTSXpOVEk0SWo0OEwzQmhkR2crUEM5emRtYytcIiBoZWlnaHQ9XCIyMFwiIGFsdD1cIlwiIGRyYWdnYWJsZT1cImZhbHNlXCI+XG5cdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImRyYWdfZWxlXCIgZGF0YS1pZD1cIjJcIj5cblx0XHRcdFx0PGltZyBzcmM9XCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQnpkR0Z1WkdGc2IyNWxQU0p1YnlJL1Bqd2hSRTlEVkZsUVJTQnpkbWNnVUZWQ1RFbERJQ0l0THk5WE0wTXZMMFJVUkNCVFZrY2dNUzR4THk5RlRpSWdJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MMGR5WVhCb2FXTnpMMU5XUnk4eExqRXZSRlJFTDNOMlp6RXhMbVIwWkNJK1BITjJaeUIwUFNJeE5qQXpNRGd4T1RJeE1EZzBJaUJqYkdGemN6MGlhV052YmlJZ2RtbGxkMEp2ZUQwaU1DQXdJREV3TWpRZ01UQXlOQ0lnZG1WeWMybHZiajBpTVM0eElpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIQXRhV1E5SWpNeE1qRWlJSGh0Ykc1ek9uaHNhVzVyUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMM2hzYVc1cklpQjNhV1IwYUQwaU1qQXdJaUJvWldsbmFIUTlJakl3TUNJK1BHUmxabk0rUEhOMGVXeGxJSFI1Y0dVOUluUmxlSFF2WTNOeklqNDhMM04wZVd4bFBqd3ZaR1ZtY3o0OGNHRjBhQ0JrUFNKTk5qUXVOekV6T0RnMElEWTFNQzQwTURReU1XdzRPVEl1TmpnME1qTXlJREFnTUNBMU5TNHdOVE00TnpNdE9Ea3lMalk0TkRJek1pQXdJREF0TlRVdU1EVXpPRGN6V2lJZ2NDMXBaRDBpTXpFeU1pSStQQzl3WVhSb1BqeHdZWFJvSUdROUlrMDFNVEV1TURVM05UTTFJREl6Tnk0ME9EYzROemxzTkRRMkxqTTBNRFU0TVNBd0lEQWdOVFV1TURVMk9UUXpMVFEwTmk0ek5EQTFPREVnTUNBd0xUVTFMakExTmprME0xb2lJSEF0YVdROUlqTXhNak1pUGp3dmNHRjBhRDQ4Y0dGMGFDQmtQU0pOTVRnNUxqSXlOVFk0T1NBME9EUXVNelkzTmpZemJERTRPQzQ1TlRNME9TQXdJRFEyTGpJNE9ESXpNeUF4TVRRdU56UTRORFF4SURZMExqYzBNVFV4TXlBd1RETXhOaTR6TmprME16Z2dNVGM1TGprd05ETTVNMnd0TmpJdU5qazBPVEF4SURCTU9EQXVPRE16TURBeklEVTVPUzR4TVRZeE1ETnNOalF1TnpRek5UWWdNRXd4T0RrdU1qSTFOamc1SURRNE5DNHpOamMyTmpONlRUSTNOUzQyTkRrd01UUWdNall5TGpjeE9UVTBZekl1TnpNeE1qQTBMVFl1T0RVMk1UVXlJRFV1TVRjeU9ERXpMVEUyTGpVNU56QXdNeUEzTGpNeE9UY3dPUzB5T1M0eU1qazNNVGhzTVM0ME5qYzBNakVnTUdNeUxqVXpOVGMxTXlBeE15NDRPVFUwTnpVZ05DNDRPREF4TkRjZ01qTXVOak0yTXpJM0lEY3VNRE13TVRFMElESTVMakl5T1RjeE9HdzJPQzQxTkRreU16WWdNVGMwTGpJNE9EUTRPRXd5TURjdU5qZ3lNRFFnTkRNM0xqQXdPREF5T1NBeU56VXVOalE1TURFMElESTJNaTQzTVRrMU5Ib2lJSEF0YVdROUlqTXhNalFpUGp3dmNHRjBhRDQ4Y0dGMGFDQmtQU0pOTlRFeExqQTFOelV6TlNBek56VXVNVEk0TnpBemJEUTBOaTR6TkRBMU9ERWdNQ0F3SURVMUxqQTFNemczTXkwME5EWXVNelF3TlRneElEQWdNQzAxTlM0d05UTTROek5hSWlCd0xXbGtQU0l6TVRJMUlqNDhMM0JoZEdnK1BIQmhkR2dnWkQwaVRUWTBMamN4TXpnNE5DQTNPRGd1TURRd09UUnNPRGt5TGpZNE5ESXpNaUF3SURBZ05UVXVNRFUwT0RrM0xUZzVNaTQyT0RReU16SWdNQ0F3TFRVMUxqQTFORGc1TjFvaUlIQXRhV1E5SWpNeE1qWWlQand2Y0dGMGFENDhjR0YwYUNCa1BTSk5OVEV4TGpBMU56VXpOU0ExTVRJdU56WTJORFUyYkRRME5pNHpOREExT0RFZ01DQXdJRFUxTGpBMU5EZzVOeTAwTkRZdU16UXdOVGd4SURBZ01DMDFOUzR3TlRRNE9UZGFJaUJ3TFdsa1BTSXpNVEkzSWo0OEwzQmhkR2crUEM5emRtYytcIiBoZWlnaHQ9XCIyMFwiIGFsdD1cIlwiIGRyYWdnYWJsZT1cImZhbHNlXCI+XG5cdFx0XHQ8L3NwYW4+XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0PHNwYW4gY2xhc3M9XCJzYXZlXCIgQGNsaWNrPVwic2F2ZVwiPlxuXHRcdFx0XHQ8aW1nIHNyYz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCemRHRnVaR0ZzYjI1bFBTSnVieUkvUGp3aFJFOURWRmxRUlNCemRtY2dVRlZDVEVsRElDSXRMeTlYTTBNdkwwUlVSQ0JUVmtjZ01TNHhMeTlGVGlJZ0ltaDBkSEE2THk5M2QzY3Vkek11YjNKbkwwZHlZWEJvYVdOekwxTldSeTh4TGpFdlJGUkVMM04yWnpFeExtUjBaQ0krUEhOMlp5QjBQU0l4TmpBeU1qazRNREExTnpBeUlpQmpiR0Z6Y3owaWFXTnZiaUlnZG1sbGQwSnZlRDBpTUNBd0lERXdNalFnTVRBeU5DSWdkbVZ5YzJsdmJqMGlNUzR4SWlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhBdGFXUTlJalEwTVRRaUlIaHRiRzV6T25oc2FXNXJQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUwzaHNhVzVySWlCM2FXUjBhRDBpTWpBd0lpQm9aV2xuYUhROUlqSXdNQ0krUEdSbFpuTStQSE4wZVd4bElIUjVjR1U5SW5SbGVIUXZZM056SWo0OEwzTjBlV3hsUGp3dlpHVm1jejQ4Y0dGMGFDQmtQU0pOT0RrMUxqZ3pJRFl5TGpFd01tTXpNUzQzTmpFZ05TNHlPVFFnTlRJdU9UTTFJREkyTGpRMk9DQTJNQzQ0TnpZZ05USXVPVE0xSURjdU9UUWdNVGd1TlRJM0lEVXVNamswSURneUxqQTBPU0ExTGpJNU5DQXhNRGd1TlRFM2RqWXhOaTQyT1RWak1DQXhPQzQxTWpjZ01DQTBNaTR6TkRrdE1pNDJORGNnTlRVdU5UZ3lMVEl1TmpRM0lETXhMamMyTVMweU15NDRNakVnTlRJdU9UTTFMVFV3TGpJNE9DQTJNQzQ0TnpZdE1UZ3VOVEkzSURjdU9UUXRPRFF1TmprM0lEVXVNamswTFRFd09DNDFNVGNnTlM0eU9UUXRNakEyTGpRME55QXdMVFF4TWk0NE9UVWdNQzAyTVRrdU16UXlJREF0TVRVdU9EZ3hJREF0TXprdU56QXhJREF0TlRVdU5UZ3lMVEl1TmpRM0xUSTVMakV4TlMweUxqWTBOeTAxTWk0NU16VXRNak11T0RJeExUWXdMamczTmkwMU1DNHlPRGd0TlM0eU9UUXRNVGd1TlRJM0xUSXVOalEzTFRnMExqWTVOeTB5TGpZME55MHhNRGd1TlRFM2RpMDJNVGt1TXpReVl6QXRNVFV1T0RneElEQXRNemN1TURVMUlEQXROVEl1T1RNMUlEVXVNamswTFRNeExqYzJNU0F5Tmk0ME5qY3ROVEl1T1RNMUlEVXlMamt6TlMwMk15NDFNaklnTVRndU5USTNMVFV1TWprMElEZ3lMakEwT1MweUxqWTBOeUF4TURndU5URTNMVEl1TmpRM0lESXdOaTQwTkRjZ01DQTBNVEF1TWpRNElEQWdOakUyTGpZNU5TQXdJREUxTGpnNE1TQXdJRE01TGpjd01TQXdJRFUxTGpVNE1pQXdlazB6TXpRdU56RTVJRE0yTVM0eE9EWm9NelUwTGpZMk5tTXhNQzQxT0RjZ01DQXhNeTR5TXpRdE5TNHlPVFFnTVRNdU1qTTBMVEV6TGpJek5IWXRNak13TGpJMk9HZ3RNemd4TGpFek0zWXlNakl1TXpJNFl6QWdNVFV1T0RneExUSXVOalEzSURJeExqRTNNeUF4TXk0eU16UWdNakV1TVRjemVrMDNOVGd1TWlBeE1UY3VOamcwZGpJME9DNDNPVFpqTUNBek55NHdOVFV0Tnk0NU5DQTFNQzR5T0RndE5EUXVPVGswSURVd0xqSTRPQzA1Tnk0NU15QXdMVE0zTUM0MU5EWWdNQzAwTVRndU1UZzRJREF0TWpFdU1UY3pJREF0TWprdU1URTFMVEV3TGpVNE55MHlPUzR4TVRVdE16Y3VNRFUxZGkweU5qSXVNREk1WXkwek1TNDNOakVnTUMwNE5DNDJPVGNnTUMweE1UWXVORFU0SURBdE1UVXVPRGd4SURBdE1qWXVORFkzSURBdE1qa3VNVEUxSURFd0xqVTROeTB5TGpZME55QTNMamswTFRJdU5qUTNJREV6Tnk0Mk16SXRNaTQyTkRjZ01UVTJMakUxT0hZMU9USXVPRGMwWXpBZ01UTXVNak0wSURBZ01qTXVPREl4SURFekxqSXpOQ0F5Tmk0ME5qY2dOUzR5T1RRZ01pNDJORGNnTVRNM0xqWXpNaUF5TGpZME55QXhOVFl1TVRVNElESXVOalEzSURVeUxqa3pOU0F3SURVNExqSXlPQ0F3SURFeE1TNHhOalFnTUhZdE1UYzVMamszT1dneU1qY3VOakl4ZGpFM09TNDVOemxqTnpRdU1UQTVJREFnTVRFeExqRTJOQ0F3SURFNE55NDVNaUF3SURFd0xqVTROeUF3SURjMExqRXdPU0F3SURjNUxqUXdNeTB5TGpZME55QXhNQzQxT0RjdE1pNDJORGNnTVRNdU1qTTBMVEV3TGpVNE55QXhNeTR5TXpRdE1qWXVORFkzZGkwMk5qa3VOak5qTUMweE15NHlNelFnTUMwMk9DNDRNVFV0TWk0Mk5EY3ROell1TnpVMkxUSXVOalEzTFRFekxqSXpOQzB4T0M0MU1qY3RNVE11TWpNMExUSTJMalEyTnkweE15NHlNelF0TXpRdU5EQTRJREF0T0RRdU5qazNJREl1TmpRM0xURXhPUzR4TURRZ01IcE5ORFV6TGpneU15QTVNRE11TnpjeWJERXhOaTQwTlRnZ01pNDJORGQyTFRFeU5DNHpPVGhvTFRFeE5pNDBOVGgyTVRJeExqYzFNWG9pSUhBdGFXUTlJalEwTVRVaVBqd3ZjR0YwYUQ0OEwzTjJaejQ9XCJcblx0XHRcdFx0aGVpZ2h0PVwiMjBcIiBhbHQ9XCJcIiBkcmFnZ2FibGU9XCJmYWxzZVwiPlxuXG5cdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImRvd25sb2FkXCIgQGNsaWNrPVwiZG93bmxvYWRcIj5cblx0XHRcdFx0PGltZyBzcmM9XCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQnpkR0Z1WkdGc2IyNWxQU0p1YnlJL1Bqd2hSRTlEVkZsUVJTQnpkbWNnVUZWQ1RFbERJQ0l0THk5WE0wTXZMMFJVUkNCVFZrY2dNUzR4THk5RlRpSWdJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MMGR5WVhCb2FXTnpMMU5XUnk4eExqRXZSRlJFTDNOMlp6RXhMbVIwWkNJK1BITjJaeUIwUFNJeE5qQXlNemsxTlRVek5qUXdJaUJqYkdGemN6MGlhV052YmlJZ2RtbGxkMEp2ZUQwaU1DQXdJREV3TWpRZ01UQXlOQ0lnZG1WeWMybHZiajBpTVM0eElpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIQXRhV1E5SWpJME1Ea2lJSGh0Ykc1ek9uaHNhVzVyUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMM2hzYVc1cklpQjNhV1IwYUQwaU1qQXdJaUJvWldsbmFIUTlJakl3TUNJK1BHUmxabk0rUEhOMGVXeGxJSFI1Y0dVOUluUmxlSFF2WTNOeklqNDhMM04wZVd4bFBqd3ZaR1ZtY3o0OGNHRjBhQ0JrUFNKTk9ETXlMakVnTlRreUxqZGpMVEV4SURBdE1qQWdPUzB5TUNBeU1IWXhOVEV1TW1Nd0lERXhMVGtnTWpBdE1qQWdNakJJTWpNeExqbGpMVEV4SURBdE1qQXRPUzB5TUMweU1GWTJNVEl1TjJNd0xURXhMVGt0TWpBdE1qQXRNakJ6TFRJd0lEa3RNakFnTWpCMk1UVXhMakpqTUNBek15NHhJREkyTGprZ05qQWdOakFnTmpCSU56a3lZek16TGpFZ01DQTJNQzB5Tmk0NUlEWXdMVFl3VmpZeE1pNDNZekF1TVMweE1TMDRMamt0TWpBdE1Ua3VPUzB5TUhvaUlIQXRhV1E5SWpJME1UQWlQand2Y0dGMGFENDhjR0YwYUNCa1BTSk5ORFk0TGpNZ05qVTRMalpqTVRFdU15QXhNUzQ1SURJM0xqSWdNVGd1TnlBME15NDJJREU0TGpjZ01UWXVOQ0F3SURNeUxqTXROaTQ0SURRekxqWXRNVGd1T0d3NU9TNHhMVEV3TkM0M1l6Y3VOaTA0SURjdU1pMHlNQzQzTFRBdU9DMHlPQzR6TFRndE55NDJMVEl3TGpjdE55NHlMVEk0TGpNZ01DNDRiQzA1TXk0MklEazRMamxXTWpJd1l6QXRNVEV0T1MweU1DMHlNQzB5TUhNdE1qQWdPUzB5TUNBeU1IWTBNRFV1TW13dE9UTXVOQzA1T0M0Mll5MDNMall0T0MweU1DNHpMVGd1TkMweU9DNHpMVEF1T0MwNElEY3VOaTA0TGpRZ01qQXVNeTB3TGpnZ01qZ3VNMnc1T0M0NUlERXdOQzQxZWlJZ2NDMXBaRDBpTWpReE1TSStQQzl3WVhSb1Bqd3ZjM1puUGc9PVwiIGhlaWdodD1cIjIwXCIgYWx0PVwiXCIgZHJhZ2dhYmxlPVwiZmFsc2VcIj5cblx0XHRcdDwvc3Bhbj5cblx0XHRcdDxzcGFuIGNsYXNzPVwianNvblwiIEBjbGljaz1cImpzU2hvd1wiPlxuXHRcdFx0XHQ8aW1nIHNyYz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCemRHRnVaR0ZzYjI1bFBTSnVieUkvUGp3aFJFOURWRmxRUlNCemRtY2dVRlZDVEVsRElDSXRMeTlYTTBNdkwwUlVSQ0JUVmtjZ01TNHhMeTlGVGlJZ0ltaDBkSEE2THk5M2QzY3Vkek11YjNKbkwwZHlZWEJvYVdOekwxTldSeTh4TGpFdlJGUkVMM04yWnpFeExtUjBaQ0krUEhOMlp5QjBQU0l4TmpBek16Z3lOemd6TXpZMUlpQmpiR0Z6Y3owaWFXTnZiaUlnZG1sbGQwSnZlRDBpTUNBd0lERXdNalFnTVRBeU5DSWdkbVZ5YzJsdmJqMGlNUzR4SWlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhBdGFXUTlJakkzTWpnaUlIaHRiRzV6T25oc2FXNXJQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUwzaHNhVzVySWlCM2FXUjBhRDBpTWpBd0lpQm9aV2xuYUhROUlqSXdNQ0krUEdSbFpuTStQSE4wZVd4bElIUjVjR1U5SW5SbGVIUXZZM056SWo0OEwzTjBlV3hsUGp3dlpHVm1jejQ4Y0dGMGFDQmtQU0pOTWpFMkxqUWdNVEEzTGpGb05UQXVNbU0xTGpjZ01DQXhNQzQwSURRdU55QXhNQzQwSURFd0xqUldNVFUyWXpBZ05TNDNMVFF1TnlBeE1DNDBMVEV3TGpRZ01UQXVOR2d0TkRVdU9HTXROUzQzSURBdE1UTXVOQ0EwTGpZdE1UTXVOQ0F4TUM0MGJDMHhJREkwTmk0Mll5MHhMak1nTXpVdU1pMHlOUzR4SURrd0xUVTRMallnT1RFdU5DQXlNeTR5TFRFZ05Ua3VOaUF6T1M0MUlEVTVMallnT0RrdU5Hd3RNU0F5TkRJdU5HTXdJRFV1T0NBMExqY2dNVGt1TmlBeE1DNDJJREU1TGpab05Ea3VNMk0xTGprZ01DQXhNQzQ0SURZdU9DQXhNQzQ0SURFeUxqaDJNekF1T1dNd0lEVXVPUzAwTGpnZ01UQXVPQzB4TUM0NElERXdMamhvTFRRNUxqaGpMVE15TGpRdE1USXVNaTAyTUM0MkxUUXdMamN0TmpBdU5pMDVNQzQwZGkweE9ERmpNQzAwT1M0NUxUSTNMakV0T1RBdU5DMDJNQzQyTFRrd0xqUklOemN1TVdNdE5pNDRJREF0TVRJdU1pMDFMalV0TVRJdU1pMHhNaTR5ZGkwMk5TNDVZekF0Tmk0NElEVXVOUzB4TWk0eUlERXlMakl0TVRJdU1tZ3hPQzR4WXpNekxqVWdNQ0EyTUM0MkxUUXdMalVnTmpBdU5pMDVNQzQwVmpFNU55NDBZekF0TkRrdU9TQXlOeTR4TFRrd0xqTWdOakF1TmkwNU1DNHpUVGd3T0M0MklERXdOeTR4WXpNekxqVWdNQ0EyTUM0MklEUXdMalFnTmpBdU5pQTVNQzR6ZGpFNE1DNDRZekFnTkRrdU9TQXlOeTR4SURrd0xqUWdOakF1TmlBNU1DNDBhREU0TGpGak5pNDNJREFnTVRJdU1pQTFMalFnTVRJdU1pQXhNaTR5ZGpZMUxqbGpNQ0EyTGpjdE5TNDBJREV5TGpJdE1USXVNaUF4TWk0eWFDMHhPQzR5WXkwek15NDFJREF0TmpBdU5pQTBNQzQxTFRZd0xqWWdPVEF1TkhZeE9ERmpNQ0EwT1M0M0xUSTRMaklnTnpndU1pMDJNQzQySURrd0xqUm9MVFE1TGpoakxUWWdNQzB4TUM0NExUUXVPUzB4TUM0NExURXdMamhXT0RjNVl6QXROaUEwTGprdE1USXVPQ0F4TUM0NExURXlMamhJT0RBNFl6VXVPU0F3SURFd0xqWXRNVE11T0NBeE1DNDJMVEU1TGpac0xURXRNalF5TGpSak1DMDBPUzQ1SURNMkxqUXRPVEF1TkNBMU9TNDJMVGc1TGpRdE16TXVOUzB4TGpRdE5UY3VNeTAxTmk0eUxUVTRMall0T1RFdU5Hd3RNUzB5TkRZdU5tTXdMVFV1T0MwM0xqY3RNVEF1TkMweE15NDBMVEV3TGpSb0xUUTFMamhqTFRVdU55QXdMVEV3TGpRdE5DNDNMVEV3TGpRdE1UQXVOSFl0TXpndU5XTXdMVFV1TnlBMExqY3RNVEF1TkNBeE1DNDBMVEV3TGpSb05UQXVNazAxTURndU5DQTJOamN1T0dNeE5pNDRJREFnTXpBdU5DQXhNeTQySURNd0xqUWdNekF1TkNBd0lERTJMamd0TVRNdU5pQXpNQzQwTFRNd0xqUWdNekF1TkMweE5pNDRJREF0TXpBdU5DMHhNeTQyTFRNd0xqUXRNekF1TkNBd0xURTJMamdnTVRNdU5pMHpNQzQwSURNd0xqUXRNekF1TkUwek9EWXVPQ0EyTmpjdU9HTXhOaTQ0SURBZ016QXVOQ0F4TXk0MklETXdMalFnTXpBdU5DQXdJREUyTGpndE1UTXVOaUF6TUM0MExUTXdMalFnTXpBdU5DMHhOaTQ0SURBdE16QXVOQzB4TXk0MkxUTXdMalF0TXpBdU5DQXdMVEUyTGpnZ01UTXVOaTB6TUM0MElETXdMalF0TXpBdU5FMDJNekFnTmpZM0xqaGpNVFl1T0NBd0lETXdMalFnTVRNdU5pQXpNQzQwSURNd0xqUWdNQ0F4Tmk0NExURXpMallnTXpBdU5DMHpNQzQwSURNd0xqUXRNVFl1T0NBd0xUTXdMalF0TVRNdU5pMHpNQzQwTFRNd0xqUWdNQzB4Tmk0NElERXpMall0TXpBdU5DQXpNQzQwTFRNd0xqUjZJaUJ3TFdsa1BTSXlOekk1SWo0OEwzQmhkR2crUEM5emRtYytcIlxuXHRcdFx0XHRoZWlnaHQ9XCIyMFwiIGFsdD1cIlwiIGRyYWdnYWJsZT1cImZhbHNlXCI+XG5cblx0XHRcdDwvc3Bhbj5cblxuXG5cdFx0PC9kaXY+XG5cdFx0PGRpdiBpZD1cInFjYW52YXNfbGF5XCIgdi1iaW5kOnN0eWxlPVwieydoZWlnaHQnOmluaXRIZWlnaHQrJ3B4J31cIj5cblx0XHRcdDxjYW52YXMgaWQ9XCJxY2FudmFzXCI+PC9jYW52YXM+XG5cdFx0XHQ8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cInRpdGxlSW5wdXRcIiB2LW1vZGVsPVwibm9kZVRpdGxlXCIgQGlucHV0PVwibW9kaVRpdGxlXCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgQGtleXVwLmVudGVyPVwib25TdWJtaXRcIj5cblx0XHRcdDxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwiY29udGFpbmVyR3JpZENvbHVtblwiIHYtbW9kZWwubnVtYmVyPVwiY29udGFpbmVyR3JpZENvbHVtblwiIEBpbnB1dD1cIm1vZGlDb250YWluZXJHcmlkQ29sdW1uXCIgYXV0b2NvbXBsZXRlPVwib2ZmXCI+XG5cdFx0XHQ8dGV4dGFyZWEgbmFtZT1cIlwiIGlkPVwidGlwXCIgdi1tb2RlbD1cInRpcFRleHRcIiBAaW5wdXQ9XCJtb2RUaXAoJGV2ZW50KVwiPjwvdGV4dGFyZWE+XG5cblx0XHRcdDxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwibGluZVRpdGxlSW5wdXRcIiB2LW1vZGVsPVwibGluZU5vZGVUaXRsZVwiIEBpbnB1dD1cIm1vZGlMaW5lVGl0bGVcIiBhdXRvY29tcGxldGU9XCJvZmZcIj5cblx0XHRcdDxzZWxlY3QgaWQ9XCJsaW5lTGlrZVwiIHYtbW9kZWw9XCJsaW5lTGlrZVwiIEBjaGFuZ2U9XCJtb2RpTGluZUxpa2VcIiBhdXRvY29tcGxldGU9XCJvZmZcIj5cblx0XHRcdFx0PG9wdGlvbiB2LWZvcj1cIml0ZW0gaW4gbGluZVN0eWxlTGlzdFwiIDp2YWx1ZT1cIml0ZW0udmFsdWVcIj57e2l0ZW0ubmFtZX19PC9vcHRpb24+IFxuXHRcdFx0PC9zZWxlY3Q+XG5cdFx0XHQ8c2VsZWN0IGlkPVwibGluZVR5cGVcIiB2LW1vZGVsPVwibGluZVR5cGVcIiBAY2hhbmdlPVwibW9kaUxpbmVUeXBlXCIgYXV0b2NvbXBsZXRlPVwib2ZmXCI+XG5cdFx0XHRcdDxvcHRpb24gdi1mb3I9XCJpdGVtIGluIGxpbmVUeXBlTGlzdFwiIDp2YWx1ZT1cIml0ZW0udmFsdWVcIj57e2l0ZW0ubmFtZX19PC9vcHRpb24+IFxuXHRcdFx0PC9zZWxlY3Q+XG5cblx0XHRcdDwhLS0gPGRpdiBjbGFzcz1cInNoZWV0TGF5XCI+XG5cdFx0XHRcdDxzcGFuIHYtZm9yPVwiaXRlbSBpbiBzaGVldHNcIj57e2l0ZW0ubmFtZX19PC9zcGFuPlxuXHRcdFx0PC9kaXY+IC0tPlxuXHRcdDwvZGl2PlxuXG5cdFx0PGVsLWRpYWxvZ1xuXHRcdCAgICB0aXRsZT1cImpzb27mlbDmja5cIlxuXHRcdCAgICA6dmlzaWJsZS5zeW5jPVwic2hvd1wiXG5cdFx0ICAgIHdpZHRoPVwiMzAlXCJcblx0XHQgICAgQGNsb3NlPVwiY2xvc2VcIj5cblx0XHQgICAgPGRpdiBjbGFzcz1cImpzb25fbGF5XCI+XG5cdFx0ICAgIFx0e3tqc29ufX1cblx0XHQgICAgPC9kaXY+XG5cdFx0ICAgIFxuXHRcdDwvZWwtZGlhbG9nPlxuXHQ8L2Rpdj5cbjwvdGVtcGxhdGU+XG48c2NyaXB0PiBcbmltcG9ydCBWdWUgZnJvbSAndnVlJztcblxuXHRpbXBvcnQge0RpYWxvZ30gZnJvbSAnZWxlbWVudC11aSdcblx0VnVlLnVzZShEaWFsb2cpO1xuXHRpbXBvcnQge0RyYWd9IGZyb20gJy4vbGliL0RyYWcuanMnOyBcblx0aW1wb3J0IHtRZmxvd30gZnJvbSAnLi9saWIvUWZsb3cuanMnO1xuXG5cblx0dmFyIHFmbG93O1xuXG5cdGV4cG9ydCBkZWZhdWx0e1xuXHRcdG5hbWU6XCJxcmVsYXRpb25cIixcblx0XHRjb21wb25lbnRzOnt9LFxuXHRcdHByb3BzOlsnaW5pdFdpZHRoJywnaW5pdEhlaWdodCcsJ2pzb25EYXRhJywnc2F2ZUZ1biddLFxuXHRcdGRhdGEoKXtcblx0XHRcdHJldHVybiB7XG5cdFx0XHQgIFx0Y3VycjowLFxuXHRcdFx0ICBcdHNoZWV0czpbXG5cdFx0XHQgIFx0XHR7XG5cdFx0XHQgIFx0XHRcdG5hbWU6J3NoZWV0MScsXG5cdFx0XHQgIFx0XHR9XG5cdFx0XHQgIFx0XSxcblx0ICBcdFx0XHRub2RlVGl0bGU6JycsXG5cdCAgXHRcdFx0bGluZU5vZGVUaXRsZTon5qCH6aKYJyxcblx0ICBcdFx0XHRsaW5lVHlwZTonJyxcblx0ICBcdFx0XHRsaW5lVHlwZUxpc3Q6W1xuXHQgIFx0XHRcdFx0e1xuXHRcdCAgXHRcdFx0XHRuYW1lOifnm7Tnur8nLFxuXHRcdCAgXHRcdFx0XHR2YWx1ZTonbGluZSdcblx0ICBcdFx0XHRcdH0sXG5cdCAgXHRcdFx0XHR7XG5cdFx0ICBcdFx0XHRcdG5hbWU6J+S6jOasoeabsue6vycsXG5cdFx0ICBcdFx0XHRcdHZhbHVlOidxdWFkcmF0aWNDdXJ2ZSdcblx0ICBcdFx0XHRcdH0sXG5cdCAgXHRcdFx0XHR7XG5cdFx0ICBcdFx0XHRcdG5hbWU6J+S4ieasoeabsue6vycsXG5cdFx0ICBcdFx0XHRcdHZhbHVlOidiZXppZXJDdXJ2ZSdcblx0ICBcdFx0XHRcdH0sXG5cdCAgXHRcdFx0XHR7XG5cdFx0ICBcdFx0XHRcdG5hbWU6J+aKmOe6vyjmqKrlkJEpJyxcblx0XHQgIFx0XHRcdFx0dmFsdWU6J2ZvbGRMaW5lMSdcblx0ICBcdFx0XHRcdH0sXG5cdCAgXHRcdFx0XHR7XG5cdFx0ICBcdFx0XHRcdG5hbWU6J+aKmOe6vyjnq5blkJEpJyxcblx0XHQgIFx0XHRcdFx0dmFsdWU6J2ZvbGRMaW5lMidcblx0ICBcdFx0XHRcdH1cblx0ICBcdFx0XHRdLFxuXHQgIFx0XHRcdGxpbmVMaWtlOicnLFxuXHQgIFx0XHRcdGxpbmVTdHlsZUxpc3Q6W1xuXHQgIFx0XHRcdFx0e1xuXHQgIFx0XHRcdFx0XHRuYW1lOictJyxcblx0ICBcdFx0XHRcdFx0dmFsdWU6Jy0nXG5cdCAgXHRcdFx0XHR9LFxuXHQgIFx0XHRcdFx0e1xuXHQgIFx0XHRcdFx0XHRuYW1lOictPicsXG5cdCAgXHRcdFx0XHRcdHZhbHVlOictPidcblx0ICBcdFx0XHRcdH0sXG5cdCAgXHRcdFx0XHR7XG5cdCAgXHRcdFx0XHRcdG5hbWU6JzwtJyxcblx0ICBcdFx0XHRcdFx0dmFsdWU6JzwtJ1xuXHQgIFx0XHRcdFx0fSxcblx0ICBcdFx0XHRcdHtcblx0ICBcdFx0XHRcdFx0bmFtZTonPC0+Jyxcblx0ICBcdFx0XHRcdFx0dmFsdWU6JzwtPidcblx0ICBcdFx0XHRcdH0sXG5cdCAgXHRcdFx0XHR7XG5cdCAgXHRcdFx0XHRcdG5hbWU6Jy0tJyxcblx0ICBcdFx0XHRcdFx0dmFsdWU6Jy0tJ1xuXHQgIFx0XHRcdFx0fSxcblx0ICBcdFx0XHRcdHtcblx0ICBcdFx0XHRcdFx0bmFtZTonPC0tJyxcblx0ICBcdFx0XHRcdFx0dmFsdWU6JzwtLSdcblx0ICBcdFx0XHRcdH0sXG5cdCAgXHRcdFx0XHR7XG5cdCAgXHRcdFx0XHRcdG5hbWU6Jy0tPicsXG5cdCAgXHRcdFx0XHRcdHZhbHVlOictLT4nXG5cdCAgXHRcdFx0XHR9LFxuXHQgIFx0XHRcdFx0e1xuXHQgIFx0XHRcdFx0XHRuYW1lOic8LS0+Jyxcblx0ICBcdFx0XHRcdFx0dmFsdWU6JzwtLT4nXG5cdCAgXHRcdFx0XHR9LFxuXHQgIFx0XHRcdF0sXG5cdCAgXHRcdFx0Y29udGFpbmVyR3JpZENvbHVtbjoxLFxuXHQgIFx0XHRcdHNob3c6ZmFsc2UsXG5cdCAgXHRcdFx0anNvbjonJyxcblx0ICBcdFx0XHR0aXBUZXh0OicnXG5cblx0XHQgIH1cblx0XHR9LFxuXHRcdG1ldGhvZHM6e1xuXHRcdFx0b25TdWJtaXQ6ZnVuY3Rpb24oKXtcblx0XHQgIFx0XHRxZmxvdy5jb250ZXh0U2V0dGluZ0hpZGUoKTtcblx0XHQgIFx0fSxcblx0XHRcdGpzU2hvdzpmdW5jdGlvbigpe1xuXHRcdFx0XHR0aGlzLmpzb24gPSBKU09OLnN0cmluZ2lmeShxZmxvdy5yZXR1cm5TYXZlRGF0YSgpKTtcblx0XHRcdFx0dGhpcy5zaG93ID0gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHRjbG9zZTpmdW5jdGlvbigpe1xuXHRcdFx0XHR0aGlzLnNob3cgPSBmYWxzZVxuXHRcdFx0fSxcblx0XHRcdGRvd25sb2FkOmZ1bmN0aW9uKCl7XG5cdFx0ICBcdFx0cWZsb3cuZG93bmxvYWQoKTtcblx0XHQgIFx0fSxcblx0XHRcdHNhdmU6ZnVuY3Rpb24oKXsgXG5cblx0XHQgIFx0XHR0aGlzLnNhdmVGdW4gJiYgdGhpcy5zYXZlRnVuKHFmbG93LnJldHVyblNhdmVEYXRhKCkpO1xuXHRcdCAgXHR9LFx0XG5cdFx0ICBcdG1vZGlUaXRsZTpmdW5jdGlvbigpe1xuXHRcdCAgXHRcdHFmbG93Lm1vZGlUaXRsZSh0aGlzLm5vZGVUaXRsZSk7XG5cdFx0ICBcdH0sXG5cdFx0ICBcdG1vZGlMaW5lVGl0bGU6ZnVuY3Rpb24oKXtcblx0XHQgIFx0XHRxZmxvdy5tb2RpTGluZVRpdGxlKHRoaXMubGluZU5vZGVUaXRsZSk7XG5cdFx0ICBcdH0sXG5cdFx0ICBcdG1vZGlMaW5lTGlrZTpmdW5jdGlvbigpe1xuXHRcdCAgXHRcdHFmbG93Lm1vZGlMaW5lTGlrZSh0aGlzLmxpbmVMaWtlKTtcblx0XHQgIFx0fSxcblx0XHQgIFx0bW9kaUxpbmVUeXBlOmZ1bmN0aW9uKCl7XG5cblx0XHQgIFx0XHRxZmxvdy5tb2RpTGluZVR5cGUodGhpcy5saW5lVHlwZSk7XG5cdFx0ICBcdH0sXG5cdFx0ICBcdG1vZFRpcDpmdW5jdGlvbihlKXtcblx0XHQgIFx0XHR2YXIgZWxlbSA9IGUudGFyZ2V0O1xuXHRcdCAgXHRcdGVsZW0uc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuXHQgICAgICAgICAgICBlbGVtLnNjcm9sbFRvcCA9IDA7IC8v6Ziy5oqW5YqoXG5cdCAgICAgICAgICAgIGVsZW0uc3R5bGUuaGVpZ2h0ID0gZWxlbS5zY3JvbGxIZWlnaHQgKyAncHgnOyBcblxuXHQgICAgICAgICAgICBxZmxvdy51cGRhdGVUaXBUZXh0KGVsZW0udmFsdWUscGFyc2VJbnQoZWxlbS5zdHlsZS5oZWlnaHQpKTtcblxuXHRcdCAgXHRcdC8vIGNvbnNvbGUubG9nKHRoaXMudGlwVGV4dCk7XG5cdFx0ICBcdFx0Ly8gdmFyIHRpcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aXAnKTtcblx0XHQgIFx0XHQvLyB0aXAuc3R5bGUuaGVpZ2h0ID0gdGlwLnNjcm9sbFRvcCArIHRpcC5zY3JvbGxIZWlnaHQgKyBcInB4XCI7XG5cblx0XHQgIFx0XHQvLyB0aGlzLnRpcFRleHQgPSB0aGlzLnRpcFRleHQucmVwbGFjZSgvIC9nLCAnJyk7XG5cblx0XHQgIFx0XHQvLyAvLyBxZmxvdy51cGRhdGVUaXBUZXh0KHRoaXMudGlwVGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpLHBhcnNlSW50KHRpcC5zdHlsZS5oZWlnaHQpKTtcblx0XHQgIFx0XHQvLyBxZmxvdy51cGRhdGVUaXBUZXh0KHRoaXMudGlwVGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgJycpLHBhcnNlSW50KHRpcC5zdHlsZS5oZWlnaHQpKTtcblxuXG5cdFx0ICBcdH0sXG5cdFx0ICBcdG1vZGlDb250YWluZXJHcmlkQ29sdW1uOmZ1bmN0aW9uKCl7XG5cblx0XHQgIFx0XHRpZih0aGlzLmNvbnRhaW5lckdyaWRDb2x1bW4gPT0nJyB8fCBcblx0XHQgIFx0XHRcdHRoaXMuY29udGFpbmVyR3JpZENvbHVtbiA9PTApe1xuXG5cdFx0ICBcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0ICBcdFx0fSBcblx0XHRcdCAgXHRxZmxvdy5tb2RpQ29udGFpbmVyR3JpZENvbHVtbih0aGlzLmNvbnRhaW5lckdyaWRDb2x1bW4pO1xuXHRcdCAgXHRcdFxuXG5cdFx0ICBcdH0sXG5cdFx0ICBcdGluaXQ6ZnVuY3Rpb24oKXtcblx0XHQgIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdCAgXHRcdHFmbG93ID0gbmV3IFFmbG93KHtcblx0XHRcdFx0XHRpZDoncWNhbnZhcycsXG5cdFx0XHRcdFx0d2lkdGg6X3RoaXMuaW5pdFdpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDpfdGhpcy5pbml0SGVpZ2h0LFxuXHRcdFx0XHRcdGluaXREYXRhOl90aGlzLmpzb25EYXRhW190aGlzLmN1cnJdLFxuXHRcdFx0XHRcdC8vIFFjYW52YXM6UWNhbnZhc1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdG5ldyBEcmFnKHsgXG5cdFx0XHQgICAgICAgICAgZHJhZ0FpbUNsYXNzOlwiZHJhZ19lbGVcIixcblx0XHRcdCAgICAgICAgICBtb3ZlRnVuOih4LHkpPT57IFxuXHRcdFx0ICAgICAgICAgIFx0Ly8gY29uc29sZS5sb2coeCx5KTtcblx0XHRcdCAgICAgICAgICB9LFxuXHRcdFx0ICAgICAgICAgIHVwRnVuOihvYmopPT57IFxuXHRcdFx0ICAgICAgICAgIFx0aWYob2JqLnkgPiA0MCAmJiBvYmoueD4wKXtcblxuXHRcdFx0ICAgICAgICAgIFx0XHQvL+i9rOaNouWIsOeUu+W4g+eahOWdkOagh1xuXHRcdFx0ICAgICAgICAgIFx0XHQvLyBvYmoueSArPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdxY2FudmFzX2xheScpLnNjcm9sbFRvcDtcblx0XHRcdCAgICAgICAgICBcdFx0Ly8gb2JqLnggKz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncWNhbnZhc19sYXknKS5zY3JvbGxMZWZ0O1xuXG5cdFx0XHRcdCBcdFx0XHRxZmxvdy5hZGRFbGUob2JqKTtcblx0XHRcdCAgICAgICAgICBcdH1cblxuXHRcdFx0ICAgICAgICAgIH1cblx0XHRcdCAgICAgIH0pXG5cdFx0ICBcdH1cblxuXHRcdH0sXG5cdFx0bW91bnRlZCgpe1xuXHRcdFx0Ly8gY29uc29sZS5sb2coRHJhZyk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyhRY2FudmFzKTtcblxuXHRcdFx0dGhpcy5pbml0KCk7XG5cdFx0fSxcblx0XHRjcmVhdGVkKCl7XG5cdFx0XHRcblx0XHR9LFxuXHRcdGNvbXB1dGVkOntcblxuXHRcdH0sXG5cdFx0d2F0Y2g6e1xuXG5cdFx0fSxcblx0XHQvLyDplIDmr4Hnm5HlkKzkuovku7Zcblx0XHRkZXN0cm95ZWQoKSB7XG5cdFx0ICBxZmxvdyAhPT0gbnVsbCAmIHFmbG93LmRlc3Ryb3koKTtcblxuXHRcdCAgcWZsb3cgPSBudWxsO1xuXHRcdH1cblx0fVxuXG48L3NjcmlwdD5cbjxzdHlsZSBzY29wZWQ+XG4uanNvbl9sYXl7XG5cdCAgICBwYWRkaW5nOiAxMHB4O1xuICAgIGhlaWdodDogMjAwcHg7XG4gICAgb3ZlcmZsb3c6IHNjcm9sbDtcbn1cbiNxZmxvd19sYXl7IFxuXHRcdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdH1cbi5jbGVhcjphZnRlcntcblx0XHRcdGNvbnRlbnQ6IFwiXCI7XG5cdFx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRcdGNsZWFyOiBib3RoO1xuXHRcdFx0Zm9udC1zaXplOiAwO1xuXHRcdFx0bGluZS1oZWlnaHQ6IDA7XG5cdFx0fVxuXHRcdGNhbnZhc3sgXG5cdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0XHR3aWR0aDogMTAwJTtcblx0XHRcdGJhY2tncm91bmQtaW1hZ2U6IHVybChcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU5EQWlJR2hsYVdkb2REMGlOREFpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEdSbFpuTStQSEJoZEhSbGNtNGdhV1E5SW1keWFXUWlJSGRwWkhSb1BTSTBNQ0lnYUdWcFoyaDBQU0kwTUNJZ2NHRjBkR1Z5YmxWdWFYUnpQU0oxYzJWeVUzQmhZMlZQYmxWelpTSStQSEJoZEdnZ1pEMGlUU0F3SURFd0lFd2dOREFnTVRBZ1RTQXhNQ0F3SUV3Z01UQWdOREFnVFNBd0lESXdJRXdnTkRBZ01qQWdUU0F5TUNBd0lFd2dNakFnTkRBZ1RTQXdJRE13SUV3Z05EQWdNekFnVFNBek1DQXdJRXdnTXpBZ05EQWlJR1pwYkd3OUltNXZibVVpSUhOMGNtOXJaVDBpSTJRd1pEQmtNQ0lnYjNCaFkybDBlVDBpTUM0eUlpQnpkSEp2YTJVdGQybGtkR2c5SWpFaUx6NDhjR0YwYUNCa1BTSk5JRFF3SURBZ1RDQXdJREFnTUNBME1DSWdabWxzYkQwaWJtOXVaU0lnYzNSeWIydGxQU0lqWkRCa01HUXdJaUJ6ZEhKdmEyVXRkMmxrZEdnOUlqRWlMejQ4TDNCaGRIUmxjbTQrUEM5a1pXWnpQanh5WldOMElIZHBaSFJvUFNJeE1EQWxJaUJvWldsbmFIUTlJakV3TUNVaUlHWnBiR3c5SW5WeWJDZ2paM0pwWkNraUx6NDhMM04yWno0PVwiKTtcblxuXHRcdH1cblx0XHQudG9vbHtcblx0XHRcdGhlaWdodDogNDBweDtcblx0XHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0XHRcdHotaW5kZXg6IDE7XG5cdFx0XHRsaW5lLWhlaWdodDogNDBweDtcblx0XHRcdGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG5cblx0XHR9XG5cdFx0LnRvb2wgc3Bhbntcblx0XHRcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcblx0XHRcdHdpZHRoOiAzMHB4O1xuXHRcdFx0aGVpZ2h0OiAzMHB4O1xuXHRcdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHRcdFx0bWFyZ2luLXRvcDo1cHg7XG5cdFx0XHRtYXJnaW4tbGVmdDoxMHB4O1xuXHRcdH0gXG5cdFx0LnRvb2wgc3BhbiBpbWd7XG5cdFx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHR9XG5cblxuXHRcdCNxY2FudmFzX2xheXtcblx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdHRvcDowO1xuXHRcdFx0bGVmdDowO1xuXHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHRib3R0b206IDA7XG5cdFx0XHRvdmVyZmxvdzpzY3JvbGw7XG5cdFx0fVxuXHRcdC5zaGVldExheXtcblx0XHRcdGZvbnQtc2l6ZTogMTJweDtcblx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdGJvdHRvbTogMDtcblx0XHRcdGxlZnQ6MDtcblx0XHRcdGJhY2tncm91bmQ6ICNmZmY7XG5cblx0XHR9XG5cdFx0Lmpzb24sXG5cdFx0LnNhdmUsXG5cdFx0LmRvd25sb2Fke1xuXHRcdFx0ZmxvYXQ6IHJpZ2h0O1xuXHRcdFx0Zm9udC1zaXplOiAxMnB4O1xuXHRcdH1cblx0XHQjdGl0bGVJbnB1dHtcblx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdGxlZnQ6MDtcblx0XHRcdHRvcDowO1xuXHRcdFx0cGFkZGluZzogMDtcblx0XHRcdG1hcmdpbjowO1xuXHRcdFx0Ym9yZGVyOm5vbmU7IFxuXHRcdFx0Zm9udC1zaXplOiAxMnB4O1xuXHRcdFx0Zm9udC1mYW1pbHk6J01pY3Jvc29mdCBZYUhlaSc7XG5cdFx0XHRvdXRsaW5lOiBub25lO1xuXHRcdFx0YmFja2dyb3VuZDogI0ZERjhFMTtcblx0XHR9XG5cdFx0I2xpbmVUaXRsZUlucHV0LFxuXHRcdCNjb250YWluZXJHcmlkQ29sdW1uLFxuXHRcdCNsaW5lTGlrZSxcblx0XHQjbGluZVR5cGV7XG5cdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHRsZWZ0OjA7XG5cdFx0XHR0b3A6MDtcblx0XHRcdHBhZGRpbmc6IDA7XG5cdFx0XHRtYXJnaW46MDtcblx0XHRcdGJvcmRlcjpub25lO1xuXHRcdFx0dGV4dC1pbmRlbnQ6IDVweDtcblx0XHRcdGZvbnQtc2l6ZTogMTJweDtcblx0XHR9XG4jdGlwe1xuXHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdCAgICB6LWluZGV4OiAxO1xuXHRcdCAgICBwYWRkaW5nOjA7XG5cdFx0ICAgIG1hcmdpbjowO1xuXHRcdCAgICBvdXRsaW5lOiBub25lO1xuXHRcdCAgICBkaXNwbGF5OiBub25lO1xuXHRcdCAgICBmb250LWZhbWlseTonTWljcm9zb2Z0IFlhSGVpJztcblx0XHQgICAgLyogZm9udC1mYW1pbHk6ICdBcmlhbCc7ICovXG5cdFx0XHR3b3JkLWJyZWFrOiBicmVhay1hbGw7XG5cdFx0ICAgIGJvcmRlcjp0cmFuc3BhcmVudDtcblx0XHQgICAgb3ZlcmZsb3c6IGhpZGRlbjsgXG5cdFx0ICAgIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsMCk7XG5cdFx0ICAgIHJlc2l6ZTpub25lO1xuXHRcdCAgICAvKnBvaW50ZXItZXZlbnRzOiBub25lOyovXG5cdFx0fVxuPC9zdHlsZT5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3FyZWxhdGlvbi52dWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzPzViNjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.isInContainer = exports.getScrollContainer = exports.isScroll = exports.getStyle = exports.once = exports.off = exports.on = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /* istanbul ignore next */\n\nexports.hasClass = hasClass;\nexports.addClass = addClass;\nexports.removeClass = removeClass;\nexports.setStyle = setStyle;\n\nvar _vue = __webpack_require__(0);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar isServer = _vue2.default.prototype.$isServer;\nvar SPECIAL_CHARS_REGEXP = /([\\:\\-\\_]+(.))/g;\nvar MOZ_HACK_REGEXP = /^moz([A-Z])/;\nvar ieVersion = isServer ? 0 : Number(document.documentMode);\n\n/* istanbul ignore next */\nvar trim = function trim(string) {\n  return (string || '').replace(/^[\\s\\uFEFF]+|[\\s\\uFEFF]+$/g, '');\n};\n/* istanbul ignore next */\nvar camelCase = function camelCase(name) {\n  return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {\n    return offset ? letter.toUpperCase() : letter;\n  }).replace(MOZ_HACK_REGEXP, 'Moz$1');\n};\n\n/* istanbul ignore next */\nvar on = exports.on = function () {\n  if (!isServer && document.addEventListener) {\n    return function (element, event, handler) {\n      if (element && event && handler) {\n        element.addEventListener(event, handler, false);\n      }\n    };\n  } else {\n    return function (element, event, handler) {\n      if (element && event && handler) {\n        element.attachEvent('on' + event, handler);\n      }\n    };\n  }\n}();\n\n/* istanbul ignore next */\nvar off = exports.off = function () {\n  if (!isServer && document.removeEventListener) {\n    return function (element, event, handler) {\n      if (element && event) {\n        element.removeEventListener(event, handler, false);\n      }\n    };\n  } else {\n    return function (element, event, handler) {\n      if (element && event) {\n        element.detachEvent('on' + event, handler);\n      }\n    };\n  }\n}();\n\n/* istanbul ignore next */\nvar once = exports.once = function once(el, event, fn) {\n  var listener = function listener() {\n    if (fn) {\n      fn.apply(this, arguments);\n    }\n    off(el, event, listener);\n  };\n  on(el, event, listener);\n};\n\n/* istanbul ignore next */\nfunction hasClass(el, cls) {\n  if (!el || !cls) return false;\n  if (cls.indexOf(' ') !== -1) throw new Error('className should not contain space.');\n  if (el.classList) {\n    return el.classList.contains(cls);\n  } else {\n    return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') > -1;\n  }\n};\n\n/* istanbul ignore next */\nfunction addClass(el, cls) {\n  if (!el) return;\n  var curClass = el.className;\n  var classes = (cls || '').split(' ');\n\n  for (var i = 0, j = classes.length; i < j; i++) {\n    var clsName = classes[i];\n    if (!clsName) continue;\n\n    if (el.classList) {\n      el.classList.add(clsName);\n    } else if (!hasClass(el, clsName)) {\n      curClass += ' ' + clsName;\n    }\n  }\n  if (!el.classList) {\n    el.className = curClass;\n  }\n};\n\n/* istanbul ignore next */\nfunction removeClass(el, cls) {\n  if (!el || !cls) return;\n  var classes = cls.split(' ');\n  var curClass = ' ' + el.className + ' ';\n\n  for (var i = 0, j = classes.length; i < j; i++) {\n    var clsName = classes[i];\n    if (!clsName) continue;\n\n    if (el.classList) {\n      el.classList.remove(clsName);\n    } else if (hasClass(el, clsName)) {\n      curClass = curClass.replace(' ' + clsName + ' ', ' ');\n    }\n  }\n  if (!el.classList) {\n    el.className = trim(curClass);\n  }\n};\n\n/* istanbul ignore next */\nvar getStyle = exports.getStyle = ieVersion < 9 ? function (element, styleName) {\n  if (isServer) return;\n  if (!element || !styleName) return null;\n  styleName = camelCase(styleName);\n  if (styleName === 'float') {\n    styleName = 'styleFloat';\n  }\n  try {\n    switch (styleName) {\n      case 'opacity':\n        try {\n          return element.filters.item('alpha').opacity / 100;\n        } catch (e) {\n          return 1.0;\n        }\n      default:\n        return element.style[styleName] || element.currentStyle ? element.currentStyle[styleName] : null;\n    }\n  } catch (e) {\n    return element.style[styleName];\n  }\n} : function (element, styleName) {\n  if (isServer) return;\n  if (!element || !styleName) return null;\n  styleName = camelCase(styleName);\n  if (styleName === 'float') {\n    styleName = 'cssFloat';\n  }\n  try {\n    var computed = document.defaultView.getComputedStyle(element, '');\n    return element.style[styleName] || computed ? computed[styleName] : null;\n  } catch (e) {\n    return element.style[styleName];\n  }\n};\n\n/* istanbul ignore next */\nfunction setStyle(element, styleName, value) {\n  if (!element || !styleName) return;\n\n  if ((typeof styleName === 'undefined' ? 'undefined' : _typeof(styleName)) === 'object') {\n    for (var prop in styleName) {\n      if (styleName.hasOwnProperty(prop)) {\n        setStyle(element, prop, styleName[prop]);\n      }\n    }\n  } else {\n    styleName = camelCase(styleName);\n    if (styleName === 'opacity' && ieVersion < 9) {\n      element.style.filter = isNaN(value) ? '' : 'alpha(opacity=' + value * 100 + ')';\n    } else {\n      element.style[styleName] = value;\n    }\n  }\n};\n\nvar isScroll = exports.isScroll = function isScroll(el, vertical) {\n  if (isServer) return;\n\n  var determinedDirection = vertical !== null || vertical !== undefined;\n  var overflow = determinedDirection ? vertical ? getStyle(el, 'overflow-y') : getStyle(el, 'overflow-x') : getStyle(el, 'overflow');\n\n  return overflow.match(/(scroll|auto)/);\n};\n\nvar getScrollContainer = exports.getScrollContainer = function getScrollContainer(el, vertical) {\n  if (isServer) return;\n\n  var parent = el;\n  while (parent) {\n    if ([window, document, document.documentElement].includes(parent)) {\n      return window;\n    }\n    if (isScroll(parent, vertical)) {\n      return parent;\n    }\n    parent = parent.parentNode;\n  }\n\n  return parent;\n};\n\nvar isInContainer = exports.isInContainer = function isInContainer(el, container) {\n  if (isServer || !el || !container) return false;\n\n  var elRect = el.getBoundingClientRect();\n  var containerRect = void 0;\n\n  if ([window, document, document.documentElement, null, undefined].includes(container)) {\n    containerRect = {\n      top: 0,\n      right: window.innerWidth,\n      bottom: window.innerHeight,\n      left: 0\n    };\n  } else {\n    containerRect = container.getBoundingClientRect();\n  }\n\n  return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvZG9tLmpzP2RhNGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTs7QUFFQSxvR0FBb0csbUJBQW1CLEVBQUUsbUJBQW1CLDhIQUE4SCxHQUFHOztBQUU3UTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsQ0FBSzs7QUFFeEI7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLE9BQU87QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLE9BQU87QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmlzSW5Db250YWluZXIgPSBleHBvcnRzLmdldFNjcm9sbENvbnRhaW5lciA9IGV4cG9ydHMuaXNTY3JvbGwgPSBleHBvcnRzLmdldFN0eWxlID0gZXhwb3J0cy5vbmNlID0gZXhwb3J0cy5vZmYgPSBleHBvcnRzLm9uID0gdW5kZWZpbmVkO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbmV4cG9ydHMuaGFzQ2xhc3MgPSBoYXNDbGFzcztcbmV4cG9ydHMuYWRkQ2xhc3MgPSBhZGRDbGFzcztcbmV4cG9ydHMucmVtb3ZlQ2xhc3MgPSByZW1vdmVDbGFzcztcbmV4cG9ydHMuc2V0U3R5bGUgPSBzZXRTdHlsZTtcblxudmFyIF92dWUgPSByZXF1aXJlKCd2dWUnKTtcblxudmFyIF92dWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdnVlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGlzU2VydmVyID0gX3Z1ZTIuZGVmYXVsdC5wcm90b3R5cGUuJGlzU2VydmVyO1xudmFyIFNQRUNJQUxfQ0hBUlNfUkVHRVhQID0gLyhbXFw6XFwtXFxfXSsoLikpL2c7XG52YXIgTU9aX0hBQ0tfUkVHRVhQID0gL15tb3ooW0EtWl0pLztcbnZhciBpZVZlcnNpb24gPSBpc1NlcnZlciA/IDAgOiBOdW1iZXIoZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnZhciB0cmltID0gZnVuY3Rpb24gdHJpbShzdHJpbmcpIHtcbiAgcmV0dXJuIChzdHJpbmcgfHwgJycpLnJlcGxhY2UoL15bXFxzXFx1RkVGRl0rfFtcXHNcXHVGRUZGXSskL2csICcnKTtcbn07XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xudmFyIGNhbWVsQ2FzZSA9IGZ1bmN0aW9uIGNhbWVsQ2FzZShuYW1lKSB7XG4gIHJldHVybiBuYW1lLnJlcGxhY2UoU1BFQ0lBTF9DSEFSU19SRUdFWFAsIGZ1bmN0aW9uIChfLCBzZXBhcmF0b3IsIGxldHRlciwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9mZnNldCA/IGxldHRlci50b1VwcGVyQ2FzZSgpIDogbGV0dGVyO1xuICB9KS5yZXBsYWNlKE1PWl9IQUNLX1JFR0VYUCwgJ01veiQxJyk7XG59O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xudmFyIG9uID0gZXhwb3J0cy5vbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCFpc1NlcnZlciAmJiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50LCBldmVudCwgaGFuZGxlcikge1xuICAgICAgaWYgKGVsZW1lbnQgJiYgZXZlbnQgJiYgaGFuZGxlcikge1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgIGlmIChlbGVtZW50ICYmIGV2ZW50ICYmIGhhbmRsZXIpIHtcbiAgICAgICAgZWxlbWVudC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0oKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnZhciBvZmYgPSBleHBvcnRzLm9mZiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCFpc1NlcnZlciAmJiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50LCBldmVudCwgaGFuZGxlcikge1xuICAgICAgaWYgKGVsZW1lbnQgJiYgZXZlbnQpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICBpZiAoZWxlbWVudCAmJiBldmVudCkge1xuICAgICAgICBlbGVtZW50LmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSgpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xudmFyIG9uY2UgPSBleHBvcnRzLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGVsLCBldmVudCwgZm4pIHtcbiAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgaWYgKGZuKSB7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvZmYoZWwsIGV2ZW50LCBsaXN0ZW5lcik7XG4gIH07XG4gIG9uKGVsLCBldmVudCwgbGlzdGVuZXIpO1xufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBjbHMpIHtcbiAgaWYgKCFlbCB8fCAhY2xzKSByZXR1cm4gZmFsc2U7XG4gIGlmIChjbHMuaW5kZXhPZignICcpICE9PSAtMSkgdGhyb3cgbmV3IEVycm9yKCdjbGFzc05hbWUgc2hvdWxkIG5vdCBjb250YWluIHNwYWNlLicpO1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgcmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhjbHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoJyAnICsgZWwuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIGNscyArICcgJykgPiAtMTtcbiAgfVxufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjbHMpIHtcbiAgaWYgKCFlbCkgcmV0dXJuO1xuICB2YXIgY3VyQ2xhc3MgPSBlbC5jbGFzc05hbWU7XG4gIHZhciBjbGFzc2VzID0gKGNscyB8fCAnJykuc3BsaXQoJyAnKTtcblxuICBmb3IgKHZhciBpID0gMCwgaiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgdmFyIGNsc05hbWUgPSBjbGFzc2VzW2ldO1xuICAgIGlmICghY2xzTmFtZSkgY29udGludWU7XG5cbiAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNsc05hbWUpO1xuICAgIH0gZWxzZSBpZiAoIWhhc0NsYXNzKGVsLCBjbHNOYW1lKSkge1xuICAgICAgY3VyQ2xhc3MgKz0gJyAnICsgY2xzTmFtZTtcbiAgICB9XG4gIH1cbiAgaWYgKCFlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc05hbWUgPSBjdXJDbGFzcztcbiAgfVxufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbHMpIHtcbiAgaWYgKCFlbCB8fCAhY2xzKSByZXR1cm47XG4gIHZhciBjbGFzc2VzID0gY2xzLnNwbGl0KCcgJyk7XG4gIHZhciBjdXJDbGFzcyA9ICcgJyArIGVsLmNsYXNzTmFtZSArICcgJztcblxuICBmb3IgKHZhciBpID0gMCwgaiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgdmFyIGNsc05hbWUgPSBjbGFzc2VzW2ldO1xuICAgIGlmICghY2xzTmFtZSkgY29udGludWU7XG5cbiAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNsc05hbWUpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ2xhc3MoZWwsIGNsc05hbWUpKSB7XG4gICAgICBjdXJDbGFzcyA9IGN1ckNsYXNzLnJlcGxhY2UoJyAnICsgY2xzTmFtZSArICcgJywgJyAnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc05hbWUgPSB0cmltKGN1ckNsYXNzKTtcbiAgfVxufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnZhciBnZXRTdHlsZSA9IGV4cG9ydHMuZ2V0U3R5bGUgPSBpZVZlcnNpb24gPCA5ID8gZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlTmFtZSkge1xuICBpZiAoaXNTZXJ2ZXIpIHJldHVybjtcbiAgaWYgKCFlbGVtZW50IHx8ICFzdHlsZU5hbWUpIHJldHVybiBudWxsO1xuICBzdHlsZU5hbWUgPSBjYW1lbENhc2Uoc3R5bGVOYW1lKTtcbiAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgIHN0eWxlTmFtZSA9ICdzdHlsZUZsb2F0JztcbiAgfVxuICB0cnkge1xuICAgIHN3aXRjaCAoc3R5bGVOYW1lKSB7XG4gICAgICBjYXNlICdvcGFjaXR5JzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5maWx0ZXJzLml0ZW0oJ2FscGhhJykub3BhY2l0eSAvIDEwMDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiAxLjA7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBlbGVtZW50LnN0eWxlW3N0eWxlTmFtZV0gfHwgZWxlbWVudC5jdXJyZW50U3R5bGUgPyBlbGVtZW50LmN1cnJlbnRTdHlsZVtzdHlsZU5hbWVdIDogbnVsbDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZWxlbWVudC5zdHlsZVtzdHlsZU5hbWVdO1xuICB9XG59IDogZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlTmFtZSkge1xuICBpZiAoaXNTZXJ2ZXIpIHJldHVybjtcbiAgaWYgKCFlbGVtZW50IHx8ICFzdHlsZU5hbWUpIHJldHVybiBudWxsO1xuICBzdHlsZU5hbWUgPSBjYW1lbENhc2Uoc3R5bGVOYW1lKTtcbiAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgIHN0eWxlTmFtZSA9ICdjc3NGbG9hdCc7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgY29tcHV0ZWQgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICcnKTtcbiAgICByZXR1cm4gZWxlbWVudC5zdHlsZVtzdHlsZU5hbWVdIHx8IGNvbXB1dGVkID8gY29tcHV0ZWRbc3R5bGVOYW1lXSA6IG51bGw7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZWxlbWVudC5zdHlsZVtzdHlsZU5hbWVdO1xuICB9XG59O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gc2V0U3R5bGUoZWxlbWVudCwgc3R5bGVOYW1lLCB2YWx1ZSkge1xuICBpZiAoIWVsZW1lbnQgfHwgIXN0eWxlTmFtZSkgcmV0dXJuO1xuXG4gIGlmICgodHlwZW9mIHN0eWxlTmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3R5bGVOYW1lKSkgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZU5hbWUpIHtcbiAgICAgIGlmIChzdHlsZU5hbWUuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgc2V0U3R5bGUoZWxlbWVudCwgcHJvcCwgc3R5bGVOYW1lW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3R5bGVOYW1lID0gY2FtZWxDYXNlKHN0eWxlTmFtZSk7XG4gICAgaWYgKHN0eWxlTmFtZSA9PT0gJ29wYWNpdHknICYmIGllVmVyc2lvbiA8IDkpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZmlsdGVyID0gaXNOYU4odmFsdWUpID8gJycgOiAnYWxwaGEob3BhY2l0eT0nICsgdmFsdWUgKiAxMDAgKyAnKSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVOYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGlzU2Nyb2xsID0gZXhwb3J0cy5pc1Njcm9sbCA9IGZ1bmN0aW9uIGlzU2Nyb2xsKGVsLCB2ZXJ0aWNhbCkge1xuICBpZiAoaXNTZXJ2ZXIpIHJldHVybjtcblxuICB2YXIgZGV0ZXJtaW5lZERpcmVjdGlvbiA9IHZlcnRpY2FsICE9PSBudWxsIHx8IHZlcnRpY2FsICE9PSB1bmRlZmluZWQ7XG4gIHZhciBvdmVyZmxvdyA9IGRldGVybWluZWREaXJlY3Rpb24gPyB2ZXJ0aWNhbCA/IGdldFN0eWxlKGVsLCAnb3ZlcmZsb3cteScpIDogZ2V0U3R5bGUoZWwsICdvdmVyZmxvdy14JykgOiBnZXRTdHlsZShlbCwgJ292ZXJmbG93Jyk7XG5cbiAgcmV0dXJuIG92ZXJmbG93Lm1hdGNoKC8oc2Nyb2xsfGF1dG8pLyk7XG59O1xuXG52YXIgZ2V0U2Nyb2xsQ29udGFpbmVyID0gZXhwb3J0cy5nZXRTY3JvbGxDb250YWluZXIgPSBmdW5jdGlvbiBnZXRTY3JvbGxDb250YWluZXIoZWwsIHZlcnRpY2FsKSB7XG4gIGlmIChpc1NlcnZlcikgcmV0dXJuO1xuXG4gIHZhciBwYXJlbnQgPSBlbDtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChbd2luZG93LCBkb2N1bWVudCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XS5pbmNsdWRlcyhwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgICBpZiAoaXNTY3JvbGwocGFyZW50LCB2ZXJ0aWNhbCkpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIHBhcmVudDtcbn07XG5cbnZhciBpc0luQ29udGFpbmVyID0gZXhwb3J0cy5pc0luQ29udGFpbmVyID0gZnVuY3Rpb24gaXNJbkNvbnRhaW5lcihlbCwgY29udGFpbmVyKSB7XG4gIGlmIChpc1NlcnZlciB8fCAhZWwgfHwgIWNvbnRhaW5lcikgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBlbFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIGNvbnRhaW5lclJlY3QgPSB2b2lkIDA7XG5cbiAgaWYgKFt3aW5kb3csIGRvY3VtZW50LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG51bGwsIHVuZGVmaW5lZF0uaW5jbHVkZXMoY29udGFpbmVyKSkge1xuICAgIGNvbnRhaW5lclJlY3QgPSB7XG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICBib3R0b206IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgIGxlZnQ6IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICByZXR1cm4gZWxSZWN0LnRvcCA8IGNvbnRhaW5lclJlY3QuYm90dG9tICYmIGVsUmVjdC5ib3R0b20gPiBjb250YWluZXJSZWN0LnRvcCAmJiBlbFJlY3QucmlnaHQgPiBjb250YWluZXJSZWN0LmxlZnQgJiYgZWxSZWN0LmxlZnQgPCBjb250YWluZXJSZWN0LnJpZ2h0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVtZW50LXVpL2xpYi91dGlscy9kb20uanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _qcanvas = __webpack_require__(8);\n\nvar _qrelation = __webpack_require__(10);\n\nvar _qrelation2 = _interopRequireDefault(_qrelation);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nwindow.Qcanvas = _qcanvas.Qcanvas;\n\nexports.default = _qrelation2.default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/OTU1MiJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJRY2FudmFzIiwicXJlbGF0aW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFFQTs7QUFDQTs7Ozs7O0FBR0FBLE9BQU9DLE9BQVAsR0FBaUJBLGdCQUFqQjs7a0JBRWVDLG1CIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuaW1wb3J0IHtRY2FudmFzfSBmcm9tICdxY2FudmFzJztcbmltcG9ydCBxcmVsYXRpb24gZnJvbSAnLi9xcmVsYXRpb24udnVlJztcblxuXG53aW5kb3cuUWNhbnZhcyA9IFFjYW52YXM7XG5cbmV4cG9ydCBkZWZhdWx0IHFyZWxhdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5kZXguanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(9);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcWNhbnZhcy9pbmRleC5qcz85NTEyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixtQkFBTyxDQUFDLENBQWUiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvUWNhbnZhcycpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3FjYW52YXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/***/ (function(module, exports) {

eval("\n/**\n * 二次贝塞尔曲线曲线类\n */\nfunction QquadraticCurve(qcanvas){\n\tthis.qquadraticCurveVersion = '1.0';\n\tthis.qcanvas = qcanvas;\n}\nQquadraticCurve.prototype.quadraticCurve = function(options) {\n\tvar _this = this;\n\tvar OPTIONS = {\n\t\tTYPE:'quadraticCurve',\n\t\tcolor:'#000',  //颜色\n\t\tlike:'-',     //画出来的样子 [-][->][<->][--][-->][<-->]\n\t\twidth:1,\n\t\tstart:[0,0],\n\t\thandler:[50,130],\n\t\tend:[100,100],\n\t\tdrag:true,\n\t\tpointerEvent:'auto',\n\t\thandlerShow:false,\n\t\t//withText:'text', //带着的文本\n\t\t//withTextAlign:'center'  //文本的横向位置 [left center(默认) right]\n\t\tcenterPoints:function(){ //元素中心点相对于整个画布的坐标\n\n\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\tvar handler = _this.qcanvas.isFun(this.handler)?this.handler():this.handler;\n\t\t\tvar end = _this.qcanvas.isFun(this.end)?this.end():this.end;\n\t\t\tvar center = [\n\t\t\t\t(start[0] < end[0] ? start[0]:end[0])+Math.abs(start[0]-end[0]) * 0.5,\n\t\t\t\t(start[1] < end[1] ? start[1]:end[1])+Math.abs(start[1]-end[1]) * 0.5\n\t\t\t]\n\n\n\t\t\treturn [\n\t\t\t\t(handler[0] < center[0] ? handler[0]:center[0])+Math.abs(handler[0]-center[0]) * 0.5,\n\t\t\t\t(handler[1] < center[1] ? handler[1]:center[1])+Math.abs(handler[1]-center[1]) * 0.5\n\t\t\t]\n\n\t\t},\n\t\tdownFun:function(e,position){ \n\n\t\t\t//线的拖动要特殊处理 鼠标点击点距结束点的距离也得记录\n\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\tvar handler = _this.qcanvas.isFun(this.handler)?this.handler():this.handler;\n\t\t \tvar end = _this.qcanvas.isFun(this.end)?this.end():this.end; \n\t\t\tthis.dis = [\n\t\t\t\tposition.x-start[0],\n\t\t\t\tposition.y-start[1],\n\t\t\t\tposition.x-handler[0],\n\t\t\t\tposition.y-handler[1],\n\t\t\t\tposition.x-end[0],\n\t\t\t\tposition.y-end[1]\n\t\t\t]; \n\t\t},\n\t\tmoveFun:function(e,position){  //当配置drageRange时  开始限制坐标\n\n\n\t\t\tvar dragIsBool = _this.qcanvas.isBool(this.drag);\n\t\t\t\t\tvar dis  =this.dis;\n\t\t\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\t\t\tvar handler = _this.qcanvas.isFun(this.handler)?this.handler():this.handler;\n\t\t\t\t \tvar end = _this.qcanvas.isFun(this.end)?this.end():this.end;\n\n\n \t\t\t\t\t\n \t\t\t\t\tvar x0,y0,x1,y1,x2,y2;\n\t\t\t\t\t\t \n\t\t\t\t\t\tif(dragIsBool && this.drag){\n\t\t\t\t\t\t\t x0 = position.x-dis[0];\n\t\t\t\t\t\t\t y0 = position.y-dis[1];\n\n\t\t\t\t\t\t\t x1 = position.x-dis[2];\n\t\t\t\t\t\t\t y1 = position.y-dis[3];\n\n\t\t\t\t\t\t\t x2 = position.x-dis[4];\n\t\t\t\t\t\t\t y2 = position.y-dis[5];\n\n\t\t\t\t\t\t}else if(this.drag == 'vertical'){\n\t\t\t\t\t\t\t x0 = start[0];\n\t\t\t\t\t\t\t y0 = position.y-dis[1];\n\t\t\t\t\t\t\t x1 = handler[0];\n\t\t\t\t\t\t\t y1 = position.y-dis[3];\n\t\t\t\t\t\t\t x2 = end[0];\n\t\t\t\t\t\t\t y2 = position.y-dis[5];\n\n\n\t\t\t\t\t\t}else if(this.drag == 'horizontal'){\n\t\t\t\t\t\t\t x0 = position.x-dis[0];\n\t\t\t\t\t\t\t y0 = start[1];\n\t\t\t\t\t\t\t x1 = position.x-dis[2];\n\t\t\t\t\t\t\t y1 = handler[1];\n\t\t\t\t\t\t\t x2 = position.x-dis[4];\n\t\t\t\t\t\t\t y2 = end[1];\n\n\t\t\t\t\t\t} \n \n\n\t\t\t\t\t //如果创建时位置数据依赖于别的元素 那么一旦拖动该元素 数据的依赖关系就会断开 切记\n\t\t\t\t\tthis.start = [x0,y0];\n\t\t\t\t\tthis.handler = [x1,y1];\n\t\t\t\t\tthis.end = [x2,y2]\n\n\t\t\t\t\tthis.handlerShow && (this.handlerObj !== null) && this.handlerObj.setStart([x1,y1]);\n\n\t\t\t},\n\t\t\tdrawArrow: function(fromX, fromY, toX, toY,theta,headlen,width,color) {\n\t\t\t\t \n\t\t\t\t    var theta = typeof(theta) != 'undefined' ? theta : 30;\n\t\t\t\t    var headlen = typeof(theta) != 'undefined' ? headlen : 10;\n\t\t\t\t    var width = typeof(width) != 'undefined' ? width : 1;\n\t\t\t\t    var color = typeof(color) != 'color' ? color : '#000';\n\t\t\t\t \n\t\t\t\t    // 计算各角度和对应的P2,P3坐标\n\t\t\t\t    var angle = Math.atan2(fromY - toY, fromX - toX) * 180 / Math.PI;\n\t\t\t\t    var angle1 = (angle + theta) * Math.PI / 180;\n\t\t\t\t    var angle2 = (angle - theta) * Math.PI / 180;\n\t\t\t\t    var topX = headlen * Math.cos(angle1);\n\t\t\t\t    var topY = headlen * Math.sin(angle1);\n\t\t\t\t    var botX = headlen * Math.cos(angle2);\n\t\t\t\t    var botY = headlen * Math.sin(angle2);\n\t\t\t\t \n\t\t\t\t    // this.qcanvas.context.save();\n\t\t\t\t    // this.qcanvas.context.beginPath();\n\t\t\t\t \n\t\t\t\t    var arrowX = fromX - topX;\n\t\t\t\t    var arrowY = fromY - topY;\n\t\t\t\t \t\t// this.qcanvas.context.beginPath();\n\t\t\t\t  \t// \tthis.qcanvas.context.setLineDash([]); \n\n\n\t\t\t\t    arrowX = toX + topX;\n\t\t\t\t    arrowY = toY + topY;\n\t\t\t\t    // this.qcanvas.context.moveTo(arrowX, arrowY);\n\t\t\t\t    // this.qcanvas.context.lineTo(toX, toY);\n\t\t\t\t    var arrow2X = toX + botX;\n\t\t\t\t    var arrow2Y = toY + botY;\n\t\t\t\t    // this.qcanvas.context.lineTo(arrow2X, arrow2Y);\n\t\t\t\t    // this.qcanvas.context.strokeStyle = color;\n\t\t\t\t    // this.qcanvas.context.lineWidth = width;\n\t\t\t\t    // this.qcanvas.context.stroke();\n\n\t\t\t\t    _this.qcanvas.qline.paintLine({\n\t\t\t\t\t\t    \tlike:'-',\n\t\t\t\t\t\t\t\tstart:[arrowX, arrowY],\n\t\t\t\t\t\t\t\tend:[toX, toY],\n\t\t\t\t\t\t\t\twidth:width,\n\t\t\t\t\t\t\t\tcolor:color,\n\t\t\t\t\t\t\t\tpointerEvent:'none'\n\n\t\t\t\t    })\n\n\t\t\t\t    _this.qcanvas.qline.paintLine({\n\t\t\t\t\t\t    \tlike:'-',\n\t\t\t\t\t\t\t\tstart:[toX, toY],\n\t\t\t\t\t\t\t\tend:[arrow2X,arrow2Y],\n\t\t\t\t\t\t\t\twidth:width,\n\t\t\t\t\t\t\t\tcolor:color,\n\t\t\t\t\t\t\t\tpointerEvent:'none'\n\t\t\t\t    }) \n\t\t\t\t}\n\t}\n\tthis.qcanvas.extend(OPTIONS,options);\t\t\n\tthis.qcanvas.appendSetFun(OPTIONS);\n\n\t//分离文字\n\tif(typeof OPTIONS.withText !='undefined' && OPTIONS.withText!=''){\n\t\t\n\t\tthis.splitText(OPTIONS);\n\t\t\t\n\t}\n\n\n\t//显示控制点\n\tOPTIONS.handlerShow && this.drawHandler(OPTIONS);\n\n\n\n\n\treturn OPTIONS;\n};\nQquadraticCurve.prototype.drawHandler = function(obj){\n\tvar _this = this;\n\tvar handler = _this.qcanvas.isFun(obj.handler)?obj.handler():obj.handler;\n\n\tobj.handlerObj = this.qcanvas.qarc.arc({\n\t\tstart:handler, \n\t\tsAngle:0,\n\t\teAngle:360,\n\t\tfillColor:'blue',\n\t\topacity:0.2,\n\t\tr:8, \n\t\tborderColor:'#ccc',\n\t\tmousemove:function(){\n\t\t\tif(_this.qcanvas.dragAim !== null){\n\t\t\t\tobj.handler = this.start;\n\t\t\t}\n\t\t}\n\t});\t \n\n}\nQquadraticCurve.prototype.paintQuadraticCurve  = function(obj){\n\tthis.qcanvas.qanimation.createAnimation(obj);\n \n\tvar start = this.qcanvas.isFun(obj.start)?obj.start():obj.start;\n\tvar handler = this.qcanvas.isFun(obj.handler)?obj.handler():obj.handler;\n\tvar end = this.qcanvas.isFun(obj.end)?obj.end():obj.end;\n\n\tthis.qcanvas.context.strokeStyle = obj.color;\n\tthis.qcanvas.context.beginPath();\n\tthis.qcanvas.context.lineWidth = obj.width;\n\n\n\tswitch(obj.like)\n\t{\n\t\tcase '-': \n\t\t\t\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]); \n\t\t\tthis.qcanvas.context.quadraticCurveTo(handler[0],handler[1] , end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tbreak;\n\t\tcase '--': \n\n\t\t\tthis.qcanvas.context.setLineDash([3]);\n\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]); \n\t\t\tthis.qcanvas.context.quadraticCurveTo(handler[0],handler[1] , end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n\n \n\t\t\tbreak;\n\t\tcase '->': \n\t\t\t\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]); \n\t\t\tthis.qcanvas.context.quadraticCurveTo(handler[0],handler[1] , end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\t\t\t \n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n\n\t\t\tobj.drawArrow(handler[0], handler[1], end[0], end[1],30,10,1,obj.color)\n\t\t\t\n\t\t\tbreak;\n\t\tcase '<-': \n\t\t\t\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]); \n\t\t\tthis.qcanvas.context.quadraticCurveTo(handler[0],handler[1] , end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\t\t\t \n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n\n\t\t\tobj.drawArrow(handler[0], handler[1], start[0], start[1],30,10,1,obj.color)\n\t\t\t\n\t\t\tbreak;\t\n\t\tcase '<->': \n\t\t\t\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]); \n\t\t\tthis.qcanvas.context.quadraticCurveTo(handler[0],handler[1] , end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\t\t\t\n\n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n\n\t\t\tobj.drawArrow(handler[0], handler[1], end[0], end[1],30,10,1,obj.color);\n\t\t\tobj.drawArrow(handler[0], handler[1],start[0], start[1],30,10,1,obj.color);\n\t\t\t\n\t\t\t\n\t\t\tbreak;\t\n\t\tcase '-->': \n\n\t\t\tthis.qcanvas.context.setLineDash([3]);\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]); \n\t\t\tthis.qcanvas.context.quadraticCurveTo(handler[0],handler[1] , end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\n\n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n\t\t\t\n\t\t\tobj.drawArrow(handler[0], handler[1], end[0], end[1],30,10,1,obj.color);\n\n\t\t\tbreak;\n\t\tcase '<--': \n\n\t\t\tthis.qcanvas.context.setLineDash([3]);\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]); \n\t\t\tthis.qcanvas.context.quadraticCurveTo(handler[0],handler[1] , end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\n\n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n\t\t\t\n\t\t\tobj.drawArrow(handler[0], handler[1], start[0], start[1],30,10,1,obj.color);\n\n\t\t\tbreak;\n\t\tcase '<-->': \n\n\t\t\tthis.qcanvas.context.setLineDash([3]);\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]); \n\t\t\tthis.qcanvas.context.quadraticCurveTo(handler[0],handler[1] , end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n \t\t\t\n\t\t\tobj.drawArrow(handler[0], handler[1], end[0], end[1],30,10,1,obj.color);\n\t\t\tobj.drawArrow(handler[0], handler[1],start[0], start[1],30,10,1,obj.color);\n\n\t\t\tbreak;\n\t}\n \n\n\t\n\t\n\n\n\n\t//需要响应事件\n\t//影子画布上需要再画一份\n\tif(obj.pointerEvent == 'auto'){ \n\t\tthis.qcanvas.shadowContext.strokeStyle = obj.shadowFillColor;\n\t\tthis.qcanvas.shadowContext.beginPath();\n\t\tthis.qcanvas.shadowContext.lineWidth = 20;\n\n\t\t\n\t\tthis.qcanvas.shadowContext.moveTo(start[0],start[1]); \n\t\tthis.qcanvas.shadowContext.quadraticCurveTo(handler[0],handler[1] , end[0],end[1]);\n\t\tthis.qcanvas.shadowContext.stroke();\n\t}\n\n\n\n}\n//分离携带的文字\t\nQquadraticCurve.prototype.splitText = function(obj){\n\t\n\n\tvar _this = this;\n\tvar tmp = this.qcanvas.qtext.text({\n\t\t\tTYPE:'text',\n\t\t\ttext:obj.withText,\n\t\t\tcolor:obj.color,\n\t\t\twithTextAlign:obj.withTextAlign?obj.withTextAlign:'center',\n\t\t\tstart:function(){return obj.centerPoints()},\n\t\t\tpointerEvent:'none'\n\t});\n\tobj.withTextId = tmp.id;\n}\n\n\n// ----------end--------------\n\n\n/**\n * 三次贝塞尔曲线类\n */\nfunction QbezierCurve(qcanvas){\n\tthis.qbezierCurveVersion = '1.0';\n\tthis.qcanvas = qcanvas;\n}\n\nQbezierCurve.prototype.bezierCurve = function(options) {\n\tvar _this = this;\n\tvar OPTIONS = {\n\t\tTYPE:'bezierCurve',\n\t\tcolor:'#000',  //颜色\n\t\tlike:'-',     //画出来的样子 [-][->][<->][--][-->][<-->]\n\t\twidth:1,\n\t\tstart:[50,50],\n\t\thandler1:[70,20],\n\t\thandler2:[100,80],\n\t\tend:[200,50],\n\t\tdrag:true,\n\t\tpointerEvent:'auto',\n\t\thandlerShow:false,\n\t\t//withText:'text', //带着的文本\n\t\t//withTextAlign:'center'  //文本的横向位置 [left center(默认) right]\n\t\tcenterPoints:function(){ //元素中心点相对于整个画布的坐标\n\n\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\tvar handler1 = _this.qcanvas.isFun(this.handler1)?this.handler1():this.handler1;\n\t\t\tvar handler2 = _this.qcanvas.isFun(this.handler2)?this.handler2():this.handler2;\n\n\t\t\tvar end = _this.qcanvas.isFun(this.end)?this.end():this.end;\n\n\t\t\tvar center1 = [\n\t\t\t\t(handler1[0] < start[0] ? handler1[0]:start[0])+Math.abs(handler1[0]-start[0]) * 0.5,\n\t\t\t\t(handler1[1] < start[1] ? handler1[1]:start[1])+Math.abs(handler1[1]-start[1]) * 0.5\n\t\t\t]\n\n\t\t\tvar center2 = [\n\t\t\t\t(handler2[0] < end[0] ? handler2[0]:end[0])+Math.abs(handler2[0]-end[0]) * 0.5,\n\t\t\t\t(handler2[1] < end[1] ? handler2[1]:end[1])+Math.abs(handler2[1]-end[1]) * 0.5\n\t\t\t]\n\n\n\t\t\treturn [\n\t\t\t\t(center2[0] < center1[0] ? center2[0]:center1[0])+Math.abs(center2[0]-center1[0]) * 0.5,\n\t\t\t\t(center2[1] < center1[1] ? center2[1]:center1[1])+Math.abs(center2[1]-center1[1]) * 0.5\n\t\t\t]\n\n\t\t},\n\t\tdownFun:function(e,position){ \n\n\t\t\t//线的拖动要特殊处理 鼠标点击点距结束点的距离也得记录\n\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\tvar handler1 = _this.qcanvas.isFun(this.handler1)?this.handler1():this.handler1;\n\t\t\tvar handler2 = _this.qcanvas.isFun(this.handler2)?this.handler2():this.handler2;\n\n\t\t \tvar end = _this.qcanvas.isFun(this.end)?this.end():this.end; \n\t\t\tthis.dis = [\n\t\t\t\tposition.x-start[0],\n\t\t\t\tposition.y-start[1],\n\t\t\t\tposition.x-handler1[0],\n\t\t\t\tposition.y-handler1[1],\n\t\t\t\tposition.x-handler2[0],\n\t\t\t\tposition.y-handler2[1],\n\t\t\t\tposition.x-end[0],\n\t\t\t\tposition.y-end[1]\n\t\t\t]; \n\t\t},\n\t\tmoveFun:function(e,position){  //当配置drageRange时  开始限制坐标\n\n\n\t\t\tvar dragIsBool = _this.qcanvas.isBool(this.drag);\n\t\t\t\t\tvar dis  =this.dis;\n\t\t\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\t\t\tvar handler1 = _this.qcanvas.isFun(this.handler1)?this.handler1():this.handler1;\n\t\t\t\t\tvar handler2 = _this.qcanvas.isFun(this.handler2)?this.handler2():this.handler2;\n\n\t\t\t\t \tvar end = _this.qcanvas.isFun(this.end)?this.end():this.end;\n\n\n \t\t\t\t\t\n \t\t\t\t\tvar x0,y0,x1,y1,x2,y2,x3,y3;\n\t\t\t\t\t\t \n\t\t\t\t\t\tif(dragIsBool && this.drag){\n\t\t\t\t\t\t\t x0 = position.x-dis[0];\n\t\t\t\t\t\t\t y0 = position.y-dis[1];\n\n\t\t\t\t\t\t\t x1 = position.x-dis[2];\n\t\t\t\t\t\t\t y1 = position.y-dis[3];\n\n\t\t\t\t\t\t\t x2 = position.x-dis[4];\n\t\t\t\t\t\t\t y2 = position.y-dis[5];\n\n\t\t\t\t\t\t\t x3 = position.x-dis[6];\n\t\t\t\t\t\t\t y3 = position.y-dis[7];\n\n\t\t\t\t\t\t}else if(this.drag == 'vertical'){\n\t\t\t\t\t\t\t x0 = start[0];\n\t\t\t\t\t\t\t y0 = position.y-dis[1];\n\t\t\t\t\t\t\t x1 = handler1[0];\n\t\t\t\t\t\t\t y1 = position.y-dis[3];\n\t\t\t\t\t\t\t x2 = handler2[0];\n\t\t\t\t\t\t\t y2 = position.y-dis[5];\n\t\t\t\t\t\t\t x3 = end[0];\n\t\t\t\t\t\t\t y3 = position.y-dis[7];\n\n\t\t\t\t\t\t}else if(this.drag == 'horizontal'){\n\t\t\t\t\t\t\t x0 = position.x-dis[0];\n\t\t\t\t\t\t\t y0 = start[1];\n\t\t\t\t\t\t\t x1 = position.x-dis[2];\n\t\t\t\t\t\t\t y1 = handler1[1];\n\t\t\t\t\t\t\t x2 = position.x-dis[4];\n\t\t\t\t\t\t\t y2 = handler2[1];\n\t\t\t\t\t\t\t x3 = position.x-dis[6];\n\t\t\t\t\t\t\t y3 = end[1];\n\n\t\t\t\t\t\t} \n \n\n\t\t\t\t\t //如果创建时位置数据依赖于别的元素 那么一旦拖动该元素 数据的依赖关系就会断开 切记\n\t\t\t\t\tthis.start = [x0,y0];\n\t\t\t\t\tthis.handler1 = [x1,y1];\n\t\t\t\t\tthis.handler2 = [x2,y2];\n\t\t\t\t\tthis.end = [x3,y3] \n\n\n\t\t\t\t\tthis.handlerShow && (this.handlerObj1 !== null) && this.handlerObj1.setStart([x1,y1]);\n\t\t\t\t\tthis.handlerShow && (this.handlerObj2 !== null) && this.handlerObj2.setStart([x2,y2]);\n\n\n\n\t\t\t},\n\t\t\tdrawArrow: function(fromX, fromY, toX, toY,theta,headlen,width,color) {\n\t\t\t\t \n\t\t\t\t    var theta = typeof(theta) != 'undefined' ? theta : 30;\n\t\t\t\t    var headlen = typeof(theta) != 'undefined' ? headlen : 10;\n\t\t\t\t    var width = typeof(width) != 'undefined' ? width : 1;\n\t\t\t\t    var color = typeof(color) != 'color' ? color : '#000';\n\t\t\t\t \n\t\t\t\t    // 计算各角度和对应的P2,P3坐标\n\t\t\t\t    var angle = Math.atan2(fromY - toY, fromX - toX) * 180 / Math.PI;\n\t\t\t\t    var angle1 = (angle + theta) * Math.PI / 180;\n\t\t\t\t    var angle2 = (angle - theta) * Math.PI / 180;\n\t\t\t\t    var topX = headlen * Math.cos(angle1);\n\t\t\t\t    var topY = headlen * Math.sin(angle1);\n\t\t\t\t    var botX = headlen * Math.cos(angle2);\n\t\t\t\t    var botY = headlen * Math.sin(angle2);\n\t\t\t\t \n\t\t\t\t    // this.qcanvas.context.save();\n\t\t\t\t    // this.qcanvas.context.beginPath();\n\t\t\t\t \n\t\t\t\t    var arrowX = fromX - topX;\n\t\t\t\t    var arrowY = fromY - topY;\n\t\t\t\t \t\t// this.qcanvas.context.beginPath();\n\t\t\t\t  \t// \tthis.qcanvas.context.setLineDash([]); \n\n\n\t\t\t\t    arrowX = toX + topX;\n\t\t\t\t    arrowY = toY + topY;\n\t\t\t\t    // this.qcanvas.context.moveTo(arrowX, arrowY);\n\t\t\t\t    // this.qcanvas.context.lineTo(toX, toY);\n\t\t\t\t    var arrow2X = toX + botX;\n\t\t\t\t    var arrow2Y = toY + botY;\n\t\t\t\t    // this.qcanvas.context.lineTo(arrow2X, arrow2Y);\n\t\t\t\t    // this.qcanvas.context.strokeStyle = color;\n\t\t\t\t    // this.qcanvas.context.lineWidth = width;\n\t\t\t\t    // this.qcanvas.context.stroke();\n\n\t\t\t\t    _this.qcanvas.qline.paintLine({\n\t\t\t\t\t\t    \tlike:'-',\n\t\t\t\t\t\t\t\tstart:[arrowX, arrowY],\n\t\t\t\t\t\t\t\tend:[toX, toY],\n\t\t\t\t\t\t\t\twidth:width,\n\t\t\t\t\t\t\t\tcolor:color,\n\t\t\t\t\t\t\t\tpointerEvent:'none'\n\n\t\t\t\t    })\n\n\t\t\t\t    _this.qcanvas.qline.paintLine({\n\t\t\t\t\t\t    \tlike:'-',\n\t\t\t\t\t\t\t\tstart:[toX, toY],\n\t\t\t\t\t\t\t\tend:[arrow2X,arrow2Y],\n\t\t\t\t\t\t\t\twidth:width,\n\t\t\t\t\t\t\t\tcolor:color,\n\t\t\t\t\t\t\t\tpointerEvent:'none'\n\t\t\t\t    }) \n\t\t\t\t}\n\t}\n\n\tthis.qcanvas.extend(OPTIONS,options);\t\t\n\tthis.qcanvas.appendSetFun(OPTIONS);\n\n\t//分离文字\n\tif(typeof OPTIONS.withText !='undefined' && OPTIONS.withText!=''){\n\t\t\n\t\tthis.splitText(OPTIONS);\n\t\t\t\n\t}\n\t//显示控制点\n\tOPTIONS.handlerShow && this.drawHandler(OPTIONS);\n\t\n\n\treturn OPTIONS;\n};\n\nQbezierCurve.prototype.drawHandler = function(obj){\n\tvar _this = this;\n\tvar handler1 = _this.qcanvas.isFun(obj.handler1)?obj.handler1():obj.handler1;\n\tvar handler2 = _this.qcanvas.isFun(obj.handler2)?obj.handler2():obj.handler2;\n\t\n\n\n\tobj.handlerObj1 = this.qcanvas.qarc.arc({\n\t\tstart:handler1, \n\t\tsAngle:0,\n\t\teAngle:360,\n\t\tfillColor:'blue',\n\t\topacity:0.2,\n\t\tr:8, \n\t\tborderColor:'#ccc',\n\t\tmousemove:function(){\n\t\t\tif(_this.qcanvas.dragAim !== null){\n\t\t\t\tobj.handler1 = this.start;\n\t\t\t}\n\t\t}\n\t});\t \n\n\tobj.handlerObj2 = this.qcanvas.qarc.arc({\n\t\tstart:handler2, \n\t\tsAngle:0,\n\t\teAngle:360,\n\t\tfillColor:'blue',\n\t\topacity:0.2,\n\t\tr:8, \n\t\tborderColor:'#ccc',\n\t\tmousemove:function(){\n\t\t\tif(_this.qcanvas.dragAim !== null){\n\t\t\t\tobj.handler2 = this.start;\n\t\t\t}\n\t\t}\n\t});\t \n\n\n\n\n\n}\nQbezierCurve.prototype.paintBezierCurve = function(obj) {\n\tthis.qcanvas.qanimation.createAnimation(obj);\n \n\tvar start = this.qcanvas.isFun(obj.start)?obj.start():obj.start;\n\tvar handler1 = this.qcanvas.isFun(obj.handler1)?obj.handler1():obj.handler1;\n\tvar handler2 = this.qcanvas.isFun(obj.handler2)?obj.handler2():obj.handler2;\n\tvar end = this.qcanvas.isFun(obj.end)?obj.end():obj.end;\n\n\tthis.qcanvas.context.strokeStyle = obj.color;\n\tthis.qcanvas.context.beginPath();\n\tthis.qcanvas.context.lineWidth = obj.width;\n\n\tswitch(obj.like)\n\t{\n\t\tcase '-': \n\t\t\t\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]); \n\t\t\tthis.qcanvas.context.bezierCurveTo(handler1[0],handler1[1],handler2[0],handler2[1], end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\t\t\t\n\t\t\tbreak;\n\t\tcase '--': \n\n\t\t\tthis.qcanvas.context.setLineDash([3]);\n\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]); \n\t\t\tthis.qcanvas.context.bezierCurveTo(handler1[0],handler1[1],handler2[0],handler2[1], end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n\n \n\t\t\tbreak;\t\n\t\tcase '->': \n\t\t\t\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]); \n\t\t\tthis.qcanvas.context.bezierCurveTo(handler1[0],handler1[1],handler2[0],handler2[1], end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\t\t\t \n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n\n\t\t\tobj.drawArrow(handler2[0], handler2[1], end[0], end[1],30,10,1,obj.color)\n\t\t\t\n\t\t\tbreak;\n\t\tcase '<-': \n\t\t\t\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]); \n\t\t\tthis.qcanvas.context.bezierCurveTo(handler1[0],handler1[1],handler2[0],handler2[1], end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\t\t\t \n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n\n\t\t\tobj.drawArrow(handler1[0], handler1[1], start[0], start[1],30,10,1,obj.color)\n\t\t\t\n\t\t\tbreak;\n\t\tcase '<->': \n\t\t\t\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]); \n\t\t\tthis.qcanvas.context.bezierCurveTo(handler1[0],handler1[1],handler2[0],handler2[1], end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\t\t\t\n\n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n\n\t\t\tobj.drawArrow(handler2[0], handler2[1], end[0], end[1],30,10,1,obj.color);\n\t\t\tobj.drawArrow(handler1[0], handler1[1],start[0], start[1],30,10,1,obj.color);\n\t\t\t\n\t\t\t\n\t\t\tbreak;\n\t\tcase '-->': \n\n\t\t\tthis.qcanvas.context.setLineDash([3]);\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]); \n\t\t\tthis.qcanvas.context.bezierCurveTo(handler1[0],handler1[1],handler2[0],handler2[1], end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\n\n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n\t\t\t\n\t\t\tobj.drawArrow(handler2[0], handler2[1], end[0], end[1],30,10,1,obj.color);\n\n\t\t\tbreak;\n\t\tcase '<--': \n\n\t\t\tthis.qcanvas.context.setLineDash([3]);\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]); \n\t\t\tthis.qcanvas.context.bezierCurveTo(handler1[0],handler1[1],handler2[0],handler2[1], end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\n\n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n\t\t\t\n\t\t\tobj.drawArrow(handler1[0], handler1[1], start[0], start[1],30,10,1,obj.color);\n\n\t\t\tbreak;\n\t\tcase '<-->': \n\n\t\t\tthis.qcanvas.context.setLineDash([3]);\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]); \n\t\t\tthis.qcanvas.context.bezierCurveTo(handler1[0],handler1[1],handler2[0],handler2[1], end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n \t\t\t\n\t\t\tobj.drawArrow(handler2[0], handler2[1], end[0], end[1],30,10,1,obj.color);\n\t\t\tobj.drawArrow(handler1[0], handler1[1],start[0], start[1],30,10,1,obj.color);\n\n\t\t\tbreak;\n\n\t}\n\n\n\t//需要响应事件\n\t//影子画布上需要再画一份\n\tif(obj.pointerEvent == 'auto'){ \n\t\tthis.qcanvas.shadowContext.strokeStyle = obj.shadowFillColor;\n\t\tthis.qcanvas.shadowContext.beginPath();\n\t\tthis.qcanvas.shadowContext.lineWidth = 20;\n\n\t\t\n\t\tthis.qcanvas.shadowContext.moveTo(start[0],start[1]); \n\t\tthis.qcanvas.shadowContext.bezierCurveTo(handler1[0],handler1[1],handler2[0],handler2[1], end[0],end[1]);\n\t\tthis.qcanvas.shadowContext.stroke();\n\t}\n\n\n};\n\n//分离携带的文字\t\nQbezierCurve.prototype.splitText = function(obj){\n\t\n\n\tvar _this = this;\n\tvar tmp = this.qcanvas.qtext.text({\n\t\t\tTYPE:'text',\n\t\t\ttext:obj.withText,\n\t\t\tcolor:obj.color,\n\t\t\twithTextAlign:obj.withTextAlign?obj.withTextAlign:'center',\n\t\t\tstart:function(){return obj.centerPoints()},\n\t\t\tpointerEvent:'none'\n\t});\n\tobj.withTextId = tmp.id;\n}\n\n\n/*画线类*/\t\nfunction Qline(qcanvas){\n\tthis.qlineVersion = '1.0';\n\tthis.qcanvas = qcanvas;\n\t// console.log(this);\n\t\n\n\t\n}\t\n\n/*\n四种形式的线 \n参数对象\n{\nTYPE:'line',\nstart:[0,0],  //开始坐标\nend:[50,50],  //结束坐标\ncolor:'red',  //颜色\nlike:'-',     //画出来的样子 [-][->][--][-->]\nwidth:1,\t\t\t//线条宽度\nwithText:'text', //带着的文本\nwithTextAlign:'center'  //文本的横向位置 [left center(默认) right]\n}\n*/\nQline.prototype.line = function(options){\n\tvar _this = this;\n\tvar OPTIONS = {\n\t\tTYPE:'line',\n\t\t\n\t\tcolor:'#000',  //颜色\n\t\tlike:'-',     //画出来的样子 [-][->][<->][--][-->][<-->]\n\t\twidth:1,\n\t\tstart:[0,0],\n\t\tend:[50,50],\n\t\tdrag:true,\n\t\tpointerEvent:'auto',\n\t\t//withText:'text', //带着的文本\n\t\t//withTextAlign:'center'  //文本的横向位置 [left center(默认) right]\n\t\tcenterPoints:function(){ //元素中心点相对于整个画布的坐标\n\n\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\tvar end = _this.qcanvas.isFun(this.end)?this.end():this.end;\n \n\t\t\treturn {\n\t\t\t\tx:(start[0] < end[0] ? start[0]:end[0])+Math.abs(start[0]-end[0]) * 0.5,\n\t\t\t\ty:(start[1] < end[1] ? start[1]:end[1])+Math.abs(start[1]-end[1]) * 0.5\n\t\t\t}\n\t\t},\n\t\tpolyPoints:function(){  //顶点坐标序列\n\t\t\tvar center = this.centerPoints();\n\n\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\tvar end = _this.qcanvas.isFun(this.end)?this.end():this.end;\n\n\t\t\t//为增大选区 把线的上下各扩展15个像素 \n\t\t\t//平行于x轴的线\n\t\t\tvar tmp,dis = 15;\n\t\t\tif(start[1] == end[1]){\n\t\t\t\ttmp = [\n\t\t\t\t\t{x:start[0],y:start[1]-dis},\n\t\t\t\t\t{x:end[0],y:end[1]-dis},\n\t\t\t\t\t{x:end[0],y:end[1]+dis},\n\t\t\t\t\t{x:start[0],y:start[1]+dis}\n\t\t\t\t]\n\t\t\t}\n\t\t\t//平行于y轴的线\n\t\t\tif(start[0] == end[0]){\n\t\t\t\ttmp = [\n\t\t\t\t\t{x:start[0]-dis,y:start[1]},\n\t\t\t\t\t{x:start[0]+dis,y:start[1]},\n\t\t\t\t\t{x:end[0]-dis,y:end[1]},\n\t\t\t\t\t{x:end[0]+dis,y:end[1]}\n\t\t\t\t]\n\t\t\t}\n\n\t\t\t\n\t\t\tvar A,B;\n\t\t\tvar oneOrThree = false;\n\t\t\tvar twoOrFour = false;\n\t\t\t//start->end (一 三象限)\n\t\t\t// A->B以下两种情况 \n\t\t\t// d1-d4是扩展成矩形后的四个点\n\t\t\t//       d1 B d2     A\n\t\t\t//         /    \t/\n\t\t\t//      @1/   或 @2/  \n\t\t\t//   \t /        / \n\t\t\t//      /\t     /\n\t\t\t//  d4 A d3\t    B\n\t\t\tif((start[0]<end[0]) && (start[1]>end[1])){\n\t\t\t\tA = start;\n\t\t\t\tB = end;\n\t\t\t\toneOrThree = true;\n\t\t\t}\n\t\t\tif((start[0]>end[0]) && (start[1]<end[1])){\n\t\t\t\tA = end;\n\t\t\t\tB = start;\n\t\t\t\toneOrThree = true;\n\n\t\t\t}\n\n\t\t\tif(oneOrThree){\n\t\t\t\ttmp = _this.getOneOrThreeCoord(A,B);\n\t\t\t}\n\n\t\t\t\n\t\t\t//start->end (二 四象限)\n\t\t\t// A->B以下两种情况\n\t\t\t// e1-e4是扩展成矩形后的四个点\n\t\t\t//B     e1 A e2\n\t\t\t// \\        \\\n\t\t\t//@1\\ 或@2   \\   \n\t\t\t//\t \\        \\ \n\t\t\t//    \\\t       \\\n\t\t\t//    A\t\t e4 B e3\n\t\t\tif((start[0] < end[0]) && (start[1]<end[1])){\n\t\t\t\tA = start;\n\t\t\t\tB = end;\n\t\t\t\ttwoOrFour = true;\n\t\t\t}\n\n\t\t\tif((start[0]>end[0]) && (start[1]>end[1])){\n\t\t\t\tA = end;\n\t\t\t\tB = start;\n\t\t\t\ttwoOrFour = true;\n\t\t\t}\n\n\t\t\tif(twoOrFour){\n\t\t\t\ttmp = _this.getTwoOrFourCoord(A,B);\n\t\t\t}\n\n\n\t\t\treturn tmp;\n\n\t\t},\n\t\tdownFun:function(e,position){\n\t\t\t//线的拖动要特殊处理 鼠标点击点距结束点的距离也得记录\n\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t \tvar end = _this.qcanvas.isFun(this.end)?this.end():this.end; \n\t\t\tthis.dis = [position.x-start[0],position.y-start[1],position.x-end[0],position.y-end[1]];\n\t\t},\n\t\tmoveFun:function(e,position){  //当配置drageRange时  开始限制坐标\n\n\n\t\t\tvar dragIsBool = _this.qcanvas.isBool(this.drag);\n\t\t\t\t\tvar dis  =this.dis;\n\t\t\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\t\t \tvar end = _this.qcanvas.isFun(this.end)?this.end():this.end;\n\n \t\t\t\t\t\n \t\t\t\t\tvar x1,y1,x2,y2;\n\t\t\t\t\t\t \n\t\t\t\t\t\tif(dragIsBool && this.drag){\n\t\t\t\t\t\t\t x1 = position.x-dis[0];\n\t\t\t\t\t\t\t y1 = position.y-dis[1];\n\n\t\t\t\t\t\t\t x2 = position.x-dis[2];\n\t\t\t\t\t\t\t y2 = position.y-dis[3];\n\n\t\t\t\t\t\t}else if(_this.qcanvas.dragAim.drag == 'vertical'){\n\t\t\t\t\t\t\t x1 = start[0];\n\t\t\t\t\t\t\t y1 = position.y-dis[1];\n\t\t\t\t\t\t\t x2 = end[0];\n\t\t\t\t\t\t\t y2 = position.y-dis[3];\n\n\n\t\t\t\t\t\t}else if(_this.qcanvas.dragAim.drag == 'horizontal'){\n\t\t\t\t\t\t\t x1 = position.x-dis[0];\n\t\t\t\t\t\t\t y1 = start[1];\n\t\t\t\t\t\t\t x2 = position.x-dis[2];\n\t\t\t\t\t\t\t y2 = end[1];\n\n\t\t\t\t\t\t} \n \n\n\n\t\t\t\t\t //如果创建时位置数据依赖于别的元素 那么一旦拖动该元素 数据的依赖关系就会断开 切记\n\t\t\t\t\tthis.start = [x1,y1];\n\t\t\t\t\tthis.end = [x2,y2] \n\n\t\t\t},\n\t\t\tdrawArrow: function(fromX, fromY, toX, toY,theta,headlen,width,color) {\n\t\t\t\t \n\t\t\t\t    var theta = typeof(theta) != 'undefined' ? theta : 30;\n\t\t\t\t    var headlen = typeof(theta) != 'undefined' ? headlen : 10;\n\t\t\t\t    var width = typeof(width) != 'undefined' ? width : 1;\n\t\t\t\t    var color = typeof(color) != 'color' ? color : '#000';\n\t\t\t\t \n\t\t\t\t    // 计算各角度和对应的P2,P3坐标\n\t\t\t\t    var angle = Math.atan2(fromY - toY, fromX - toX) * 180 / Math.PI;\n\t\t\t\t    var angle1 = (angle + theta) * Math.PI / 180;\n\t\t\t\t    var angle2 = (angle - theta) * Math.PI / 180;\n\t\t\t\t    var topX = headlen * Math.cos(angle1);\n\t\t\t\t    var topY = headlen * Math.sin(angle1);\n\t\t\t\t    var botX = headlen * Math.cos(angle2);\n\t\t\t\t    var botY = headlen * Math.sin(angle2);\n\t\t\t\t \n\t\t\t\t    // this.qcanvas.context.save();\n\t\t\t\t    // this.qcanvas.context.beginPath();\n\t\t\t\t \n\t\t\t\t    var arrowX = fromX - topX;\n\t\t\t\t    var arrowY = fromY - topY;\n\t\t\t\t \t\t// this.qcanvas.context.beginPath();\n\t\t\t\t  \t// \tthis.qcanvas.context.setLineDash([]); \n\n\n\t\t\t\t    arrowX = toX + topX;\n\t\t\t\t    arrowY = toY + topY;\n\t\t\t\t    // this.qcanvas.context.moveTo(arrowX, arrowY);\n\t\t\t\t    // this.qcanvas.context.lineTo(toX, toY);\n\t\t\t\t    var arrow2X = toX + botX;\n\t\t\t\t    var arrow2Y = toY + botY;\n\t\t\t\t    // this.qcanvas.context.lineTo(arrow2X, arrow2Y);\n\t\t\t\t    // this.qcanvas.context.strokeStyle = color;\n\t\t\t\t    // this.qcanvas.context.lineWidth = width;\n\t\t\t\t    // this.qcanvas.context.stroke();\n\n\t\t\t\t    _this.paintLine({\n\t\t\t\t\t\t    \tlike:'-',\n\t\t\t\t\t\t\t\tstart:[arrowX, arrowY],\n\t\t\t\t\t\t\t\tend:[toX, toY],\n\t\t\t\t\t\t\t\twidth:width,\n\t\t\t\t\t\t\t\tcolor:color,\n\t\t\t\t\t\t\t\tpointerEvent:'none'\n\n\t\t\t\t    })\n\n\t\t\t\t    _this.paintLine({\n\t\t\t\t\t\t    \tlike:'-',\n\t\t\t\t\t\t\t\tstart:[toX, toY],\n\t\t\t\t\t\t\t\tend:[arrow2X,arrow2Y],\n\t\t\t\t\t\t\t\twidth:width,\n\t\t\t\t\t\t\t\tcolor:color,\n\t\t\t\t\t\t\t\tpointerEvent:'none'\n\t\t\t\t    })\n\n\t\t\t\t  //   return [\n\t\t\t\t  //   \t{\n\t\t\t\t\t\t// \t\tlike:'-',\n\t\t\t\t\t\t// \t\tstart:[arrowX, arrowY],\n\t\t\t\t\t\t// \t\tend:[toX, toY]\n\t\t\t\t\t\t// },\n\t\t\t\t\t\t// {\n\t\t\t\t\t\t// \t\tlike:'-',\n\t\t\t\t\t\t// \t\tstart:[toX, toY],\n\t\t\t\t\t\t// \t\tend:[arrow2X,arrow2Y]\n\t\t\t\t\t\t// },\t\n\t\t\t\t  //   ]\n\n\n\t\t\t\t   //  \tangle = null;\n\t\t\t\t   //      angle1 =  null;\n\t\t\t\t   //      angle2 =  null;\n\t\t\t\t   //      topX =  null;\n\t\t\t\t   //      topY =  null;\n\t\t\t\t   //      botX =  null;\n\t\t\t\t   //      botY =  null;\n\t\t\t\t   //      arrowX = null;\n\t\t\t\t   //      arrowY = null;\n\n\t\t\t\t   //  theta = null;\n\t\t\t\t   //  headlen = null\n\t\t\t\t   //  width = null;\n\t\t\t\t   //  color = null;\n\t\t\t\t}\n\t}\n\t\n\t\n\t\t\t\n\t\t\t\t\t\t\n\tthis.qcanvas.extend(OPTIONS,options);\t\t\n\tthis.qcanvas.appendSetFun(OPTIONS);\n\t\n\t//分离文字\n\tif(typeof OPTIONS.withText !='undefined' && OPTIONS.withText!=''){\n\t\t\n\t\tthis.splitText(OPTIONS);\n\t\t\t\n\t}\n\t\n\treturn OPTIONS;\n}\n/**\n * 取得扩展后的四个点 (一 三象限)\n * @param  {[type]} A [description]\n * @param  {[type]} B [description]\n * @return {[type]}   [description]\n */\nQline.prototype.getOneOrThreeCoord = function(A,B) {\n\tvar dis = 15;\n\tvar l = Math.sqrt(Math.pow(Math.abs(A[0]-B[0]),2)+Math.pow(Math.abs(A[1]-B[1]),2));\n\tvar sinA = Math.abs(A[1]-B[1])/l;\n\tvar h = dis*sinA;\n\n\treturn [\n\t\t{x:B[0]-Math.sqrt(Math.pow(dis,2)+Math.pow(h,2)),y:B[1]-h},\n\t\t{x:B[0]+h,y:Math.sqrt(Math.pow(dis,2)-Math.pow(h,2))+B[1]},\n\t\t{x:A[0]+h,y:A[1]+Math.sqrt(Math.pow(dis,2)-Math.pow(h,2))},\n\t\t{x:A[0]-h,y:A[1]-Math.sqrt(Math.pow(dis,2)-Math.pow(h,2))},\n\n\t]\n\n};\n/**\n * 取得扩展后的四个点 (二 四象限)\n * @param  {[type]} A [description]\n * @param  {[type]} B [description]\n * @return {[type]}   [description]\n */\nQline.prototype.getTwoOrFourCoord = function(A,B) {\n\tvar dis = 15;\n\tvar l = Math.sqrt(Math.pow(Math.abs(A[0]-B[0]),2)+Math.pow(Math.abs(A[1]-B[1]),2));\n\tvar sinA = Math.abs(A[1]-B[1])/l;\n\tvar h = dis*sinA;\n\n\treturn [\n\t\t{x:A[0]-h,y:A[1]+Math.sqrt(Math.pow(dis,2)-Math.pow(h,2))},\n\t\t{x:A[0]+h,y:A[1]-Math.sqrt(Math.pow(dis,2)-Math.pow(h,2))},\n\t\t{x:B[0]+h,y:B[1]-Math.sqrt(Math.pow(dis,2)-Math.pow(h,2))},\n\t\t{x:B[0]-Math.sqrt(Math.pow(dis,2)-Math.pow(h,2)),y:B[1]+h},\n\n\t]\n\n};\n\n\n\nQline.prototype.getMiddleCoordinates = function(obj){\n\n\tvar start = this.qcanvas.isFun(obj.start)?obj.start():obj.start;\n\tvar end = this.qcanvas.isFun(obj.end)?obj.end():obj.end;\n\n\treturn [\n\t\t(start[0] < end[0] ? start[0]:end[0])+Math.abs(start[0]-end[0]) * 0.5,\n\t\t(start[1] < end[1] ? start[1]:end[1])+Math.abs(start[1]-end[1]) * 0.5,\n\t];\n\t\n}\n\t\t\n//分离携带的文字\t\nQline.prototype.splitText = function(obj){\n\t\n\n\tvar _this = this;\n\tvar tmp = this.qcanvas.qtext.text({\n\t\t\tTYPE:'text',\n\t\t\ttext:obj.withText,\n\t\t\tcolor:obj.color,\n\t\t\twithTextAlign:obj.withTextAlign?obj.withTextAlign:'center',\n\t\t\tstart:function(){return _this.getMiddleCoordinates.call(_this,obj)},\n\t\t\tpointerEvent:'none'\n\t});\n\tobj.withTextId = tmp.id;\n}\t\n\t\nQline.prototype.paintLine  = function(obj){\n\tthis.qcanvas.qanimation.createAnimation(obj);\n\n\tvar start = this.qcanvas.isFun(obj.start)?obj.start():obj.start;\n\tvar end = this.qcanvas.isFun(obj.end)?obj.end():obj.end;\n\n\n\tthis.qcanvas.context.strokeStyle = obj.color;\n\tthis.qcanvas.context.beginPath();\n\tthis.qcanvas.context.lineWidth=obj.width;\n\n\tswitch(obj.like)\n\t{\n\t\tcase '-':\n\t\t\t//if(obj.like == '--'){\n\t\t\t//\tthis.qcanvas.context.setLineDash([2, 4]);\n\t\t\t//}\n\t\t\t\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]);\n\t\t\tthis.qcanvas.context.lineTo(end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tbreak;\n\t\tcase '--': \n\n\t\t\tthis.qcanvas.context.setLineDash([3]);\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]);\n\t\t\tthis.qcanvas.context.lineTo(end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n \n\t\t\tbreak;\n\t\tcase '->': \n\t\t\t\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]);\n\t\t\tthis.qcanvas.context.lineTo(end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\t\t\t \n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n\n\t\t\tobj.drawArrow(start[0], start[1], end[0], end[1],30,10,1,obj.color)\n\t\t\t\n\t\t\tbreak;\n\t\tcase '<-': \n\t\t\t\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]);\n\t\t\tthis.qcanvas.context.lineTo(end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\t\t\t \n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n\n\t\t\tobj.drawArrow(end[0], end[1],start[0], start[1],30,10,1,obj.color)\n\t\t\t\n\t\t\tbreak;\n\t\tcase '<->': \n\t\t\t\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]);\n\t\t\tthis.qcanvas.context.lineTo(end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\t\t\t \n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n\n\t\t\tobj.drawArrow(start[0], start[1], end[0], end[1],30,10,1,obj.color);\n\t\t\tobj.drawArrow(end[0], end[1],start[0], start[1],30,10,1,obj.color);\n\t\t\t\n\t\t\t\n\t\t\tbreak;\t\n\t\tcase '-->': \n\n\t\t\tthis.qcanvas.context.setLineDash([3]);\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]);\n\t\t\tthis.qcanvas.context.lineTo(end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n \t\t\t\n \t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n\n\t\t\tobj.drawArrow(start[0], start[1], end[0], end[1],30,10,1,obj.color);\n\t\t\tbreak;\n\t\tcase '<--': \n\n\t\t\tthis.qcanvas.context.setLineDash([3]);\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]);\n\t\t\tthis.qcanvas.context.lineTo(end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n \t\t\t\n \t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n\n\t\t\tobj.drawArrow( end[0], end[1],start[0], start[1],30,10,1,obj.color);\n\t\t\tbreak;\t\n\t\tcase '<-->': \n\n\t\t\tthis.qcanvas.context.setLineDash([3]);\n\t\t\tthis.qcanvas.context.moveTo(start[0],start[1]);\n\t\t\tthis.qcanvas.context.lineTo(end[0],end[1]);\n\t\t\tthis.qcanvas.context.stroke();\n\n\t\t\t//可能路径是虚线形式的 设置成实线\n\t\t\tthis.qcanvas.context.setLineDash([]);\n\t\t\t \n\t\t\tobj.drawArrow(start[0], start[1], end[0], end[1],30,10,1,obj.color);\n\t\t\tobj.drawArrow(end[0], end[1],start[0], start[1],30,10,1,obj.color);\n\n\t\t\tbreak;\n\t}\n\n\t\t\n\t\n}\t\n\n\n/**\n * 画箭头的两条实线\n * @param  {[type]} fromX   [description]\n * @param  {[type]} fromY   [description]\n * @param  {[type]} toX     [description]\n * @param  {[type]} toY     [description]\n * @param  {[type]} theta   [description]\n * @param  {[type]} headlen [description]\n * @param  {[type]} width   [description]\n * @param  {[type]} color   [description]\n * @return {[type]}         [description]\n */\nQline.prototype.drawArrow = function(fromX, fromY, toX, toY,theta,headlen,width,color) {\n \n    var theta = typeof(theta) != 'undefined' ? theta : 30;\n    var headlen = typeof(theta) != 'undefined' ? headlen : 10;\n    var width = typeof(width) != 'undefined' ? width : 1;\n    var color = typeof(color) != 'color' ? color : '#000';\n \n    // 计算各角度和对应的P2,P3坐标\n    var angle = Math.atan2(fromY - toY, fromX - toX) * 180 / Math.PI;\n    var angle1 = (angle + theta) * Math.PI / 180;\n    var angle2 = (angle - theta) * Math.PI / 180;\n    var topX = headlen * Math.cos(angle1);\n    var topY = headlen * Math.sin(angle1);\n    var botX = headlen * Math.cos(angle2);\n    var botY = headlen * Math.sin(angle2);\n \n    // this.qcanvas.context.save();\n    // this.qcanvas.context.beginPath();\n \n    var arrowX = fromX - topX;\n    var arrowY = fromY - topY;\n \t\t// this.qcanvas.context.beginPath();\n  \t// \tthis.qcanvas.context.setLineDash([]); \n\n\n    arrowX = toX + topX;\n    arrowY = toY + topY;\n    // this.qcanvas.context.moveTo(arrowX, arrowY);\n    // this.qcanvas.context.lineTo(toX, toY);\n    var arrow2X = toX + botX;\n    var arrow2Y = toY + botY;\n    // this.qcanvas.context.lineTo(arrow2X, arrow2Y);\n    // this.qcanvas.context.strokeStyle = color;\n    // this.qcanvas.context.lineWidth = width;\n    // this.qcanvas.context.stroke();\n\n    this.paintLine({\n\t\t    \tlike:'-',\n\t\t\t\tstart:[arrowX, arrowY],\n\t\t\t\tend:[toX, toY]\n    })\n\n    this.paintLine({\n    \tlike:'-',\n\t\t\t\tstart:[toX, toY],\n\t\t\t\tend:[arrow2X,arrow2Y]\n    })\n\n  //   return [\n  //   \t{\n\t\t// \t\tlike:'-',\n\t\t// \t\tstart:[arrowX, arrowY],\n\t\t// \t\tend:[toX, toY]\n\t\t// },\n\t\t// {\n\t\t// \t\tlike:'-',\n\t\t// \t\tstart:[toX, toY],\n\t\t// \t\tend:[arrow2X,arrow2Y]\n\t\t// },\t\n  //   ]\n\n\n   //  \tangle = null;\n   //      angle1 =  null;\n   //      angle2 =  null;\n   //      topX =  null;\n   //      topY =  null;\n   //      botX =  null;\n   //      botY =  null;\n   //      arrowX = null;\n   //      arrowY = null;\n\n   //  theta = null;\n   //  headlen = null\n   //  width = null;\n   //  color = null;\n}\n\n\n\n//附加箭头对象 (不用这个了)\nQline.prototype.appendArrow = function(obj){\n\n\tvar start = this.qcanvas.isFun(obj.start)?obj.start():obj.start;\n\tvar end = this.qcanvas.isFun(obj.end)?obj.end():obj.end;\n\n\t\t\t\tarrowObj = this._calcH({\n\t\t\t\t\n\t\t\t\t},{\n\t\t\t\t\t'x':start[0],\n\t\t\t\t\t'y':start[1],\n\t\t\t\t},{\n\t\t\t\t\t'x':end[0],\n\t\t\t\t\t'y':end[1],\n\t\t\t\t});\n\t\n\t\t\tobj.arrow = [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlike:'-',\n\t\t\t\t\t\t\t\t\tstart:[arrowObj.h1.x,arrowObj.h1.y],\n\t\t\t\t\t\t\t\t\tend:[end[0],end[1]]\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlike:'-',\n\t\t\t\t\t\t\t\t\tstart:[arrowObj.h2.x,arrowObj.h2.y],\n\t\t\t\t\t\t\t\t\tend:[end[0],end[1]]\n\t\t\t\t\t\t\t},\t\n\t\t\t\t\t]\n}\t\n\t\n\t\n //计算头部坐标\nQline.prototype._calcH=function(a,sp,ep){\n\t var theta=Math.atan((ep.x-sp.x)/(ep.y-sp.y));\n\t var cep=this._scrollXOY(ep,-theta);\n\t var csp=this._scrollXOY(sp,-theta);\n\t var ch1={x:0,y:0};\n\t var ch2={x:0,y:0};\n\t var l=cep.y-csp.y;\n\t ch1.x=cep.x+l*(a.sharp||0.025);\n\t ch1.y=cep.y-l*(a.size||0.05);\n\t ch2.x=cep.x-l*(a.sharp||0.025);\n\t ch2.y=cep.y-l*(a.size||0.05);\n\t var h1=this._scrollXOY(ch1,theta);\n\t var h2=this._scrollXOY(ch2,theta);\n\t return {\n\t\th1:h1,\n\t\th2:h2\n\t\t};\n };\n //旋转坐标\nQline.prototype._scrollXOY=function(p,theta){\n\t return {\n\t\tx:p.x*Math.cos(theta)+p.y*Math.sin(theta),\n\t\ty:p.y*Math.cos(theta)-p.x*Math.sin(theta)\n\t };\n };\n\t\n\t\n\nQline.prototype.getBeveling = function(x,y){  \n    return Math.sqrt(Math.pow(x,2)+Math.pow(y,2));  \n}  \t\n\n\n//起止点是否有变化\t\nQline.prototype.lineIsChange = function(obj){\n\t\n\tvar start = this.qcanvas.isFun(obj.start)?obj.start():obj.start;\n\tvar end = this.qcanvas.isFun(obj.end)?obj.end():obj.end;\n\t//当前的起止点和原来的做比较\n\t\n\tif(typeof obj.oldStart =='undefined'){\n\t\t\tobj.oldStart = JSON.parse(JSON.stringify(start));\n\t\t\tobj.oldEnd = JSON.parse(JSON.stringify(end));\n\t\t\treturn true;\n\t}else{\n\t\t\n\t\tif(start[0]==obj.oldStart[0] &&\n\t\t\t start[1]==obj.oldStart[1] &&\n\t\t\t end[0]==obj.oldEnd[0] &&\n\t\t\t end[1]==obj.oldEnd[1]\n\t\t\t){\n\t\t\t\n\t\t\treturn false;\n\t\t}else{\n\t\t\tobj.oldStart = JSON.parse(JSON.stringify(start));\n\t\t\tobj.oldEnd = JSON.parse(JSON.stringify(end));\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t\n\t}\n}\t\n\t\n//画虚线\t\nQline.prototype.paintDashLine = function(obj){\n\t\n\t\t\tthis.qcanvas.context.strokeStyle = obj.color;\n\t\t\tthis.qcanvas.context.beginPath();\n\t\t\tthis.qcanvas.context.lineWidth=obj.width;\n\n\t\t\tvar start = this.qcanvas.isFun(obj.start)?obj.start():obj.start;\n\t\t\tvar end = this.qcanvas.isFun(obj.end)?obj.end():obj.end;\n\t\n\t\t\tif(this.lineIsChange(obj)){\n\t\t\t\t\n\t\t\t\t\tvar dashLen = 2;  \n\t\t\t\t\t//得到斜边的总长度  \n\t\t\t\t\tvar beveling = this.getBeveling(end[0]-start[0],end[0]-start[1]);  \n\t\t\t\t\t//计算有多少个线段  \n\t\t\t\t\tvar num = Math.floor(beveling/dashLen);  \n\t\t\t\n\t\t\t\t\tobj.dashPoint = [];\n\t\t\t\t\t\t\n\t\t\t\t\tfor(var i = 0 ; i < num; i++)  \n\t\t\t\t\t{  \n\t\t\t\t\t\tobj.dashPoint.push([\n\t\t\t\t\t\t\tstart[0]+(end[0]-start[0])/num*i,\n\t\t\t\t\t\t\tstart[1]+(end[1]-start[1])/num*i\n\t\t\t\t\t\t])  \n\t\t\t\t\t}  \n\t\t\t\t\n\t\t\t\tif(obj.like=='-->'){\n\t\t\t\t\t\tthis.appendArrow(obj);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\t\n\t\t\t\tfor(var i = 0 ; i < obj.dashPoint.length; i++){\n\t\t\t\t\t  \n\t\t\t\t\t\tthis.qcanvas.context[i%2 == 0 ? 'moveTo' : 'lineTo'](obj.dashPoint[i][0],obj.dashPoint[i][1]);  \n\t\t\t\t} \n\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\n\t\t\tthis.qcanvas.context.stroke();  \n}\t\n\t\n\t\n\n\t\n\t\n\n\t\n/*文字类--------------------------------------------------------*/\nfunction Qtext(qcanvas){\n\tthis.qtextVersion = '1.0';\n\tthis.qcanvas = qcanvas;\n\t\n\t\n}\t\n\nQtext.prototype.text = function(options){\n\t\tvar _this = this;\n\t\tvar OPTIONS = {\n\t\t\tTYPE:'text',\n\t\t\ttext:'Qcanvas Text',\n\t\t\tcolor:'red',\n\t\t\ttextAlign:'center',\n\t\t\ttextBaseline:'middle',\n\t\t\tlineHeight:'12px',\n\t\t\tfontSize:\"12px\",\n\t\t\tfontFamily:'Microsoft YaHei',\n\t\t\tstart:[0,0],\n\t\t\tdrag:true,\n\t\t\t  dragRange:[],  //限制拖动的区域 必须为两个坐标点[[左上角x,左上角y]，[右下角x,右下角y]]\n\n\t\t\tpointerEvent:'auto',\n\t\t\trange:{width:0,height:0},\n\t\t\tdegree:0,\n\t\t\tcenterPoints:function(){ //元素中心点相对于整个画布的坐标\n\n\t\t\t\tvar x = 0;\n\t\t\t\tvar y = 0;\n\t\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\n\n\t\t\t\tif(this.textAlign == 'left'){\n\t\t\t\t\tx = this.range.width*0.5+start[0];\n\n\t\t\t\t}else if(this.textAlign == 'center'){\n\t\t\t\t\tx = start[0];\n\t\t\t\t}else if(this.textAlign == 'right'){\n\t\t\t\t\tx = start[0] - this.range.width*0.5;\n\t\t\t\t}\n\n\t\t\t\tif(this.textBaseline == 'top'){\n\t\t\t\t\ty = this.range.height *0.5+start[1];\n\t\t\t\t}else if(this.textBaseline == 'middle'){\n\t\t\t\t\ty = start[1];\n\t\t\t\t}else if(this.textBaseline == 'bottom'){\n\t\t\t\t\ty = start[1] - this.range.height*0.5;\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tx:x,\n\t\t\t\t\ty:y\n\t\t\t\t}\n\t\t\t},\n\t\t\tpolyPoints:function(){  //顶点坐标序列\n\t\t\t\t\tvar half_x = this.range.width*0.5;\n\t\t\t\t\tvar half_y = this.range.height*0.5; \n\t\t\t\t\tvar center = this.centerPoints();\n\n\n\n\t\t\t\t\t// var pos1x = 0,pos1y = 0,pos2x = 0,pos2y = 0,pos3x = 0,pos3y = 0,pos4x = 0,pos4y = 0;\n\n\n\t\t\t\t\t// if(this.textAlign == 'center'){\n\t\t\t\t\t// \tpos1x = this.start[0]-half_x;\n\t\t\t\t\t// \tpos2x = this.start[0]+half_x;\n\t\t\t\t\t// \tpos3x = this.start[0]+half_x;\n\t\t\t\t\t// \tpos4x = this.start[0]-half_x;\n\t\t\t\t\t// }else if(this.textAlign == 'left'){\n\t\t\t\t\t// \tpos1x = this.start[0];\n\t\t\t\t\t// \tpos2x = this.start[0]+half_x*2;\n\t\t\t\t\t// \tpos3x = this.start[0];\n\t\t\t\t\t// \tpos4x = this.start[0]+half_x*2;\n\t\t\t\t\t// }else if(this.textAlign == 'right'){\n\t\t\t\t\t// \tpos1x = this.start[0]-half_x*2;\n\t\t\t\t\t// \tpos2x = this.start[0];\n\t\t\t\t\t// \tpos3x = this.start[0];\n\t\t\t\t\t// \tpos4x = this.start[0]-half_x*2;\n\t\t\t\t\t// }\n\n\t\t\t\t\t// if(this.textBaseline == 'middle'){\n\t\t\t\t\t// \tpos1y = this.start[1]-half_y;\n\t\t\t\t\t// \tpos2y = this.start[1]-half_y;\n\t\t\t\t\t// \tpos3y = this.start[1]+half_y;\n\t\t\t\t\t// \tpos4y = this.start[1]+half_y;\n\t\t\t\t\t// }else if(this.textBaseline == 'top'){\n\t\t\t\t\t// \tpos1y = this.start[1];\n\t\t\t\t\t// \tpos2y = this.start[1];\n\t\t\t\t\t// \tpos3y = this.start[1]+half_y*2;\n\t\t\t\t\t// \tpos4y = this.start[1]+half_y*2;\n\t\t\t\t\t// }else if(this.textBaseline == 'bottom'){\n\t\t\t\t\t// \tpos1y = this.start[1]-half_y*2;\n\t\t\t\t\t// \tpos2y = this.start[1]-half_y*2;\n\t\t\t\t\t// \tpos3y = this.start[1];\n\t\t\t\t\t// \tpos4y = this.start[1];\n\t\t\t\t\t// }\n\n\t\t\t\t\t// return [\n\t\t\t\t\t// \t{\"x\":pos1x,\"y\":pos1y},\n\t\t\t\t\t// \t{\"x\":pos2x,\"y\":pos2y},\n\t\t\t\t\t// \t{\"x\":pos3x,\"y\":pos3y},\n\t\t\t\t\t// \t{\"x\":pos4x,\"y\":pos4y}\n\n\t\t\t\t\t// ]\n\n\n\t\t\t\t\t// return [\n\t\t\t\t\t// \t{\"x\":this.start[0]-half_x,\"y\":this.start[1]-half_y},\n\t\t\t\t\t// \t{\"x\":this.start[0]+half_x,\"y\":this.start[1]-half_y},\n\t\t\t\t\t// \t{\"x\":this.start[0]+half_x,\"y\":this.start[1]+half_y},\n\t\t\t\t\t// \t{\"x\":this.start[0]-half_x,\"y\":this.start[1]+half_y},\n\t\t\t\t\t// ]\n\t\t\t\t\tvar temp = 0;\n\t\t\t\t\tif(this.degree <0){ \n\t\t\t\t\t\ttemp = 360+this.degree;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp = this.degree;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif((temp>0 && temp<=90) || (temp>180 && temp<=270)){\n\n\t\t\t\t\t\tif(temp >180){\n\t\t\t\t\t\t\ttemp = temp-180;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar E_x = center.x-Math.cos(temp*Math.PI/180)*half_x;\n\t\t\t\t\t\tvar E_y = center.y-Math.sin(temp*Math.PI/180)*half_x;\n\t\t\t\t\t\t \n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{x:E_x+Math.sin(temp*Math.PI/180)*half_y,y:E_y-Math.cos(temp*Math.PI/180)*half_y},\n\t\t\t\t\t\t\t{x:center.x-(E_x-Math.sin(temp*Math.PI/180)*half_y)+center.x,y:center.y-(E_y+Math.cos(temp*Math.PI/180)*half_y)+center.y},\n\t\t\t\t\t\t\t{x:center.x-(E_x+Math.sin(temp*Math.PI/180)*half_y)+center.x,y:center.y-(E_y-Math.cos(temp*Math.PI/180)*half_y)+center.y},\n\t\t\t\t\t\t\t{x:E_x-Math.sin(temp*Math.PI/180)*half_y,y:E_y+Math.cos(temp*Math.PI/180)*half_y},\n\t\t\t\t\t\t];\n\n\n\n\t\t\t\t\t}else if((temp>90 && temp<180) || (temp>270 && temp<360)){\n\n\t\t\t\t\t\tif(temp>270){\n\t\t\t\t\t\t\ttemp = temp-180;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttemp = 180 - temp;\n\t\t\t\t\t\tvar E_x = center.x+Math.cos(temp*Math.PI/180)*half_x;\n\t\t\t\t\t\tvar E_y = center.y-Math.sin(temp*Math.PI/180)*half_x;\n \n\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{x:E_x+Math.sin(temp*Math.PI/180)*half_y,y:E_y+Math.cos(temp*Math.PI/180)*half_y},\n\t\t\t\t\t\t\t{x:center.x-(E_x-Math.sin(temp*Math.PI/180)*half_y)+center.x,y:center.y-(E_y-Math.cos(temp*Math.PI/180)*half_y)+center.y},\n\t\t\t\t\t\t\t{x:center.x-(E_x+Math.sin(temp*Math.PI/180)*half_y)+center.x,y:center.y-(E_y+Math.cos(temp*Math.PI/180)*half_y)+center.y},\n\t\t\t\t\t\t\t{x:E_x-Math.sin(temp*Math.PI/180)*half_y,y:E_y-Math.cos(temp*Math.PI/180)*half_y},\n\t\t\t\t\t\t]\n\n\n\n\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{\"x\":center.x-half_x,\"y\":center.y-half_y},\n\t\t\t\t\t\t\t{\"x\":center.x+half_x,\"y\":center.y-half_y},\n\t\t\t\t\t\t\t{\"x\":center.x+half_x,\"y\":center.y+half_y},\n\t\t\t\t\t\t\t{\"x\":center.x-half_x,\"y\":center.y+half_y}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t},\t\n\t\t\tdownFun:function(e,position){\n\t\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\t\tthis.dis = [position.x-start[0],position.y-start[1]];\n\t\t\t},\n\t\t\tmoveFun:function(e,position){  //当配置drageRange时  开始限制坐标\n\n\t\t\t\tvar dragIsBool = _this.qcanvas.isBool(this.drag);\n\t\t\t\tvar dis  = this.dis;\n\t\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\t\tvar range = _this.qcanvas.isFun(this.dragRange)?this.dragRange():this.dragRange;\n\n\t\t\t\tvar x,y;\n\t\t\t\tif(dragIsBool && this.drag){\n\t\t\t\t\t x = position.x-dis[0];\n\t\t\t\t\t y = position.y-dis[1];\n\n\t\t\t\t\t if(range.length == 2){  \n\t\t\t\t\t\tx = x>=range[1][0]?range[1][0]:x;\n\t\t\t\t\t\tx = x<=range[0][0]?range[0][0]:x;\n\n\t\t\t\t\t\ty = y>=range[1][1]?range[1][1]:y;\n\t\t\t\t\t\ty = y<=range[0][1]?range[0][1]:y;\n\t\t\t\t\t}\n\n\t\t\t\t}else if(this.drag == 'vertical'){\n\t\t\t\t\t x = this.start[0];\n\t\t\t\t\t y = position.y-dis[1];\n\n\n\t\t\t\t\t if(range.length == 2){   \n\n\t\t\t\t\t\ty = y>=range[1][1]?range[1][1]:y;\n\t\t\t\t\t\ty = y<=range[0][1]?range[0][1]:y;\n\t\t\t\t\t}\n\n\n\t\t\t\t}else if(this.drag == 'horizontal'){\n\t\t\t\t\t x = position.x-dis[0];\n\t\t\t\t\t y = this.start[1]; \n\n\n\t\t\t\t\t if(range.length == 2){  \n\t\t\t\t\t\tx = x>=range[1][0]?range[1][0]:x;\n\t\t\t\t\t\tx = x<=range[0][0]?range[0][0]:x; \n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t \t//如果创建时位置数据依赖于别的元素 那么一旦拖动该元素 数据的依赖关系就会断开 切记\n\t\t\t\tthis.start = [x,y];\n\t\t\t},\n\t\t\tformatText:function(obj) {  //处理多行文本\n\t\t\t\tvar text = _this.qcanvas.isFun(obj.text)?obj.text():obj.text;\n\t\t\t\tvar t;\n\t\t\t\tif((text+'').indexOf('\\n') > -1){\n\t\t\t\t\tt =  text.split('\\n');\n\t\t\t\t}else{\n\n\t\t\t\t\tt = [text];\n\t\t\t\t}\n\n\t\t\t\t//计算每行的宽度\n\t\t\t\tvar w = [];\n\t\t\t\tt.forEach(function(item){\n\t\t\t\t\tw.push(_this.qcanvas.context.measureText(item).width);\n\t\t\t\t})\n\n\t\t\t\treturn {\n\t\t\t\t\ttext:t,\n\t\t\t\t\twidth:w\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\tthis.qcanvas.extend(OPTIONS,options);\n\tthis.qcanvas.appendSetFun(OPTIONS);\n\t\n\treturn OPTIONS;\n}\n \nQtext.prototype.paintText = function(obj){\n\tvar _this = this;\n\tvar textArr = obj.formatText(obj);  \n\n\tobj.range = {\n\t\t// width:this.qcanvas.context.measureText(this.qcanvas.isFun(obj.text)?obj.text():obj.text).width,\n\t //    height:parseInt(obj.fontSize),\n\t    width:Math.max.apply(null,textArr.width),\n\t    height:parseInt(obj.lineHeight)*textArr.text.length\n\t};\n\t\t//有角度时 移动画布原点 旋转画布\n\t\tvar centerPos = this.qcanvas.setDegree(obj);  \n\n\t\t//设置字体颜色\n    \t// this.qcanvas.context.strokeStyle = obj.color;\n    \tthis.qcanvas.context.fillStyle = obj.color;\n \n\t\t//可能路径是虚线形式的 设置成实线\n\t\tthis.qcanvas.context.setLineDash([]); \n\t\t\n\t\tvar start = this.qcanvas.isFun(obj.start)?obj.start():obj.start;\n\t\tthis.qcanvas.context.textBaseline = obj.textBaseline;\n\t\tthis.qcanvas.context.font = obj.fontSize + ' '+obj.fontFamily;\n\t\tthis.qcanvas.context.textAlign = obj.textAlign;\n    \t// this.qcanvas.context.strokeText(this.qcanvas.isFun(obj.text)?obj.text():obj.text,  start[0],  start[1]);\n    \t// this.qcanvas.context.fillText(this.qcanvas.isFun(obj.text)?obj.text():obj.text,  start[0],  start[1]);\n\n    \ttextArr.text.forEach(function(item,index){\n\t    \t_this.qcanvas.context.fillText(item,  start[0],  start[1]+parseInt(obj.lineHeight)*index);\n    \t})\n\n\n    \t\n\n\t\t// //重置画布原点 旋转复原\n\t\tthis.qcanvas.resetDegree(obj,centerPos); \n\t\t\n\n\t\t//重置\n\t\tthis.qcanvas.context.textAlign ='center';\n\t\tthis.qcanvas.context.textBaseline ='middle';\n\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n}\n\n\n/*矩形类-----------------------------------------------------*/\nfunction Qrect(qcanvas){\n\tthis.qrectVersion = '1.0';\n\tthis.qcanvas = qcanvas;\n\n}\n\nQrect.prototype.rect = function(options){\n\tvar _this = this;\n\tvar OPTIONS = {\n\t\t\tTYPE:'rect',\n\t\t\tlineWidth:1,\n\t\t\tstart:[0,0],\n\t\t\twidth:100,\n\t\t\theight:50,\n\t\t\tborderColor:'#000', \n\t\t\tfillColor:'',\n\t\t\tdrag:true,\n\t\t\tdragRange:[],\n\t\t\tdashed:false,\n\t\t\tdegree:0,\n\t\t\tradius:0,\n\t\t\tpointerEvent:'auto',\n\t\t\tresize:false,\n\t\t\trotate:false,\n\t\t\tcenterPoints:function(){ //元素中心点相对于整个画布的坐标\n\t\t\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\t\t\tvar width = _this.qcanvas.isFun(this.width)?this.width():this.width;\n\t\t\t\t\tvar height = _this.qcanvas.isFun(this.height)?this.height():this.height;\n\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tx:start[0]+width*0.5,\n\t\t\t\t\t\ty:start[1]+height*0.5\n\t\t\t\t\t}\n\n\t\t\t},\n\t\t\tpolyPoints:function(){  //顶点坐标序列\n\t\t\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\t\t\tvar width = _this.qcanvas.isFun(this.width)?this.width():this.width;\n\t\t\t\t\tvar height = _this.qcanvas.isFun(this.height)?this.height():this.height;\n\n\t\t\t\t\tvar half_x = width*0.5;\n\t\t\t\t\tvar half_y = height*0.5; \n\t\t\t\t\tvar center = this.centerPoints();\n\n\n\t\t\t\t\tvar temp = 0;\n\t\t\t\t\tif(this.degree <0){ \n\t\t\t\t\t\ttemp = 360+this.degree;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp = this.degree;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif((temp>0 && temp<=90) || (temp>180 && temp<=270)){\n\n\t\t\t\t\t\tif(temp >180){\n\t\t\t\t\t\t\ttemp = temp-180;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar E_x = center.x-Math.cos(temp*Math.PI/180)*half_x;\n\t\t\t\t\t\tvar E_y = center.y-Math.sin(temp*Math.PI/180)*half_x;\n\t\t\t\t\t\t \n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{x:E_x+Math.sin(temp*Math.PI/180)*half_y,y:E_y-Math.cos(temp*Math.PI/180)*half_y},\n\t\t\t\t\t\t\t{x:center.x-(E_x-Math.sin(temp*Math.PI/180)*half_y)+center.x,y:center.y-(E_y+Math.cos(temp*Math.PI/180)*half_y)+center.y},\n\t\t\t\t\t\t\t{x:center.x-(E_x+Math.sin(temp*Math.PI/180)*half_y)+center.x,y:center.y-(E_y-Math.cos(temp*Math.PI/180)*half_y)+center.y},\n\t\t\t\t\t\t\t{x:E_x-Math.sin(temp*Math.PI/180)*half_y,y:E_y+Math.cos(temp*Math.PI/180)*half_y},\n\t\t\t\t\t\t];\n\n\n\n\t\t\t\t\t}else if((temp>90 && temp<180) || (temp>270 && temp<360)){\n\n\t\t\t\t\t\tif(temp>270){\n\t\t\t\t\t\t\ttemp = temp-180;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttemp = 180 - temp;\n\t\t\t\t\t\tvar E_x = center.x+Math.cos(temp*Math.PI/180)*half_x;\n\t\t\t\t\t\tvar E_y = center.y-Math.sin(temp*Math.PI/180)*half_x;\n \n\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{x:E_x+Math.sin(temp*Math.PI/180)*half_y,y:E_y+Math.cos(temp*Math.PI/180)*half_y},\n\t\t\t\t\t\t\t{x:center.x-(E_x-Math.sin(temp*Math.PI/180)*half_y)+center.x,y:center.y-(E_y-Math.cos(temp*Math.PI/180)*half_y)+center.y},\n\t\t\t\t\t\t\t{x:center.x-(E_x+Math.sin(temp*Math.PI/180)*half_y)+center.x,y:center.y-(E_y+Math.cos(temp*Math.PI/180)*half_y)+center.y},\n\t\t\t\t\t\t\t{x:E_x-Math.sin(temp*Math.PI/180)*half_y,y:E_y-Math.cos(temp*Math.PI/180)*half_y},\n\t\t\t\t\t\t]\n\n\n\n\n\t\t\t\t\t}else{\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{\"x\":start[0],\"y\":start[1]},\n\t\t\t\t\t\t\t{\"x\":start[0]+width,\"y\":start[1]},\n\t\t\t\t\t\t\t{\"x\":start[0]+width,\"y\":start[1]+height},\n\t\t\t\t\t\t\t{\"x\":start[0],\"y\":start[1]+height},\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t},\t\n\t\t\tdownFun:function(e,position){\n\t\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\t\tthis.dis = [position.x-start[0],position.y-start[1]];\n\t\t\t},\n\t\t\tmoveFun:function(e,position){  //当配置drageRange时  开始限制坐标\n\n\t\t\t\tvar dragIsBool = _this.qcanvas.isBool(this.drag);\n\t\t\t\tvar dis  = this.dis;\n\t\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\t\t// var range = _this.qcanvas.isFun(this.dragRange)?this.dragRange():this.dragRange;\n\n\n\t\t\t\tvar x,y;\n\t\t\t\tif(dragIsBool && this.drag){\n\t\t\t\t\t x = position.x-dis[0];\n\t\t\t\t\t y = position.y-dis[1];\n\n\t\t\t\t\t//  if(range.length == 2){  \n\t\t\t\t\t// \tx = x>=range[1][0]?range[1][0]:x;\n\t\t\t\t\t// \tx = x<=range[0][0]?range[0][0]:x;\n\n\t\t\t\t\t// \ty = y>=range[1][1]?range[1][1]:y;\n\t\t\t\t\t// \ty = y<=range[0][1]?range[0][1]:y;\n\t\t\t\t\t// }\n\n\t\t\t\t}else if(this.drag == 'vertical'){\n\t\t\t\t\t x = this.start[0];\n\t\t\t\t\t y = position.y-dis[1];\n\n\n\t\t\t\t\t//  if(range.length == 2){   \n\n\t\t\t\t\t// \ty = y>=range[1][1]?range[1][1]:y;\n\t\t\t\t\t// \ty = y<=range[0][1]?range[0][1]:y;\n\t\t\t\t\t// }\n\n\n\t\t\t\t}else if(this.drag == 'horizontal'){\n\t\t\t\t\t x = position.x-dis[0];\n\t\t\t\t\t y = this.start[1]; \n\n\n\t\t\t\t\t//  if(range.length == 2){  \n\t\t\t\t\t// \tx = x>=range[1][0]?range[1][0]:x;\n\t\t\t\t\t// \tx = x<=range[0][0]?range[0][0]:x; \n\t\t\t\t\t// }\n\t\t\t\t} \n\t\t\t \t//如果创建时位置数据依赖于别的元素 那么一旦拖动该元素 数据的依赖关系就会断开 切记\n\t\t\t\tthis.start = [x,y];\n\t\t\t}\n\t\t\t// mouseup:function(position){\n\t\t\t// \t\tconsole.log('添加一些点击的事件');\n\t\t\t// }\t\t\t\n\n\t\t\n\t\t\t\n\t\t}\n\t\t\t\n\tthis.qcanvas.extend(OPTIONS,options);\n\tthis.qcanvas.appendSetFun(OPTIONS);\n\t\n\treturn OPTIONS;\n}\n\nQrect.prototype.drawRoundedRect = function(ctx, x, y, width, height, obj) {\n\t\t\t\n\n            ctx.beginPath(); // draw top and top right corner \n\n            ctx.lineWidth=obj.lineWidth;\n            ctx.strokeStyle=obj.borderColor;\n           \n            ctx.moveTo(x + obj.radius, y);\n            ctx.arcTo(x + width, y, x + width, y + obj.radius, obj.radius); // draw right side and bottom right corner \n            ctx.arcTo(x + width, y + height, x + width - obj.radius, y + height, obj.radius); // draw bottom and bottom left corner \n            ctx.arcTo(x, y + height, x, y + height - obj.radius, obj.radius); // draw left and top left corner \n            ctx.arcTo(x, y, x + obj.radius, y, obj.radius);\n            \n\n            ctx.stroke();\n\n\n            \n            var rgb = this.qcanvas.colorRgb(obj.fillColor).replace('RGB(','').replace(')','');\n\n\t\t(obj.fillColor!='') && \n\t\t\t(obj.opacity && (ctx.fillStyle=\"rgba(\"+rgb+','+obj.opacity+\")\") ||\n\t\t\t(ctx.fillStyle = obj.fillColor)) &&\n\t\t\tctx.fill();\n \n        }\n\nQrect.prototype.paintRect = function(obj){\n\t\t// console.log(this);\n\t\tthis.qcanvas.qanimation.createAnimation(obj);\t\n\n\t\tvar start = this.qcanvas.isFun(obj.start)?obj.start():obj.start;\n\t\tvar width = this.qcanvas.isFun(obj.width)?obj.width():obj.width;\n\t\tvar height = this.qcanvas.isFun(obj.height)?obj.height():obj.height;\n\n\n\t\t//有角度时 移动画布原点 旋转画布\n\t\tvar centerPos = this.qcanvas.setDegree(obj);   \n\n\t\tif(obj.dashed){\n\t\t\tthis.qcanvas.context.setLineDash([3]);\n\t\t}\n\n\n\t\tif(this.qcanvas.isNum(obj.radius) && (obj.radius>0)){  //圆角矩形\n\n\t\t\tthis.drawRoundedRect(this.qcanvas.context,start[0],start[1],width,height,obj);\n\t\t}else{\n\t\t\tthis.qcanvas.context.beginPath();\n\t\t\tthis.qcanvas.context.lineWidth=obj.lineWidth;\n\t\t\tthis.qcanvas.context.strokeStyle=obj.borderColor;\n\t\t\n\t\t\t\n\t\t\n\t\t\tthis.qcanvas.context.rect(start[0],start[1],width,height);\n\t\t\tthis.qcanvas.context.stroke();\n\n\t\t\tvar rgb = this.qcanvas.colorRgb(obj.fillColor).replace('RGB(','').replace(')','');\n\t\t\n\t\t(obj.fillColor!='') && \n\t\t\t(obj.opacity && (this.qcanvas.context.fillStyle=\"rgba(\"+rgb+','+obj.opacity+\")\") ||\n\t\t\t(this.qcanvas.context.fillStyle = obj.fillColor)) &&\n\t\t\tthis.qcanvas.context.fill();\n\t\t}\n\n\t\t\n\t\n\t\n\t\t// (obj.fillColor!='') && (this.qcanvas.context.fillStyle = obj.fillColor) && this.qcanvas.context.fill();\n\n\t\t// //重置画布原点 旋转复原\n\t\tthis.qcanvas.resetDegree(obj,centerPos); \n\n\t\tthis.qcanvas.context.setLineDash([]);\n\n\n}\n\n\t\t\n/*不规则图形类*/\nfunction Qshape(qcanvas){\n\tthis.qshapeVersion = '1.0';\n\tthis.qcanvas = qcanvas;\n\t\n\t\n}\t\n\nQshape.prototype.shape = function(options){\n\t\tvar _this = this;\n\t\tvar OPTIONS = {\n\t\t\tTYPE:'shape',\n\t\t\tfillColor:'#666',\n\t\t\tpoints:[\n\t\t\t\t[310,20],\n\t\t\t\t[556,100],\n\t\t\t\t[530,191],\n\t\t\t\t[350,180]\n\t\t\t],\n\t\t\tdrag:true,\n\t\t\tpointerEvent:'auto',\n\t\t\tpolyPoints:function(){  //顶点坐标序列\n\t\t\t\t\t\n\t\t\t\tvar temp = [];\n\t\t\t\tvar points = _this.qcanvas.isFun(this.points)?this.points():this.points;\n\t\t\t\tpoints.forEach(function(v,index){\n\t\t\t\t\ttemp.push({\n\t\t\t\t\t\t\"x\":v[0],\n\t\t\t\t\t\t\"y\":v[1]\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t\t\n\t\t\t\treturn temp;\n\t\t\t\t\t\n\t\t\t},\t\n\t\t\tdownFun:function(e,position){\n\t\t\t\tvar _self = this;\n\t\t\t\tthis.dis = [];\n\t\t\t\tvar points = _this.qcanvas.isFun(this.points)?this.points():this.points;\n\t\t\t\tpoints.forEach(function(v,index){\n\t\t\t\t\t\t_self.dis.push([\n\t\t\t\t\t\t\tposition.x-points[index][0],\n\t\t\t\t\t\t\tposition.y-points[index][1]\n\t\t\t\t\t\t])\t\t\t\t\n\t\t\t\t})\n\t\t\t},\n\t\t\tmoveFun:function(e,position){\n\t\t\t\tvar dragIsBool = _this.qcanvas.isBool(this.drag);\n\t\t\t\tvar dis  =this.dis;\n\t\t\t\tvar points = _this.qcanvas.isFun(this.points)?this.points():this.points;\n\t\t\t\tpoints.forEach(function(v,index){\n\t\t\t\t\t\tpoints[index][0] = position.x- dis[index][0];\n\t\t\t\t\t\tpoints[index][1] = position.y- dis[index][1];\n\t\t\t\t\t\n\t\t\t\t})\n\t\t\t\t\n\t\t\t\tif(dragIsBool && this.drag){\n\t\t\t\t\tpoints.forEach(function(v,index){\n\t\t\t\t\t\t\tpoints[index][0] = position.x- dis[index][0];\n\t\t\t\t\t\t\tpoints[index][1] = position.y- dis[index][1];\n\t\t\t\t\t\t\n\t\t\t\t\t})\n\t\t\t\t}else if(this.drag == 'vertical'){\n\t\t\t\t\t points.forEach(function(v,index){\n\t\t\t\t\t\t\t// points[index][0] = position.x- dis[index][0];\n\t\t\t\t\t\t\tpoints[index][1] = position.y- dis[index][1];\n\t\t\t\t\t\t\n\t\t\t\t\t})\n\n\t\t\t\t}else if(this.drag == 'horizontal'){\n\t\t\t\t\t points.forEach(function(v,index){\n\t\t\t\t\t\t\tpoints[index][0] = position.x- dis[index][0];\n\t\t\t\t\t\t\t// points[index][1] = position.y- dis[index][1];\n\t\t\t\t\t\t\n\t\t\t\t\t})\n\t\t\t\t}\n\n\n\t\t\t\tthis.points = points;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\t\n\tthis.qcanvas.extend(OPTIONS,options);\n\tthis.qcanvas.appendSetFun(OPTIONS);\n\t\n\treturn OPTIONS;\n}\n\nQshape.prototype.paintShape = function(obj){\n\tthis.qcanvas.context.lineWidth=1;\n\tthis.qcanvas.context.strokeStyle = \"#000\";\n\tthis.qcanvas.context.beginPath();\n\t\n\tvar _this = this;\n\tvar points = this.qcanvas.isFun(obj.points)?obj.points():obj.points;\n\tpoints.forEach(function(v,index){\n\t\tif(index==0){\n\t\t\t_this.qcanvas.context.moveTo(v[0], v[1]);\n\t\t}else{\n\t\t\t_this.qcanvas.context.lineTo(v[0], v[1]);\n\t\t}\n\t})\n\t\n\t\n\t//先关闭绘制路径。注意，此时将会使用直线连接当前端点和起始端点。\n\tthis.qcanvas.context.closePath();\n\tthis.qcanvas.context.stroke();\n\t\n\tvar rgb = this.qcanvas.colorRgb(obj.fillColor).replace('RGB(','').replace(')','');\n\t\n\t(obj.fillColor!='') && \n\t\t(obj.opacity && (this.qcanvas.context.fillStyle=\"rgba(\"+rgb+','+obj.opacity+\")\") ||\n\t\t(this.qcanvas.context.fillStyle = obj.fillColor)) &&\n\t\tthis.qcanvas.context.fill();\n}\n\t\t\n\t\n\n/*圆类--------------------*/\nfunction Qarc(qcanvas){\n\tthis.qarcVersion = '1.0';\n\tthis.qcanvas = qcanvas; \n}\n\nQarc.prototype.arc = function(options){\n\tvar  _this = this;\n\tvar OPTIONS = {\n\t\t\tTYPE:'arc',\n\t\t\tlineWidth:1,\n\t\t\tborderColor:'#000',\n\t\t\tfillColor:'red',\n\t\t\tstart:[0,0],\n\t\t\tr:20,\n\t\t\tsAngle:0,\n\t\t\teAngle:0,\n\t\t\tcounterclockwise:false,\n\t\t  drag:true,\n\t\t  dragRange:[],  //限制拖动的区域 必须为两个坐标点[[左上角x,左上角y]，[右下角x,右下角y]]\n\t\t  pointerEvent:'auto',\n\t\t  like:'-',\n\t\t\tpolyPoints:function(){  //顶点坐标序列 (注意顺序 要形成一个闭合的区域)\n\t\t\t\t\n\t\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\t\t//平均分八个点 有45度的\n\t\t\t\tvar temp =  [\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t{'x':start[0]+this.r,'y':start[1]},\n\t\t\t\t\t{'x':start[0]+0.7071*this.r,'y':start[1]-0.7071*this.r}, //第一象限的45度的点\n\t\t\t\t\t{'x':start[0],'y':start[1]-this.r},\n\t\t\t\t\t{'x':start[0]-0.7071*this.r,'y':start[1]-0.7071*this.r}, //第二象限的45度的点\n\t\t\t\t\t{'x':start[0]-this.r,'y':start[1]},\n\t\t\t\t\t{'x':start[0]-0.7071*this.r,'y':start[1]+0.7071*this.r}, //第三象限的45度的度\n\t\t\t\t\t{'x':start[0],'y':start[1]+this.r},\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t{'x':start[0]+0.7071*this.r,'y':start[1]+0.7071*this.r}, //第四象限的45度的度\n\t\t\t\t];\n\t\t\t\treturn temp;\t\n\t\t\t\t\t\n\t\t\t},\t\n\t\t\tdownFun:function(e,position){\n\t\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start; \n\t\t\t\tthis.dis = [position.x-start[0],position.y-start[1]];\n\t\t\t},\n\t\t\tmoveFun:function(e,position){  //当配置drageRange时  开始限制坐标\n\n\t\t\t\tvar dragIsBool = _this.qcanvas.isBool(this.drag);\n\t\t\t\tvar dis  = this.dis;\n\t\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\t\tvar range = _this.qcanvas.isFun(this.dragRange)?this.dragRange():this.dragRange;\n\n\n\t\t\t\tvar x,y;\n\t\t\t\tif(dragIsBool && this.drag){\n\t\t\t\t\t x = position.x-dis[0];\n\t\t\t\t\t y = position.y-dis[1];\n\n\t\t\t\t\t if(range.length == 2){  \n\t\t\t\t\t\tx = x>=range[1][0]?range[1][0]:x;\n\t\t\t\t\t\tx = x<=range[0][0]?range[0][0]:x;\n\n\t\t\t\t\t\ty = y>=range[1][1]?range[1][1]:y;\n\t\t\t\t\t\ty = y<=range[0][1]?range[0][1]:y;\n\t\t\t\t\t}\n\n\t\t\t\t}else if(this.drag == 'vertical'){\n\t\t\t\t\t x = this.start[0];\n\t\t\t\t\t y = position.y-dis[1];\n\n\n\t\t\t\t\t if(range.length == 2){   \n\n\t\t\t\t\t\ty = y>=range[1][1]?range[1][1]:y;\n\t\t\t\t\t\ty = y<=range[0][1]?range[0][1]:y;\n\t\t\t\t\t}\n\n\n\t\t\t\t}else if(this.drag == 'horizontal'){\n\t\t\t\t\t x = position.x-dis[0];\n\t\t\t\t\t y = this.start[1]; \n\n\n\t\t\t\t\t if(range.length == 2){  \n\t\t\t\t\t\tx = x>=range[1][0]?range[1][0]:x;\n\t\t\t\t\t\tx = x<=range[0][0]?range[0][0]:x; \n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t \t//如果创建时位置数据依赖于别的元素 那么一旦拖动该元素 数据的依赖关系就会断开 切记\n\t\t\t\tthis.start = [x,y];\n\t\t\t}\n\t\t}\n\t\t\t\n\tthis.qcanvas.extend(OPTIONS,options);\n\tthis.qcanvas.appendSetFun(OPTIONS);\n\t\n\treturn OPTIONS;\n}\t\n\t\nQarc.prototype.paintArc = function(obj){\n\n\tif(obj.like=='--'){\n\t\tthis.qcanvas.context.setLineDash([3]);\n\t}\n\n\tvar unit = Math.PI / 180;\n\tthis.qcanvas.qanimation.createAnimation(obj);\n\tthis.qcanvas.context.beginPath();\n\tthis.qcanvas.context.lineWidth=obj.lineWidth;\n\tthis.qcanvas.context.strokeStyle=obj.borderColor;\n\tvar start = this.qcanvas.isFun(obj.start)?obj.start():obj.start;\n\tthis.qcanvas.context.arc(start[0],start[1],obj.r,obj.sAngle*unit,obj.eAngle*unit);\n\n\tthis.qcanvas.context.stroke();\n\t\n\tvar rgb = this.qcanvas.colorRgb(obj.fillColor).replace('RGB(','').replace(')','');\n\t\n\t(obj.fillColor!='') && \n\t\t(obj.opacity && (this.qcanvas.context.fillStyle=\"rgba(\"+rgb+','+obj.opacity+\")\") ||\n\t\t(this.qcanvas.context.fillStyle = obj.fillColor)) &&\n\t\tthis.qcanvas.context.fill();\n\n\tthis.qcanvas.context.setLineDash([]);\n\t\n}\t\n\t\n\t\n/*正多边形类----------------*/\nfunction Qpolygon(qcanvas){\n\tthis.qpolygonVersion = '1.0';\n\tthis.qcanvas = qcanvas;\n}\nQpolygon.prototype.polygon = function(options){\n\tvar _this = this;\n\tvar OPTIONS = {\n\t\t\tTYPE:'polygon',\n\t\t\tlineWidth:1,\n\t\t\tborderColor:'#000',\n\t\t\tfillColor:'red',\n\t\t\tstart:[0,0],\n\t\t\tr:20,\n\t\t\tnum:4,\n\t\t\tdrag:true,\n\t\t\tdragRange:[],\n\t\t\topacity:1,\n\t\t\tpointerEvent:'auto',\n\t\t\tdownFun:function(e,position){\n\t\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\t\tthis.dis = [position.x-start[0],position.y-start[1]];\n\t\t\t},\n\t\t\tmoveFun:function(e,position){  //当配置drageRange时  开始限制坐标\n\n\t\t\t\tvar dragIsBool = _this.qcanvas.isBool(this.drag);\n\t\t\t\tvar dis  = this.dis;\n\t\t\t\tvar start = _this.qcanvas.isFun(this.start)?this.start():this.start;\n\t\t\t\tvar range = _this.qcanvas.isFun(this.dragRange)?this.dragRange():this.dragRange;\n\n\n\t\t\t\tvar x,y;\n\t\t\t\tif(dragIsBool && this.drag){\n\t\t\t\t\t x = position.x-dis[0];\n\t\t\t\t\t y = position.y-dis[1];\n\n\t\t\t\t\t if(range.length == 2){  \n\t\t\t\t\t\tx = x>=range[1][0]?range[1][0]:x;\n\t\t\t\t\t\tx = x<=range[0][0]?range[0][0]:x;\n\n\t\t\t\t\t\ty = y>=range[1][1]?range[1][1]:y;\n\t\t\t\t\t\ty = y<=range[0][1]?range[0][1]:y;\n\t\t\t\t\t}\n\n\t\t\t\t}else if(this.drag == 'vertical'){\n\t\t\t\t\t x = this.start[0];\n\t\t\t\t\t y = position.y-dis[1];\n\n\n\t\t\t\t\t if(range.length == 2){   \n\n\t\t\t\t\t\ty = y>=range[1][1]?range[1][1]:y;\n\t\t\t\t\t\ty = y<=range[0][1]?range[0][1]:y;\n\t\t\t\t\t}\n\n\n\t\t\t\t}else if(this.drag == 'horizontal'){\n\t\t\t\t\t x = position.x-dis[0];\n\t\t\t\t\t y = this.start[1]; \n\n\n\t\t\t\t\t if(range.length == 2){  \n\t\t\t\t\t\tx = x>=range[1][0]?range[1][0]:x;\n\t\t\t\t\t\tx = x<=range[0][0]?range[0][0]:x; \n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t \t//如果创建时位置数据依赖于别的元素 那么一旦拖动该元素 数据的依赖关系就会断开 切记\n\t\t\t\tthis.start = [x,y];\n\t\t\t}\n\t\t}\n\t\t\t\n\tthis.qcanvas.extend(OPTIONS,options);\n\tthis.qcanvas.appendSetFun(OPTIONS);\n\t\n\treturn OPTIONS;\n}\t\n\t\n\t\nQpolygon.prototype.paintPolygon = function(obj){\n\tvar ctx = this.qcanvas.context;\n\t\n\tvar x = obj && obj.start[0] || 0;  //中心点x坐标\n    var y = obj && obj.start[1] || 0;  //中心点y坐标\n    var num = obj && obj.num || 3;   //图形边的个数\n    var r = obj && obj.r || 100;   //图形的半径\n    var width = obj && obj.lineWidth || 1;\n    var strokeStyle = obj && obj.borderColor;\n    var fillStyle = obj && obj.fillColor;\n    var opacity = obj && obj.opacity;\n    //开始路径\n    ctx.beginPath();\n    var points = [];\n    var startX = x + r * Math.cos(2*Math.PI*0/num);\n    var startY = y + r * Math.sin(2*Math.PI*0/num);\n    ctx.moveTo(startX, startY);\n    points.push({x:startX,y:startY});\n    for(var i = 1; i <= num; i++) {\n        var newX = x + r * Math.cos(2*Math.PI*i/num);\n        var newY = y + r * Math.sin(2*Math.PI*i/num);\n        ctx.lineTo(newX, newY);\n        points.push({x:newX,y:newY});\n    }\n    ctx.closePath();\n\n\n    //顶点坐标序列 用于点击时目标元素的判断\n    obj.polyPoints = function(){\n    \treturn points;\n    }\n\n\n\n    //路径闭合\n    if(strokeStyle) {\n        ctx.strokeStyle = strokeStyle;\n        ctx.lineWidth = width;\n        ctx.lineJoin = 'round';\n        ctx.stroke();\n    }\n    if(fillStyle) {\n\n\t\tvar rgb = this.qcanvas.colorRgb(fillStyle).replace('RGB(','').replace(')','');\n \n\t    ctx.fillStyle = \"rgba(\"+rgb+','+obj.opacity+\")\";\n\t\t\n\n        ctx.fill();\n    }\n\n \n\t\n}\t\t\n\n/*动画类----------------*/\nfunction Qanimation(qcanvas){\n\tthis.qanimationVersion = '1.0';\n\tthis.qcanvas = qcanvas;\n}\t\n\nQanimation.prototype.animate = function(aim,startStyle,endStyle,during,isLoop,tweenType,finishCallback){\n\t\n\t//要求 startStyle对象和endStyle对象属性必须是一样的\n\t//序列帧对象(属性=>值)  \n\tvar frames = {};\n\tvar framesCount = this.qcanvas.fps * during;\n\tvar tweenType = typeof tweenType !='undefined'?(tweenType==''?'Linear':tweenType):'Linear';\n\t// console.log(tweenType);\n\t\n\tvar tween = eval('this.qcanvas.Tween[\"'+tweenType.split('.').join('\"][\"')+'\"]');\n\t// console.log(tween);\n\t\n\tfor(var i in startStyle){\n\t\t\t\n\t\t\t//如果是属性的值是数组的 生成成对的数组序列 用于渲染动画\n\t\t\tif(this.qcanvas.isArr(startStyle[i])){\n\t\t\t\tframes[i] = [];\n\t\t\t\t\n\t\t\t\tvar perArr = [];\n\t\t\t\tfor(var j=0;j<startStyle[i].length;j++){\n\t\t\t\t\t\tperArr.push((endStyle[i][j] - startStyle[i][j])/framesCount);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfor(var t=0;t<framesCount;t++){\n\t\t\t\t\tvar temp = [];\n\t\t\t\t\tfor(var p=0;p<perArr.length;p++){\n\t\t\t\t\t\t\t//temp.push(startStyle[i][p]+ t*perArr[p]);  //暂时都是线性变化 \n\t\t\t\t\t\ttemp.push(tween(t,startStyle[i][p],perArr[p]*framesCount,framesCount));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tframes[i].push(temp);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t//属性的值是数字的\n\t\t\tif(this.qcanvas.isNum(startStyle[i])){\n\t\t\t\tframes[i] = [];\n\t\t\t\tvar per = (endStyle[i] - startStyle[i])/framesCount;\n\t\t\t\t\n\t\t\t\tfor(var t=0;t<framesCount;t++){\n\t\t\t\t\tframes[i].push(tween(t,startStyle[i],endStyle[i] - startStyle[i],framesCount));\n\t\t\t\t\t\n\t\t\t\t\t//frames[i].push(startStyle[i]+ t*per);\n\t\t\t\t\t//\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\taim.animation = {\n\t\t'framesIndex':0,\n\t\t'framesCount':framesCount,\n\t\t'during':during,\n\t\t'frames':frames,\n\t\t'isLoop':isLoop?isLoop:false,\n\t\t'isExeCallback':false,  //是否已执行了finishCallback\n\t\t'finishCallback':finishCallback?finishCallback:function(){}\n\t}\n\t\n}\n//通过对象的animation属性中序列对象frames 改变相应的属性值\n//使渲染过程中生成动画\t\t\nQanimation.prototype.createAnimation = function(obj){\n\t\t\n\t\tif(typeof obj.animation !='undefined' && obj.animation && obj.animation.frames){\n\t\t\t\t\n\t\t\t\tvar framesIndex = obj.animation.framesIndex;\n\t\t\t\tvar framesCount = obj.animation.framesCount;\n\t\t\t\tvar frames = obj.animation.frames;\n\t\t\t\tvar isLoop = obj.animation.isLoop;\n\t\t\n\t\t\t\tobj.animation.step = typeof obj.animation.step !='undefined'?obj.animation.step:1;//控制方向  \n\t\t\t\t\n\t\t\t\tvar step = obj.animation.step;\n\t\t\t\t\n\t\t\t\tobj.animation.framesIndex=obj.animation.framesIndex+step;\n\t\t\n\t\t\t\tobj.animation.framesIndex = obj.animation.framesIndex<=0?0:obj.animation.framesIndex;\n\t\t\n\t\t\t\tobj.animation.framesIndex = obj.animation.framesIndex>=framesCount?(framesCount-1):obj.animation.framesIndex;\n\t\t\t\t\n\t\t\t\tif(typeof isLoop !='undefined'){\n\n\t\t\t\t\tif(this.qcanvas.isNum(isLoop)){ //循环次数\n\n\t\t\t\t\t\tisLoop = isLoop > 0?isLoop:1;\n\n\t\t\t\t\t\tif(typeof obj.animation.loopNum =='undefined'){\n\t\t\t\t\t\t\tobj.animation.loopNum = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(obj.animation.framesIndex==(framesCount-1)){\n\t\t\t\t\t\t\t\tobj.animation.loopNum ++;\n\n\t\t\t\t\t\t\t\tif(obj.animation.loopNum <= isLoop){\n\t\t\t\t\t\t\t\t\tobj.animation.step = -1; //反方向运动回去\t\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif((obj.animation.loopNum -1) == isLoop){\n\t\t\t\t\t\t\t\t\tobj.animation.finishCallback(obj);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(obj.animation.framesIndex == 0){\n\t\t\t\t\t\t\tobj.animation.loopNum ++;\n\n\n\t\t\t\t\t\t\tif(obj.animation.loopNum <= isLoop){\n\t\t\t\t\t\t\t\tobj.animation.step = 1; //反方向运动回去\t\n\t\t\t\t\t\t\t\t// obj.animation.framesIndex = 0;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif((obj.animation.loopNum -1) == isLoop){\n\t\t\t\t\t\t\t\tobj.animation.finishCallback(obj);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\n\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tif(isLoop){\n\t\t\t\t\t\t\tif(obj.animation.framesIndex==(framesCount-1)){\n\t\t\t\t\t\t\t\tobj.animation.step = -1; //反方向运动回去\t\n\t\t\t\t\t\t\t\t// obj.animation.framesIndex = 0;\n\t\t\t\t\t\t\t\tobj.animation.finishCallback(obj);\n\t\t\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(obj.animation.framesIndex==0){\n\t\t\t\t\t\t\t\tobj.animation.step = 1; \n\t\t\t\t\t\t\t\tobj.animation.finishCallback(obj);\t\t\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(obj.animation.framesIndex==(framesCount-1)){\n\t\t\t\t\t\t\t\t!obj.animation.isExeCallback && (obj.animation.isExeCallback = true) && \n\t\t\t\t\t\t\t\tobj.animation.finishCallback(obj);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\n\t\t\t\t}else{\n\n\t\t\t\t\tif(obj.animation.framesIndex==(framesCount-1)){\n\t\t\t\t\t\t!obj.animation.isExeCallback && (obj.animation.isExeCallback = true) && \n\t\t\t\t\t\tobj.animation.finishCallback(obj);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\n\t\t\t\t//console.log(framesIndex);\n\t\t\t\t\n\t\t\t\n\t\t\t\tfor(var i in obj.animation.frames){\n\t\t\t\t\t\tobj[i] =  obj.animation.frames[i][framesIndex];\n\t\t\t\t}\n\t\t\t\t\n\t\t\n\t\t}\n\t\t\n}\t\n\n\t\n/*画图片类*/\nfunction Qimg(qcanvas){\n\tthis.qimgVersion = '1.0';\n\tthis.qcanvas = qcanvas;\n}\t\n\nQimg.prototype.sourcePosition = function(pic,w,h){\n\t\t\t\n\t\t\t//原图及目标区域的宽高比\n\t\t\tvar sourceRate = pic.width/pic.height;\n\t\t\tvar targetRate = w/h;\n\t\t\tvar x,y,w,h;\n\t\t\t\n\t\t\tif(sourceRate>=targetRate){\n\t\t\t\t\th = pic.height;\n\t\t\t\t\tw = targetRate*pic.height;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tx = (pic.width - w)*0.5;\n\t\t\t}else{\n\t\t\t\t\tw = pic.width;\n\t\t\t\t\th = pic.width/targetRate;\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = (pic.height - h)*0.5;\n\t\t\t\n\t\t\t}\n\t\t\t\n\treturn {\n\t\tsStart:[x,y],\n\t\tsWidth:w,\n\t\tsHeight:h,\n\t\tsourceRate:sourceRate,\n\t\ttargetRate:targetRate\n\t}\n\t\n\t\n}\n\nQimg.prototype.img = function(options){\n\tvar _this = this;\n\tvar OPTIONS = {\n\t\t\tTYPE:'img',\n\t\t\timg:{},\n\t\t\tsize:\"\",\n\t\t\tdrag:true,\n\t\t\tpointerEvent:'auto',\n\t\t\tdegree:0,\n\t\t\t/*sStart:[0,0],\n\t\t\tsWidth:options.width,\n\t\t\tsHeight:options.height,\n\t\t\ttStart:[0,0],\n\t\t\ttWidth:options.width,\n\t\t\ttHeight:options.height,*/\n\t\t\tcenterPoints:function(){ //元素中心点相对于整个画布的坐标\n\t\t\t\t\tvar tStart = _this.qcanvas.isFun(this.tStart)?this.tStart():this.tStart; \n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tx:tStart[0]+this.tWidth*0.5,\n\t\t\t\t\t\ty:tStart[1]+this.tHeight*0.5\n\t\t\t\t\t}\n\n\t\t\t},\n\t\t\tpolyPoints:function(){  //顶点坐标序列 \n\t\t\t\tvar tStart = _this.qcanvas.isFun(this.tStart)?this.tStart():this.tStart;\n\n\n\t\t\t\t\tvar half_x = this.tWidth*0.5;\n\t\t\t\t\tvar half_y = this.tHeight*0.5; \n\t\t\t\t\tvar center = this.centerPoints();\n\n\n\t\t\t\t\tvar temp = 0;\n\t\t\t\t\tif(this.degree <0){ \n\t\t\t\t\t\ttemp = 360+this.degree;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp = this.degree;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif((temp>0 && temp<=90) || (temp>180 && temp<=270)){\n\n\t\t\t\t\t\tif(temp >180){\n\t\t\t\t\t\t\ttemp = temp-180;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar E_x = center.x-Math.cos(temp*Math.PI/180)*half_x;\n\t\t\t\t\t\tvar E_y = center.y-Math.sin(temp*Math.PI/180)*half_x;\n\t\t\t\t\t\t \n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{x:E_x-Math.sin(temp*Math.PI/180)*half_y,y:E_y+Math.cos(temp*Math.PI/180)*half_y},\n\t\t\t\t\t\t\t{x:E_x+Math.sin(temp*Math.PI/180)*half_y,y:E_y-Math.cos(temp*Math.PI/180)*half_y},\n\t\t\t\t\t\t\t{x:center.x-(E_x-Math.sin(temp*Math.PI/180)*half_y)+center.x,y:center.y-(E_y+Math.cos(temp*Math.PI/180)*half_y)+center.y},\n\t\t\t\t\t\t\t{x:center.x-(E_x+Math.sin(temp*Math.PI/180)*half_y)+center.x,y:center.y-(E_y-Math.cos(temp*Math.PI/180)*half_y)+center.y}\n\t\t\t\t\t\t];\n\n\n\n\t\t\t\t\t}else if((temp>90 && temp<180) || (temp>270 && temp<360)){\n\n\t\t\t\t\t\tif(temp>270){\n\t\t\t\t\t\t\ttemp = temp-180;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttemp = 180 - temp;\n\t\t\t\t\t\tvar E_x = center.x+Math.cos(temp*Math.PI/180)*half_x;\n\t\t\t\t\t\tvar E_y = center.y-Math.sin(temp*Math.PI/180)*half_x;\n \n\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{x:E_x-Math.sin(temp*Math.PI/180)*half_y,y:E_y-Math.cos(temp*Math.PI/180)*half_y},\n\t\t\t\t\t\t\t{x:E_x+Math.sin(temp*Math.PI/180)*half_y,y:E_y+Math.cos(temp*Math.PI/180)*half_y},\n\t\t\t\t\t\t\t{x:center.x-(E_x-Math.sin(temp*Math.PI/180)*half_y)+center.x,y:center.y-(E_y-Math.cos(temp*Math.PI/180)*half_y)+center.y},\n\t\t\t\t\t\t\t{x:center.x-(E_x+Math.sin(temp*Math.PI/180)*half_y)+center.x,y:center.y-(E_y+Math.cos(temp*Math.PI/180)*half_y)+center.y}\n\t\t\t\t\t\t]\n\n\n\n\n\t\t\t\t\t}else{\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{\"x\":tStart[0],\"y\":tStart[1]},\n\t\t\t\t\t\t\t{\"x\":tStart[0]+this.tWidth,\"y\":tStart[1]},\n\t\t\t\t\t\t\t{\"x\":tStart[0]+this.tWidth,\"y\":tStart[1]+this.tHeight},\n\t\t\t\t\t\t\t{\"x\":tStart[0],\"y\":tStart[1]+this.tHeight},\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t},\t\n\t\t\tdownFun:function(e,position){\n\t\t\t\tvar tStart = _this.qcanvas.isFun(this.tStart)?this.tStart():this.tStart;\n\t\t\t\tthis.dis = [position.x-tStart[0],position.y-tStart[1]];\n\t\t\t},\n\t\t\tmoveFun:function(e,position){\n\t\t\t\t\tvar dragIsBool = _this.qcanvas.isBool(this.drag);\n\t\t\t\t\tvar dis  = this.dis; \n\n\t\t\t\t\tif(dragIsBool && this.drag){\n\t\t\t\t\t\tthis.tStart[0] = position.x-dis[0];\n\t\t\t\t\t\tthis.tStart[1] = position.y-dis[1];\n\t\t\t\t\t}else if(this.drag == 'vertical'){\n\t\t\t\t\t\t this.tStart[1] = position.y-dis[1];\n\n\t\t\t\t\t}else if(this.drag == 'horizontal'){\n\t\t\t\t\t\t this.tStart[0] = position.x-dis[0];\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t//占位图替换掉options.img\n\tvar tmp = '';\n\tif(this.qcanvas.isStr(options.img)){\n\t\ttmp = options.img;\n\t\toptions.img = this.qcanvas.placeHolderImg;\n\t}\n\t\t\n\t\t\t\n\tthis.qcanvas.extend(OPTIONS,options);\n\tthis.qcanvas.appendSetFun(OPTIONS);\n\n\n\t//如果指定的img参数是一个图片地址 则需要去加载 完成后替找掉OPTIONS.img\n\tif(tmp !=''){\n\t\tOPTIONS.sWidth = 1;\n\t\tOPTIONS.sHeight = 1;\n \n\t\tthis.qcanvas.loadImgSource(tmp).then(function(img){\n\t\t\tvar img = img[0];\n\t\t\tOPTIONS.sWidth = img.width;\n\t\t\tOPTIONS.sHeight = img.height;\n\t\t\tOPTIONS.img = img;\n\n\n\t\t\tif(OPTIONS.size!=''){\n\t\t\t\t\n\t\t\t\t//重新计算sStart sWidth sHeight\n\t\t\t\t//全覆盖目标区域 图像的某些部分也许无法显示在目标区域中\n\t\t\t\tif(OPTIONS.size =='cover'){ \n\t\t\t\t\t\tdelete OPTIONS.sStart;\n\t\t\t\t\t  \tdelete OPTIONS.sWidth;\n\t\t\t\t\t\tdelete OPTIONS.sHeight;\n\t\t\t\t\t  \n\t\t\t\t\t\t\n\t\t\t\t\t\tvar sourceObj = _this.sourcePosition(OPTIONS.img,OPTIONS.tWidth,OPTIONS.tHeight);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tOPTIONS.sStart = sourceObj.sStart;\n\t\t\t\t\t\tOPTIONS.sWidth = sourceObj.sWidth;\n\t\t\t\t\t\tOPTIONS.sHeight = sourceObj.sHeight;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t}\n\n\t\t},function(){\n\t\t\tconsole.log('加载资源失败')\n\t\t})\n\t\t// this.qcanvas.load({img:tmp},function(){\n\t\t// \tvar img = _this.qcanvas.getSourceByName(\"img\");\n\n\t\t// \tOPTIONS.sWidth = img.width;\n\t\t// \tOPTIONS.sHeight = img.height;\n\t\t// \tOPTIONS.img = img;\n\n\n\t\t// \tif(OPTIONS.size!=''){\n\t\t\t\t\n\t\t// \t\t//重新计算sStart sWidth sHeight\n\t\t// \t\t//全覆盖目标区域 图像的某些部分也许无法显示在目标区域中\n\t\t// \t\tif(OPTIONS.size =='cover'){ \n\t\t// \t\t\t\tdelete OPTIONS.sStart;\n\t\t// \t\t\t  \tdelete OPTIONS.sWidth;\n\t\t// \t\t\t\tdelete OPTIONS.sHeight;\n\t\t\t\t\t  \n\t\t\t\t\t\t\n\t\t// \t\t\t\tvar sourceObj = _this.sourcePosition(OPTIONS.img,OPTIONS.tWidth,OPTIONS.tHeight);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t// \t\t\t\tOPTIONS.sStart = sourceObj.sStart;\n\t\t// \t\t\t\tOPTIONS.sWidth = sourceObj.sWidth;\n\t\t// \t\t\t\tOPTIONS.sHeight = sourceObj.sHeight;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t// \t\t}\n\t\t\t\n\t\t\t\n\t\t// \t}\n\n\n\n\t\t// })\n    } \n\t\n\t\n\tif(OPTIONS.size!=''){\n\t\t\n\t\t//重新计算sStart sWidth sHeight\n\t\t//全覆盖目标区域 图像的某些部分也许无法显示在目标区域中\n\t\tif(OPTIONS.size =='cover'){ \n\t\t\t\tdelete OPTIONS.sStart;\n\t\t\t  \tdelete OPTIONS.sWidth;\n\t\t\t\tdelete OPTIONS.sHeight;\n\t\t\t  \n\t\t\t\t\n\t\t\t\tvar sourceObj = this.sourcePosition(OPTIONS.img,OPTIONS.tWidth,OPTIONS.tHeight);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tOPTIONS.sStart = sourceObj.sStart;\n\t\t\t\tOPTIONS.sWidth = sourceObj.sWidth;\n\t\t\t\tOPTIONS.sHeight = sourceObj.sHeight;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\n\t\n\t}\n\t\n\treturn OPTIONS;\n}\t\nQimg.prototype.paintImg = function(obj){ \n\t\n\tvar tStart = this.qcanvas.isFun(obj.tStart)?obj.tStart():obj.tStart;\n\n\n\t//有角度时 移动画布原点 旋转画布\n\tvar centerPos = this.qcanvas.setDegree(obj);   \n\t \n\n\tthis.qcanvas.context.drawImage(obj.img,obj.sStart[0],obj.sStart[1],obj.sWidth,obj.sHeight,tStart[0],tStart[1],obj.tWidth,obj.tHeight);\n\t\n\n\t// //重置画布原点 旋转复原\n\tthis.qcanvas.resetDegree(obj,centerPos); \n}\t\n\t\n/*精灵类-------------------------*/\nfunction Qspirit(qcanvas){\n\tthis.qspiritVersion = '1.0';\n\tthis.qcanvas = qcanvas;\n}\nQspirit.prototype.spirit = function(options){\n\tvar _this = this;\n\tvar OPTIONS = {\n\t\t\tTYPE:'spirit',\n\t\t\tstop:function(){this.isLoop = false},\n\t\t\tplay:function(){this.isLoop = true},\n\t\t  \tdrag:true,\n\t\t  \tpointerEvent:'auto',\n\t\t\tdegree:0,\n\n\t\t\t/*img:{},\n\t\t\trow:0,\n\t\t\tcolumn:0,\n\t\t\tframeIndex:[],\n\t\t\tisLoop:true,\n\t\t\tduring:2*/\n\t\t\tcenterPoints:function(){ //元素中心点相对于整个画布的坐标\n\t\t\t\t\t\n\t\t\t\t\treturn {\n\t\t\t\t\t\tx:this.tStart[0]+this.tWidth*0.5,\n\t\t\t\t\t\ty:this.tStart[1]+this.tHeight*0.5\n\t\t\t\t\t}\n\n\t\t\t},\n\t\t\tpolyPoints:function(){  //顶点坐标序列\n\n\t\t\t\t\tvar half_x = this.tWidth*0.5;\n\t\t\t\t\tvar half_y = this.tHeight*0.5; \n\t\t\t\t\tvar center = this.centerPoints();\n\n\n\t\t\t\t\tvar temp = 0;\n\t\t\t\t\tif(this.degree <0){ \n\t\t\t\t\t\ttemp = 360+this.degree;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp = this.degree;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif((temp>0 && temp<=90) || (temp>180 && temp<=270)){\n\n\t\t\t\t\t\tif(temp >180){\n\t\t\t\t\t\t\ttemp = temp-180;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar E_x = center.x-Math.cos(temp*Math.PI/180)*half_x;\n\t\t\t\t\t\tvar E_y = center.y-Math.sin(temp*Math.PI/180)*half_x;\n\t\t\t\t\t\t \n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{x:E_x-Math.sin(temp*Math.PI/180)*half_y,y:E_y+Math.cos(temp*Math.PI/180)*half_y},\n\t\t\t\t\t\t\t{x:E_x+Math.sin(temp*Math.PI/180)*half_y,y:E_y-Math.cos(temp*Math.PI/180)*half_y},\n\t\t\t\t\t\t\t{x:center.x-(E_x-Math.sin(temp*Math.PI/180)*half_y)+center.x,y:center.y-(E_y+Math.cos(temp*Math.PI/180)*half_y)+center.y},\n\t\t\t\t\t\t\t{x:center.x-(E_x+Math.sin(temp*Math.PI/180)*half_y)+center.x,y:center.y-(E_y-Math.cos(temp*Math.PI/180)*half_y)+center.y}\n\t\t\t\t\t\t];\n\n\n\n\t\t\t\t\t}else if((temp>90 && temp<180) || (temp>270 && temp<360)){\n\n\t\t\t\t\t\tif(temp>270){\n\t\t\t\t\t\t\ttemp = temp-180;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttemp = 180 - temp;\n\t\t\t\t\t\tvar E_x = center.x+Math.cos(temp*Math.PI/180)*half_x;\n\t\t\t\t\t\tvar E_y = center.y-Math.sin(temp*Math.PI/180)*half_x;\n \n\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{x:E_x-Math.sin(temp*Math.PI/180)*half_y,y:E_y-Math.cos(temp*Math.PI/180)*half_y},\n\t\t\t\t\t\t\t{x:E_x+Math.sin(temp*Math.PI/180)*half_y,y:E_y+Math.cos(temp*Math.PI/180)*half_y},\n\t\t\t\t\t\t\t{x:center.x-(E_x-Math.sin(temp*Math.PI/180)*half_y)+center.x,y:center.y-(E_y-Math.cos(temp*Math.PI/180)*half_y)+center.y},\n\t\t\t\t\t\t\t{x:center.x-(E_x+Math.sin(temp*Math.PI/180)*half_y)+center.x,y:center.y-(E_y+Math.cos(temp*Math.PI/180)*half_y)+center.y}\n\t\t\t\t\t\t]\n\n\n\n\n\t\t\t\t\t}else{\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{\"x\":this.tStart[0],\"y\":this.tStart[1]},\n\t\t\t\t\t\t\t{\"x\":this.tStart[0]+this.tWidth,\"y\":this.tStart[1]},\n\t\t\t\t\t\t\t{\"x\":this.tStart[0]+this.tWidth,\"y\":this.tStart[1]+this.tHeight},\n\t\t\t\t\t\t\t{\"x\":this.tStart[0],\"y\":this.tStart[1]+this.tHeight},\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t},\n\t\t\tmoveFrameIndex:function(obj){\n\t\t\t\tobj.step = typeof obj.step !='undefined'?obj.step:1;//控制方向  \n\t\t\t\t\t\t\n\t\t\t\tvar step = obj.step;\n\t\t\t\tvar max = obj.frames[obj.framesIndex[0]].length;\n\t\t\t\t\n\t\t\t\tobj.framesIndex[1] = obj.framesIndex[1]+step;\n\t\t\t  \tobj.framesIndex[1] = obj.framesIndex[1]<=0?0:obj.framesIndex[1];\n\t\t\t\tobj.framesIndex[1] = obj.framesIndex[1]>=max?(max-1):obj.framesIndex[1];\n\t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t\t\tif(obj.isLoop){\n\t\t\t\t\t\n\t\t\t\t\tif(obj.framesIndex[1]==(max-1)){\n\t\t\t\t\t\t\t//obj.step=-1;\n\t\t\t\t\t\t\tobj.framesIndex[1] = 0;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(obj.framesIndex[1]==0){\n\t\t\t\t\t\t\t\tobj.step = 1; \t\t\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t}\t\n\t\t\t},\n\t\t\tdownFun:function(e,position){\n\t\t\t\tvar tStart = _this.qcanvas.isFun(this.tStart)?this.tStart():this.tStart;\n\t\t\t\tthis.dis = [position.x-tStart[0],position.y-tStart[1]];\n\t\t\t},\n\t\t\tmoveFun:function(e,position){\n\t\t\t\t\tvar dragIsBool = _this.qcanvas.isBool(this.drag);\n\t\t\t\t\tvar dis  = this.dis; \n\n\t\t\t\t\tif(dragIsBool && this.drag){\n\t\t\t\t\t\tthis.tStart[0] = position.x-dis[0];\n\t\t\t\t\t\tthis.tStart[1] = position.y-dis[1];\n\t\t\t\t\t}else if(this.drag == 'vertical'){\n\t\t\t\t\t\t this.tStart[1] = position.y-dis[1];\n\n\t\t\t\t\t}else if(this.drag == 'horizontal'){\n\t\t\t\t\t\t this.tStart[0] = position.x-dis[0];\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t}\n\n\t//占位图替换掉options.img\n\tvar tmp = '';\n\tif(this.qcanvas.isStr(options.img)){\n\t\ttmp = options.img;\n\t\toptions.img = this.qcanvas.placeHolderImg;\n\t}\n\t\t\t\n\tthis.qcanvas.extend(OPTIONS,options);\n\tthis.qcanvas.appendSetFun(OPTIONS);\n\n\t//如果指定的img参数是一个图片地址 则需要去加载 完成后替找掉OPTIONS.img\n\tif(tmp !=''){ \n\n\t\tthis.qcanvas.load({img:tmp},function(){\n\t\t\tvar img = _this.qcanvas.getSourceByName(\"img\");\n \n\t\t\tOPTIONS.img = img;\n\t\t\t_this.createFrames(OPTIONS); \n\n\t\t})\n    } \n\t\n\t \n\n\n\n\t\n\tthis.createFrames(OPTIONS);\n\t\n\treturn OPTIONS;\n}\t\n\nQspirit.prototype.createFrames = function(obj){\n\t\n\tvar frameWidth = obj.img.width/obj.column;\n\tvar frameHeight = obj.img.height/obj.row;\n\t\n\tvar framesCount = this.qcanvas.fps * obj.during;\n\t\n\tvar num = 1;\n\tif(framesCount>obj.column){\n\t\t\tnum = Math.floor(framesCount/obj.column);\n\t}\n\t\n\t\n\t\n\t//生成二维坐标数组\n\tvar frames = [];\n\tfor(var i=0; i<obj.row;i++){\n\t\tframes[i] = [];\n\t\tfor(var j=0; j<obj.column;j++){\n\t\t\t\n\t\t\t//为了控制速度 加入同样的序列帧\n\t\t\tfor(var t=0; t<num;t++){\n\t\t\t\tframes[i].push([j*frameWidth,i*frameHeight]);\n\t\t\t\t//frames[i].push([i*frameHeight,j*frameWidth]);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tobj.framesIndex = typeof obj.framesIndex=='undefined'?[0,0]:obj.framesIndex;\n\tobj.frames = frames;\n}\n\t\nQspirit.prototype.moveFrameIndex = function(obj){\n\t\t\n\t\tobj.step = typeof obj.step !='undefined'?obj.step:1;//控制方向  \n\t\t\t\t\n\t\tvar step = obj.step;\n\t\tvar max = obj.frames[obj.framesIndex[0]].length;\n\t\t\n\t\tobj.framesIndex[1] = obj.framesIndex[1]+step;\n\t  \tobj.framesIndex[1] = obj.framesIndex[1]<=0?0:obj.framesIndex[1];\n\t\tobj.framesIndex[1] = obj.framesIndex[1]>=max?(max-1):obj.framesIndex[1];\n\t\t\n\t\t\n\t\n\t\tif(obj.isLoop){\n\t\t\t\n\t\t\tif(obj.framesIndex[1]==(max-1)){\n\t\t\t\t\t//obj.step=-1;\n\t\t\t\t\tobj.framesIndex[1] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tif(obj.framesIndex[1]==0){\n\t\t\t\t\t\tobj.step = 1; \t\t\n\t\t\t}\n\t\n\t\t}\t\n\t\n}\t\t\n\t\n\t\nQspirit.prototype.paintSpirit = function(obj){\n\t\tthis.qcanvas.qanimation.createAnimation(obj);\n\n\t\tvar moveFrameIndex = function(obj){\n\t\t\tobj.step = typeof obj.step !='undefined'?obj.step:1;//控制方向  \n\t\t\t\t\t\n\t\t\tvar step = obj.step;\n\t\t\tvar max = obj.frames[obj.framesIndex[0]].length;\n\t\t\t\n\t\t\tobj.framesIndex[1] = obj.framesIndex[1]+step;\n\t\t  \tobj.framesIndex[1] = obj.framesIndex[1]<=0?0:obj.framesIndex[1];\n\t\t\tobj.framesIndex[1] = obj.framesIndex[1]>=max?(max-1):obj.framesIndex[1];\n\t\t\t\n\t\t\t\n\t\t\n\t\t\tif(obj.isLoop){\n\t\t\t\t\n\t\t\t\tif(obj.framesIndex[1]==(max-1)){\n\t\t\t\t\t\t//obj.step=-1;\n\t\t\t\t\t\tobj.framesIndex[1] = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(obj.framesIndex[1]==0){\n\t\t\t\t\t\t\tobj.step = 1; \t\t\n\t\t\t\t}\n\t\t\n\t\t\t}\t\n\t\t}\n\t\t// this.moveFrameIndex(obj);\n\t\tobj.moveFrameIndex(obj);\n\n\t\t\n\t//console.log(obj.framesIndex);\n\t\n\t\n\t\tvar sx = obj.frames[obj.framesIndex[0]][obj.framesIndex[1]][0];\n\t\tvar sy = obj.frames[obj.framesIndex[0]][obj.framesIndex[1]][1];\n\t\tvar sWidth = obj.img.width/obj.column;//obj.tWidth;\n\t\tvar sHeight = obj.img.height/obj.row;//obj.tHeight;\n\t\n\t\t//console.log(obj.frames[obj.framesIndex[1]][obj.framesIndex[0]]);\n\t\t\n\t\t//有角度时 移动画布原点 旋转画布\n\t\tvar centerPos = this.qcanvas.setDegree(obj);   \n\t\t \n\t\n\t\tthis.qcanvas.context.drawImage(obj.img,sx,sy,sWidth,sHeight,obj.tStart[0],obj.tStart[1],obj.tWidth,obj.tHeight);\n\n\t\t// //重置画布原点 旋转复原\n\t\tthis.qcanvas.resetDegree(obj,centerPos);\n}\t\n\t\n\n/*Qevent类---------*/\nfunction Qevent(qcanvas){\n\tthis.qeventVersion = '1.0';\n\tthis.qcanvas = qcanvas;\n\tthis.triggerEleType = {  //触发事件的元素类型\n\t\t\"rect\":1,\n\t\t\"spirit\":1,\n\t\t\"img\":1,\n\t\t\"text\":1,\n\t\t\"shape\":1,\n\t\t\"arc\":1,\n\t\t\"polygon\":1,  \n\t\t\"layer\":1,    //是容器 本身不响应事件 只判断其中的元素\n\t\t\"group\":1,    //是容器 本身不响应事件 只判断其中的元素\n\t\t\"line\":1,\n\t\t\"quadraticCurve\":1, //二次曲线\n\t\t\"bezierCurve\":1 //三次曲线\n\t}\n\tvar _this = this;\n\n\n\tvar initResizeLayer = function(id){\n\t\tif(_this.qcanvas.qresize === null){  \n\t\t\t_this.qcanvas.qresize = new Qresize(qcanvas,id);\n\t\t}else{\n\t\t\t_this.qcanvas.qresize.showHandler(_this.qcanvas.dragAim);\n\t\t}\n\t}\n\n\tvar initRotateLayer = function(id){\n\t\tif(_this.qcanvas.qrotate === null){  \n\t\t\t_this.qcanvas.qrotate = new Qrotate(qcanvas,id);\n\t\t}else{\n\t\t\t_this.qcanvas.qrotate.showHandler(_this.qcanvas.dragAim);\n\t\t}\n\t}\n\n\n\tvar eventCallback = {\n\t\t'mouseenter':function(e,position){\n\n\t\t},\n\t\t'mousedown_or_touchstart':function(e,position){\n\t\t\t// var position = _this.getEventPosition(e);\n\t\t\tvar aim  = _this.findElmByEventPosition(position); \n\n\t\t\t(aim!==null && aim.drag && _this.triggerEleType[aim.TYPE] \n\t\t\t&& \n\t\t\t(function(){\n\t\t\t\taim.downFun(e,position);\n\t\t\t\t_this.qcanvas.dragAim = aim;\n\n\t\t\t})()) || \n\t\t\t(aim!==null && aim.TYPE == 'canvas' && (function(){\n\t\t\t\t_this.qcanvas.dragAim = aim;\n\t\t\t\t\n\t\t\t})())\n  \n\t\t\tif(aim !== null){\n\t\t\t\taim.TYPE == 'rect' && aim.resize && initResizeLayer(aim.id);\n\t\t\t\taim.TYPE == 'rect' && aim.rotate && initRotateLayer(aim.id);\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t'mousemove_or_touchmove':function(e,position){\n\n\t\t\t\t// if(_this.qcanvas.moveAim === null){\n\t\t\t\t// \t_this.qcanvas.moveAim = _this.findElmByEventPosition(position);\n\t\t\t\t// }\n\n\t\t\t\tif(    \n\t\t\t\t\t  (_this.qcanvas.dragAim !== null)\n\t\t\t\t\t&& (_this.qcanvas.qresize !== null)\n\t\t\t\t\t&& (_this.qcanvas.qrotate !== null)\n\n\t\t\t\t){  \n\n\t\t\t\t\t//如果拖动不是resize或rotate句柄 那么拖动的同时需要 更新句柄坐标 \n\t\t\t\t\t!_this.qcanvas.qrotate.rotateLayer.hasOwnEle(_this.qcanvas.dragAim) \n\t\t\t\t\t&& !_this.qcanvas.qresize.resizeLayer.hasOwnEle(_this.qcanvas.dragAim)\n\t\t\t\t\t&& (function(){\n\n\t\t\t\t\t\t_this.qcanvas.qrotate.hideHandler()\n\t\t\t\t\t\t_this.qcanvas.qresize.hideHandler();\n\n\t\t\t\t\t})()\n\n\t\t\t\t}else{\n\n\t\t\t\t\tif((_this.qcanvas.qresize !== null) \n\t\t\t\t\t&& (_this.qcanvas.dragAim !== null)){\n\n\t\t\t\t\t\t!_this.qcanvas.qresize.resizeLayer.hasOwnEle(_this.qcanvas.dragAim)\n\t\t\t\t\t\t&& _this.qcanvas.qresize.hideHandler();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif(_this.qcanvas.qrotate !== null \n\t\t\t\t\t&& (_this.qcanvas.dragAim !== null)){\n\n\t\t\t\t\t\t!_this.qcanvas.qrotate.rotateLayer.hasOwnEle(_this.qcanvas.dragAim) \n\t\t\t\t\t\t&& _this.qcanvas.qrotate.hideHandler();\n\t\t\t\t\t\t \n\t\t\t\t\t}\n\n\t\t\t\t\t\t\n\t\t\t\t}\n\n\n\t\t\t\tif(_this.qcanvas.dragAim !== null){\n\t\t\t\t\t_this.triggerEleType[_this.qcanvas.dragAim.TYPE] \n\t\t\t\t\t&&\n\t\t\t\t\t_this.qcanvas.dragAim.moveFun(e,position);\n\n\t\t\t\t}\n\n\t\t},\n\t\t'mouseup_or_mouseout_or_touchend':function(e,position){\n\t\t\t_this.qcanvas.dragAim = null;\n\t\t}\n\t};\n\n\tthis.PC_Event = {\n\t\t\"mouseenter\":eventCallback['mouseenter'],\n\t\t\"mousedown\":eventCallback['mousedown_or_touchstart'],\n\t\t\"mousemove\":eventCallback['mousemove_or_touchmove'],\n\t\t\"mouseup\":eventCallback['mouseup_or_mouseout_or_touchend'],\n\t\t\"mouseout\":eventCallback['mouseup_or_mouseout_or_touchend'],\n\t\t\"dblclick\":function(){}\n\t};\n\tthis.MOBILE_Event = {\n\t\t\"touchstart\":eventCallback['mousedown_or_touchstart'],\n\t\t\"touchmove\":eventCallback['mousemove_or_touchmove'],\n\t\t\"touchend\":eventCallback['mouseup_or_mouseout_or_touchend']\n\t};\t\n\t\n\tthis.init();\n}\n\nQevent.prototype.init = function(){\n\tvar canvas = this.qcanvas.canvas;\n\tvar _this = this;\n\t\n\n\t\n\tif(\"ontouchstart\" in window){\n\t\tfor(var i in this.MOBILE_Event){\n\t\t\t// canvas.addEventListener(i,callback,false);\t\t\n\t\t\tcanvas.addEventListener(i,function(e){\n\t\t\t\tvar position = _this.getEventPosition(e);\n\t\t\t\t_this.eventCallback(e,position);\t//用户定义的回调函数\n\t\t\t\t_this.MOBILE_Event[e.type](e,position); //系统定义的回调函数\n\t\t\t},false);\t\t\n\n\t\t}\n\t\t\n\t}else{\n\t\tfor(var i in this.PC_Event){\n\t\t\tcanvas.addEventListener(i,function(e){\n\t\t\t\tvar position = _this.getEventPosition(e);\n\t\t\t\t_this.eventCallback(e,position);\t //用户定义的回调函数\n\t\t\t\t_this.PC_Event[e.type](e,position);  //系统定义的回调函数\n\t\t\t},false);\t\t\n\t\t}\n\n\n\t\tcanvas.oncontextmenu=function(ev){  \n\t        ev.preventDefault();\n\t    }\n\t\t\n\t}\n\t\n}\t\n\nQevent.prototype.executeMouseOutOrMouseEnter = function(aim,position){ \n\t//修复对象mouseout自定义事件不执行的问题 \n\tif(this.qcanvas.isObj(aim)){\n\n\t\tif(this.qcanvas.moveAim == null){\n\t\t\t\tthis.qcanvas.moveAim = aim;\n\t\t\t\taim['mouseenter'] && aim['mouseenter'](aim,position);\n\n\n\t\t}else if(this.qcanvas.moveAim.id !== aim.id){ //划过了不同的对象 需要执行上一个对象的moveout事件\n\t\t\t\t// console.log('划过了不同的对象');\n\t\t\t\tthis.qcanvas.moveAim['mouseout'] && this.qcanvas.moveAim['mouseout'](this.qcanvas.moveAim,position);\n\t\t\t\taim['mouseenter'] && aim['mouseenter'](aim,position);\n\t\t\t\tthis.qcanvas.moveAim = aim;\n\t\t\t}\n\n\t}else{\n\n\n\t\tif(this.qcanvas.isObj(this.qcanvas.moveAim)){\n\t\t\tthis.qcanvas.moveAim['mouseout'] && this.qcanvas.moveAim['mouseout'](this.qcanvas.moveAim,position);\n\t\t\tthis.qcanvas.moveAim = null;\n\t\t}\n\t}\n\n}\n\n\n\n\nQevent.prototype.eventCallback = function(e,position){\n\n\t \tvar aim = this.findElmByEventPosition(position);\n\n\t \t//修复对象mouseout mouserenter自定义事件不执行的问题\n\t  \tthis.executeMouseOutOrMouseEnter(aim,position);\n\n\n\t  \t//触发aim的事件(调用用户配置好的事件) \n\t  \t(aim !== null) && (typeof aim[e.type] !='undefined') &&  aim[e.type](e,position);\n\n\t  \t// //模拟drag事件 \n\t  \t// (aim !== null) && \n\t  \t// (this.qcanvas.dragAim !==null)  && \n\t  \t// (e.type =='mousemove') && \n\t  \t// (typeof aim['drag'] !='undefined') &&  aim['drag'](e,position);\n\t  \n}\t\n\t\n\n//根据点击的坐标 找到要触发事件的元素 \nQevent.prototype.findElmByEventPosition = function(position){\n\t\tvar elements = this.qcanvas.elements;\n\t\tvar aim = null;\t\n\n\t\n\t\t//elements数组从后往前 碰到第一个元素 点击的坐标正好在它的范围内 那么就触发它的事件\n\t\t//越往后的元素 在画布上是越在上面的 \n\t\tvar len = elements.length;\n\n\t\tif(len == 0){\n\t\t\treturn this.qcanvas;\n\t\t}\n\n\t\tfor(var i=len-1;i>=0;i--){\n\n\t\t\t//跳过不显示的元素和不响应事件的元素\n\t\t\tif(elements[i].display=='none' || (elements[i].pointerEvent == 'none')){\n\t\t\t\tcontinue;\n\t\t\t};\n\t\t\t\n\t\t\tif(this.triggerEleType[elements[i].TYPE]){\n\n\n\t\t\t\t//如果是容器对象 要判断属于该容器里的元素\n\t\t\t\tif((elements[i].TYPE == 'layer') || (elements[i].TYPE == 'group')){  \n\t\t\t\t\tvar childLen = elements[i].elements.length;\n\t\t\t\t\tif(childLen == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} \n\n\t\t\t\t\tfor (var j = childLen-1; j >= 0; j--) {\n\n\n\t\t\t\t\t\t//跳过不显示的元素和不响应事件的元素\n\t\t\t\t\t\tif(elements[i].elements[j].display=='none' || (elements[i].elements[j].pointerEvent == 'none')){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}; \n\n\t\t\t\t\t\tif(elements[i].elements[j].TYPE=='quadraticCurve' || elements[i].elements[j].TYPE=='bezierCurve'){ \n\t\t\t\t\t\t\t//曲线的拾取 需要用到影子画布实现\n\t\t\t\t\t\t\t// console.log(position);\n\t\t\t\t\t\t\tvar color = this.qcanvas.getShadowPixelColor.call(this.qcanvas,position);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(color.rgba === elements[i].elements[j].shadowFillColor){\n\t\t\t\t\t\t\t\taim = elements[i].elements[j];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}else if(this.rayCasting(position,elements[i].elements[j].polyPoints())=='in'){\n\t\t\t\t\t\t\taim = elements[i].elements[j];  \n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(aim !== null){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n \n\t\t\t\t}else{\n\n\t\t\t\t\t if(elements[i].TYPE=='quadraticCurve' || elements[i].TYPE=='bezierCurve'){\n\t\t\t\t\t\t\t//曲线的拾取 需要用到影子画布实现\n\t\t\t\t\t\t\t// console.log(position);\n\t\t\t\t\t\t\tvar color = this.qcanvas.getShadowPixelColor.call(this.qcanvas,position);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(color.rgba === elements[i].shadowFillColor){\n\t\t\t\t\t\t\t\taim = elements[i];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t }else{\n\n\t\t\t\t\t \tif(this.rayCasting(position,elements[i].polyPoints())=='in'){\n\t\t\t\t\t\t\taim = elements[i];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t }\n\n\t\t\t\t\t\n\t\t\t\t} \n\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t} \n\t\t}\n \n\n\t\t//如果aim == null那么点中的目标就是主canvas\n\t\taim === null && (aim = this.qcanvas);\n\t\n\t\t\n\t\treturn aim;\n\t\n}\n\t\nQevent.prototype.getEventPosition = function(ev){\n  var x, y;\n\t//console.log(ev);\n\tif(this.MOBILE_Event[ev.type]){\n\t\tvar c = ev.type!='touchend'?ev.touches[0]:ev.changedTouches[0];\n\t\tx= c.clientX-c.target.offsetLeft;\n\t\ty= c.clientY-c.target.offsetTop;\n\t\t\n\t}else{\n\t\t if (ev.layerX || ev.layerX == 0) {\n\t\t\tx = ev.layerX;\n\t\t\ty = ev.layerY;\n\t\t} else if (ev.offsetX || ev.offsetX == 0) { // Opera\n\t\t\tx = ev.offsetX;\n\t\t\ty = ev.offsetY;\n\t\t}\n\t}\n\t\n\t\n \n  return {x: x, y: y};\n}\n\t\n/**\n   * @description 射线法判断点是否在多边形内部\n   * @param {Object} p 待判断的点，格式：{ x: X坐标, y: Y坐标 }\n   * @param {Array} poly 多边形顶点，数组成员的格式同 p\n   * @return {String} 点 p 和多边形 poly 的几何关系\n   */\nQevent.prototype.rayCasting = function(p, poly) {\n    var px = p.x,\n        py = p.y,\n        flag = false\n\n    for(var i = 0, l = poly.length, j = l - 1; i < l; j = i, i++) {\n      var sx = poly[i].x,\n          sy = poly[i].y,\n          tx = poly[j].x,\n          ty = poly[j].y\n\n      // 点与多边形顶点重合\n      if((sx === px && sy === py) || (tx === px && ty === py)) {\n        return 'on'\n      }\n\n      // 判断线段两端点是否在射线两侧\n      if((sy < py && ty >= py) || (sy >= py && ty < py)) {\n        // 线段上与射线 Y 坐标相同的点的 X 坐标\n        var x = sx + (py - sy) * (tx - sx) / (ty - sy)\n\n        // 点在多边形的边上\n        if(x === px) {\n          return 'on'\n        }\n\n        // 射线穿过多边形的边界\n        if(x > px) {\n          flag = !flag\n        }\n      }\n    }\n\n    // 射线穿过多边形边界的次数为奇数时点在多边形内\n    return flag ? 'in' : 'out'\n  }\t\n\n\n\n//元素容器类\nfunction Qlayer(p){\n\tvar _this = this;\n\tthis.qlayerVersion = '1.0';\n\tthis.pcanvas = p;   //主canvas \n\tthis.dpr = window.devicePixelRatio; // 假设dpr为2\n\n\t\n\t\n\n\tthis.layer = function(){   //作为一个构造函数\n\n\t\t//每个layer都创建新的临时canvas\n\t\t//实例属性覆盖原型Qcanvas继承过来的属性\n\t\t_this.canvasEle = document.createElement('canvas');\n\n\t\t_this.canvasEle.width = _this.pcanvas.stage.width*_this.dpr;\n\t\t_this.canvasEle.height = _this.pcanvas.stage.height*_this.dpr; \n\t\t_this.canvasEle.id = (new Date()).getTime()+''+parseInt(Math.random()*100000000);\n\n\n\t\t//重写生成一个qcanvas属性\n\t\t_this.qcanvas = {}; \n\t\t\n\t\t//把Qcanvas的属性都复制过来  通过原型继承的\n\t\tfor(var i in p){\n\t\t\t_this.qcanvas[i] = p[i];\n\t\t}\n\n\t\t_this.qcanvas.elements = [];\n \n\t\t//layer所有继承过来的元素对象相应的paint方法 都是使用 this.qcanvas.context 画到画布上的\n\t\t//所以重写qcanvas.context 使它指向layer临时的canvas 那么就会画到layer对应的画布上\n\t\t_this.qcanvas.context = _this.canvasEle.getContext('2d');\n\t\t_this.qcanvas.context.scale(_this.dpr,_this.dpr);\n\n\n\n\t\t\n\t\tvar o = { \n\t\t\tTYPE:\"layer\",\n\t\t\tcanvasEle:_this.canvasEle,\n\t\t\tpcanvas:this.pcanvas,\n\t\t\t// elements:this.qcanvas.elements,\n\t\t\telements:[],\n\t\t\tid: (new Date()).getTime()+''+parseInt(Math.random()*100000000),\n\t\t\tdisplay:'block', \n\t\t\tpush:function(ele){\n\t\t\t\tvar t = Array.prototype.slice.apply(arguments);\n\t\t\t\tvar l = t.length;\n\t\t\t\tfor (var i = 0; i < l; i++) {\n\n\t\t\t\t\t//不支持layer对象上再放入layer或group\n\t\t\t\t\tif((t[i].TYPE == 'layer') || (t[i].TYPE == 'group')){   \n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n \n\t\t\t\t\tif(this.pcanvas.isObj(t[i])){\n\t\t\t\t\t\tthis.pcanvas.removeEle.call(this.pcanvas,t[i]);\n\t\t\t\t\t\tthis.elements.push(t[i]);\n\t\t\t\t\t\t// this.qcanvas.elements.push(t[i]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif((t[i].TYPE =='line' || t[i].TYPE=='bezierCurve' || t[i].TYPE=='quadraticCurve') && typeof t[i].withTextId !='undefined'){  \n\t\t\t\t\t\t\t//如果线段上带有文本 也需要把文本加入到该layer里 \n\t\t\t\t\t\t\tvar withTextObj = this.pcanvas.getEleById.call(this.pcanvas,t[i].withTextId);\n\t\t\t\t\t\t\tthis.pcanvas.removeEle.call(this.pcanvas,withTextObj);\n\t\t\t\t\t\t\tthis.elements.push(withTextObj);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// this.elements = this.elements.concat(tmp);\n\t\t\t\t\n\t\t\t},\n\t\t\thasOwnEle:function(ele){  //当前layer对象里是存在ele元素\n\t\t\t\tvar tmp = this.elements.filter(function(item){\n\t\t\t\t\treturn item.id == ele.id;\n\t\t\t\t})\n\n\t\t\t\treturn tmp.length>0;\n\t\t\t},\n\n\t\t\tgetEleById: this.pcanvas.getEleById,\n\t\t\tremoveEle: this.pcanvas.removeEle,\n\t\t\tremoveEleById: this.pcanvas.removeEleById,\n\n\n\t\t\tgetIndexById: this.pcanvas.getIndexById,\n\t\t\tlower: this.pcanvas.lower,\n\t\t\tlowerToBottom: this.pcanvas.lowerToBottom,\n\t\t\traise: this.pcanvas.raise,\n\t\t\traiseToTop: this.pcanvas.raiseToTop,\n\t\t\tdestroy:this.pcanvas.destroy\n\n\t\t}\n\t\t\n\t\t\n\t\t// var o = new f();\n\t\t\n\n\t\tthis.pcanvas.appendSetFun(o);\n\t\tthis.pcanvas.elements.push(o);\n\n\n\n\t\t// this.pcanvas.pushElements.call(this.pcanvas,this);\n\t\treturn o;\n\n\t}\n\n\tthis.paintLayer = function(o){\n\t\tthis.start(o);\n\t\t// o.display == 'block' &&  this.pcanvas.context.drawImage(t,0,0,this.pcanvas.stage.width*this.dpr,this.pcanvas.stage.height*this.dpr,0,0,this.pcanvas.stage.width,this.pcanvas.stage.height);\n\t\to.display == 'block' &&  this.pcanvas.context.drawImage(this.canvasEle,0,0,this.canvasEle.width,this.canvasEle.height,0,0,this.pcanvas.stage.width,this.pcanvas.stage.height);\n\t\t\n\t}\n\n\tthis.paint = function(layer){\n\n\t\tif(layer.display == 'none'){return;};\n\t\tvar l = layer.elements.length;\n\t\tfor(var i = 0; i<l; i++){\n\t\t\tvar o = layer.elements[i];\n\n\t\t\tif(o.display=='none'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.TypeGroup[o.TYPE].call(this,o); \n\t\t\t\t\t\n\t\t}\n\t\t\t\n\n\n\t\t// this.pcanvas.context.drawImage(t,0,0);\n\n\t}\n\tthis.clear = function(layer){\n\t\tif(layer.display == 'none'){return;};\n\t\tthis.canvasEle.width = this.canvasEle.width;\n\t\tthis.qcanvas.context.scale(this.dpr,this.dpr);\n\n\t\t// this.qcanvas.context.clearRect(0,0,this.canvasEle.width,this.canvasEle.height);\n\t}\n\n\tthis.start = function(o){\n\t\tthis.clear(o);\n\t\tthis.paint(o);\t\t\t\n\t\t\n\t\tvar currentLoop = (new Date()).getMilliseconds();\n\t    if (this.lastLoop > currentLoop) {\n\t\t\t\tthis.currFps = this.count;\n\t      this.count = 1;\n\t    } else {\n\t\t\t\tthis.count  += 1;\t\n\t    }\n\t\t\t\t\t\n\t\tthis.lastLoop = currentLoop;\t\t\n\t\t \n\t\t\n\t}\t \n\n\t// window.requestNextAnimationFrame(this.start.bind(this));\n\n\n} \n\n\t\n/*-------end---------*/\t\n\n//元素分组类\nfunction Qgroup(qcanvas){\n\tthis.qgroupVersion = '1.0';\n\tthis.qcanvas = qcanvas;\n}\nQgroup.prototype.group = function(options){\n\tvar _this = this;\n\tvar OPTIONS = {\n\t\t\tTYPE:'group',\n\t\t\tdisplay:'block',\n\t\t\twidth:_this.qcanvas.stage.width,\n\t\t\theight:_this.qcanvas.stage.height,\n\t\t\telements:[],   //容器里包含的元素\n\t\t\t// canvasEle:_this.createCanvas(),\n\t\t\tpush:this.push,\n\t\t\tqcanvas:this.qcanvas,\n\t\t\tgetEleById:this.qcanvas.getEleById,\n\t\t\tremoveEle:this.qcanvas.removeEle,\n\t\t\tremoveEleById:this.qcanvas.removeEleById,\n\n\t\t\tgetIndexById:this.qcanvas.getIndexById,\n\t\t\tlower:this.qcanvas.lower,\n\t\t\tlowerToBottom:this.qcanvas.lowerToBottom,\n\t\t\traise:this.qcanvas.raise,\n\t\t\traiseToTop:this.qcanvas.raiseToTop\n\n\t\t}\n\n\tthis.qcanvas.extend(OPTIONS,options);\n\tthis.qcanvas.appendSetFun(OPTIONS);\n\n\n\treturn OPTIONS;\t\n\n} \n\nQgroup.prototype.paintGroup = function(obj){\n\n\t//把属于该容器的元素绘在layerCanvas\n\tvar l = obj.elements.length;\n\tfor(var i = 0; i<l; i++){\n\t\tvar o = obj.elements[i];\n\n\t\tif(o.display=='none'){\n\t\t\tcontinue;\n\t\t}\n\n\t\tthis.qcanvas.TypeGroup[o.TYPE].call(this.qcanvas['q'+o.TYPE],o);\n\n\t} \n}\nQgroup.prototype.push = function(ele){\n\tvar t = Array.prototype.slice.apply(arguments);\n\tvar l = t.length;\n\tfor (var i = 0; i < l; i++) {\n\n\t\t//不支持group对象上再放入group\n\t\tif(t[i].TYPE == 'group' || t[i].TYPE == 'layer'){   \n\t\t\tcontinue;\n\t\t}\n\n\t\tif(this.qcanvas.isObj(t[i])){\n\t\t\tthis.qcanvas.removeEle(t[i]);\n\t\t\tthis.elements.push(t[i]);\n\t\t} \n\t}\n\n\n\n\t//核心Qcanvas类成员 elements中 删掉该元素\n\t// this.qcanvas.removeEle(ele);\n\n\n\t//添加到Qlayer类成员elements中\n\t// this.elements.push(ele);\n\n} \n \n/*-------end---------*/\t\n\n/**\n * 角度控件类\n * @param {[type]} qcanvas [description]\n * @param {[type]} id      [description]\n */\nfunction Qrotate(qcanvas,id){\n\tthis.qrotateVersion = '1.0';\n\tthis.qcanvas = qcanvas;\n\tthis.rotateLayer = null;\n\tthis.rotateObj = null;\n\n\tthis.init(id);\n}\n\n//取得顶点坐标中 以元素中心点判断 （右边且靠下的一个点）\nQrotate.prototype.rightBottomPoint = function(obj){\n\tvar polyPoints = obj.polyPoints();\n\tvar xArr = polyPoints.map(function(item){return item.x});\n\tvar yArr = polyPoints.map(function(item){return item.y});\n \n\tvar maxX = Math.max.apply({},xArr);\n\tvar maxY = Math.max.apply({},yArr);\n \n\treturn [\n\t\t[Math.min.apply({},xArr),Math.min.apply({},yArr)],\n\t\t[Math.max.apply({},xArr),Math.max.apply({},yArr)],\n\n\t]\n\n\n}\n \n\nQrotate.prototype.rectRotate = function(obj) {\n\tvar _this = this;\n\tvar obj = this.rotateObj;\n\tvar c = obj.centerPoints();\n\t// var startAndEndPosition = _this.rightBottomPoint(obj);\n\tvar start = this.qcanvas.isFun(obj.start)?obj.start():obj.start;\n\tvar r = Math.sqrt(Math.pow(Math.abs(c.x-start[0]),2)+Math.pow(Math.abs(c.y-start[1]),2));\n\n\tvar down = false;\n\tthis.bg = this.qcanvas.qrect.rect({\n\t\tstart:[c.x+r+10,c.y-18],\n\t\twidth:4,\n\t\theight:36,\n\t\tborderColor:'blue',\n\t\t// display:'none',\n\t\tfillColor:'blue',\n\t\ttitle:'rotate背景',\n\t\tdrag:false,\n\t\t// mousedown:function(pos){\n\t\t// \t_this.handler.setStart([this.start[0]+5,pos.y]);\n\t\t// \tvar dis = pos.y - this.start[1];\n\n\t\t// \tobj.setDegree(dis*10);\n\n\t\t// \tvar down = true;\n\n\t\t// },\n\t\t// mousemove:function(pos){\n\n\t\t// \tif(down){\n\t\t// \t\t_this.handler.setStart([this.start[0]+5,pos.y]);\n\t\t// \t\tvar dis = pos.y - this.start[1];\n\n\t\t// \t\tobj.setDegree(dis*10);\n\n\t\t// \t}\n\t\t// },\n\t\t// mouseup:function(){\n\t\t// \tvar down = false;\n\n\t\t// }\n\t})\t\n\n\tthis.handler = this.qcanvas.qarc.arc({\n\t\t\t\tstart:[c.x+r+10+2,c.y-18+(obj.degree<0?(obj.degree+360):obj.degree)/10],\n\t\t\t\tsAngle:0,\n\t\t\t\teAngle:360,\n\t\t\t\tfillColor:'red',\n\t\t\t\topacity:0.2, \n\t\t\t\tr:10,\n\t\t\t\ttitle:'rotate句柄',\n\t\t\t\tdrag:'vertical',\n\t\t\t\t// pointerEvent:'none',\n\t\t\t\tdragRange:function(){\n\n\t\t\t\t\treturn [_this.bg.start,[_this.bg.start[0]+_this.bg.width,_this.bg.start[1]+_this.bg.height]];\n\n\t\t\t\t},\n\t\t\t\tmousemove:function(){\n\t\t\t\t\tvar dis = this.start[1] - _this.bg.start[1];\n\n\t\t\t\t\tdis = dis<0?0:dis;\n\t\t\t\t\tdis = dis>36?36:dis;\n\n\t\t\t\t\tobj.setDegree(dis*10);\n\t\t\t\t},\n\t\t\t\tmouseup:function(){\n\t\t\t\t\tvar y = this.start[1] <= _this.bg.start[1]?_this.bg.start[1]:this.start[1];\n\t\t\t\t\ty = this.start[1] >= (_this.bg.start[1]+36)?(_this.bg.start[1]+36):y;\n\n\t\t\t\t\tthis.setStart([this.start[0],y]);\n\t\t\t\t}\n\t\t\t})\n\t\n\tthis.text = this.qcanvas.qtext.text({\n\t\tstart:function(){\n\t\t\tvar c = _this.rotateObj.centerPoints();\n\t\t\treturn [c.x,c.y];\n\t\t},\n\t\t// [c.x,c.y],\n\t\ttext:function(){\n\t\t\treturn (_this.rotateObj.degree<0?(_this.rotateObj.degree+360):_this.rotateObj.degree)+'˚';\n\t\t}\n\t})\t\n\n\t\n\tthis.rotateLayer.push(this.bg,this.handler,this.text);\t \n}\n\nQrotate.prototype.init = function(id) {\n\tthis.rotateLayer = this.qcanvas.qlayer.layer();\n\tthis.rotateObj = this.qcanvas.getEleById(id);\n\n\n\tswitch(this.rotateObj.TYPE){\n\t\tcase 'rect':\n\t\t\tthis.rectRotate();\n\t\tbreak;\n\t}\n\n\n\n\tthis.rotateLayer.setDisplay('block');\n\n\tthis.qcanvas.raiseToTop(this.rotateLayer);\n\n};\n\nQrotate.prototype.updateElePosition = function(obj) {\n\t// var obj = this.qcanvas.dragAim;\n\tvar obj = this.rotateObj;\n\tvar c =  obj.centerPoints();\n\tvar start = this.qcanvas.isFun(obj.start)?obj.start():obj.start;\n\n\tvar r = Math.sqrt(Math.pow(Math.abs(c.x-start[0]),2)+Math.pow(Math.abs(c.y-start[1]),2));\n\t \n\tthis.bg.setStart([c.x+r+10,c.y-18]);\n\tthis.handler.setStart([c.x+r+10+2,c.y-18+(obj.degree<0?(obj.degree+360):obj.degree)/10]);\n\n}\n\nQrotate.prototype.showHandler = function(obj) {\n\tthis.rotateObj = obj;\n\tthis.updateElePosition(obj);\n\tthis.rotateLayer.setDisplay('block');\n\tthis.qcanvas.raiseToTop(this.rotateLayer);\n\n\t\n};\n\nQrotate.prototype.hideHandler = function() {\n\tthis.rotateLayer.setDisplay('none');\n}\n\n/**\n * 缩放控件类\n * @param {[type]} qcanvas [description]\n * @param {[type]} id      [description]\n */\nfunction Qresize(qcanvas,id){\n\tthis.qrotateVersion = '1.0';\n\tthis.qcanvas = qcanvas;\n\tthis.resizeLayer = null;\n\tthis.resizeObj = null;\n\n\tthis.init(id);\n}\n\n//取得顶点坐标中 以元素中心点判断 （右边且靠下的一个点）\nQresize.prototype.rightBottomPoint = function(obj){\n\tvar polyPoints = obj.polyPoints();\n\tvar xArr = polyPoints.map(function(item){return item.x});\n\tvar yArr = polyPoints.map(function(item){return item.y});\n \n\tvar maxX = Math.max.apply({},xArr);\n\tvar maxY = Math.max.apply({},yArr);\n \n\treturn [\n\t\t[Math.min.apply({},xArr),Math.min.apply({},yArr)],\n\t\t[Math.max.apply({},xArr),Math.max.apply({},yArr)],\n\n\t]\n\n\n}\n \n\nQresize.prototype.rectResize = function(obj) {\n\tvar _this = this;\n\t// var startAndEndPosition = this.rightBottomPoint(obj);\n\tvar c = this.resizeObj.centerPoints();\n\tvar start = this.qcanvas.isFun(this.resizeObj.start)?this.resizeObj.start():this.resizeObj.start;\n\n\tvar oldHeight = null;\n\tvar oldWidth = null;\n\tvar rate = null; //宽高比\n\n\t//矩形中心点到开始坐标点的距离（两点之的距离做为一个圆的半径）\n\tvar r = Math.sqrt(Math.pow(Math.abs(c.x-start[0]),2)+Math.pow(Math.abs(c.y-start[1]),2));\n\n\n\tthis.cover = this.qcanvas.qarc.arc({\n\t\t\t\tstart:[c.x,c.y],\n\t\t\t\tsAngle:0,\n\t\t\t\teAngle:360,\n\t\t\t\tfillColor:'',\n\t\t\t\t// opacity:0.2,\n\t\t\t\tborderColor:'blue',\n\t\t\t\tpointerEvent:'none',\n\t\t\t\tlike:'--',\n\t\t\t\ttitle:'resize覆盖元素',\n\t\t\t\tr:r\n\t\t\t})\n\n\tvar polyPoints = this.resizeObj.polyPoints(); \n\tvar position = this.cover.polyPoints();\n\n\tthis.handler = this.qcanvas.qarc.arc({\n\t\t\t\tstart:[position[7].x,position[7].y],\n\t\t\t\n\t\t\t\tsAngle:0,\n\t\t\t\teAngle:360,\n\t\t\t\tfillColor:'red',\n\t\t\t\topacity:0.2, \n\t\t\t\ttitle:'resize操作句柄',\n\t\t\t\tr:10,\n\t\t\t\tmousedown:function(){ \n\n\t\t\t\t\toldHeight = _this.resizeObj.height;\n\t\t\t\t\toldWidth = _this.resizeObj.width;\n\n\n\t\t\t\t\trate = _this.resizeObj.width/_this.resizeObj.height;\n\n\n\t\t\t\t},\n\t\t\t\tmousemove:function(){ \n\n\t\t\t\t\tif(rate !== null){ \n\t\t\t\t\t\tvar c = _this.resizeObj.centerPoints();\n\n\n\t\t\t\t\t\t//重置this.point的半径\n\t\t\t\t\t\tvar R = Math.sqrt(Math.pow(Math.abs(c.x-this.start[0]),2)+Math.pow(Math.abs(c.y-this.start[1]),2));\n\t\t\t\t\t\t_this.cover.setR(R);\n\n\n\t\t\t\t\t\tvar newH = Math.sqrt(4*R*R/(rate*rate+1));\n\t\t\t\t\t\tvar newW = rate*newH;\n\t\t\t\t\t\tvar start = [c.x-newW*0.5,c.y-newH*0.5];\n\n\t\t\t\t\t\t_this.resizeObj.setStart(start);\n\t\t\t\t\t\t_this.resizeObj.setHeight(newH);\n\t\t\t\t\t\t_this.resizeObj.setWidth(newW);\n\n\n\t\t\t\t\t\t// if(_this.qcanvas.qrotate !== null\n\t\t\t\t\t\t// \t&& _this.qcanvas.qrotate.rotateObj.rotate){\n\t\t\t\t\t\tif(_this.resizeObj.rotate){\t\n \n\t\t\t\t\t\t\t_this.qcanvas.qrotate.rotateLayer.elements[0].setStart([c.x+R+10,c.y-18]);\n\t\t\t\t\t\t\t_this.qcanvas.qrotate.showHandler(_this.resizeObj);\n\n\t\t\t\t\t\t}else if(_this.qcanvas.qrotate !==null){ \n\t\t\t\t\t\t\t_this.qcanvas.qrotate.rotateLayer.setDisplay('none');\n\t\t\t\t\t\t}\t\n\n\n\t\t\t\t\t}\n\n\n\t\t\t\t},\n\t\t\t\tmouseup:function(){\n\t\t\t\t\toldHeight = null;\n\t\t\t\t\toldWidth = null;\n\n\t\t\t\t\trate = null;\n\t\t\t\t}\n\t})\n\n\n \n\t\n\tthis.resizeLayer.push(this.cover,this.handler);\n}\n\nQresize.prototype.init = function(id) {\n\tthis.resizeLayer = this.qcanvas.qlayer.layer();\n\tthis.resizeObj = this.qcanvas.getEleById(id);\n\t// console.log(obj);\n\n\n\tswitch(this.resizeObj.TYPE){\n\t\tcase 'rect':\n\t\t\tthis.rectResize();\n\t\tbreak;\n\t}\n\n\n\n\tthis.resizeLayer.setDisplay('block');\n\n\tthis.qcanvas.raiseToTop(this.resizeLayer);\n};\n\nQresize.prototype.updateElePosition = function(obj) {\n\t// var obj = this.qcanvas.dragAim;\n\tvar obj = this.resizeObj;\n\tvar c =  obj.centerPoints();\n\tvar start = this.qcanvas.isFun(obj.start)?obj.start():obj.start;\n\n\tvar r = Math.sqrt(Math.pow(Math.abs(c.x-start[0]),2)+Math.pow(Math.abs(c.y-start[1]),2));\n\t \n\tthis.cover.setStart([c.x,c.y]);\n\tthis.cover.setR(r);\n\n\n\tvar position = this.cover.polyPoints();\n\tthis.handler.setStart([position[7].x,position[7].y]);\n\n}\n\nQresize.prototype.showHandler = function(obj) {\n\n\tif(obj.id != this.resizeObj.id){ //切换不同的元素时 缩放和角度控件都隐藏\n\t\tthis.resizeObj.rotate &&  this.qcanvas.qrotate.rotateLayer.setDisplay('none');\n\t\tthis.resizeObj.resize &&  this.qcanvas.qresize.resizeLayer.setDisplay('none');\n\t}\t\n\n\tthis.resizeObj = obj;\n\n\n\tthis.updateElePosition();\n\tthis.resizeLayer.setDisplay('block');\n\tthis.qcanvas.raiseToTop(this.resizeLayer);\n\n\n \n\t\n};\n\nQresize.prototype.hideHandler = function() {\n\tthis.resizeLayer.setDisplay('none');\n}\n\t\n\n/*\n画布框架Qcanvas结构---------------------------------------------------------\n*/\n/*主类*/\n/*\nc_p:初始化canvas参数数组\n*/\t\nfunction Qcanvas(options){\n\t\n\tvar doc = document;\n\tthis.dpr = window.devicePixelRatio; // 假设this.dpr为2\n\tthis.delayRender = false;  //是否延时执行 (如果元素以静态为主 建议开启 增加渲染效率)\n\n\tif(this.isArr(options)){\n\t\tif(options.length<3 ){\n\t\t\tconsole.log('初始化参数不正确');\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar c_obj = doc.getElementById(options[0]);\n\t\tc_obj.width = options[1]*this.dpr;\n\t\tc_obj.height = options[2]*this.dpr;\n\t\tc_obj.style.width = options[1]+'px';\n\t\tc_obj.style.height = options[2]+'px';\n\n\t\t\n\t\t//舞台对象\n\t\tthis.stage = {\n\t\t\t\"canvas\":c_obj,\n\t\t\t\"id\":options[0],\n\t\t\t\"width\":options[1],\n\t\t\t\"height\":options[2]\n\t\t};\n\t}\n\n\n\tif(this.isObj(options)){\n\n\t\tif((typeof options.id =='undefined') \n\t\t\t|| (typeof options.height =='undefined')\n\t\t\t|| (typeof options.width =='undefined')){\n\t\t\tconsole.log('初始化参数不正确');\n\t\t\treturn false;\n\t\t}\n \n\t\tvar c_obj = doc.getElementById(options.id);\n\t\tc_obj.width = options.width*this.dpr;\n\t\tc_obj.height = options.height*this.dpr;\n\t\tc_obj.style.width = options.width+'px';\n\t\tc_obj.style.height = options.height+'px';\n\t\t\n\t\t//舞台对象\n\t\tthis.stage = {\n\t\t\t\"canvas\":c_obj,\n\t\t\t\"id\":options.id,\n\t\t\t\"width\":options.width,\n\t\t\t\"height\":options.height\n\t\t};\n\n\t\tthis.mousedown = options.mousedown || function(){};\n\t\tthis.mousemove = options.mousemove || function(){};\n\t\tthis.mouseup = options.mouseup || function(){};\n\t\tthis.mouseout = options.mouseout || function(){};\n\t\tthis.mouseenter = options.mouseenter || function(){};\n\t\tthis.dblclick = options.dblclick || function(){};\n\n\n\t\tthis.delayRender = typeof options.delayRender !='undefined'?options.delayRender :false;\n\t}\n\n\tthis.createShadowCanvas();\t\n\n\t// if(options.length<3 ){\n\t// \t// console.log('Qcanvas 初始化参数不正确');\n\t// \treturn false;\n\t// }\n\t\n\t// var c_obj = doc.getElementById(options[0]);\n\t// c_obj.width = options[1];\n\t// c_obj.height = options[2];\n\t\n\t// //舞台对象\n\t// this.stage = {\n\t// \t\"id\":options[0],\n\t// \t\"width\":options[1],\n\t// \t\"height\":options[2]\n\t// };\n\t\n\tthis.qcanvasVersion = '1.0';\n\tthis.TYPE = 'canvas';\n\tthis.id = (new Date()).getTime()+''+parseInt(Math.random()*100000000);\n\tthis.context = c_obj.getContext('2d');\n\t// 需要将绘制比例放大\n    this.context.scale(this.dpr,this.dpr);\n\n\tthis.canvas = c_obj;\n\tthis.fps = 60;\n\tthis.dragAim = null;  //当前拖动的对象\n\tthis.moveAim = null;  //当前鼠标划过的对象\n\n\t//当有元素有配置了resize时 才会创建qresize实例\n\t//qresize = {\n\t//\tresizeLayer:{} //是一个layer对象 保存有一组缩放大小的操作点\n\t//}\n\tthis.qresize = null;  \n\n\n\t//当元素配置了rotate时 才会创建qrotate实例\n\t//qrotate = {\n\t//\trotateLayer:{} //是一个layer对象 保存有一组角度的操作点\n\t//}\n\tthis.qrotate = null;  \n\n\t\n\t\n\t\n\t\n\t//元素数组 （按z-index由小到大排序）\n\tthis.elements = [];\n\t \n\t\n\t\n\tthis.qline = new Qline(this);\n\tthis.qtext = new Qtext(this);\n\tthis.qrect = new Qrect(this);\n\tthis.qarc = new Qarc(this);\n\tthis.qpolygon = new Qpolygon(this);\n\tthis.qanimation = new Qanimation(this);\n\tthis.qimg = new Qimg(this);\n\tthis.qspirit = new Qspirit(this);\n\tthis.qshape = new Qshape(this);\n\n\tQlayer.prototype = this;\n\tthis.qlayer = new Qlayer(this);\n\tthis.qgroup = new Qgroup(this);\n\n\n\tthis.qquadraticCurve = new QquadraticCurve(this);\n\tthis.qbezierCurve = new QbezierCurve(this);\n\t\n\t\n\tthis.event = new Qevent(this);\n\t\n\t// this.animationFrame = this.requestNextAnimationFrame();\n\t// console.log('animationFrame');\n\t// console.log(this.animationFrame.toString());\n\t\n\t//计算fps\n\tthis.lastLoop = (new Date()).getMilliseconds();\n\tthis.count = 1;\n  \tthis.currFps = 0;\n\n  \tthis.TypeGroup = {\n  \t\t'line':this.qline.paintLine,\n  \t\t'text':this.qtext.paintText,\n  \t\t'rect':this.qrect.paintRect,\n  \t\t'arc':this.qarc.paintArc,\n  \t\t'polygon':this.qpolygon.paintPolygon,\n  \t\t'img':this.qimg.paintImg,\n  \t\t'spirit':this.qspirit.paintSpirit,\n  \t\t'shape':this.qshape.paintShape,\n  \t\t'layer':this.qlayer.paintLayer, \n  \t\t'group':this.qgroup.paintGroup,\n  \t\t'quadraticCurve':this.qquadraticCurve.paintQuadraticCurve,\n  \t\t'bezierCurve':this.qbezierCurve.paintBezierCurve\n  \t} \n\n\n  \t//1px占位图 \n  \tthis.placeHolderImg = new Image();\n  \tthis.placeHolderImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQwIDc5LjE2MDQ1MSwgMjAxNy8wNS8wNi0wMTowODoyMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTggKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NDlEMzc4NzlFMDJDMTFFQUE1QkREQzVDRjA2NDgzNEQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NDlEMzc4N0FFMDJDMTFFQUE1QkREQzVDRjA2NDgzNEQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0OUQzNzg3N0UwMkMxMUVBQTVCRERDNUNGMDY0ODM0RCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0OUQzNzg3OEUwMkMxMUVBQTVCRERDNUNGMDY0ODM0RCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Ph/0HDsAAAAQSURBVHjaYvj//z8DQIABAAj8Av7bok0WAAAAAElFTkSuQmCC'\n\n\t//启动\n\tthis.start();\n\t// this.requestNextAnimationFrame1.call(this,this.start);\n\t// \n\t// \n// window.requestNextAnimationFrame(this.start.bind(this))\n\n\n// this.animationFrame(this.start.bind(this));\n\n\n}\n\nQcanvas.prototype.createShadowCanvas = function() {\n\tthis.shadowCanvas = document.createElement('canvas');\n\tthis.shadowCanvas.id =(new Date()).getTime()+''+parseInt(Math.random()*100000000);\n\t// this.shadowCanvas = document.getElementById('qcanvas1');\n\n\n\tthis.shadowCanvas.width = this.stage.width;\n\tthis.shadowCanvas.height = this.stage.height;  \n\tthis.shadowContext = this.shadowCanvas.getContext('2d');\n\n};\nQcanvas.prototype.getShadowPixelColor = function(pos) {\n\t  var imageData = this.shadowContext.getImageData(pos.x,pos.y, 1, 1);\n\t  var pixel = imageData.data;\n\t  var r = pixel[0];\n\t  var g = pixel[1];\n\t  var b = pixel[2];\n\t  var a = pixel[3] / 255;\n\t  a = Math.round(a * 100) / 100;\n\t  var rHex = r.toString(16);\n\t  r < 16 && (rHex = \"0\" + rHex);\n\t  var gHex = g.toString(16);\n\t  g < 16 && (gHex = \"0\" + gHex);\n\t  var bHex = b.toString(16);\n\t  b < 16 && (bHex = \"0\" + bHex);\n\t  var rgbaColor = \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + a + \")\";\n\t  var rgbColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n\t  var hexColor = \"#\" + rHex + gHex + bHex;\n\t  return {\n\t    rgba: rgbaColor,\n\t    rgb: rgbColor,\n\t    hex: hexColor,\n\t    r: r,\n\t    g: g,\n\t    b: b,\n\t    a: a\n\t  };\n};\n//销毁所有对象 释放资源\nQcanvas.prototype.destroy = function(){\n\tthis.elements = []; \n\n}\nQcanvas.prototype.Tween = {\n    Linear: function(t, b, c, d) { return c*t/d + b; },\n    Quad: {\n        easeIn: function(t, b, c, d) {\n            return c * (t /= d) * t + b;\n        },\n        easeOut: function(t, b, c, d) {\n            return -c *(t /= d)*(t-2) + b;\n        },\n        easeInOut: function(t, b, c, d) {\n            if ((t /= d / 2) < 1) return c / 2 * t * t + b;\n            return -c / 2 * ((--t) * (t-2) - 1) + b;\n        }\n    },\n    Cubic: {\n        easeIn: function(t, b, c, d) {\n            return c * (t /= d) * t * t + b;\n        },\n        easeOut: function(t, b, c, d) {\n            return c * ((t = t/d - 1) * t * t + 1) + b;\n        },\n        easeInOut: function(t, b, c, d) {\n            if ((t /= d / 2) < 1) return c / 2 * t * t*t + b;\n            return c / 2*((t -= 2) * t * t + 2) + b;\n        }\n    },\n    Quart: {\n        easeIn: function(t, b, c, d) {\n            return c * (t /= d) * t * t*t + b;\n        },\n        easeOut: function(t, b, c, d) {\n            return -c * ((t = t/d - 1) * t * t*t - 1) + b;\n        },\n        easeInOut: function(t, b, c, d) {\n            if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;\n            return -c / 2 * ((t -= 2) * t * t*t - 2) + b;\n        }\n    },\n    Quint: {\n        easeIn: function(t, b, c, d) {\n            return c * (t /= d) * t * t * t * t + b;\n        },\n        easeOut: function(t, b, c, d) {\n            return c * ((t = t/d - 1) * t * t * t * t + 1) + b;\n        },\n        easeInOut: function(t, b, c, d) {\n            if ((t /= d / 2) < 1) return c / 2 * t * t * t * t * t + b;\n            return c / 2*((t -= 2) * t * t * t * t + 2) + b;\n        }\n    },\n    Sine: {\n        easeIn: function(t, b, c, d) {\n            return -c * Math.cos(t/d * (Math.PI/2)) + c + b;\n        },\n        easeOut: function(t, b, c, d) {\n            return c * Math.sin(t/d * (Math.PI/2)) + b;\n        },\n        easeInOut: function(t, b, c, d) {\n            return -c / 2 * (Math.cos(Math.PI * t/d) - 1) + b;\n        }\n    },\n    Expo: {\n        easeIn: function(t, b, c, d) {\n            return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;\n        },\n        easeOut: function(t, b, c, d) {\n            return (t==d) ? b + c : c * (-Math.pow(2, -10 * t/d) + 1) + b;\n        },\n        easeInOut: function(t, b, c, d) {\n            if (t==0) return b;\n            if (t==d) return b+c;\n            if ((t /= d / 2) < 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n            return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n        }\n    },\n    Circ: {\n        easeIn: function(t, b, c, d) {\n            return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n        },\n        easeOut: function(t, b, c, d) {\n            return c * Math.sqrt(1 - (t = t/d - 1) * t) + b;\n        },\n        easeInOut: function(t, b, c, d) {\n            if ((t /= d / 2) < 1) return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n            return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n        }\n    },\n    Elastic: {\n        easeIn: function(t, b, c, d, a, p) {\n            var s;\n            if (t==0) return b;\n            if ((t /= d) == 1) return b + c;\n            if (typeof p == \"undefined\") p = d * .3;\n            if (!a || a < Math.abs(c)) {\n                s = p / 4;\n                a = c;\n            } else {\n                s = p / (2 * Math.PI) * Math.asin(c / a);\n            }\n            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n        },\n        easeOut: function(t, b, c, d, a, p) {\n            var s;\n            if (t==0) return b;\n            if ((t /= d) == 1) return b + c;\n            if (typeof p == \"undefined\") p = d * .3;\n            if (!a || a < Math.abs(c)) {\n                a = c; \n                s = p / 4;\n            } else {\n                s = p/(2*Math.PI) * Math.asin(c/a);\n            }\n            return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);\n        },\n        easeInOut: function(t, b, c, d, a, p) {\n            var s;\n            if (t==0) return b;\n            if ((t /= d / 2) == 2) return b+c;\n            if (typeof p == \"undefined\") p = d * (.3 * 1.5);\n            if (!a || a < Math.abs(c)) {\n                a = c; \n                s = p / 4;\n            } else {\n                s = p / (2  *Math.PI) * Math.asin(c / a);\n            }\n            if (t < 1) return -.5 * (a * Math.pow(2, 10* (t -=1 )) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p ) * .5 + c + b;\n        }\n    },\n    Back: {\n        easeIn: function(t, b, c, d, s) {\n            if (typeof s == \"undefined\") s = 1.70158;\n            return c * (t /= d) * t * ((s + 1) * t - s) + b;\n        },\n        easeOut: function(t, b, c, d, s) {\n            if (typeof s == \"undefined\") s = 1.70158;\n            return c * ((t = t/d - 1) * t * ((s + 1) * t + s) + 1) + b;\n        },\n        easeInOut: function(t, b, c, d, s) {\n            if (typeof s == \"undefined\") s = 1.70158; \n            if ((t /= d / 2) < 1) return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;\n            return c / 2*((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;\n        }\n    },\n    Bounce: {\n        easeIn: function(t, b, c, d) {\n            //return c - Tween.Bounce.easeOut(d-t, 0, c, d) + b;\n\t\t\t\t\treturn c - this.easeOut(d-t, 0, c, d) + b;\n        },\n        easeOut: function(t, b, c, d) {\n            if ((t /= d) < (1 / 2.75)) {\n                return c * (7.5625 * t * t) + b;\n            } else if (t < (2 / 2.75)) {\n                return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;\n            } else if (t < (2.5 / 2.75)) {\n                return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;\n            } else {\n                return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;\n            }\n        },\n        easeInOut: function(t, b, c, d) {\n            if (t < d / 2) {\n                //return Tween.Bounce.easeIn(t * 2, 0, c, d) * .5 + b;\n\t\t\t\t\t\t\treturn this.easeIn(t * 2, 0, c, d) * .5 + b;\n            } else {\n                //return Tween.Bounce.easeOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;\n\t\t\t\t\t\t\treturn this.easeOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;\n            }\n        }\n    }\n}\t\n\nQcanvas.prototype.delayRenderFun = function() {\n\tthis.renderTime = (new Date()).getTime();\n\tthis.clear();\n\tthis.paint();\n\n\tif(((new Date()).getTime() - this.renderTime)> 16){\n\t\t// console.log('渲染超过16ms了，重新更新时间');\n\t\tthis.renderTime = (new Date()).getTime();\n\t}\n\n};\n//启动\nQcanvas.prototype.start = function(){\n\t \n\tif(this.delayRender){ \n\t\tif(typeof this.renderTime == 'undefined'){\n\t\t\tthis.delayRenderFun();\n\n\t\t}else if(((new Date()).getTime() - this.renderTime)> 16){\n\t\t\tthis.delayRenderFun();\n\t\t}/*else{\n\t\t\tconsole.log('不需要重新 等下一个16ms');\n\t\t}*/\n\n\t}else{\n\t\tthis.clear();\n\t\tthis.paint();\n\t}\n\t\n\t\n\t//requestNextAnimationFrame.call(this,[arguments.callee]);\n\t\n\tvar currentLoop = (new Date()).getMilliseconds();\n    if (this.lastLoop > currentLoop) {\n\t\t\tthis.currFps = this.count;\n      this.count = 1;\n    } else {\n\t\t\tthis.count  += 1;\t\n    }\n\t\t\t\t\n\t\tthis.lastLoop = currentLoop;\t\t\n\t\n\t// this.animationFrame(this.callback = arguments.callee);\n\t// this.animationFrame(this.start.bind(this));\n\n\t// this.requestNextAnimationFrame1.call(this,this.start);\n\n\nwindow.requestNextAnimationFrame(this.start.bind(this))\n\t\n}\t\t\t\t\n\t\n\n//根据elements数组 画所有元素\nQcanvas.prototype.paint = function(\t){\n\tvar l = this.elements.length;\n\tfor(var i = 0; i<l; i++){\n\t\tvar o = this.elements[i];\n\n\t\tif(o.display=='none'){\n\t\t\tcontinue;\n\t\t}\n\n\t\tthis.TypeGroup[o.TYPE].call(this['q'+o.TYPE],o);\n\t\t\n\t\t// switch (o.TYPE){\n\t\t// \tcase 'line':\n\t\t// \t\tthis.qline.paintLine(o);\n\t\t// \t\tbreak;\n\t\t// \tcase 'text':\n\t\t// \t\tthis.qtext.paintText(o);\n\t\t// \t\tbreak;\n\t\t// \tcase 'rect':\n\t\t// \t\tthis.qrect.paintRect(o);\n\t\t// \t\tbreak;\n\t\t// \tcase 'arc':\n\t\t// \t\tthis.qarc.paintArc(o);\n\t\t// \t\tbreak;\t\n\t\t// \tcase 'polygon':\n\t\t// \t\tthis.qpolygon.paintPolygon(o);\n\t\t// \t\tbreak;\t\n\t\t// \tcase 'img':\n\t\t// \t\tthis.qimg.paintImg(o);\n\t\t// \t\tbreak;\n\t\t// \tcase 'spirit':\n\t\t// \t\tthis.qspirit.paintSpirit(o);\n\t\t// \t\tbreak;\t\n\t\t// \tcase 'shape':\n\t\t// \t\tthis.qshape.paintShape(o);\n\t\t// \t\tbreak;\t\t\n\t\t// }\n\t\t\t\t\n\t}\n}\n\n\n\n\n\n\t\nQcanvas.prototype.clear = function(){\n\t\tthis.canvas.width = this.canvas.width;\n\t\tthis.context.scale(this.dpr,this.dpr);\n\t\tthis.shadowCanvas.width = this.shadowCanvas.width;\n\n\t\t// this.context.clearRect(0,0,this.stage.width,this.stage.height);\n\t\t// this.shadowContext.clearRect(0,0,this.stage.width,this.stage.height);\n}\t\n\n\t\t\n\n//根据对象属性名称自动生成[set+属性名称]方法\nQcanvas.prototype.appendSetFun = function(o){\n\t\tvar _this = this;\n\t\tvar firstToUpperCase = function(s){\n\t\t\t\tvar p = s.split('');\n\t\t\t\tp[0] = p[0].toUpperCase();\n\t\t\t\t\n\t\t\t\treturn p.join('');\n\t\t}\t\t\n\n\t\t//所有元素都附加display属性\n\t\tif(typeof o.display =='undefined'){\n\t\t\to.display = 'block';\n\t\t}\n\t\t\n\n\t\t\n\t\t\t\t\n\t\tfor(var i in o){\n\t\t\t\n\t\t\t\t(i != 'TYPE') && \n\t\t\t\t(i != 'id') && \n\t\t\t\t(i != 'withText') && \n\t\t\t\t(i != 'withTextAlign') && \n\t\t\t\t!this.isFun(o[i]) &&\n\t\t\t\t(o['set'+firstToUpperCase(i)] = (function(index,obj){\n\t\t\t\t\tvar p = index;\n\t\t\t\t\treturn function(t){\n\t\t\t\t\t\tobj[p] = t;\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t}\n\t\t\t})(i,o));\n\n\t\t\t\t\n\t\t}\t\t\n}\n\nQcanvas.prototype.extend = function(o,n){\n\t \n\tfor(var i in n){ \n\t\t(i != 'TYPE') && (o[i] = n[i]); \n\t}\n\t\t\t\t \n\tthis.pushElements(o);\n}\nQcanvas.prototype.RandomNumBoth = function(Min,Max){\n      var Range = Max - Min;\n      var Rand = Math.random();\n      var num = Min + Math.round(Rand * Range); //四舍五入\n      return num;\n}\t\nQcanvas.prototype.pushElements = function(element){\n\t\n\tif(typeof element.id == 'undefined'){\n\t\t//自动生成一个唯一id\n\t\telement.id = (new Date()).getTime()+''+parseInt(Math.random()*100000000);\n\t\telement.shadowFillColor = 'rgba('+this.RandomNumBoth(0,255)+','+this.RandomNumBoth(0,255)+','+this.RandomNumBoth(0,255)+',1)';\n\t\tthis.elements.push(element);\n\t}\n\t\n}\n\nQcanvas.prototype.getEleById = function(id){\n\tvar l = this.elements.length;\n\tfor(var i=0;i<l;i++){\n\t\tif(this.elements[i].id == id){\n\t\t\t\treturn this.elements[i];\n\t\t\t\tbreak;\n\t\t}\t\n\t}\n\t\n}\n\n//从elements数组中删除 \n//该方法使用时要注意 如果其它元素的某一属性与该元素有关联 为了不让它出现在画布中最好用setDisplay()方法\nQcanvas.prototype.removeEle = function(obj){\n\tvar l = this.elements.length;\n\t\tfor(var i=0;i<l;i++){\n\t\t\tif(this.elements[i].id == obj.id){ \n\t\t\t\t\tthis.elements.splice(i,1);\n\t\t\t\t\tbreak;\n\t\t\t}\t\n\t\t}\n \n\t\n}\n//从elements数组中删除 \n//该方法使用时要注意 如果其它元素的某一属性与该元素有关联 为了不让它出现在画布中最好用setDisplay()方法\nQcanvas.prototype.removeEleById = function(id){\n\tvar l = this.elements.length;\n\t\tfor(var i=0;i<l;i++){\n\t\t\tif(this.elements[i].id == id){ \n\t\t\t\t\tthis.elements.splice(i,1);\n\t\t\t\t\tbreak;\n\t\t\t}\t\n\t\t}\n \n\t\n}\n\n\n\n\nQcanvas.prototype.getIndexById = function(id){\n\tvar l = this.elements.length;\n\tfor(var i=0;i<l;i++){\n\t\tif(this.elements[i].id == id){\n\t\t\t\treturn i; \n\t\t\t\tbreak;\n\t\t}\t\n\t}\n \n}\n\n\nQcanvas.prototype.lower = function(el){\n\n\tvar currIndex = this.getIndexById(el.id); \n\tif((currIndex-1 < 0) || (typeof this.elements[currIndex-1] == 'undefined')){\n\t\treturn false;\n\t}\n\n\tthis.elements[currIndex] = this.elements.splice(currIndex-1,1,this.elements[currIndex])[0];\n\n\n}\n\nQcanvas.prototype.lowerToBottom = function(el){ \n\n\tif(this.getIndexById(el.id) == 0){  //已经是最底层\n\t\treturn false;\n\t}\n\n\tthis.removeEle(el);\n\tthis.elements.unshift(el);\n\n}\n\nQcanvas.prototype.raise = function(el){ \n\n\tvar currIndex = this.getIndexById(el.id);  \n\tif(typeof this.elements[currIndex+1] == 'undefined'){\n\t\treturn false;\n\t}\n\n\tthis.elements[currIndex] = this.elements.splice(currIndex+1,1,this.elements[currIndex])[0];\n\n\n}\n\nQcanvas.prototype.raiseToTop = function(el){\n \n\tif(this.getIndexById(el.id) == (this.elements.length-1)){  //已经是最顶层\n\t\treturn false;\n\t}\n\n\tthis.removeEle(el);\n\tthis.elements.push(el);\n}\n\n//promise类\nQcanvas.prototype.loadPromise = function(fn) {\n    var value = null, succallbacks = [], failcallbacks = [];\n    this.then = function (fulfilled, rejected) {\n        succallbacks.push(fulfilled);\n        failcallbacks.push(rejected);\n    }\n\n    function resolve(value) {\n        setTimeout(function(){ \n            succallbacks.forEach((callback) => {\n                callback(value);\n            })\n        },0)\n    }\n\n    function reject(value) {\n        setTimeout(function(){\n            failcallbacks.forEach((callback) => {\n                callback(value);\n            })\n        },0)\n       \n    }\n\n    fn(resolve, reject);\n}\nQcanvas.prototype.loadImgSource = function(sourceObj){\n\tif(this.isArr(sourceObj)){\n\t\tvar urlArr = sourceObj;\n\t}else{\n\t\tif(arguments.length>0){\n\t\t\tvar urlArr  = [].slice.call(arguments)\n\t\t}\n\t}\n\t\n\tvar _this = this; \n\treturn new this.loadPromise(function(resolve,reject){\n\t\t//先实现加载图片资源\n\t\tvar imgArr = [];\n\t\tvar num = 0;\n\n\t\t\tfor (var i = 0; i < urlArr.length; i++) { \n\t\t\t\timg = new Image();\n\t\t\t\timgArr.push(img);\n\t\t\t\timg.onload = function(){\n\t\t\t\t\tnum++;\n\t\t\t\t\tif(num==imgArr.length){\n\t\t\t\t\t\tresolve(imgArr);\n\t\t\t\t\t}\n\t\t\t\t}; \n\t\t\t\timg.onerror = function(){\n\t\t\t\t\t// console.log('err');\n\t\t\t\t\tnum++;\n\t\t\t\t\tif(num==imgArr.length){\n\t\t\t\t\t\tresolve(imgArr);\n\t\t\t\t\t}\n\t\t\t\t\tconsole.log('索引为'+this.sort+'的资源加载失败');\n\t\t\t\t}\n\t\t\t\timg.sort = i;\n\t\t\t\timg.src = urlArr[i];\n\t\t\t}\n\t\t\n\t\t\n\n\t}) \n\n\n}\n//加载图片资源\t\t\t\t\nQcanvas.prototype.load = function(sourceObj,callback){\n\t\n\tif(typeof this.source=='undefined'){\n\t\t\tthis.source = {};\n\t}\n\t\n\tvar _this = this;\n\t\n\t//先实现加载图片资源\n\tvar imgArr = [];\n\tvar num = 0;\n\tfor(var i in sourceObj){\n\t\t\n\t\t\n\t\timg = new Image();\n\t\timgArr.push(img);\n\t\timg.onload = function(){\n\t\t\t_this.source[this.alias] = this;\n\t\t\t\n\t\t\tnum++;\n\t\t\t\n\t\t\tif(num==imgArr.length){\n\t\t\t\tcallback(_this.source);\n\t\t\t}\n\t\t};\n\t\timg.alias = i;\n\t\timg.src=sourceObj[i];\n\t}\n\t\n}\n\nQcanvas.prototype.getSourceByName = function(name){\n\t\t\n\t\treturn this.source[name];\t\t\n}\t\t\t\t\n\nQcanvas.prototype.isObj = function(o){\n\treturn Object.prototype.toString.call(o)==='[object Object]';\n}\t\t\t\n\n\t\nQcanvas.prototype.isFun = function(o){\n\treturn Object.prototype.toString.call(o)==='[object Function]'; \n}\n\t\t\t\t\nQcanvas.prototype.isArr = function(o){\n\treturn Object.prototype.toString.call(o)==='[object Array]';\n}\t\n\t\t\t\t\nQcanvas.prototype.isNum = function(o){\n\treturn Object.prototype.toString.call(o)==='[object Number]';\n}\t\n\nQcanvas.prototype.isBool = function(o){\n\treturn Object.prototype.toString.call(o)==='[object Boolean]';\n}\t\t\n\nQcanvas.prototype.isStr = function(o){\n\treturn Object.prototype.toString.call(o)==='[object String]';\n}\t\t\t\t\n\n\t\t\t\t\nQcanvas.prototype.colorRgb = function(color){\n\n\tif(color == ''){\n\t\treturn '0,0,0';\n\t}\n\n\t//17种基本色\n\tvar basicColor = {\n\t\t\"aqua\":\"#00FFFF\",\n\t\t\"black\":\"#000000\",\n\t\t\"blue\":\"#0000FF\",\n\t\t\"fuchsia\":\"#FF00FF\",\n\t\t\"gray\":\"#808080\",\n\t\t\"green\":\"#008000\",\n\t\t\"lime\":\"#00FF00\",\n\t\t\"maroon\":\"#800000\",\n\t\t\"navy\":\"#000080\",\n\t\t\"olive\":\"#808000\",\n\t\t\"orange\":\"#FFA500\",\n\t\t\"purple\":\"#800080\",\n\t\t\"red\":\"#FF0000\",\n\t\t\"silver\":\"#C0C0C0\",\n\t\t\"teal\":\"#008080\",\n\t\t\"white\":\"#FFFFFF\",\n\t\t\"yellow\":\"#FFFF00\"\n\t}\n\n\tif(color.indexOf('#')<0){ \n\t\tcolor = basicColor[color.toLowerCase()];\n\t}\n\n\t\n\tvar reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;\n    var sColor = color.toLowerCase();\n    if(sColor && reg.test(sColor)){\n        if(sColor.length === 4){\n            var sColorNew = \"#\";\n                for(var i=1; i<4; i+=1){\n                    sColorNew += sColor.slice(i,i+1).concat(sColor.slice(i,i+1));        \n                }\n                sColor = sColorNew;\n        }\n        //处理六位的颜色值\n        var sColorChange = [];\n        for(var i=1; i<7; i+=2){\n            sColorChange.push(parseInt(\"0x\"+sColor.slice(i,i+2)));        \n        }\n        return \"RGB(\" + sColorChange.join(\",\") + \")\";\n    }else{\n        return sColor;        \n    }};\t\n\t\n\nQcanvas.prototype.requestNextAnimationFrame1 = function(callback){\n         \n\t\tvar self = this;\n\n        return window.requestNextAnimationFrame ||\n               window.webkitRequestAnimationFrame ||\n               window.mozRequestAnimationFrame ||\n               window.oRequestAnimationFrame ||\n               window.msRequestAnimationFrame ||\n\n\n               function (callback){ \n                    window.setTimeout(callback , self.timeout);\n               };\n}\n\t\t\t\t\nQcanvas.prototype.requestNextAnimationFrame = function(){\n        var originalWebkitMethod,\n            wrapper = undefined,\n            callback = undefined,\n            geckoVersion = 0,\n            userAgent = navigator.userAgent,\n            index = 0,\n            self = this;\n        if(window.webkitRequestAnimationFrame){\n            wrapper = function(time){\n                if(time === undefined){\n                    time += new Date();\n                }\n                self.callback(time);\n            };\n            originalWebkitMethod = window.webkitRequestAnimationFrame;\n            window.webkitRequestAnimationFrame = function(callback,element){\n                self.callback = callback;\n                originalWebkitMethod(wrapper , element);\n            }\n        }\n        if(window.mozRequestAnimationFrame){\n            index = userAgent.indexOf('rv:');\n            if(userAgent.indexOf('Gecko') != -1){\n                geckoVersion = userAgent.substr(index+3 , 3);\n                if(geckoVersion === '2.0'){\n                    window.mozRequestAnimationFrame = undefined;\n                }\n            }\n        }\n\n\n        return window.requestNextAnimationFrame ||\n               window.webkitRequestAnimationFrame ||\n               window.mozRequestAnimationFrame ||\n               window.oRequestAnimationFrame ||\n               window.msRequestAnimationFrame ||\n\n\n               function (callback , element){\n                    var start,\n                        finish;\n                    window.setTimeout(function(){\n                        start = +new Date();\n                        callback.call(self,start);\n                        finish = +new Date();\n                        self.timeout = 1000/self.fps - (finish - start);\n                    } , self.timeout);\n               };\n}\n\nQcanvas.prototype.setDegree = function(obj){\n\t\tvar centerPos = {};\n\t\t\n\t\tif(obj.degree != 0){\n\t\t\tcenterPos = obj.centerPoints();\n\n\t\t\tthis.context.translate(centerPos.x,centerPos.y);\n\t\t\tthis.context.rotate(obj.degree*Math.PI/180);\n\t\t\tthis.context.translate(-centerPos.x,-centerPos.y);\n\n\t\t}\t\n\n\t\treturn centerPos;\n}\n\nQcanvas.prototype.resetDegree = function(obj,centerPos){\n\tif(obj.degree != 0){\n\t\tthis.context.translate(centerPos.x,centerPos.y);\n\t\tthis.context.rotate(-obj.degree*Math.PI/180);\n\t\tthis.context.translate(-centerPos.x,-centerPos.y);\n\t}\n}\n\ntypeof window.requestNextAnimationFrame =='undefined'\n&& (function(){\n\n\twindow.requestNextAnimationFrame =\n   (function () {\n      var originalWebkitRequestAnimationFrame = undefined,\n          wrapper = undefined,\n          callback = undefined,\n          geckoVersion = 0,\n          userAgent = navigator.userAgent,\n          index = 0,\n          self = this;\n\n      // Workaround for Chrome 10 bug where Chrome\n      // does not pass the time to the animation function\n      \n      if (window.webkitRequestAnimationFrame) {\n         // Define the wrapper\n\n         wrapper = function (time) {\n           if (time === undefined) {\n              time = +new Date();\n           }\n           self.callback(time);\n         };\n\n         // Make the switch\n          \n         originalWebkitRequestAnimationFrame = window.webkitRequestAnimationFrame;    \n\n         window.webkitRequestAnimationFrame = function (callback, element) {\n            self.callback = callback;\n\n            // Browser calls the wrapper and wrapper calls the callback\n            \n            originalWebkitRequestAnimationFrame(wrapper, element);\n         }\n      }\n\n      // Workaround for Gecko 2.0, which has a bug in\n      // mozRequestAnimationFrame() that restricts animations\n      // to 30-40 fps.\n\n      if (window.mozRequestAnimationFrame) {\n         // Check the Gecko version. Gecko is used by browsers\n         // other than Firefox. Gecko 2.0 corresponds to\n         // Firefox 4.0.\n         \n         index = userAgent.indexOf('rv:');\n\n         if (userAgent.indexOf('Gecko') != -1) {\n            geckoVersion = userAgent.substr(index + 3, 3);\n\n            if (geckoVersion === '2.0') {\n               // Forces the return statement to fall through\n               // to the setTimeout() function.\n\n               window.mozRequestAnimationFrame = undefined;\n            }\n         }\n      }\n      \n      return window.requestAnimationFrame   ||\n         window.webkitRequestAnimationFrame ||\n         window.mozRequestAnimationFrame    ||\n         window.oRequestAnimationFrame      ||\n         window.msRequestAnimationFrame     ||\n\n         function (callback, element) {\n            var start,\n                finish;\n\n\n            window.setTimeout( function () {\n               start = +new Date();\n               callback(start);\n               finish = +new Date();\n\n               self.timeout = 1000 / self.fps - (finish - start);\n\n            }, self.timeout);\n         };\n      }\n   )\n();\n\n\n\n})()\n\t\nmodule.exports.Qcanvas = Qcanvas;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcWNhbnZhcy9saWIvUWNhbnZhcy5qcz80ZTRmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSCwrQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSztBQUNBLEdBQUc7QUFDSCwrQkFBK0I7OztBQUcvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE87OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsa0Q7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTs7QUFFQSxrRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxrRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFM7QUFDQTs7QUFFQSxrRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EsUztBQUNBOztBQUVBO0FBQ0Esa0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0EsZ0M7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHVEO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0gsK0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLO0FBQ0EsR0FBRztBQUNILCtCQUErQjs7O0FBRy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7OztBQUlBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBLFM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUEsQzs7O0FBR0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSwyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHFCOzs7QUFHQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EscUI7Ozs7OztBQU1BO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJOzs7QUFHQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSw4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9COztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCLEVBQUU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0I7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7O0FBRUgsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0I7QUFDQTs7QUFFQSw4Qjs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQSxDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGE7QUFDQTtBQUNBO0FBQ0EsYTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhO0FBQ0E7QUFDQTtBQUNBLGE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEM7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSixHO0FBQ0E7O0FBRUE7O0FBRUEsaUI7QUFDQSxpQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0EsRztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCLHFDO0FBQ0E7QUFDQTtBQUNBLEk7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQixpQztBQUNBO0FBQ0E7QUFDQSxJO0FBQ0E7OztBQUdBOzs7OztBQUtBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQSxhO0FBQ0E7QUFDQSxHO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBLDBDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQSwrQzs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHVDOztBQUVBLDBDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQSwwREFBMEQ7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBbUIsTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMkI7QUFDQSxDOztBQUVBO0FBQ0E7QUFDQSxDOzs7QUFHQTtBQUNBLGdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEM7O0FBRUE7QUFDQTtBQUNBLEM7O0FBRUE7QUFDQTtBQUNBLEM7O0FBRUE7QUFDQTtBQUNBLEM7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCO0FBQ0E7QUFDQTs7O0FBR0EsMkJBQTJCLEVBQUUsYUFBYSxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUs7QUFDakMsaUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekIsa0U7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHNCO0FBQ0EsTzs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsbUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBLENBQUM7O0FBRUQiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiDkuozmrKHotJ3loZ7lsJTmm7Lnur/mm7Lnur/nsbtcbiAqL1xuZnVuY3Rpb24gUXF1YWRyYXRpY0N1cnZlKHFjYW52YXMpe1xuXHR0aGlzLnFxdWFkcmF0aWNDdXJ2ZVZlcnNpb24gPSAnMS4wJztcblx0dGhpcy5xY2FudmFzID0gcWNhbnZhcztcbn1cblFxdWFkcmF0aWNDdXJ2ZS5wcm90b3R5cGUucXVhZHJhdGljQ3VydmUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdHZhciBfdGhpcyA9IHRoaXM7XG5cdHZhciBPUFRJT05TID0ge1xuXHRcdFRZUEU6J3F1YWRyYXRpY0N1cnZlJyxcblx0XHRjb2xvcjonIzAwMCcsICAvL+minOiJslxuXHRcdGxpa2U6Jy0nLCAgICAgLy/nlLvlh7rmnaXnmoTmoLflrZAgWy1dWy0+XVs8LT5dWy0tXVstLT5dWzwtLT5dXG5cdFx0d2lkdGg6MSxcblx0XHRzdGFydDpbMCwwXSxcblx0XHRoYW5kbGVyOls1MCwxMzBdLFxuXHRcdGVuZDpbMTAwLDEwMF0sXG5cdFx0ZHJhZzp0cnVlLFxuXHRcdHBvaW50ZXJFdmVudDonYXV0bycsXG5cdFx0aGFuZGxlclNob3c6ZmFsc2UsXG5cdFx0Ly93aXRoVGV4dDondGV4dCcsIC8v5bim552A55qE5paH5pysXG5cdFx0Ly93aXRoVGV4dEFsaWduOidjZW50ZXInICAvL+aWh+acrOeahOaoquWQkeS9jee9riBbbGVmdCBjZW50ZXIo6buY6K6kKSByaWdodF1cblx0XHRjZW50ZXJQb2ludHM6ZnVuY3Rpb24oKXsgLy/lhYPntKDkuK3lv4Pngrnnm7jlr7nkuo7mlbTkuKrnlLvluIPnmoTlnZDmoIdcblxuXHRcdFx0dmFyIHN0YXJ0ID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLnN0YXJ0KT90aGlzLnN0YXJ0KCk6dGhpcy5zdGFydDtcblx0XHRcdHZhciBoYW5kbGVyID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLmhhbmRsZXIpP3RoaXMuaGFuZGxlcigpOnRoaXMuaGFuZGxlcjtcblx0XHRcdHZhciBlbmQgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuZW5kKT90aGlzLmVuZCgpOnRoaXMuZW5kO1xuXHRcdFx0dmFyIGNlbnRlciA9IFtcblx0XHRcdFx0KHN0YXJ0WzBdIDwgZW5kWzBdID8gc3RhcnRbMF06ZW5kWzBdKStNYXRoLmFicyhzdGFydFswXS1lbmRbMF0pICogMC41LFxuXHRcdFx0XHQoc3RhcnRbMV0gPCBlbmRbMV0gPyBzdGFydFsxXTplbmRbMV0pK01hdGguYWJzKHN0YXJ0WzFdLWVuZFsxXSkgKiAwLjVcblx0XHRcdF1cblxuXG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHQoaGFuZGxlclswXSA8IGNlbnRlclswXSA/IGhhbmRsZXJbMF06Y2VudGVyWzBdKStNYXRoLmFicyhoYW5kbGVyWzBdLWNlbnRlclswXSkgKiAwLjUsXG5cdFx0XHRcdChoYW5kbGVyWzFdIDwgY2VudGVyWzFdID8gaGFuZGxlclsxXTpjZW50ZXJbMV0pK01hdGguYWJzKGhhbmRsZXJbMV0tY2VudGVyWzFdKSAqIDAuNVxuXHRcdFx0XVxuXG5cdFx0fSxcblx0XHRkb3duRnVuOmZ1bmN0aW9uKGUscG9zaXRpb24peyBcblxuXHRcdFx0Ly/nur/nmoTmi5bliqjopoHnibnmrorlpITnkIYg6byg5qCH54K55Ye754K56Led57uT5p2f54K555qE6Led56a75Lmf5b6X6K6w5b2VXG5cdFx0XHR2YXIgc3RhcnQgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuc3RhcnQpP3RoaXMuc3RhcnQoKTp0aGlzLnN0YXJ0O1xuXHRcdFx0dmFyIGhhbmRsZXIgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuaGFuZGxlcik/dGhpcy5oYW5kbGVyKCk6dGhpcy5oYW5kbGVyO1xuXHRcdCBcdHZhciBlbmQgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuZW5kKT90aGlzLmVuZCgpOnRoaXMuZW5kOyBcblx0XHRcdHRoaXMuZGlzID0gW1xuXHRcdFx0XHRwb3NpdGlvbi54LXN0YXJ0WzBdLFxuXHRcdFx0XHRwb3NpdGlvbi55LXN0YXJ0WzFdLFxuXHRcdFx0XHRwb3NpdGlvbi54LWhhbmRsZXJbMF0sXG5cdFx0XHRcdHBvc2l0aW9uLnktaGFuZGxlclsxXSxcblx0XHRcdFx0cG9zaXRpb24ueC1lbmRbMF0sXG5cdFx0XHRcdHBvc2l0aW9uLnktZW5kWzFdXG5cdFx0XHRdOyBcblx0XHR9LFxuXHRcdG1vdmVGdW46ZnVuY3Rpb24oZSxwb3NpdGlvbil7ICAvL+W9k+mFjee9rmRyYWdlUmFuZ2Xml7YgIOW8gOWni+mZkOWItuWdkOagh1xuXG5cblx0XHRcdHZhciBkcmFnSXNCb29sID0gX3RoaXMucWNhbnZhcy5pc0Jvb2wodGhpcy5kcmFnKTtcblx0XHRcdFx0XHR2YXIgZGlzICA9dGhpcy5kaXM7XG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLnN0YXJ0KT90aGlzLnN0YXJ0KCk6dGhpcy5zdGFydDtcblx0XHRcdFx0XHR2YXIgaGFuZGxlciA9IF90aGlzLnFjYW52YXMuaXNGdW4odGhpcy5oYW5kbGVyKT90aGlzLmhhbmRsZXIoKTp0aGlzLmhhbmRsZXI7XG5cdFx0XHRcdCBcdHZhciBlbmQgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuZW5kKT90aGlzLmVuZCgpOnRoaXMuZW5kO1xuXG5cbiBcdFx0XHRcdFx0XG4gXHRcdFx0XHRcdHZhciB4MCx5MCx4MSx5MSx4Mix5Mjtcblx0XHRcdFx0XHRcdCBcblx0XHRcdFx0XHRcdGlmKGRyYWdJc0Jvb2wgJiYgdGhpcy5kcmFnKXtcblx0XHRcdFx0XHRcdFx0IHgwID0gcG9zaXRpb24ueC1kaXNbMF07XG5cdFx0XHRcdFx0XHRcdCB5MCA9IHBvc2l0aW9uLnktZGlzWzFdO1xuXG5cdFx0XHRcdFx0XHRcdCB4MSA9IHBvc2l0aW9uLngtZGlzWzJdO1xuXHRcdFx0XHRcdFx0XHQgeTEgPSBwb3NpdGlvbi55LWRpc1szXTtcblxuXHRcdFx0XHRcdFx0XHQgeDIgPSBwb3NpdGlvbi54LWRpc1s0XTtcblx0XHRcdFx0XHRcdFx0IHkyID0gcG9zaXRpb24ueS1kaXNbNV07XG5cblx0XHRcdFx0XHRcdH1lbHNlIGlmKHRoaXMuZHJhZyA9PSAndmVydGljYWwnKXtcblx0XHRcdFx0XHRcdFx0IHgwID0gc3RhcnRbMF07XG5cdFx0XHRcdFx0XHRcdCB5MCA9IHBvc2l0aW9uLnktZGlzWzFdO1xuXHRcdFx0XHRcdFx0XHQgeDEgPSBoYW5kbGVyWzBdO1xuXHRcdFx0XHRcdFx0XHQgeTEgPSBwb3NpdGlvbi55LWRpc1szXTtcblx0XHRcdFx0XHRcdFx0IHgyID0gZW5kWzBdO1xuXHRcdFx0XHRcdFx0XHQgeTIgPSBwb3NpdGlvbi55LWRpc1s1XTtcblxuXG5cdFx0XHRcdFx0XHR9ZWxzZSBpZih0aGlzLmRyYWcgPT0gJ2hvcml6b250YWwnKXtcblx0XHRcdFx0XHRcdFx0IHgwID0gcG9zaXRpb24ueC1kaXNbMF07XG5cdFx0XHRcdFx0XHRcdCB5MCA9IHN0YXJ0WzFdO1xuXHRcdFx0XHRcdFx0XHQgeDEgPSBwb3NpdGlvbi54LWRpc1syXTtcblx0XHRcdFx0XHRcdFx0IHkxID0gaGFuZGxlclsxXTtcblx0XHRcdFx0XHRcdFx0IHgyID0gcG9zaXRpb24ueC1kaXNbNF07XG5cdFx0XHRcdFx0XHRcdCB5MiA9IGVuZFsxXTtcblxuXHRcdFx0XHRcdFx0fSBcbiBcblxuXHRcdFx0XHRcdCAvL+WmguaenOWIm+W7uuaXtuS9jee9ruaVsOaNruS+nei1luS6juWIq+eahOWFg+e0oCDpgqPkuYjkuIDml6bmi5bliqjor6XlhYPntKAg5pWw5o2u55qE5L6d6LWW5YWz57O75bCx5Lya5pat5byAIOWIh+iusFxuXHRcdFx0XHRcdHRoaXMuc3RhcnQgPSBbeDAseTBdO1xuXHRcdFx0XHRcdHRoaXMuaGFuZGxlciA9IFt4MSx5MV07XG5cdFx0XHRcdFx0dGhpcy5lbmQgPSBbeDIseTJdXG5cblx0XHRcdFx0XHR0aGlzLmhhbmRsZXJTaG93ICYmICh0aGlzLmhhbmRsZXJPYmogIT09IG51bGwpICYmIHRoaXMuaGFuZGxlck9iai5zZXRTdGFydChbeDEseTFdKTtcblxuXHRcdFx0fSxcblx0XHRcdGRyYXdBcnJvdzogZnVuY3Rpb24oZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSx0aGV0YSxoZWFkbGVuLHdpZHRoLGNvbG9yKSB7XG5cdFx0XHRcdCBcblx0XHRcdFx0ICAgIHZhciB0aGV0YSA9IHR5cGVvZih0aGV0YSkgIT0gJ3VuZGVmaW5lZCcgPyB0aGV0YSA6IDMwO1xuXHRcdFx0XHQgICAgdmFyIGhlYWRsZW4gPSB0eXBlb2YodGhldGEpICE9ICd1bmRlZmluZWQnID8gaGVhZGxlbiA6IDEwO1xuXHRcdFx0XHQgICAgdmFyIHdpZHRoID0gdHlwZW9mKHdpZHRoKSAhPSAndW5kZWZpbmVkJyA/IHdpZHRoIDogMTtcblx0XHRcdFx0ICAgIHZhciBjb2xvciA9IHR5cGVvZihjb2xvcikgIT0gJ2NvbG9yJyA/IGNvbG9yIDogJyMwMDAnO1xuXHRcdFx0XHQgXG5cdFx0XHRcdCAgICAvLyDorqHnrpflkITop5Lluqblkozlr7nlupTnmoRQMixQM+WdkOagh1xuXHRcdFx0XHQgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihmcm9tWSAtIHRvWSwgZnJvbVggLSB0b1gpICogMTgwIC8gTWF0aC5QSTtcblx0XHRcdFx0ICAgIHZhciBhbmdsZTEgPSAoYW5nbGUgKyB0aGV0YSkgKiBNYXRoLlBJIC8gMTgwO1xuXHRcdFx0XHQgICAgdmFyIGFuZ2xlMiA9IChhbmdsZSAtIHRoZXRhKSAqIE1hdGguUEkgLyAxODA7XG5cdFx0XHRcdCAgICB2YXIgdG9wWCA9IGhlYWRsZW4gKiBNYXRoLmNvcyhhbmdsZTEpO1xuXHRcdFx0XHQgICAgdmFyIHRvcFkgPSBoZWFkbGVuICogTWF0aC5zaW4oYW5nbGUxKTtcblx0XHRcdFx0ICAgIHZhciBib3RYID0gaGVhZGxlbiAqIE1hdGguY29zKGFuZ2xlMik7XG5cdFx0XHRcdCAgICB2YXIgYm90WSA9IGhlYWRsZW4gKiBNYXRoLnNpbihhbmdsZTIpO1xuXHRcdFx0XHQgXG5cdFx0XHRcdCAgICAvLyB0aGlzLnFjYW52YXMuY29udGV4dC5zYXZlKCk7XG5cdFx0XHRcdCAgICAvLyB0aGlzLnFjYW52YXMuY29udGV4dC5iZWdpblBhdGgoKTtcblx0XHRcdFx0IFxuXHRcdFx0XHQgICAgdmFyIGFycm93WCA9IGZyb21YIC0gdG9wWDtcblx0XHRcdFx0ICAgIHZhciBhcnJvd1kgPSBmcm9tWSAtIHRvcFk7XG5cdFx0XHRcdCBcdFx0Ly8gdGhpcy5xY2FudmFzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0XHRcdCAgXHQvLyBcdHRoaXMucWNhbnZhcy5jb250ZXh0LnNldExpbmVEYXNoKFtdKTsgXG5cblxuXHRcdFx0XHQgICAgYXJyb3dYID0gdG9YICsgdG9wWDtcblx0XHRcdFx0ICAgIGFycm93WSA9IHRvWSArIHRvcFk7XG5cdFx0XHRcdCAgICAvLyB0aGlzLnFjYW52YXMuY29udGV4dC5tb3ZlVG8oYXJyb3dYLCBhcnJvd1kpO1xuXHRcdFx0XHQgICAgLy8gdGhpcy5xY2FudmFzLmNvbnRleHQubGluZVRvKHRvWCwgdG9ZKTtcblx0XHRcdFx0ICAgIHZhciBhcnJvdzJYID0gdG9YICsgYm90WDtcblx0XHRcdFx0ICAgIHZhciBhcnJvdzJZID0gdG9ZICsgYm90WTtcblx0XHRcdFx0ICAgIC8vIHRoaXMucWNhbnZhcy5jb250ZXh0LmxpbmVUbyhhcnJvdzJYLCBhcnJvdzJZKTtcblx0XHRcdFx0ICAgIC8vIHRoaXMucWNhbnZhcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG5cdFx0XHRcdCAgICAvLyB0aGlzLnFjYW52YXMuY29udGV4dC5saW5lV2lkdGggPSB3aWR0aDtcblx0XHRcdFx0ICAgIC8vIHRoaXMucWNhbnZhcy5jb250ZXh0LnN0cm9rZSgpO1xuXG5cdFx0XHRcdCAgICBfdGhpcy5xY2FudmFzLnFsaW5lLnBhaW50TGluZSh7XG5cdFx0XHRcdFx0XHQgICAgXHRsaWtlOictJyxcblx0XHRcdFx0XHRcdFx0XHRzdGFydDpbYXJyb3dYLCBhcnJvd1ldLFxuXHRcdFx0XHRcdFx0XHRcdGVuZDpbdG9YLCB0b1ldLFxuXHRcdFx0XHRcdFx0XHRcdHdpZHRoOndpZHRoLFxuXHRcdFx0XHRcdFx0XHRcdGNvbG9yOmNvbG9yLFxuXHRcdFx0XHRcdFx0XHRcdHBvaW50ZXJFdmVudDonbm9uZSdcblxuXHRcdFx0XHQgICAgfSlcblxuXHRcdFx0XHQgICAgX3RoaXMucWNhbnZhcy5xbGluZS5wYWludExpbmUoe1xuXHRcdFx0XHRcdFx0ICAgIFx0bGlrZTonLScsXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQ6W3RvWCwgdG9ZXSxcblx0XHRcdFx0XHRcdFx0XHRlbmQ6W2Fycm93MlgsYXJyb3cyWV0sXG5cdFx0XHRcdFx0XHRcdFx0d2lkdGg6d2lkdGgsXG5cdFx0XHRcdFx0XHRcdFx0Y29sb3I6Y29sb3IsXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnRlckV2ZW50Oidub25lJ1xuXHRcdFx0XHQgICAgfSkgXG5cdFx0XHRcdH1cblx0fVxuXHR0aGlzLnFjYW52YXMuZXh0ZW5kKE9QVElPTlMsb3B0aW9ucyk7XHRcdFxuXHR0aGlzLnFjYW52YXMuYXBwZW5kU2V0RnVuKE9QVElPTlMpO1xuXG5cdC8v5YiG56a75paH5a2XXG5cdGlmKHR5cGVvZiBPUFRJT05TLndpdGhUZXh0ICE9J3VuZGVmaW5lZCcgJiYgT1BUSU9OUy53aXRoVGV4dCE9Jycpe1xuXHRcdFxuXHRcdHRoaXMuc3BsaXRUZXh0KE9QVElPTlMpO1xuXHRcdFx0XG5cdH1cblxuXG5cdC8v5pi+56S65o6n5Yi254K5XG5cdE9QVElPTlMuaGFuZGxlclNob3cgJiYgdGhpcy5kcmF3SGFuZGxlcihPUFRJT05TKTtcblxuXG5cblxuXHRyZXR1cm4gT1BUSU9OUztcbn07XG5RcXVhZHJhdGljQ3VydmUucHJvdG90eXBlLmRyYXdIYW5kbGVyID0gZnVuY3Rpb24ob2JqKXtcblx0dmFyIF90aGlzID0gdGhpcztcblx0dmFyIGhhbmRsZXIgPSBfdGhpcy5xY2FudmFzLmlzRnVuKG9iai5oYW5kbGVyKT9vYmouaGFuZGxlcigpOm9iai5oYW5kbGVyO1xuXG5cdG9iai5oYW5kbGVyT2JqID0gdGhpcy5xY2FudmFzLnFhcmMuYXJjKHtcblx0XHRzdGFydDpoYW5kbGVyLCBcblx0XHRzQW5nbGU6MCxcblx0XHRlQW5nbGU6MzYwLFxuXHRcdGZpbGxDb2xvcjonYmx1ZScsXG5cdFx0b3BhY2l0eTowLjIsXG5cdFx0cjo4LCBcblx0XHRib3JkZXJDb2xvcjonI2NjYycsXG5cdFx0bW91c2Vtb3ZlOmZ1bmN0aW9uKCl7XG5cdFx0XHRpZihfdGhpcy5xY2FudmFzLmRyYWdBaW0gIT09IG51bGwpe1xuXHRcdFx0XHRvYmouaGFuZGxlciA9IHRoaXMuc3RhcnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcdCBcblxufVxuUXF1YWRyYXRpY0N1cnZlLnByb3RvdHlwZS5wYWludFF1YWRyYXRpY0N1cnZlICA9IGZ1bmN0aW9uKG9iail7XG5cdHRoaXMucWNhbnZhcy5xYW5pbWF0aW9uLmNyZWF0ZUFuaW1hdGlvbihvYmopO1xuIFxuXHR2YXIgc3RhcnQgPSB0aGlzLnFjYW52YXMuaXNGdW4ob2JqLnN0YXJ0KT9vYmouc3RhcnQoKTpvYmouc3RhcnQ7XG5cdHZhciBoYW5kbGVyID0gdGhpcy5xY2FudmFzLmlzRnVuKG9iai5oYW5kbGVyKT9vYmouaGFuZGxlcigpOm9iai5oYW5kbGVyO1xuXHR2YXIgZW5kID0gdGhpcy5xY2FudmFzLmlzRnVuKG9iai5lbmQpP29iai5lbmQoKTpvYmouZW5kO1xuXG5cdHRoaXMucWNhbnZhcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gb2JqLmNvbG9yO1xuXHR0aGlzLnFjYW52YXMuY29udGV4dC5iZWdpblBhdGgoKTtcblx0dGhpcy5xY2FudmFzLmNvbnRleHQubGluZVdpZHRoID0gb2JqLndpZHRoO1xuXG5cblx0c3dpdGNoKG9iai5saWtlKVxuXHR7XG5cdFx0Y2FzZSAnLSc6IFxuXHRcdFx0XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5tb3ZlVG8oc3RhcnRbMF0sc3RhcnRbMV0pOyBcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oaGFuZGxlclswXSxoYW5kbGVyWzFdICwgZW5kWzBdLGVuZFsxXSk7XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zdHJva2UoKTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJy0tJzogXG5cblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnNldExpbmVEYXNoKFszXSk7XG5cblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0Lm1vdmVUbyhzdGFydFswXSxzdGFydFsxXSk7IFxuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhoYW5kbGVyWzBdLGhhbmRsZXJbMV0gLCBlbmRbMF0sZW5kWzFdKTtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnN0cm9rZSgpO1xuXG5cdFx0XHQvL+WPr+iDvei3r+W+hOaYr+iZmue6v+W9ouW8j+eahCDorr7nva7miJDlrp7nur9cblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnNldExpbmVEYXNoKFtdKTtcblxuIFxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnLT4nOiBcblx0XHRcdFxuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQubW92ZVRvKHN0YXJ0WzBdLHN0YXJ0WzFdKTsgXG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGhhbmRsZXJbMF0saGFuZGxlclsxXSAsIGVuZFswXSxlbmRbMV0pO1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc3Ryb2tlKCk7XG5cdFx0XHQgXG5cdFx0XHQvL+WPr+iDvei3r+W+hOaYr+iZmue6v+W9ouW8j+eahCDorr7nva7miJDlrp7nur9cblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnNldExpbmVEYXNoKFtdKTtcblxuXHRcdFx0b2JqLmRyYXdBcnJvdyhoYW5kbGVyWzBdLCBoYW5kbGVyWzFdLCBlbmRbMF0sIGVuZFsxXSwzMCwxMCwxLG9iai5jb2xvcilcblx0XHRcdFxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnPC0nOiBcblx0XHRcdFxuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQubW92ZVRvKHN0YXJ0WzBdLHN0YXJ0WzFdKTsgXG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGhhbmRsZXJbMF0saGFuZGxlclsxXSAsIGVuZFswXSxlbmRbMV0pO1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc3Ryb2tlKCk7XG5cdFx0XHQgXG5cdFx0XHQvL+WPr+iDvei3r+W+hOaYr+iZmue6v+W9ouW8j+eahCDorr7nva7miJDlrp7nur9cblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnNldExpbmVEYXNoKFtdKTtcblxuXHRcdFx0b2JqLmRyYXdBcnJvdyhoYW5kbGVyWzBdLCBoYW5kbGVyWzFdLCBzdGFydFswXSwgc3RhcnRbMV0sMzAsMTAsMSxvYmouY29sb3IpXG5cdFx0XHRcblx0XHRcdGJyZWFrO1x0XG5cdFx0Y2FzZSAnPC0+JzogXG5cdFx0XHRcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0Lm1vdmVUbyhzdGFydFswXSxzdGFydFsxXSk7IFxuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhoYW5kbGVyWzBdLGhhbmRsZXJbMV0gLCBlbmRbMF0sZW5kWzFdKTtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnN0cm9rZSgpO1xuXHRcdFx0XG5cblx0XHRcdC8v5Y+v6IO96Lev5b6E5piv6Jma57q/5b2i5byP55qEIOiuvue9ruaIkOWunue6v1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc2V0TGluZURhc2goW10pO1xuXG5cdFx0XHRvYmouZHJhd0Fycm93KGhhbmRsZXJbMF0sIGhhbmRsZXJbMV0sIGVuZFswXSwgZW5kWzFdLDMwLDEwLDEsb2JqLmNvbG9yKTtcblx0XHRcdG9iai5kcmF3QXJyb3coaGFuZGxlclswXSwgaGFuZGxlclsxXSxzdGFydFswXSwgc3RhcnRbMV0sMzAsMTAsMSxvYmouY29sb3IpO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdGJyZWFrO1x0XG5cdFx0Y2FzZSAnLS0+JzogXG5cblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnNldExpbmVEYXNoKFszXSk7XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5tb3ZlVG8oc3RhcnRbMF0sc3RhcnRbMV0pOyBcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oaGFuZGxlclswXSxoYW5kbGVyWzFdICwgZW5kWzBdLGVuZFsxXSk7XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zdHJva2UoKTtcblxuXG5cdFx0XHQvL+WPr+iDvei3r+W+hOaYr+iZmue6v+W9ouW8j+eahCDorr7nva7miJDlrp7nur9cblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdFxuXHRcdFx0b2JqLmRyYXdBcnJvdyhoYW5kbGVyWzBdLCBoYW5kbGVyWzFdLCBlbmRbMF0sIGVuZFsxXSwzMCwxMCwxLG9iai5jb2xvcik7XG5cblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJzwtLSc6IFxuXG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zZXRMaW5lRGFzaChbM10pO1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQubW92ZVRvKHN0YXJ0WzBdLHN0YXJ0WzFdKTsgXG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGhhbmRsZXJbMF0saGFuZGxlclsxXSAsIGVuZFswXSxlbmRbMV0pO1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc3Ryb2tlKCk7XG5cblxuXHRcdFx0Ly/lj6/og73ot6/lvoTmmK/omZrnur/lvaLlvI/nmoQg6K6+572u5oiQ5a6e57q/XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG5cdFx0XHRcblx0XHRcdG9iai5kcmF3QXJyb3coaGFuZGxlclswXSwgaGFuZGxlclsxXSwgc3RhcnRbMF0sIHN0YXJ0WzFdLDMwLDEwLDEsb2JqLmNvbG9yKTtcblxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnPC0tPic6IFxuXG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zZXRMaW5lRGFzaChbM10pO1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQubW92ZVRvKHN0YXJ0WzBdLHN0YXJ0WzFdKTsgXG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGhhbmRsZXJbMF0saGFuZGxlclsxXSAsIGVuZFswXSxlbmRbMV0pO1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc3Ryb2tlKCk7XG5cblx0XHRcdC8v5Y+v6IO96Lev5b6E5piv6Jma57q/5b2i5byP55qEIOiuvue9ruaIkOWunue6v1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc2V0TGluZURhc2goW10pO1xuIFx0XHRcdFxuXHRcdFx0b2JqLmRyYXdBcnJvdyhoYW5kbGVyWzBdLCBoYW5kbGVyWzFdLCBlbmRbMF0sIGVuZFsxXSwzMCwxMCwxLG9iai5jb2xvcik7XG5cdFx0XHRvYmouZHJhd0Fycm93KGhhbmRsZXJbMF0sIGhhbmRsZXJbMV0sc3RhcnRbMF0sIHN0YXJ0WzFdLDMwLDEwLDEsb2JqLmNvbG9yKTtcblxuXHRcdFx0YnJlYWs7XG5cdH1cbiBcblxuXHRcblx0XG5cblxuXG5cdC8v6ZyA6KaB5ZON5bqU5LqL5Lu2XG5cdC8v5b2x5a2Q55S75biD5LiK6ZyA6KaB5YaN55S75LiA5Lu9XG5cdGlmKG9iai5wb2ludGVyRXZlbnQgPT0gJ2F1dG8nKXsgXG5cdFx0dGhpcy5xY2FudmFzLnNoYWRvd0NvbnRleHQuc3Ryb2tlU3R5bGUgPSBvYmouc2hhZG93RmlsbENvbG9yO1xuXHRcdHRoaXMucWNhbnZhcy5zaGFkb3dDb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdHRoaXMucWNhbnZhcy5zaGFkb3dDb250ZXh0LmxpbmVXaWR0aCA9IDIwO1xuXG5cdFx0XG5cdFx0dGhpcy5xY2FudmFzLnNoYWRvd0NvbnRleHQubW92ZVRvKHN0YXJ0WzBdLHN0YXJ0WzFdKTsgXG5cdFx0dGhpcy5xY2FudmFzLnNoYWRvd0NvbnRleHQucXVhZHJhdGljQ3VydmVUbyhoYW5kbGVyWzBdLGhhbmRsZXJbMV0gLCBlbmRbMF0sZW5kWzFdKTtcblx0XHR0aGlzLnFjYW52YXMuc2hhZG93Q29udGV4dC5zdHJva2UoKTtcblx0fVxuXG5cblxufVxuLy/liIbnprvmkLrluKbnmoTmloflrZdcdFxuUXF1YWRyYXRpY0N1cnZlLnByb3RvdHlwZS5zcGxpdFRleHQgPSBmdW5jdGlvbihvYmope1xuXHRcblxuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXHR2YXIgdG1wID0gdGhpcy5xY2FudmFzLnF0ZXh0LnRleHQoe1xuXHRcdFx0VFlQRTondGV4dCcsXG5cdFx0XHR0ZXh0Om9iai53aXRoVGV4dCxcblx0XHRcdGNvbG9yOm9iai5jb2xvcixcblx0XHRcdHdpdGhUZXh0QWxpZ246b2JqLndpdGhUZXh0QWxpZ24/b2JqLndpdGhUZXh0QWxpZ246J2NlbnRlcicsXG5cdFx0XHRzdGFydDpmdW5jdGlvbigpe3JldHVybiBvYmouY2VudGVyUG9pbnRzKCl9LFxuXHRcdFx0cG9pbnRlckV2ZW50Oidub25lJ1xuXHR9KTtcblx0b2JqLndpdGhUZXh0SWQgPSB0bXAuaWQ7XG59XG5cblxuLy8gLS0tLS0tLS0tLWVuZC0tLS0tLS0tLS0tLS0tXG5cblxuLyoqXG4gKiDkuInmrKHotJ3loZ7lsJTmm7Lnur/nsbtcbiAqL1xuZnVuY3Rpb24gUWJlemllckN1cnZlKHFjYW52YXMpe1xuXHR0aGlzLnFiZXppZXJDdXJ2ZVZlcnNpb24gPSAnMS4wJztcblx0dGhpcy5xY2FudmFzID0gcWNhbnZhcztcbn1cblxuUWJlemllckN1cnZlLnByb3RvdHlwZS5iZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0dmFyIF90aGlzID0gdGhpcztcblx0dmFyIE9QVElPTlMgPSB7XG5cdFx0VFlQRTonYmV6aWVyQ3VydmUnLFxuXHRcdGNvbG9yOicjMDAwJywgIC8v6aKc6ImyXG5cdFx0bGlrZTonLScsICAgICAvL+eUu+WHuuadpeeahOagt+WtkCBbLV1bLT5dWzwtPl1bLS1dWy0tPl1bPC0tPl1cblx0XHR3aWR0aDoxLFxuXHRcdHN0YXJ0Ols1MCw1MF0sXG5cdFx0aGFuZGxlcjE6WzcwLDIwXSxcblx0XHRoYW5kbGVyMjpbMTAwLDgwXSxcblx0XHRlbmQ6WzIwMCw1MF0sXG5cdFx0ZHJhZzp0cnVlLFxuXHRcdHBvaW50ZXJFdmVudDonYXV0bycsXG5cdFx0aGFuZGxlclNob3c6ZmFsc2UsXG5cdFx0Ly93aXRoVGV4dDondGV4dCcsIC8v5bim552A55qE5paH5pysXG5cdFx0Ly93aXRoVGV4dEFsaWduOidjZW50ZXInICAvL+aWh+acrOeahOaoquWQkeS9jee9riBbbGVmdCBjZW50ZXIo6buY6K6kKSByaWdodF1cblx0XHRjZW50ZXJQb2ludHM6ZnVuY3Rpb24oKXsgLy/lhYPntKDkuK3lv4Pngrnnm7jlr7nkuo7mlbTkuKrnlLvluIPnmoTlnZDmoIdcblxuXHRcdFx0dmFyIHN0YXJ0ID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLnN0YXJ0KT90aGlzLnN0YXJ0KCk6dGhpcy5zdGFydDtcblx0XHRcdHZhciBoYW5kbGVyMSA9IF90aGlzLnFjYW52YXMuaXNGdW4odGhpcy5oYW5kbGVyMSk/dGhpcy5oYW5kbGVyMSgpOnRoaXMuaGFuZGxlcjE7XG5cdFx0XHR2YXIgaGFuZGxlcjIgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuaGFuZGxlcjIpP3RoaXMuaGFuZGxlcjIoKTp0aGlzLmhhbmRsZXIyO1xuXG5cdFx0XHR2YXIgZW5kID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLmVuZCk/dGhpcy5lbmQoKTp0aGlzLmVuZDtcblxuXHRcdFx0dmFyIGNlbnRlcjEgPSBbXG5cdFx0XHRcdChoYW5kbGVyMVswXSA8IHN0YXJ0WzBdID8gaGFuZGxlcjFbMF06c3RhcnRbMF0pK01hdGguYWJzKGhhbmRsZXIxWzBdLXN0YXJ0WzBdKSAqIDAuNSxcblx0XHRcdFx0KGhhbmRsZXIxWzFdIDwgc3RhcnRbMV0gPyBoYW5kbGVyMVsxXTpzdGFydFsxXSkrTWF0aC5hYnMoaGFuZGxlcjFbMV0tc3RhcnRbMV0pICogMC41XG5cdFx0XHRdXG5cblx0XHRcdHZhciBjZW50ZXIyID0gW1xuXHRcdFx0XHQoaGFuZGxlcjJbMF0gPCBlbmRbMF0gPyBoYW5kbGVyMlswXTplbmRbMF0pK01hdGguYWJzKGhhbmRsZXIyWzBdLWVuZFswXSkgKiAwLjUsXG5cdFx0XHRcdChoYW5kbGVyMlsxXSA8IGVuZFsxXSA/IGhhbmRsZXIyWzFdOmVuZFsxXSkrTWF0aC5hYnMoaGFuZGxlcjJbMV0tZW5kWzFdKSAqIDAuNVxuXHRcdFx0XVxuXG5cblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdChjZW50ZXIyWzBdIDwgY2VudGVyMVswXSA/IGNlbnRlcjJbMF06Y2VudGVyMVswXSkrTWF0aC5hYnMoY2VudGVyMlswXS1jZW50ZXIxWzBdKSAqIDAuNSxcblx0XHRcdFx0KGNlbnRlcjJbMV0gPCBjZW50ZXIxWzFdID8gY2VudGVyMlsxXTpjZW50ZXIxWzFdKStNYXRoLmFicyhjZW50ZXIyWzFdLWNlbnRlcjFbMV0pICogMC41XG5cdFx0XHRdXG5cblx0XHR9LFxuXHRcdGRvd25GdW46ZnVuY3Rpb24oZSxwb3NpdGlvbil7IFxuXG5cdFx0XHQvL+e6v+eahOaLluWKqOimgeeJueauiuWkhOeQhiDpvKDmoIfngrnlh7vngrnot53nu5PmnZ/ngrnnmoTot53nprvkuZ/lvpforrDlvZVcblx0XHRcdHZhciBzdGFydCA9IF90aGlzLnFjYW52YXMuaXNGdW4odGhpcy5zdGFydCk/dGhpcy5zdGFydCgpOnRoaXMuc3RhcnQ7XG5cdFx0XHR2YXIgaGFuZGxlcjEgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuaGFuZGxlcjEpP3RoaXMuaGFuZGxlcjEoKTp0aGlzLmhhbmRsZXIxO1xuXHRcdFx0dmFyIGhhbmRsZXIyID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLmhhbmRsZXIyKT90aGlzLmhhbmRsZXIyKCk6dGhpcy5oYW5kbGVyMjtcblxuXHRcdCBcdHZhciBlbmQgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuZW5kKT90aGlzLmVuZCgpOnRoaXMuZW5kOyBcblx0XHRcdHRoaXMuZGlzID0gW1xuXHRcdFx0XHRwb3NpdGlvbi54LXN0YXJ0WzBdLFxuXHRcdFx0XHRwb3NpdGlvbi55LXN0YXJ0WzFdLFxuXHRcdFx0XHRwb3NpdGlvbi54LWhhbmRsZXIxWzBdLFxuXHRcdFx0XHRwb3NpdGlvbi55LWhhbmRsZXIxWzFdLFxuXHRcdFx0XHRwb3NpdGlvbi54LWhhbmRsZXIyWzBdLFxuXHRcdFx0XHRwb3NpdGlvbi55LWhhbmRsZXIyWzFdLFxuXHRcdFx0XHRwb3NpdGlvbi54LWVuZFswXSxcblx0XHRcdFx0cG9zaXRpb24ueS1lbmRbMV1cblx0XHRcdF07IFxuXHRcdH0sXG5cdFx0bW92ZUZ1bjpmdW5jdGlvbihlLHBvc2l0aW9uKXsgIC8v5b2T6YWN572uZHJhZ2VSYW5nZeaXtiAg5byA5aeL6ZmQ5Yi25Z2Q5qCHXG5cblxuXHRcdFx0dmFyIGRyYWdJc0Jvb2wgPSBfdGhpcy5xY2FudmFzLmlzQm9vbCh0aGlzLmRyYWcpO1xuXHRcdFx0XHRcdHZhciBkaXMgID10aGlzLmRpcztcblx0XHRcdFx0XHR2YXIgc3RhcnQgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuc3RhcnQpP3RoaXMuc3RhcnQoKTp0aGlzLnN0YXJ0O1xuXHRcdFx0XHRcdHZhciBoYW5kbGVyMSA9IF90aGlzLnFjYW52YXMuaXNGdW4odGhpcy5oYW5kbGVyMSk/dGhpcy5oYW5kbGVyMSgpOnRoaXMuaGFuZGxlcjE7XG5cdFx0XHRcdFx0dmFyIGhhbmRsZXIyID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLmhhbmRsZXIyKT90aGlzLmhhbmRsZXIyKCk6dGhpcy5oYW5kbGVyMjtcblxuXHRcdFx0XHQgXHR2YXIgZW5kID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLmVuZCk/dGhpcy5lbmQoKTp0aGlzLmVuZDtcblxuXG4gXHRcdFx0XHRcdFxuIFx0XHRcdFx0XHR2YXIgeDAseTAseDEseTEseDIseTIseDMseTM7XG5cdFx0XHRcdFx0XHQgXG5cdFx0XHRcdFx0XHRpZihkcmFnSXNCb29sICYmIHRoaXMuZHJhZyl7XG5cdFx0XHRcdFx0XHRcdCB4MCA9IHBvc2l0aW9uLngtZGlzWzBdO1xuXHRcdFx0XHRcdFx0XHQgeTAgPSBwb3NpdGlvbi55LWRpc1sxXTtcblxuXHRcdFx0XHRcdFx0XHQgeDEgPSBwb3NpdGlvbi54LWRpc1syXTtcblx0XHRcdFx0XHRcdFx0IHkxID0gcG9zaXRpb24ueS1kaXNbM107XG5cblx0XHRcdFx0XHRcdFx0IHgyID0gcG9zaXRpb24ueC1kaXNbNF07XG5cdFx0XHRcdFx0XHRcdCB5MiA9IHBvc2l0aW9uLnktZGlzWzVdO1xuXG5cdFx0XHRcdFx0XHRcdCB4MyA9IHBvc2l0aW9uLngtZGlzWzZdO1xuXHRcdFx0XHRcdFx0XHQgeTMgPSBwb3NpdGlvbi55LWRpc1s3XTtcblxuXHRcdFx0XHRcdFx0fWVsc2UgaWYodGhpcy5kcmFnID09ICd2ZXJ0aWNhbCcpe1xuXHRcdFx0XHRcdFx0XHQgeDAgPSBzdGFydFswXTtcblx0XHRcdFx0XHRcdFx0IHkwID0gcG9zaXRpb24ueS1kaXNbMV07XG5cdFx0XHRcdFx0XHRcdCB4MSA9IGhhbmRsZXIxWzBdO1xuXHRcdFx0XHRcdFx0XHQgeTEgPSBwb3NpdGlvbi55LWRpc1szXTtcblx0XHRcdFx0XHRcdFx0IHgyID0gaGFuZGxlcjJbMF07XG5cdFx0XHRcdFx0XHRcdCB5MiA9IHBvc2l0aW9uLnktZGlzWzVdO1xuXHRcdFx0XHRcdFx0XHQgeDMgPSBlbmRbMF07XG5cdFx0XHRcdFx0XHRcdCB5MyA9IHBvc2l0aW9uLnktZGlzWzddO1xuXG5cdFx0XHRcdFx0XHR9ZWxzZSBpZih0aGlzLmRyYWcgPT0gJ2hvcml6b250YWwnKXtcblx0XHRcdFx0XHRcdFx0IHgwID0gcG9zaXRpb24ueC1kaXNbMF07XG5cdFx0XHRcdFx0XHRcdCB5MCA9IHN0YXJ0WzFdO1xuXHRcdFx0XHRcdFx0XHQgeDEgPSBwb3NpdGlvbi54LWRpc1syXTtcblx0XHRcdFx0XHRcdFx0IHkxID0gaGFuZGxlcjFbMV07XG5cdFx0XHRcdFx0XHRcdCB4MiA9IHBvc2l0aW9uLngtZGlzWzRdO1xuXHRcdFx0XHRcdFx0XHQgeTIgPSBoYW5kbGVyMlsxXTtcblx0XHRcdFx0XHRcdFx0IHgzID0gcG9zaXRpb24ueC1kaXNbNl07XG5cdFx0XHRcdFx0XHRcdCB5MyA9IGVuZFsxXTtcblxuXHRcdFx0XHRcdFx0fSBcbiBcblxuXHRcdFx0XHRcdCAvL+WmguaenOWIm+W7uuaXtuS9jee9ruaVsOaNruS+nei1luS6juWIq+eahOWFg+e0oCDpgqPkuYjkuIDml6bmi5bliqjor6XlhYPntKAg5pWw5o2u55qE5L6d6LWW5YWz57O75bCx5Lya5pat5byAIOWIh+iusFxuXHRcdFx0XHRcdHRoaXMuc3RhcnQgPSBbeDAseTBdO1xuXHRcdFx0XHRcdHRoaXMuaGFuZGxlcjEgPSBbeDEseTFdO1xuXHRcdFx0XHRcdHRoaXMuaGFuZGxlcjIgPSBbeDIseTJdO1xuXHRcdFx0XHRcdHRoaXMuZW5kID0gW3gzLHkzXSBcblxuXG5cdFx0XHRcdFx0dGhpcy5oYW5kbGVyU2hvdyAmJiAodGhpcy5oYW5kbGVyT2JqMSAhPT0gbnVsbCkgJiYgdGhpcy5oYW5kbGVyT2JqMS5zZXRTdGFydChbeDEseTFdKTtcblx0XHRcdFx0XHR0aGlzLmhhbmRsZXJTaG93ICYmICh0aGlzLmhhbmRsZXJPYmoyICE9PSBudWxsKSAmJiB0aGlzLmhhbmRsZXJPYmoyLnNldFN0YXJ0KFt4Mix5Ml0pO1xuXG5cblxuXHRcdFx0fSxcblx0XHRcdGRyYXdBcnJvdzogZnVuY3Rpb24oZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSx0aGV0YSxoZWFkbGVuLHdpZHRoLGNvbG9yKSB7XG5cdFx0XHRcdCBcblx0XHRcdFx0ICAgIHZhciB0aGV0YSA9IHR5cGVvZih0aGV0YSkgIT0gJ3VuZGVmaW5lZCcgPyB0aGV0YSA6IDMwO1xuXHRcdFx0XHQgICAgdmFyIGhlYWRsZW4gPSB0eXBlb2YodGhldGEpICE9ICd1bmRlZmluZWQnID8gaGVhZGxlbiA6IDEwO1xuXHRcdFx0XHQgICAgdmFyIHdpZHRoID0gdHlwZW9mKHdpZHRoKSAhPSAndW5kZWZpbmVkJyA/IHdpZHRoIDogMTtcblx0XHRcdFx0ICAgIHZhciBjb2xvciA9IHR5cGVvZihjb2xvcikgIT0gJ2NvbG9yJyA/IGNvbG9yIDogJyMwMDAnO1xuXHRcdFx0XHQgXG5cdFx0XHRcdCAgICAvLyDorqHnrpflkITop5Lluqblkozlr7nlupTnmoRQMixQM+WdkOagh1xuXHRcdFx0XHQgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihmcm9tWSAtIHRvWSwgZnJvbVggLSB0b1gpICogMTgwIC8gTWF0aC5QSTtcblx0XHRcdFx0ICAgIHZhciBhbmdsZTEgPSAoYW5nbGUgKyB0aGV0YSkgKiBNYXRoLlBJIC8gMTgwO1xuXHRcdFx0XHQgICAgdmFyIGFuZ2xlMiA9IChhbmdsZSAtIHRoZXRhKSAqIE1hdGguUEkgLyAxODA7XG5cdFx0XHRcdCAgICB2YXIgdG9wWCA9IGhlYWRsZW4gKiBNYXRoLmNvcyhhbmdsZTEpO1xuXHRcdFx0XHQgICAgdmFyIHRvcFkgPSBoZWFkbGVuICogTWF0aC5zaW4oYW5nbGUxKTtcblx0XHRcdFx0ICAgIHZhciBib3RYID0gaGVhZGxlbiAqIE1hdGguY29zKGFuZ2xlMik7XG5cdFx0XHRcdCAgICB2YXIgYm90WSA9IGhlYWRsZW4gKiBNYXRoLnNpbihhbmdsZTIpO1xuXHRcdFx0XHQgXG5cdFx0XHRcdCAgICAvLyB0aGlzLnFjYW52YXMuY29udGV4dC5zYXZlKCk7XG5cdFx0XHRcdCAgICAvLyB0aGlzLnFjYW52YXMuY29udGV4dC5iZWdpblBhdGgoKTtcblx0XHRcdFx0IFxuXHRcdFx0XHQgICAgdmFyIGFycm93WCA9IGZyb21YIC0gdG9wWDtcblx0XHRcdFx0ICAgIHZhciBhcnJvd1kgPSBmcm9tWSAtIHRvcFk7XG5cdFx0XHRcdCBcdFx0Ly8gdGhpcy5xY2FudmFzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0XHRcdCAgXHQvLyBcdHRoaXMucWNhbnZhcy5jb250ZXh0LnNldExpbmVEYXNoKFtdKTsgXG5cblxuXHRcdFx0XHQgICAgYXJyb3dYID0gdG9YICsgdG9wWDtcblx0XHRcdFx0ICAgIGFycm93WSA9IHRvWSArIHRvcFk7XG5cdFx0XHRcdCAgICAvLyB0aGlzLnFjYW52YXMuY29udGV4dC5tb3ZlVG8oYXJyb3dYLCBhcnJvd1kpO1xuXHRcdFx0XHQgICAgLy8gdGhpcy5xY2FudmFzLmNvbnRleHQubGluZVRvKHRvWCwgdG9ZKTtcblx0XHRcdFx0ICAgIHZhciBhcnJvdzJYID0gdG9YICsgYm90WDtcblx0XHRcdFx0ICAgIHZhciBhcnJvdzJZID0gdG9ZICsgYm90WTtcblx0XHRcdFx0ICAgIC8vIHRoaXMucWNhbnZhcy5jb250ZXh0LmxpbmVUbyhhcnJvdzJYLCBhcnJvdzJZKTtcblx0XHRcdFx0ICAgIC8vIHRoaXMucWNhbnZhcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG5cdFx0XHRcdCAgICAvLyB0aGlzLnFjYW52YXMuY29udGV4dC5saW5lV2lkdGggPSB3aWR0aDtcblx0XHRcdFx0ICAgIC8vIHRoaXMucWNhbnZhcy5jb250ZXh0LnN0cm9rZSgpO1xuXG5cdFx0XHRcdCAgICBfdGhpcy5xY2FudmFzLnFsaW5lLnBhaW50TGluZSh7XG5cdFx0XHRcdFx0XHQgICAgXHRsaWtlOictJyxcblx0XHRcdFx0XHRcdFx0XHRzdGFydDpbYXJyb3dYLCBhcnJvd1ldLFxuXHRcdFx0XHRcdFx0XHRcdGVuZDpbdG9YLCB0b1ldLFxuXHRcdFx0XHRcdFx0XHRcdHdpZHRoOndpZHRoLFxuXHRcdFx0XHRcdFx0XHRcdGNvbG9yOmNvbG9yLFxuXHRcdFx0XHRcdFx0XHRcdHBvaW50ZXJFdmVudDonbm9uZSdcblxuXHRcdFx0XHQgICAgfSlcblxuXHRcdFx0XHQgICAgX3RoaXMucWNhbnZhcy5xbGluZS5wYWludExpbmUoe1xuXHRcdFx0XHRcdFx0ICAgIFx0bGlrZTonLScsXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQ6W3RvWCwgdG9ZXSxcblx0XHRcdFx0XHRcdFx0XHRlbmQ6W2Fycm93MlgsYXJyb3cyWV0sXG5cdFx0XHRcdFx0XHRcdFx0d2lkdGg6d2lkdGgsXG5cdFx0XHRcdFx0XHRcdFx0Y29sb3I6Y29sb3IsXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnRlckV2ZW50Oidub25lJ1xuXHRcdFx0XHQgICAgfSkgXG5cdFx0XHRcdH1cblx0fVxuXG5cdHRoaXMucWNhbnZhcy5leHRlbmQoT1BUSU9OUyxvcHRpb25zKTtcdFx0XG5cdHRoaXMucWNhbnZhcy5hcHBlbmRTZXRGdW4oT1BUSU9OUyk7XG5cblx0Ly/liIbnprvmloflrZdcblx0aWYodHlwZW9mIE9QVElPTlMud2l0aFRleHQgIT0ndW5kZWZpbmVkJyAmJiBPUFRJT05TLndpdGhUZXh0IT0nJyl7XG5cdFx0XG5cdFx0dGhpcy5zcGxpdFRleHQoT1BUSU9OUyk7XG5cdFx0XHRcblx0fVxuXHQvL+aYvuekuuaOp+WItueCuVxuXHRPUFRJT05TLmhhbmRsZXJTaG93ICYmIHRoaXMuZHJhd0hhbmRsZXIoT1BUSU9OUyk7XG5cdFxuXG5cdHJldHVybiBPUFRJT05TO1xufTtcblxuUWJlemllckN1cnZlLnByb3RvdHlwZS5kcmF3SGFuZGxlciA9IGZ1bmN0aW9uKG9iail7XG5cdHZhciBfdGhpcyA9IHRoaXM7XG5cdHZhciBoYW5kbGVyMSA9IF90aGlzLnFjYW52YXMuaXNGdW4ob2JqLmhhbmRsZXIxKT9vYmouaGFuZGxlcjEoKTpvYmouaGFuZGxlcjE7XG5cdHZhciBoYW5kbGVyMiA9IF90aGlzLnFjYW52YXMuaXNGdW4ob2JqLmhhbmRsZXIyKT9vYmouaGFuZGxlcjIoKTpvYmouaGFuZGxlcjI7XG5cdFxuXG5cblx0b2JqLmhhbmRsZXJPYmoxID0gdGhpcy5xY2FudmFzLnFhcmMuYXJjKHtcblx0XHRzdGFydDpoYW5kbGVyMSwgXG5cdFx0c0FuZ2xlOjAsXG5cdFx0ZUFuZ2xlOjM2MCxcblx0XHRmaWxsQ29sb3I6J2JsdWUnLFxuXHRcdG9wYWNpdHk6MC4yLFxuXHRcdHI6OCwgXG5cdFx0Ym9yZGVyQ29sb3I6JyNjY2MnLFxuXHRcdG1vdXNlbW92ZTpmdW5jdGlvbigpe1xuXHRcdFx0aWYoX3RoaXMucWNhbnZhcy5kcmFnQWltICE9PSBudWxsKXtcblx0XHRcdFx0b2JqLmhhbmRsZXIxID0gdGhpcy5zdGFydDtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1x0IFxuXG5cdG9iai5oYW5kbGVyT2JqMiA9IHRoaXMucWNhbnZhcy5xYXJjLmFyYyh7XG5cdFx0c3RhcnQ6aGFuZGxlcjIsIFxuXHRcdHNBbmdsZTowLFxuXHRcdGVBbmdsZTozNjAsXG5cdFx0ZmlsbENvbG9yOidibHVlJyxcblx0XHRvcGFjaXR5OjAuMixcblx0XHRyOjgsIFxuXHRcdGJvcmRlckNvbG9yOicjY2NjJyxcblx0XHRtb3VzZW1vdmU6ZnVuY3Rpb24oKXtcblx0XHRcdGlmKF90aGlzLnFjYW52YXMuZHJhZ0FpbSAhPT0gbnVsbCl7XG5cdFx0XHRcdG9iai5oYW5kbGVyMiA9IHRoaXMuc3RhcnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcdCBcblxuXG5cblxuXG59XG5RYmV6aWVyQ3VydmUucHJvdG90eXBlLnBhaW50QmV6aWVyQ3VydmUgPSBmdW5jdGlvbihvYmopIHtcblx0dGhpcy5xY2FudmFzLnFhbmltYXRpb24uY3JlYXRlQW5pbWF0aW9uKG9iaik7XG4gXG5cdHZhciBzdGFydCA9IHRoaXMucWNhbnZhcy5pc0Z1bihvYmouc3RhcnQpP29iai5zdGFydCgpOm9iai5zdGFydDtcblx0dmFyIGhhbmRsZXIxID0gdGhpcy5xY2FudmFzLmlzRnVuKG9iai5oYW5kbGVyMSk/b2JqLmhhbmRsZXIxKCk6b2JqLmhhbmRsZXIxO1xuXHR2YXIgaGFuZGxlcjIgPSB0aGlzLnFjYW52YXMuaXNGdW4ob2JqLmhhbmRsZXIyKT9vYmouaGFuZGxlcjIoKTpvYmouaGFuZGxlcjI7XG5cdHZhciBlbmQgPSB0aGlzLnFjYW52YXMuaXNGdW4ob2JqLmVuZCk/b2JqLmVuZCgpOm9iai5lbmQ7XG5cblx0dGhpcy5xY2FudmFzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSBvYmouY29sb3I7XG5cdHRoaXMucWNhbnZhcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuXHR0aGlzLnFjYW52YXMuY29udGV4dC5saW5lV2lkdGggPSBvYmoud2lkdGg7XG5cblx0c3dpdGNoKG9iai5saWtlKVxuXHR7XG5cdFx0Y2FzZSAnLSc6IFxuXHRcdFx0XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5tb3ZlVG8oc3RhcnRbMF0sc3RhcnRbMV0pOyBcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LmJlemllckN1cnZlVG8oaGFuZGxlcjFbMF0saGFuZGxlcjFbMV0saGFuZGxlcjJbMF0saGFuZGxlcjJbMV0sIGVuZFswXSxlbmRbMV0pO1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc3Ryb2tlKCk7XG5cdFx0XHRcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJy0tJzogXG5cblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnNldExpbmVEYXNoKFszXSk7XG5cblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0Lm1vdmVUbyhzdGFydFswXSxzdGFydFsxXSk7IFxuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuYmV6aWVyQ3VydmVUbyhoYW5kbGVyMVswXSxoYW5kbGVyMVsxXSxoYW5kbGVyMlswXSxoYW5kbGVyMlsxXSwgZW5kWzBdLGVuZFsxXSk7XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zdHJva2UoKTtcblxuXHRcdFx0Ly/lj6/og73ot6/lvoTmmK/omZrnur/lvaLlvI/nmoQg6K6+572u5oiQ5a6e57q/XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG5cbiBcblx0XHRcdGJyZWFrO1x0XG5cdFx0Y2FzZSAnLT4nOiBcblx0XHRcdFxuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQubW92ZVRvKHN0YXJ0WzBdLHN0YXJ0WzFdKTsgXG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5iZXppZXJDdXJ2ZVRvKGhhbmRsZXIxWzBdLGhhbmRsZXIxWzFdLGhhbmRsZXIyWzBdLGhhbmRsZXIyWzFdLCBlbmRbMF0sZW5kWzFdKTtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnN0cm9rZSgpO1xuXHRcdFx0IFxuXHRcdFx0Ly/lj6/og73ot6/lvoTmmK/omZrnur/lvaLlvI/nmoQg6K6+572u5oiQ5a6e57q/XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG5cblx0XHRcdG9iai5kcmF3QXJyb3coaGFuZGxlcjJbMF0sIGhhbmRsZXIyWzFdLCBlbmRbMF0sIGVuZFsxXSwzMCwxMCwxLG9iai5jb2xvcilcblx0XHRcdFxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnPC0nOiBcblx0XHRcdFxuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQubW92ZVRvKHN0YXJ0WzBdLHN0YXJ0WzFdKTsgXG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5iZXppZXJDdXJ2ZVRvKGhhbmRsZXIxWzBdLGhhbmRsZXIxWzFdLGhhbmRsZXIyWzBdLGhhbmRsZXIyWzFdLCBlbmRbMF0sZW5kWzFdKTtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnN0cm9rZSgpO1xuXHRcdFx0IFxuXHRcdFx0Ly/lj6/og73ot6/lvoTmmK/omZrnur/lvaLlvI/nmoQg6K6+572u5oiQ5a6e57q/XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG5cblx0XHRcdG9iai5kcmF3QXJyb3coaGFuZGxlcjFbMF0sIGhhbmRsZXIxWzFdLCBzdGFydFswXSwgc3RhcnRbMV0sMzAsMTAsMSxvYmouY29sb3IpXG5cdFx0XHRcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJzwtPic6IFxuXHRcdFx0XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5tb3ZlVG8oc3RhcnRbMF0sc3RhcnRbMV0pOyBcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LmJlemllckN1cnZlVG8oaGFuZGxlcjFbMF0saGFuZGxlcjFbMV0saGFuZGxlcjJbMF0saGFuZGxlcjJbMV0sIGVuZFswXSxlbmRbMV0pO1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc3Ryb2tlKCk7XG5cdFx0XHRcblxuXHRcdFx0Ly/lj6/og73ot6/lvoTmmK/omZrnur/lvaLlvI/nmoQg6K6+572u5oiQ5a6e57q/XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG5cblx0XHRcdG9iai5kcmF3QXJyb3coaGFuZGxlcjJbMF0sIGhhbmRsZXIyWzFdLCBlbmRbMF0sIGVuZFsxXSwzMCwxMCwxLG9iai5jb2xvcik7XG5cdFx0XHRvYmouZHJhd0Fycm93KGhhbmRsZXIxWzBdLCBoYW5kbGVyMVsxXSxzdGFydFswXSwgc3RhcnRbMV0sMzAsMTAsMSxvYmouY29sb3IpO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJy0tPic6IFxuXG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zZXRMaW5lRGFzaChbM10pO1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQubW92ZVRvKHN0YXJ0WzBdLHN0YXJ0WzFdKTsgXG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5iZXppZXJDdXJ2ZVRvKGhhbmRsZXIxWzBdLGhhbmRsZXIxWzFdLGhhbmRsZXIyWzBdLGhhbmRsZXIyWzFdLCBlbmRbMF0sZW5kWzFdKTtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnN0cm9rZSgpO1xuXG5cblx0XHRcdC8v5Y+v6IO96Lev5b6E5piv6Jma57q/5b2i5byP55qEIOiuvue9ruaIkOWunue6v1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc2V0TGluZURhc2goW10pO1xuXHRcdFx0XG5cdFx0XHRvYmouZHJhd0Fycm93KGhhbmRsZXIyWzBdLCBoYW5kbGVyMlsxXSwgZW5kWzBdLCBlbmRbMV0sMzAsMTAsMSxvYmouY29sb3IpO1xuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICc8LS0nOiBcblxuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc2V0TGluZURhc2goWzNdKTtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0Lm1vdmVUbyhzdGFydFswXSxzdGFydFsxXSk7IFxuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuYmV6aWVyQ3VydmVUbyhoYW5kbGVyMVswXSxoYW5kbGVyMVsxXSxoYW5kbGVyMlswXSxoYW5kbGVyMlsxXSwgZW5kWzBdLGVuZFsxXSk7XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zdHJva2UoKTtcblxuXG5cdFx0XHQvL+WPr+iDvei3r+W+hOaYr+iZmue6v+W9ouW8j+eahCDorr7nva7miJDlrp7nur9cblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdFxuXHRcdFx0b2JqLmRyYXdBcnJvdyhoYW5kbGVyMVswXSwgaGFuZGxlcjFbMV0sIHN0YXJ0WzBdLCBzdGFydFsxXSwzMCwxMCwxLG9iai5jb2xvcik7XG5cblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJzwtLT4nOiBcblxuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc2V0TGluZURhc2goWzNdKTtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0Lm1vdmVUbyhzdGFydFswXSxzdGFydFsxXSk7IFxuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuYmV6aWVyQ3VydmVUbyhoYW5kbGVyMVswXSxoYW5kbGVyMVsxXSxoYW5kbGVyMlswXSxoYW5kbGVyMlsxXSwgZW5kWzBdLGVuZFsxXSk7XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zdHJva2UoKTtcblxuXHRcdFx0Ly/lj6/og73ot6/lvoTmmK/omZrnur/lvaLlvI/nmoQg6K6+572u5oiQ5a6e57q/XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gXHRcdFx0XG5cdFx0XHRvYmouZHJhd0Fycm93KGhhbmRsZXIyWzBdLCBoYW5kbGVyMlsxXSwgZW5kWzBdLCBlbmRbMV0sMzAsMTAsMSxvYmouY29sb3IpO1xuXHRcdFx0b2JqLmRyYXdBcnJvdyhoYW5kbGVyMVswXSwgaGFuZGxlcjFbMV0sc3RhcnRbMF0sIHN0YXJ0WzFdLDMwLDEwLDEsb2JqLmNvbG9yKTtcblxuXHRcdFx0YnJlYWs7XG5cblx0fVxuXG5cblx0Ly/pnIDopoHlk43lupTkuovku7Zcblx0Ly/lvbHlrZDnlLvluIPkuIrpnIDopoHlho3nlLvkuIDku71cblx0aWYob2JqLnBvaW50ZXJFdmVudCA9PSAnYXV0bycpeyBcblx0XHR0aGlzLnFjYW52YXMuc2hhZG93Q29udGV4dC5zdHJva2VTdHlsZSA9IG9iai5zaGFkb3dGaWxsQ29sb3I7XG5cdFx0dGhpcy5xY2FudmFzLnNoYWRvd0NvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0dGhpcy5xY2FudmFzLnNoYWRvd0NvbnRleHQubGluZVdpZHRoID0gMjA7XG5cblx0XHRcblx0XHR0aGlzLnFjYW52YXMuc2hhZG93Q29udGV4dC5tb3ZlVG8oc3RhcnRbMF0sc3RhcnRbMV0pOyBcblx0XHR0aGlzLnFjYW52YXMuc2hhZG93Q29udGV4dC5iZXppZXJDdXJ2ZVRvKGhhbmRsZXIxWzBdLGhhbmRsZXIxWzFdLGhhbmRsZXIyWzBdLGhhbmRsZXIyWzFdLCBlbmRbMF0sZW5kWzFdKTtcblx0XHR0aGlzLnFjYW52YXMuc2hhZG93Q29udGV4dC5zdHJva2UoKTtcblx0fVxuXG5cbn07XG5cbi8v5YiG56a75pC65bim55qE5paH5a2XXHRcblFiZXppZXJDdXJ2ZS5wcm90b3R5cGUuc3BsaXRUZXh0ID0gZnVuY3Rpb24ob2JqKXtcblx0XG5cblx0dmFyIF90aGlzID0gdGhpcztcblx0dmFyIHRtcCA9IHRoaXMucWNhbnZhcy5xdGV4dC50ZXh0KHtcblx0XHRcdFRZUEU6J3RleHQnLFxuXHRcdFx0dGV4dDpvYmoud2l0aFRleHQsXG5cdFx0XHRjb2xvcjpvYmouY29sb3IsXG5cdFx0XHR3aXRoVGV4dEFsaWduOm9iai53aXRoVGV4dEFsaWduP29iai53aXRoVGV4dEFsaWduOidjZW50ZXInLFxuXHRcdFx0c3RhcnQ6ZnVuY3Rpb24oKXtyZXR1cm4gb2JqLmNlbnRlclBvaW50cygpfSxcblx0XHRcdHBvaW50ZXJFdmVudDonbm9uZSdcblx0fSk7XG5cdG9iai53aXRoVGV4dElkID0gdG1wLmlkO1xufVxuXG5cbi8q55S757q/57G7Ki9cdFxuZnVuY3Rpb24gUWxpbmUocWNhbnZhcyl7XG5cdHRoaXMucWxpbmVWZXJzaW9uID0gJzEuMCc7XG5cdHRoaXMucWNhbnZhcyA9IHFjYW52YXM7XG5cdC8vIGNvbnNvbGUubG9nKHRoaXMpO1xuXHRcblxuXHRcbn1cdFxuXG4vKlxu5Zub56eN5b2i5byP55qE57q/IFxu5Y+C5pWw5a+56LGhXG57XG5UWVBFOidsaW5lJyxcbnN0YXJ0OlswLDBdLCAgLy/lvIDlp4vlnZDmoIdcbmVuZDpbNTAsNTBdLCAgLy/nu5PmnZ/lnZDmoIdcbmNvbG9yOidyZWQnLCAgLy/popzoibJcbmxpa2U6Jy0nLCAgICAgLy/nlLvlh7rmnaXnmoTmoLflrZAgWy1dWy0+XVstLV1bLS0+XVxud2lkdGg6MSxcdFx0XHQvL+e6v+adoeWuveW6plxud2l0aFRleHQ6J3RleHQnLCAvL+W4puedgOeahOaWh+acrFxud2l0aFRleHRBbGlnbjonY2VudGVyJyAgLy/mlofmnKznmoTmqKrlkJHkvY3nva4gW2xlZnQgY2VudGVyKOm7mOiupCkgcmlnaHRdXG59XG4qL1xuUWxpbmUucHJvdG90eXBlLmxpbmUgPSBmdW5jdGlvbihvcHRpb25zKXtcblx0dmFyIF90aGlzID0gdGhpcztcblx0dmFyIE9QVElPTlMgPSB7XG5cdFx0VFlQRTonbGluZScsXG5cdFx0XG5cdFx0Y29sb3I6JyMwMDAnLCAgLy/popzoibJcblx0XHRsaWtlOictJywgICAgIC8v55S75Ye65p2l55qE5qC35a2QIFstXVstPl1bPC0+XVstLV1bLS0+XVs8LS0+XVxuXHRcdHdpZHRoOjEsXG5cdFx0c3RhcnQ6WzAsMF0sXG5cdFx0ZW5kOls1MCw1MF0sXG5cdFx0ZHJhZzp0cnVlLFxuXHRcdHBvaW50ZXJFdmVudDonYXV0bycsXG5cdFx0Ly93aXRoVGV4dDondGV4dCcsIC8v5bim552A55qE5paH5pysXG5cdFx0Ly93aXRoVGV4dEFsaWduOidjZW50ZXInICAvL+aWh+acrOeahOaoquWQkeS9jee9riBbbGVmdCBjZW50ZXIo6buY6K6kKSByaWdodF1cblx0XHRjZW50ZXJQb2ludHM6ZnVuY3Rpb24oKXsgLy/lhYPntKDkuK3lv4Pngrnnm7jlr7nkuo7mlbTkuKrnlLvluIPnmoTlnZDmoIdcblxuXHRcdFx0dmFyIHN0YXJ0ID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLnN0YXJ0KT90aGlzLnN0YXJ0KCk6dGhpcy5zdGFydDtcblx0XHRcdHZhciBlbmQgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuZW5kKT90aGlzLmVuZCgpOnRoaXMuZW5kO1xuIFxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDooc3RhcnRbMF0gPCBlbmRbMF0gPyBzdGFydFswXTplbmRbMF0pK01hdGguYWJzKHN0YXJ0WzBdLWVuZFswXSkgKiAwLjUsXG5cdFx0XHRcdHk6KHN0YXJ0WzFdIDwgZW5kWzFdID8gc3RhcnRbMV06ZW5kWzFdKStNYXRoLmFicyhzdGFydFsxXS1lbmRbMV0pICogMC41XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRwb2x5UG9pbnRzOmZ1bmN0aW9uKCl7ICAvL+mhtueCueWdkOagh+W6j+WIl1xuXHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuY2VudGVyUG9pbnRzKCk7XG5cblx0XHRcdHZhciBzdGFydCA9IF90aGlzLnFjYW52YXMuaXNGdW4odGhpcy5zdGFydCk/dGhpcy5zdGFydCgpOnRoaXMuc3RhcnQ7XG5cdFx0XHR2YXIgZW5kID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLmVuZCk/dGhpcy5lbmQoKTp0aGlzLmVuZDtcblxuXHRcdFx0Ly/kuLrlop7lpKfpgInljLog5oqK57q/55qE5LiK5LiL5ZCE5omp5bGVMTXkuKrlg4/ntKAgXG5cdFx0XHQvL+W5s+ihjOS6jnjovbTnmoTnur9cblx0XHRcdHZhciB0bXAsZGlzID0gMTU7XG5cdFx0XHRpZihzdGFydFsxXSA9PSBlbmRbMV0pe1xuXHRcdFx0XHR0bXAgPSBbXG5cdFx0XHRcdFx0e3g6c3RhcnRbMF0seTpzdGFydFsxXS1kaXN9LFxuXHRcdFx0XHRcdHt4OmVuZFswXSx5OmVuZFsxXS1kaXN9LFxuXHRcdFx0XHRcdHt4OmVuZFswXSx5OmVuZFsxXStkaXN9LFxuXHRcdFx0XHRcdHt4OnN0YXJ0WzBdLHk6c3RhcnRbMV0rZGlzfVxuXHRcdFx0XHRdXG5cdFx0XHR9XG5cdFx0XHQvL+W5s+ihjOS6jnnovbTnmoTnur9cblx0XHRcdGlmKHN0YXJ0WzBdID09IGVuZFswXSl7XG5cdFx0XHRcdHRtcCA9IFtcblx0XHRcdFx0XHR7eDpzdGFydFswXS1kaXMseTpzdGFydFsxXX0sXG5cdFx0XHRcdFx0e3g6c3RhcnRbMF0rZGlzLHk6c3RhcnRbMV19LFxuXHRcdFx0XHRcdHt4OmVuZFswXS1kaXMseTplbmRbMV19LFxuXHRcdFx0XHRcdHt4OmVuZFswXStkaXMseTplbmRbMV19XG5cdFx0XHRcdF1cblx0XHRcdH1cblxuXHRcdFx0XG5cdFx0XHR2YXIgQSxCO1xuXHRcdFx0dmFyIG9uZU9yVGhyZWUgPSBmYWxzZTtcblx0XHRcdHZhciB0d29PckZvdXIgPSBmYWxzZTtcblx0XHRcdC8vc3RhcnQtPmVuZCAo5LiAIOS4ieixoemZkClcblx0XHRcdC8vIEEtPkLku6XkuIvkuKTnp43mg4XlhrUgXG5cdFx0XHQvLyBkMS1kNOaYr+aJqeWxleaIkOefqeW9ouWQjueahOWbm+S4queCuVxuXHRcdFx0Ly8gICAgICAgZDEgQiBkMiAgICAgQVxuXHRcdFx0Ly8gICAgICAgICAvICAgIFx0L1xuXHRcdFx0Ly8gICAgICBAMS8gICDmiJYgQDIvICBcblx0XHRcdC8vICAgXHQgLyAgICAgICAgLyBcblx0XHRcdC8vICAgICAgL1x0ICAgICAvXG5cdFx0XHQvLyAgZDQgQSBkM1x0ICAgIEJcblx0XHRcdGlmKChzdGFydFswXTxlbmRbMF0pICYmIChzdGFydFsxXT5lbmRbMV0pKXtcblx0XHRcdFx0QSA9IHN0YXJ0O1xuXHRcdFx0XHRCID0gZW5kO1xuXHRcdFx0XHRvbmVPclRocmVlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmKChzdGFydFswXT5lbmRbMF0pICYmIChzdGFydFsxXTxlbmRbMV0pKXtcblx0XHRcdFx0QSA9IGVuZDtcblx0XHRcdFx0QiA9IHN0YXJ0O1xuXHRcdFx0XHRvbmVPclRocmVlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZihvbmVPclRocmVlKXtcblx0XHRcdFx0dG1wID0gX3RoaXMuZ2V0T25lT3JUaHJlZUNvb3JkKEEsQik7XG5cdFx0XHR9XG5cblx0XHRcdFxuXHRcdFx0Ly9zdGFydC0+ZW5kICjkuowg5Zub6LGh6ZmQKVxuXHRcdFx0Ly8gQS0+QuS7peS4i+S4pOenjeaDheWGtVxuXHRcdFx0Ly8gZTEtZTTmmK/mianlsZXmiJDnn6nlvaLlkI7nmoTlm5vkuKrngrlcblx0XHRcdC8vQiAgICAgZTEgQSBlMlxuXHRcdFx0Ly8gXFwgICAgICAgIFxcXG5cdFx0XHQvL0AxXFwg5oiWQDIgICBcXCAgIFxuXHRcdFx0Ly9cdCBcXCAgICAgICAgXFwgXG5cdFx0XHQvLyAgICBcXFx0ICAgICAgIFxcXG5cdFx0XHQvLyAgICBBXHRcdCBlNCBCIGUzXG5cdFx0XHRpZigoc3RhcnRbMF0gPCBlbmRbMF0pICYmIChzdGFydFsxXTxlbmRbMV0pKXtcblx0XHRcdFx0QSA9IHN0YXJ0O1xuXHRcdFx0XHRCID0gZW5kO1xuXHRcdFx0XHR0d29PckZvdXIgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZigoc3RhcnRbMF0+ZW5kWzBdKSAmJiAoc3RhcnRbMV0+ZW5kWzFdKSl7XG5cdFx0XHRcdEEgPSBlbmQ7XG5cdFx0XHRcdEIgPSBzdGFydDtcblx0XHRcdFx0dHdvT3JGb3VyID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYodHdvT3JGb3VyKXtcblx0XHRcdFx0dG1wID0gX3RoaXMuZ2V0VHdvT3JGb3VyQ29vcmQoQSxCKTtcblx0XHRcdH1cblxuXG5cdFx0XHRyZXR1cm4gdG1wO1xuXG5cdFx0fSxcblx0XHRkb3duRnVuOmZ1bmN0aW9uKGUscG9zaXRpb24pe1xuXHRcdFx0Ly/nur/nmoTmi5bliqjopoHnibnmrorlpITnkIYg6byg5qCH54K55Ye754K56Led57uT5p2f54K555qE6Led56a75Lmf5b6X6K6w5b2VXG5cdFx0XHR2YXIgc3RhcnQgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuc3RhcnQpP3RoaXMuc3RhcnQoKTp0aGlzLnN0YXJ0O1xuXHRcdCBcdHZhciBlbmQgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuZW5kKT90aGlzLmVuZCgpOnRoaXMuZW5kOyBcblx0XHRcdHRoaXMuZGlzID0gW3Bvc2l0aW9uLngtc3RhcnRbMF0scG9zaXRpb24ueS1zdGFydFsxXSxwb3NpdGlvbi54LWVuZFswXSxwb3NpdGlvbi55LWVuZFsxXV07XG5cdFx0fSxcblx0XHRtb3ZlRnVuOmZ1bmN0aW9uKGUscG9zaXRpb24peyAgLy/lvZPphY3nva5kcmFnZVJhbmdl5pe2ICDlvIDlp4vpmZDliLblnZDmoIdcblxuXG5cdFx0XHR2YXIgZHJhZ0lzQm9vbCA9IF90aGlzLnFjYW52YXMuaXNCb29sKHRoaXMuZHJhZyk7XG5cdFx0XHRcdFx0dmFyIGRpcyAgPXRoaXMuZGlzO1xuXHRcdFx0XHRcdHZhciBzdGFydCA9IF90aGlzLnFjYW52YXMuaXNGdW4odGhpcy5zdGFydCk/dGhpcy5zdGFydCgpOnRoaXMuc3RhcnQ7XG5cdFx0XHRcdCBcdHZhciBlbmQgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuZW5kKT90aGlzLmVuZCgpOnRoaXMuZW5kO1xuXG4gXHRcdFx0XHRcdFxuIFx0XHRcdFx0XHR2YXIgeDEseTEseDIseTI7XG5cdFx0XHRcdFx0XHQgXG5cdFx0XHRcdFx0XHRpZihkcmFnSXNCb29sICYmIHRoaXMuZHJhZyl7XG5cdFx0XHRcdFx0XHRcdCB4MSA9IHBvc2l0aW9uLngtZGlzWzBdO1xuXHRcdFx0XHRcdFx0XHQgeTEgPSBwb3NpdGlvbi55LWRpc1sxXTtcblxuXHRcdFx0XHRcdFx0XHQgeDIgPSBwb3NpdGlvbi54LWRpc1syXTtcblx0XHRcdFx0XHRcdFx0IHkyID0gcG9zaXRpb24ueS1kaXNbM107XG5cblx0XHRcdFx0XHRcdH1lbHNlIGlmKF90aGlzLnFjYW52YXMuZHJhZ0FpbS5kcmFnID09ICd2ZXJ0aWNhbCcpe1xuXHRcdFx0XHRcdFx0XHQgeDEgPSBzdGFydFswXTtcblx0XHRcdFx0XHRcdFx0IHkxID0gcG9zaXRpb24ueS1kaXNbMV07XG5cdFx0XHRcdFx0XHRcdCB4MiA9IGVuZFswXTtcblx0XHRcdFx0XHRcdFx0IHkyID0gcG9zaXRpb24ueS1kaXNbM107XG5cblxuXHRcdFx0XHRcdFx0fWVsc2UgaWYoX3RoaXMucWNhbnZhcy5kcmFnQWltLmRyYWcgPT0gJ2hvcml6b250YWwnKXtcblx0XHRcdFx0XHRcdFx0IHgxID0gcG9zaXRpb24ueC1kaXNbMF07XG5cdFx0XHRcdFx0XHRcdCB5MSA9IHN0YXJ0WzFdO1xuXHRcdFx0XHRcdFx0XHQgeDIgPSBwb3NpdGlvbi54LWRpc1syXTtcblx0XHRcdFx0XHRcdFx0IHkyID0gZW5kWzFdO1xuXG5cdFx0XHRcdFx0XHR9IFxuIFxuXG5cblx0XHRcdFx0XHQgLy/lpoLmnpzliJvlu7rml7bkvY3nva7mlbDmja7kvp3otZbkuo7liKvnmoTlhYPntKAg6YKj5LmI5LiA5pem5ouW5Yqo6K+l5YWD57SgIOaVsOaNrueahOS+nei1luWFs+ezu+WwseS8muaWreW8gCDliIforrBcblx0XHRcdFx0XHR0aGlzLnN0YXJ0ID0gW3gxLHkxXTtcblx0XHRcdFx0XHR0aGlzLmVuZCA9IFt4Mix5Ml0gXG5cblx0XHRcdH0sXG5cdFx0XHRkcmF3QXJyb3c6IGZ1bmN0aW9uKGZyb21YLCBmcm9tWSwgdG9YLCB0b1ksdGhldGEsaGVhZGxlbix3aWR0aCxjb2xvcikge1xuXHRcdFx0XHQgXG5cdFx0XHRcdCAgICB2YXIgdGhldGEgPSB0eXBlb2YodGhldGEpICE9ICd1bmRlZmluZWQnID8gdGhldGEgOiAzMDtcblx0XHRcdFx0ICAgIHZhciBoZWFkbGVuID0gdHlwZW9mKHRoZXRhKSAhPSAndW5kZWZpbmVkJyA/IGhlYWRsZW4gOiAxMDtcblx0XHRcdFx0ICAgIHZhciB3aWR0aCA9IHR5cGVvZih3aWR0aCkgIT0gJ3VuZGVmaW5lZCcgPyB3aWR0aCA6IDE7XG5cdFx0XHRcdCAgICB2YXIgY29sb3IgPSB0eXBlb2YoY29sb3IpICE9ICdjb2xvcicgPyBjb2xvciA6ICcjMDAwJztcblx0XHRcdFx0IFxuXHRcdFx0XHQgICAgLy8g6K6h566X5ZCE6KeS5bqm5ZKM5a+55bqU55qEUDIsUDPlnZDmoIdcblx0XHRcdFx0ICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZnJvbVkgLSB0b1ksIGZyb21YIC0gdG9YKSAqIDE4MCAvIE1hdGguUEk7XG5cdFx0XHRcdCAgICB2YXIgYW5nbGUxID0gKGFuZ2xlICsgdGhldGEpICogTWF0aC5QSSAvIDE4MDtcblx0XHRcdFx0ICAgIHZhciBhbmdsZTIgPSAoYW5nbGUgLSB0aGV0YSkgKiBNYXRoLlBJIC8gMTgwO1xuXHRcdFx0XHQgICAgdmFyIHRvcFggPSBoZWFkbGVuICogTWF0aC5jb3MoYW5nbGUxKTtcblx0XHRcdFx0ICAgIHZhciB0b3BZID0gaGVhZGxlbiAqIE1hdGguc2luKGFuZ2xlMSk7XG5cdFx0XHRcdCAgICB2YXIgYm90WCA9IGhlYWRsZW4gKiBNYXRoLmNvcyhhbmdsZTIpO1xuXHRcdFx0XHQgICAgdmFyIGJvdFkgPSBoZWFkbGVuICogTWF0aC5zaW4oYW5nbGUyKTtcblx0XHRcdFx0IFxuXHRcdFx0XHQgICAgLy8gdGhpcy5xY2FudmFzLmNvbnRleHQuc2F2ZSgpO1xuXHRcdFx0XHQgICAgLy8gdGhpcy5xY2FudmFzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0XHRcdCBcblx0XHRcdFx0ICAgIHZhciBhcnJvd1ggPSBmcm9tWCAtIHRvcFg7XG5cdFx0XHRcdCAgICB2YXIgYXJyb3dZID0gZnJvbVkgLSB0b3BZO1xuXHRcdFx0XHQgXHRcdC8vIHRoaXMucWNhbnZhcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHQgIFx0Ly8gXHR0aGlzLnFjYW52YXMuY29udGV4dC5zZXRMaW5lRGFzaChbXSk7IFxuXG5cblx0XHRcdFx0ICAgIGFycm93WCA9IHRvWCArIHRvcFg7XG5cdFx0XHRcdCAgICBhcnJvd1kgPSB0b1kgKyB0b3BZO1xuXHRcdFx0XHQgICAgLy8gdGhpcy5xY2FudmFzLmNvbnRleHQubW92ZVRvKGFycm93WCwgYXJyb3dZKTtcblx0XHRcdFx0ICAgIC8vIHRoaXMucWNhbnZhcy5jb250ZXh0LmxpbmVUbyh0b1gsIHRvWSk7XG5cdFx0XHRcdCAgICB2YXIgYXJyb3cyWCA9IHRvWCArIGJvdFg7XG5cdFx0XHRcdCAgICB2YXIgYXJyb3cyWSA9IHRvWSArIGJvdFk7XG5cdFx0XHRcdCAgICAvLyB0aGlzLnFjYW52YXMuY29udGV4dC5saW5lVG8oYXJyb3cyWCwgYXJyb3cyWSk7XG5cdFx0XHRcdCAgICAvLyB0aGlzLnFjYW52YXMuY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuXHRcdFx0XHQgICAgLy8gdGhpcy5xY2FudmFzLmNvbnRleHQubGluZVdpZHRoID0gd2lkdGg7XG5cdFx0XHRcdCAgICAvLyB0aGlzLnFjYW52YXMuY29udGV4dC5zdHJva2UoKTtcblxuXHRcdFx0XHQgICAgX3RoaXMucGFpbnRMaW5lKHtcblx0XHRcdFx0XHRcdCAgICBcdGxpa2U6Jy0nLFxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0OlthcnJvd1gsIGFycm93WV0sXG5cdFx0XHRcdFx0XHRcdFx0ZW5kOlt0b1gsIHRvWV0sXG5cdFx0XHRcdFx0XHRcdFx0d2lkdGg6d2lkdGgsXG5cdFx0XHRcdFx0XHRcdFx0Y29sb3I6Y29sb3IsXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnRlckV2ZW50Oidub25lJ1xuXG5cdFx0XHRcdCAgICB9KVxuXG5cdFx0XHRcdCAgICBfdGhpcy5wYWludExpbmUoe1xuXHRcdFx0XHRcdFx0ICAgIFx0bGlrZTonLScsXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQ6W3RvWCwgdG9ZXSxcblx0XHRcdFx0XHRcdFx0XHRlbmQ6W2Fycm93MlgsYXJyb3cyWV0sXG5cdFx0XHRcdFx0XHRcdFx0d2lkdGg6d2lkdGgsXG5cdFx0XHRcdFx0XHRcdFx0Y29sb3I6Y29sb3IsXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnRlckV2ZW50Oidub25lJ1xuXHRcdFx0XHQgICAgfSlcblxuXHRcdFx0XHQgIC8vICAgcmV0dXJuIFtcblx0XHRcdFx0ICAvLyAgIFx0e1xuXHRcdFx0XHRcdFx0Ly8gXHRcdGxpa2U6Jy0nLFxuXHRcdFx0XHRcdFx0Ly8gXHRcdHN0YXJ0OlthcnJvd1gsIGFycm93WV0sXG5cdFx0XHRcdFx0XHQvLyBcdFx0ZW5kOlt0b1gsIHRvWV1cblx0XHRcdFx0XHRcdC8vIH0sXG5cdFx0XHRcdFx0XHQvLyB7XG5cdFx0XHRcdFx0XHQvLyBcdFx0bGlrZTonLScsXG5cdFx0XHRcdFx0XHQvLyBcdFx0c3RhcnQ6W3RvWCwgdG9ZXSxcblx0XHRcdFx0XHRcdC8vIFx0XHRlbmQ6W2Fycm93MlgsYXJyb3cyWV1cblx0XHRcdFx0XHRcdC8vIH0sXHRcblx0XHRcdFx0ICAvLyAgIF1cblxuXG5cdFx0XHRcdCAgIC8vICBcdGFuZ2xlID0gbnVsbDtcblx0XHRcdFx0ICAgLy8gICAgICBhbmdsZTEgPSAgbnVsbDtcblx0XHRcdFx0ICAgLy8gICAgICBhbmdsZTIgPSAgbnVsbDtcblx0XHRcdFx0ICAgLy8gICAgICB0b3BYID0gIG51bGw7XG5cdFx0XHRcdCAgIC8vICAgICAgdG9wWSA9ICBudWxsO1xuXHRcdFx0XHQgICAvLyAgICAgIGJvdFggPSAgbnVsbDtcblx0XHRcdFx0ICAgLy8gICAgICBib3RZID0gIG51bGw7XG5cdFx0XHRcdCAgIC8vICAgICAgYXJyb3dYID0gbnVsbDtcblx0XHRcdFx0ICAgLy8gICAgICBhcnJvd1kgPSBudWxsO1xuXG5cdFx0XHRcdCAgIC8vICB0aGV0YSA9IG51bGw7XG5cdFx0XHRcdCAgIC8vICBoZWFkbGVuID0gbnVsbFxuXHRcdFx0XHQgICAvLyAgd2lkdGggPSBudWxsO1xuXHRcdFx0XHQgICAvLyAgY29sb3IgPSBudWxsO1xuXHRcdFx0XHR9XG5cdH1cblx0XG5cdFxuXHRcdFx0XG5cdFx0XHRcdFx0XHRcblx0dGhpcy5xY2FudmFzLmV4dGVuZChPUFRJT05TLG9wdGlvbnMpO1x0XHRcblx0dGhpcy5xY2FudmFzLmFwcGVuZFNldEZ1bihPUFRJT05TKTtcblx0XG5cdC8v5YiG56a75paH5a2XXG5cdGlmKHR5cGVvZiBPUFRJT05TLndpdGhUZXh0ICE9J3VuZGVmaW5lZCcgJiYgT1BUSU9OUy53aXRoVGV4dCE9Jycpe1xuXHRcdFxuXHRcdHRoaXMuc3BsaXRUZXh0KE9QVElPTlMpO1xuXHRcdFx0XG5cdH1cblx0XG5cdHJldHVybiBPUFRJT05TO1xufVxuLyoqXG4gKiDlj5blvpfmianlsZXlkI7nmoTlm5vkuKrngrkgKOS4gCDkuInosaHpmZApXG4gKiBAcGFyYW0gIHtbdHlwZV19IEEgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7W3R5cGVdfSBCIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge1t0eXBlXX0gICBbZGVzY3JpcHRpb25dXG4gKi9cblFsaW5lLnByb3RvdHlwZS5nZXRPbmVPclRocmVlQ29vcmQgPSBmdW5jdGlvbihBLEIpIHtcblx0dmFyIGRpcyA9IDE1O1xuXHR2YXIgbCA9IE1hdGguc3FydChNYXRoLnBvdyhNYXRoLmFicyhBWzBdLUJbMF0pLDIpK01hdGgucG93KE1hdGguYWJzKEFbMV0tQlsxXSksMikpO1xuXHR2YXIgc2luQSA9IE1hdGguYWJzKEFbMV0tQlsxXSkvbDtcblx0dmFyIGggPSBkaXMqc2luQTtcblxuXHRyZXR1cm4gW1xuXHRcdHt4OkJbMF0tTWF0aC5zcXJ0KE1hdGgucG93KGRpcywyKStNYXRoLnBvdyhoLDIpKSx5OkJbMV0taH0sXG5cdFx0e3g6QlswXStoLHk6TWF0aC5zcXJ0KE1hdGgucG93KGRpcywyKS1NYXRoLnBvdyhoLDIpKStCWzFdfSxcblx0XHR7eDpBWzBdK2gseTpBWzFdK01hdGguc3FydChNYXRoLnBvdyhkaXMsMiktTWF0aC5wb3coaCwyKSl9LFxuXHRcdHt4OkFbMF0taCx5OkFbMV0tTWF0aC5zcXJ0KE1hdGgucG93KGRpcywyKS1NYXRoLnBvdyhoLDIpKX0sXG5cblx0XVxuXG59O1xuLyoqXG4gKiDlj5blvpfmianlsZXlkI7nmoTlm5vkuKrngrkgKOS6jCDlm5vosaHpmZApXG4gKiBAcGFyYW0gIHtbdHlwZV19IEEgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7W3R5cGVdfSBCIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge1t0eXBlXX0gICBbZGVzY3JpcHRpb25dXG4gKi9cblFsaW5lLnByb3RvdHlwZS5nZXRUd29PckZvdXJDb29yZCA9IGZ1bmN0aW9uKEEsQikge1xuXHR2YXIgZGlzID0gMTU7XG5cdHZhciBsID0gTWF0aC5zcXJ0KE1hdGgucG93KE1hdGguYWJzKEFbMF0tQlswXSksMikrTWF0aC5wb3coTWF0aC5hYnMoQVsxXS1CWzFdKSwyKSk7XG5cdHZhciBzaW5BID0gTWF0aC5hYnMoQVsxXS1CWzFdKS9sO1xuXHR2YXIgaCA9IGRpcypzaW5BO1xuXG5cdHJldHVybiBbXG5cdFx0e3g6QVswXS1oLHk6QVsxXStNYXRoLnNxcnQoTWF0aC5wb3coZGlzLDIpLU1hdGgucG93KGgsMikpfSxcblx0XHR7eDpBWzBdK2gseTpBWzFdLU1hdGguc3FydChNYXRoLnBvdyhkaXMsMiktTWF0aC5wb3coaCwyKSl9LFxuXHRcdHt4OkJbMF0raCx5OkJbMV0tTWF0aC5zcXJ0KE1hdGgucG93KGRpcywyKS1NYXRoLnBvdyhoLDIpKX0sXG5cdFx0e3g6QlswXS1NYXRoLnNxcnQoTWF0aC5wb3coZGlzLDIpLU1hdGgucG93KGgsMikpLHk6QlsxXStofSxcblxuXHRdXG5cbn07XG5cblxuXG5RbGluZS5wcm90b3R5cGUuZ2V0TWlkZGxlQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbihvYmope1xuXG5cdHZhciBzdGFydCA9IHRoaXMucWNhbnZhcy5pc0Z1bihvYmouc3RhcnQpP29iai5zdGFydCgpOm9iai5zdGFydDtcblx0dmFyIGVuZCA9IHRoaXMucWNhbnZhcy5pc0Z1bihvYmouZW5kKT9vYmouZW5kKCk6b2JqLmVuZDtcblxuXHRyZXR1cm4gW1xuXHRcdChzdGFydFswXSA8IGVuZFswXSA/IHN0YXJ0WzBdOmVuZFswXSkrTWF0aC5hYnMoc3RhcnRbMF0tZW5kWzBdKSAqIDAuNSxcblx0XHQoc3RhcnRbMV0gPCBlbmRbMV0gPyBzdGFydFsxXTplbmRbMV0pK01hdGguYWJzKHN0YXJ0WzFdLWVuZFsxXSkgKiAwLjUsXG5cdF07XG5cdFxufVxuXHRcdFxuLy/liIbnprvmkLrluKbnmoTmloflrZdcdFxuUWxpbmUucHJvdG90eXBlLnNwbGl0VGV4dCA9IGZ1bmN0aW9uKG9iail7XG5cdFxuXG5cdHZhciBfdGhpcyA9IHRoaXM7XG5cdHZhciB0bXAgPSB0aGlzLnFjYW52YXMucXRleHQudGV4dCh7XG5cdFx0XHRUWVBFOid0ZXh0Jyxcblx0XHRcdHRleHQ6b2JqLndpdGhUZXh0LFxuXHRcdFx0Y29sb3I6b2JqLmNvbG9yLFxuXHRcdFx0d2l0aFRleHRBbGlnbjpvYmoud2l0aFRleHRBbGlnbj9vYmoud2l0aFRleHRBbGlnbjonY2VudGVyJyxcblx0XHRcdHN0YXJ0OmZ1bmN0aW9uKCl7cmV0dXJuIF90aGlzLmdldE1pZGRsZUNvb3JkaW5hdGVzLmNhbGwoX3RoaXMsb2JqKX0sXG5cdFx0XHRwb2ludGVyRXZlbnQ6J25vbmUnXG5cdH0pO1xuXHRvYmoud2l0aFRleHRJZCA9IHRtcC5pZDtcbn1cdFxuXHRcblFsaW5lLnByb3RvdHlwZS5wYWludExpbmUgID0gZnVuY3Rpb24ob2JqKXtcblx0dGhpcy5xY2FudmFzLnFhbmltYXRpb24uY3JlYXRlQW5pbWF0aW9uKG9iaik7XG5cblx0dmFyIHN0YXJ0ID0gdGhpcy5xY2FudmFzLmlzRnVuKG9iai5zdGFydCk/b2JqLnN0YXJ0KCk6b2JqLnN0YXJ0O1xuXHR2YXIgZW5kID0gdGhpcy5xY2FudmFzLmlzRnVuKG9iai5lbmQpP29iai5lbmQoKTpvYmouZW5kO1xuXG5cblx0dGhpcy5xY2FudmFzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSBvYmouY29sb3I7XG5cdHRoaXMucWNhbnZhcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuXHR0aGlzLnFjYW52YXMuY29udGV4dC5saW5lV2lkdGg9b2JqLndpZHRoO1xuXG5cdHN3aXRjaChvYmoubGlrZSlcblx0e1xuXHRcdGNhc2UgJy0nOlxuXHRcdFx0Ly9pZihvYmoubGlrZSA9PSAnLS0nKXtcblx0XHRcdC8vXHR0aGlzLnFjYW52YXMuY29udGV4dC5zZXRMaW5lRGFzaChbMiwgNF0pO1xuXHRcdFx0Ly99XG5cdFx0XHRcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0Lm1vdmVUbyhzdGFydFswXSxzdGFydFsxXSk7XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5saW5lVG8oZW5kWzBdLGVuZFsxXSk7XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zdHJva2UoKTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJy0tJzogXG5cblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnNldExpbmVEYXNoKFszXSk7XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5tb3ZlVG8oc3RhcnRbMF0sc3RhcnRbMV0pO1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQubGluZVRvKGVuZFswXSxlbmRbMV0pO1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc3Ryb2tlKCk7XG5cblx0XHRcdC8v5Y+v6IO96Lev5b6E5piv6Jma57q/5b2i5byP55qEIOiuvue9ruaIkOWunue6v1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc2V0TGluZURhc2goW10pO1xuIFxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnLT4nOiBcblx0XHRcdFxuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQubW92ZVRvKHN0YXJ0WzBdLHN0YXJ0WzFdKTtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LmxpbmVUbyhlbmRbMF0sZW5kWzFdKTtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnN0cm9rZSgpO1xuXHRcdFx0IFxuXHRcdFx0Ly/lj6/og73ot6/lvoTmmK/omZrnur/lvaLlvI/nmoQg6K6+572u5oiQ5a6e57q/XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG5cblx0XHRcdG9iai5kcmF3QXJyb3coc3RhcnRbMF0sIHN0YXJ0WzFdLCBlbmRbMF0sIGVuZFsxXSwzMCwxMCwxLG9iai5jb2xvcilcblx0XHRcdFxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnPC0nOiBcblx0XHRcdFxuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQubW92ZVRvKHN0YXJ0WzBdLHN0YXJ0WzFdKTtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LmxpbmVUbyhlbmRbMF0sZW5kWzFdKTtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnN0cm9rZSgpO1xuXHRcdFx0IFxuXHRcdFx0Ly/lj6/og73ot6/lvoTmmK/omZrnur/lvaLlvI/nmoQg6K6+572u5oiQ5a6e57q/XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG5cblx0XHRcdG9iai5kcmF3QXJyb3coZW5kWzBdLCBlbmRbMV0sc3RhcnRbMF0sIHN0YXJ0WzFdLDMwLDEwLDEsb2JqLmNvbG9yKVxuXHRcdFx0XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICc8LT4nOiBcblx0XHRcdFxuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQubW92ZVRvKHN0YXJ0WzBdLHN0YXJ0WzFdKTtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LmxpbmVUbyhlbmRbMF0sZW5kWzFdKTtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnN0cm9rZSgpO1xuXHRcdFx0IFxuXHRcdFx0Ly/lj6/og73ot6/lvoTmmK/omZrnur/lvaLlvI/nmoQg6K6+572u5oiQ5a6e57q/XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG5cblx0XHRcdG9iai5kcmF3QXJyb3coc3RhcnRbMF0sIHN0YXJ0WzFdLCBlbmRbMF0sIGVuZFsxXSwzMCwxMCwxLG9iai5jb2xvcik7XG5cdFx0XHRvYmouZHJhd0Fycm93KGVuZFswXSwgZW5kWzFdLHN0YXJ0WzBdLCBzdGFydFsxXSwzMCwxMCwxLG9iai5jb2xvcik7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0YnJlYWs7XHRcblx0XHRjYXNlICctLT4nOiBcblxuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc2V0TGluZURhc2goWzNdKTtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0Lm1vdmVUbyhzdGFydFswXSxzdGFydFsxXSk7XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5saW5lVG8oZW5kWzBdLGVuZFsxXSk7XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zdHJva2UoKTtcbiBcdFx0XHRcbiBcdFx0XHQvL+WPr+iDvei3r+W+hOaYr+iZmue6v+W9ouW8j+eahCDorr7nva7miJDlrp7nur9cblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnNldExpbmVEYXNoKFtdKTtcblxuXHRcdFx0b2JqLmRyYXdBcnJvdyhzdGFydFswXSwgc3RhcnRbMV0sIGVuZFswXSwgZW5kWzFdLDMwLDEwLDEsb2JqLmNvbG9yKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJzwtLSc6IFxuXG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zZXRMaW5lRGFzaChbM10pO1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQubW92ZVRvKHN0YXJ0WzBdLHN0YXJ0WzFdKTtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LmxpbmVUbyhlbmRbMF0sZW5kWzFdKTtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnN0cm9rZSgpO1xuIFx0XHRcdFxuIFx0XHRcdC8v5Y+v6IO96Lev5b6E5piv6Jma57q/5b2i5byP55qEIOiuvue9ruaIkOWunue6v1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc2V0TGluZURhc2goW10pO1xuXG5cdFx0XHRvYmouZHJhd0Fycm93KCBlbmRbMF0sIGVuZFsxXSxzdGFydFswXSwgc3RhcnRbMV0sMzAsMTAsMSxvYmouY29sb3IpO1xuXHRcdFx0YnJlYWs7XHRcblx0XHRjYXNlICc8LS0+JzogXG5cblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnNldExpbmVEYXNoKFszXSk7XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5tb3ZlVG8oc3RhcnRbMF0sc3RhcnRbMV0pO1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQubGluZVRvKGVuZFswXSxlbmRbMV0pO1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc3Ryb2tlKCk7XG5cblx0XHRcdC8v5Y+v6IO96Lev5b6E5piv6Jma57q/5b2i5byP55qEIOiuvue9ruaIkOWunue6v1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc2V0TGluZURhc2goW10pO1xuXHRcdFx0IFxuXHRcdFx0b2JqLmRyYXdBcnJvdyhzdGFydFswXSwgc3RhcnRbMV0sIGVuZFswXSwgZW5kWzFdLDMwLDEwLDEsb2JqLmNvbG9yKTtcblx0XHRcdG9iai5kcmF3QXJyb3coZW5kWzBdLCBlbmRbMV0sc3RhcnRbMF0sIHN0YXJ0WzFdLDMwLDEwLDEsb2JqLmNvbG9yKTtcblxuXHRcdFx0YnJlYWs7XG5cdH1cblxuXHRcdFxuXHRcbn1cdFxuXG5cbi8qKlxuICog55S7566t5aS055qE5Lik5p2h5a6e57q/XG4gKiBAcGFyYW0gIHtbdHlwZV19IGZyb21YICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7W3R5cGVdfSBmcm9tWSAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge1t0eXBlXX0gdG9YICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtbdHlwZV19IHRvWSAgICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7W3R5cGVdfSB0aGV0YSAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge1t0eXBlXX0gaGVhZGxlbiBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtbdHlwZV19IHdpZHRoICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7W3R5cGVdfSBjb2xvciAgIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cblFsaW5lLnByb3RvdHlwZS5kcmF3QXJyb3cgPSBmdW5jdGlvbihmcm9tWCwgZnJvbVksIHRvWCwgdG9ZLHRoZXRhLGhlYWRsZW4sd2lkdGgsY29sb3IpIHtcbiBcbiAgICB2YXIgdGhldGEgPSB0eXBlb2YodGhldGEpICE9ICd1bmRlZmluZWQnID8gdGhldGEgOiAzMDtcbiAgICB2YXIgaGVhZGxlbiA9IHR5cGVvZih0aGV0YSkgIT0gJ3VuZGVmaW5lZCcgPyBoZWFkbGVuIDogMTA7XG4gICAgdmFyIHdpZHRoID0gdHlwZW9mKHdpZHRoKSAhPSAndW5kZWZpbmVkJyA/IHdpZHRoIDogMTtcbiAgICB2YXIgY29sb3IgPSB0eXBlb2YoY29sb3IpICE9ICdjb2xvcicgPyBjb2xvciA6ICcjMDAwJztcbiBcbiAgICAvLyDorqHnrpflkITop5Lluqblkozlr7nlupTnmoRQMixQM+WdkOagh1xuICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZnJvbVkgLSB0b1ksIGZyb21YIC0gdG9YKSAqIDE4MCAvIE1hdGguUEk7XG4gICAgdmFyIGFuZ2xlMSA9IChhbmdsZSArIHRoZXRhKSAqIE1hdGguUEkgLyAxODA7XG4gICAgdmFyIGFuZ2xlMiA9IChhbmdsZSAtIHRoZXRhKSAqIE1hdGguUEkgLyAxODA7XG4gICAgdmFyIHRvcFggPSBoZWFkbGVuICogTWF0aC5jb3MoYW5nbGUxKTtcbiAgICB2YXIgdG9wWSA9IGhlYWRsZW4gKiBNYXRoLnNpbihhbmdsZTEpO1xuICAgIHZhciBib3RYID0gaGVhZGxlbiAqIE1hdGguY29zKGFuZ2xlMik7XG4gICAgdmFyIGJvdFkgPSBoZWFkbGVuICogTWF0aC5zaW4oYW5nbGUyKTtcbiBcbiAgICAvLyB0aGlzLnFjYW52YXMuY29udGV4dC5zYXZlKCk7XG4gICAgLy8gdGhpcy5xY2FudmFzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gXG4gICAgdmFyIGFycm93WCA9IGZyb21YIC0gdG9wWDtcbiAgICB2YXIgYXJyb3dZID0gZnJvbVkgLSB0b3BZO1xuIFx0XHQvLyB0aGlzLnFjYW52YXMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgXHQvLyBcdHRoaXMucWNhbnZhcy5jb250ZXh0LnNldExpbmVEYXNoKFtdKTsgXG5cblxuICAgIGFycm93WCA9IHRvWCArIHRvcFg7XG4gICAgYXJyb3dZID0gdG9ZICsgdG9wWTtcbiAgICAvLyB0aGlzLnFjYW52YXMuY29udGV4dC5tb3ZlVG8oYXJyb3dYLCBhcnJvd1kpO1xuICAgIC8vIHRoaXMucWNhbnZhcy5jb250ZXh0LmxpbmVUbyh0b1gsIHRvWSk7XG4gICAgdmFyIGFycm93MlggPSB0b1ggKyBib3RYO1xuICAgIHZhciBhcnJvdzJZID0gdG9ZICsgYm90WTtcbiAgICAvLyB0aGlzLnFjYW52YXMuY29udGV4dC5saW5lVG8oYXJyb3cyWCwgYXJyb3cyWSk7XG4gICAgLy8gdGhpcy5xY2FudmFzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAvLyB0aGlzLnFjYW52YXMuY29udGV4dC5saW5lV2lkdGggPSB3aWR0aDtcbiAgICAvLyB0aGlzLnFjYW52YXMuY29udGV4dC5zdHJva2UoKTtcblxuICAgIHRoaXMucGFpbnRMaW5lKHtcblx0XHQgICAgXHRsaWtlOictJyxcblx0XHRcdFx0c3RhcnQ6W2Fycm93WCwgYXJyb3dZXSxcblx0XHRcdFx0ZW5kOlt0b1gsIHRvWV1cbiAgICB9KVxuXG4gICAgdGhpcy5wYWludExpbmUoe1xuICAgIFx0bGlrZTonLScsXG5cdFx0XHRcdHN0YXJ0Olt0b1gsIHRvWV0sXG5cdFx0XHRcdGVuZDpbYXJyb3cyWCxhcnJvdzJZXVxuICAgIH0pXG5cbiAgLy8gICByZXR1cm4gW1xuICAvLyAgIFx0e1xuXHRcdC8vIFx0XHRsaWtlOictJyxcblx0XHQvLyBcdFx0c3RhcnQ6W2Fycm93WCwgYXJyb3dZXSxcblx0XHQvLyBcdFx0ZW5kOlt0b1gsIHRvWV1cblx0XHQvLyB9LFxuXHRcdC8vIHtcblx0XHQvLyBcdFx0bGlrZTonLScsXG5cdFx0Ly8gXHRcdHN0YXJ0Olt0b1gsIHRvWV0sXG5cdFx0Ly8gXHRcdGVuZDpbYXJyb3cyWCxhcnJvdzJZXVxuXHRcdC8vIH0sXHRcbiAgLy8gICBdXG5cblxuICAgLy8gIFx0YW5nbGUgPSBudWxsO1xuICAgLy8gICAgICBhbmdsZTEgPSAgbnVsbDtcbiAgIC8vICAgICAgYW5nbGUyID0gIG51bGw7XG4gICAvLyAgICAgIHRvcFggPSAgbnVsbDtcbiAgIC8vICAgICAgdG9wWSA9ICBudWxsO1xuICAgLy8gICAgICBib3RYID0gIG51bGw7XG4gICAvLyAgICAgIGJvdFkgPSAgbnVsbDtcbiAgIC8vICAgICAgYXJyb3dYID0gbnVsbDtcbiAgIC8vICAgICAgYXJyb3dZID0gbnVsbDtcblxuICAgLy8gIHRoZXRhID0gbnVsbDtcbiAgIC8vICBoZWFkbGVuID0gbnVsbFxuICAgLy8gIHdpZHRoID0gbnVsbDtcbiAgIC8vICBjb2xvciA9IG51bGw7XG59XG5cblxuXG4vL+mZhOWKoOeureWktOWvueixoSAo5LiN55So6L+Z5Liq5LqGKVxuUWxpbmUucHJvdG90eXBlLmFwcGVuZEFycm93ID0gZnVuY3Rpb24ob2JqKXtcblxuXHR2YXIgc3RhcnQgPSB0aGlzLnFjYW52YXMuaXNGdW4ob2JqLnN0YXJ0KT9vYmouc3RhcnQoKTpvYmouc3RhcnQ7XG5cdHZhciBlbmQgPSB0aGlzLnFjYW52YXMuaXNGdW4ob2JqLmVuZCk/b2JqLmVuZCgpOm9iai5lbmQ7XG5cblx0XHRcdFx0YXJyb3dPYmogPSB0aGlzLl9jYWxjSCh7XG5cdFx0XHRcdFxuXHRcdFx0XHR9LHtcblx0XHRcdFx0XHQneCc6c3RhcnRbMF0sXG5cdFx0XHRcdFx0J3knOnN0YXJ0WzFdLFxuXHRcdFx0XHR9LHtcblx0XHRcdFx0XHQneCc6ZW5kWzBdLFxuXHRcdFx0XHRcdCd5JzplbmRbMV0sXG5cdFx0XHRcdH0pO1xuXHRcblx0XHRcdG9iai5hcnJvdyA9IFtcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlrZTonLScsXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydDpbYXJyb3dPYmouaDEueCxhcnJvd09iai5oMS55XSxcblx0XHRcdFx0XHRcdFx0XHRcdGVuZDpbZW5kWzBdLGVuZFsxXV1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlrZTonLScsXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydDpbYXJyb3dPYmouaDIueCxhcnJvd09iai5oMi55XSxcblx0XHRcdFx0XHRcdFx0XHRcdGVuZDpbZW5kWzBdLGVuZFsxXV1cblx0XHRcdFx0XHRcdFx0fSxcdFxuXHRcdFx0XHRcdF1cbn1cdFxuXHRcblx0XG7CoC8v6K6h566X5aS06YOo5Z2Q5qCHXG5RbGluZS5wcm90b3R5cGUuX2NhbGNIPWZ1bmN0aW9uKGEsc3AsZXApe1xuXHQgdmFyIHRoZXRhPU1hdGguYXRhbigoZXAueC1zcC54KS8oZXAueS1zcC55KSk7XG5cdCB2YXIgY2VwPXRoaXMuX3Njcm9sbFhPWShlcCwtdGhldGEpO1xuXHQgdmFyIGNzcD10aGlzLl9zY3JvbGxYT1koc3AsLXRoZXRhKTtcblx0IHZhciBjaDE9e3g6MCx5OjB9O1xuXHQgdmFyIGNoMj17eDowLHk6MH07XG5cdCB2YXIgbD1jZXAueS1jc3AueTtcblx0IGNoMS54PWNlcC54K2wqKGEuc2hhcnB8fDAuMDI1KTtcblx0IGNoMS55PWNlcC55LWwqKGEuc2l6ZXx8MC4wNSk7XG5cdCBjaDIueD1jZXAueC1sKihhLnNoYXJwfHwwLjAyNSk7XG5cdCBjaDIueT1jZXAueS1sKihhLnNpemV8fDAuMDUpO1xuXHQgdmFyIGgxPXRoaXMuX3Njcm9sbFhPWShjaDEsdGhldGEpO1xuXHQgdmFyIGgyPXRoaXMuX3Njcm9sbFhPWShjaDIsdGhldGEpO1xuXHQgcmV0dXJuIHtcblx0XHRoMTpoMSxcblx0XHRoMjpoMlxuXHRcdH07XG7CoH07XG7CoC8v5peL6L2s5Z2Q5qCHXG5RbGluZS5wcm90b3R5cGUuX3Njcm9sbFhPWT1mdW5jdGlvbihwLHRoZXRhKXtcblx0IHJldHVybiB7XG5cdFx0eDpwLngqTWF0aC5jb3ModGhldGEpK3AueSpNYXRoLnNpbih0aGV0YSksXG5cdFx0eTpwLnkqTWF0aC5jb3ModGhldGEpLXAueCpNYXRoLnNpbih0aGV0YSlcblx0IH07XG7CoH07XG5cdFxuXHRcblxuUWxpbmUucHJvdG90eXBlLmdldEJldmVsaW5nID0gZnVuY3Rpb24oeCx5KXsgIFxuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeCwyKStNYXRoLnBvdyh5LDIpKTsgIFxufSAgXHRcblxuXG4vL+i1t+atoueCueaYr+WQpuacieWPmOWMllx0XG5RbGluZS5wcm90b3R5cGUubGluZUlzQ2hhbmdlID0gZnVuY3Rpb24ob2JqKXtcblx0XG5cdHZhciBzdGFydCA9IHRoaXMucWNhbnZhcy5pc0Z1bihvYmouc3RhcnQpP29iai5zdGFydCgpOm9iai5zdGFydDtcblx0dmFyIGVuZCA9IHRoaXMucWNhbnZhcy5pc0Z1bihvYmouZW5kKT9vYmouZW5kKCk6b2JqLmVuZDtcblx0Ly/lvZPliY3nmoTotbfmraLngrnlkozljp/mnaXnmoTlgZrmr5TovoNcblx0XG5cdGlmKHR5cGVvZiBvYmoub2xkU3RhcnQgPT0ndW5kZWZpbmVkJyl7XG5cdFx0XHRvYmoub2xkU3RhcnQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHN0YXJ0KSk7XG5cdFx0XHRvYmoub2xkRW5kID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbmQpKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHR9ZWxzZXtcblx0XHRcblx0XHRpZihzdGFydFswXT09b2JqLm9sZFN0YXJ0WzBdICYmXG5cdFx0XHQgc3RhcnRbMV09PW9iai5vbGRTdGFydFsxXSAmJlxuXHRcdFx0IGVuZFswXT09b2JqLm9sZEVuZFswXSAmJlxuXHRcdFx0IGVuZFsxXT09b2JqLm9sZEVuZFsxXVxuXHRcdFx0KXtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1lbHNle1xuXHRcdFx0b2JqLm9sZFN0YXJ0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzdGFydCkpO1xuXHRcdFx0b2JqLm9sZEVuZCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZW5kKSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0XG5cdFx0XG5cdH1cbn1cdFxuXHRcbi8v55S76Jma57q/XHRcblFsaW5lLnByb3RvdHlwZS5wYWludERhc2hMaW5lID0gZnVuY3Rpb24ob2JqKXtcblx0XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zdHJva2VTdHlsZSA9IG9iai5jb2xvcjtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQubGluZVdpZHRoPW9iai53aWR0aDtcblxuXHRcdFx0dmFyIHN0YXJ0ID0gdGhpcy5xY2FudmFzLmlzRnVuKG9iai5zdGFydCk/b2JqLnN0YXJ0KCk6b2JqLnN0YXJ0O1xuXHRcdFx0dmFyIGVuZCA9IHRoaXMucWNhbnZhcy5pc0Z1bihvYmouZW5kKT9vYmouZW5kKCk6b2JqLmVuZDtcblx0XG5cdFx0XHRpZih0aGlzLmxpbmVJc0NoYW5nZShvYmopKXtcblx0XHRcdFx0XG5cdFx0XHRcdFx0dmFyIGRhc2hMZW4gPSAyOyAgXG5cdFx0XHRcdFx0Ly/lvpfliLDmlpzovrnnmoTmgLvplb/luqYgIFxuXHRcdFx0XHRcdHZhciBiZXZlbGluZyA9IHRoaXMuZ2V0QmV2ZWxpbmcoZW5kWzBdLXN0YXJ0WzBdLGVuZFswXS1zdGFydFsxXSk7ICBcblx0XHRcdFx0XHQvL+iuoeeul+acieWkmuWwkeS4que6v+autSAgXG5cdFx0XHRcdFx0dmFyIG51bSA9IE1hdGguZmxvb3IoYmV2ZWxpbmcvZGFzaExlbik7ICBcblx0XHRcdFxuXHRcdFx0XHRcdG9iai5kYXNoUG9pbnQgPSBbXTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDAgOyBpIDwgbnVtOyBpKyspICBcblx0XHRcdFx0XHR7ICBcblx0XHRcdFx0XHRcdG9iai5kYXNoUG9pbnQucHVzaChbXG5cdFx0XHRcdFx0XHRcdHN0YXJ0WzBdKyhlbmRbMF0tc3RhcnRbMF0pL251bSppLFxuXHRcdFx0XHRcdFx0XHRzdGFydFsxXSsoZW5kWzFdLXN0YXJ0WzFdKS9udW0qaVxuXHRcdFx0XHRcdFx0XSkgIFxuXHRcdFx0XHRcdH0gIFxuXHRcdFx0XHRcblx0XHRcdFx0aWYob2JqLmxpa2U9PSctLT4nKXtcblx0XHRcdFx0XHRcdHRoaXMuYXBwZW5kQXJyb3cob2JqKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IodmFyIGkgPSAwIDsgaSA8IG9iai5kYXNoUG9pbnQubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRcdCAgXG5cdFx0XHRcdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dFtpJTIgPT0gMCA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKG9iai5kYXNoUG9pbnRbaV1bMF0sb2JqLmRhc2hQb2ludFtpXVsxXSk7ICBcblx0XHRcdFx0fSBcblx0XHRcdFxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcblx0XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zdHJva2UoKTsgIFxufVx0XG5cdFxuXHRcblxuXHRcblx0XG5cblx0XG4vKuaWh+Wtl+exuy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIFF0ZXh0KHFjYW52YXMpe1xuXHR0aGlzLnF0ZXh0VmVyc2lvbiA9ICcxLjAnO1xuXHR0aGlzLnFjYW52YXMgPSBxY2FudmFzO1xuXHRcblx0XG59XHRcblxuUXRleHQucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbihvcHRpb25zKXtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciBPUFRJT05TID0ge1xuXHRcdFx0VFlQRTondGV4dCcsXG5cdFx0XHR0ZXh0OidRY2FudmFzIFRleHQnLFxuXHRcdFx0Y29sb3I6J3JlZCcsXG5cdFx0XHR0ZXh0QWxpZ246J2NlbnRlcicsXG5cdFx0XHR0ZXh0QmFzZWxpbmU6J21pZGRsZScsXG5cdFx0XHRsaW5lSGVpZ2h0OicxMnB4Jyxcblx0XHRcdGZvbnRTaXplOlwiMTJweFwiLFxuXHRcdFx0Zm9udEZhbWlseTonTWljcm9zb2Z0IFlhSGVpJyxcblx0XHRcdHN0YXJ0OlswLDBdLFxuXHRcdFx0ZHJhZzp0cnVlLFxuXHRcdFx0ICBkcmFnUmFuZ2U6W10sICAvL+mZkOWItuaLluWKqOeahOWMuuWfnyDlv4XpobvkuLrkuKTkuKrlnZDmoIfngrlbW+W3puS4iuinkngs5bem5LiK6KeSeV3vvIxb5Y+z5LiL6KeSeCzlj7PkuIvop5J5XV1cblxuXHRcdFx0cG9pbnRlckV2ZW50OidhdXRvJyxcblx0XHRcdHJhbmdlOnt3aWR0aDowLGhlaWdodDowfSxcblx0XHRcdGRlZ3JlZTowLFxuXHRcdFx0Y2VudGVyUG9pbnRzOmZ1bmN0aW9uKCl7IC8v5YWD57Sg5Lit5b+D54K555u45a+55LqO5pW05Liq55S75biD55qE5Z2Q5qCHXG5cblx0XHRcdFx0dmFyIHggPSAwO1xuXHRcdFx0XHR2YXIgeSA9IDA7XG5cdFx0XHRcdHZhciBzdGFydCA9IF90aGlzLnFjYW52YXMuaXNGdW4odGhpcy5zdGFydCk/dGhpcy5zdGFydCgpOnRoaXMuc3RhcnQ7XG5cblxuXHRcdFx0XHRpZih0aGlzLnRleHRBbGlnbiA9PSAnbGVmdCcpe1xuXHRcdFx0XHRcdHggPSB0aGlzLnJhbmdlLndpZHRoKjAuNStzdGFydFswXTtcblxuXHRcdFx0XHR9ZWxzZSBpZih0aGlzLnRleHRBbGlnbiA9PSAnY2VudGVyJyl7XG5cdFx0XHRcdFx0eCA9IHN0YXJ0WzBdO1xuXHRcdFx0XHR9ZWxzZSBpZih0aGlzLnRleHRBbGlnbiA9PSAncmlnaHQnKXtcblx0XHRcdFx0XHR4ID0gc3RhcnRbMF0gLSB0aGlzLnJhbmdlLndpZHRoKjAuNTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKHRoaXMudGV4dEJhc2VsaW5lID09ICd0b3AnKXtcblx0XHRcdFx0XHR5ID0gdGhpcy5yYW5nZS5oZWlnaHQgKjAuNStzdGFydFsxXTtcblx0XHRcdFx0fWVsc2UgaWYodGhpcy50ZXh0QmFzZWxpbmUgPT0gJ21pZGRsZScpe1xuXHRcdFx0XHRcdHkgPSBzdGFydFsxXTtcblx0XHRcdFx0fWVsc2UgaWYodGhpcy50ZXh0QmFzZWxpbmUgPT0gJ2JvdHRvbScpe1xuXHRcdFx0XHRcdHkgPSBzdGFydFsxXSAtIHRoaXMucmFuZ2UuaGVpZ2h0KjAuNTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0eDp4LFxuXHRcdFx0XHRcdHk6eVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cG9seVBvaW50czpmdW5jdGlvbigpeyAgLy/pobbngrnlnZDmoIfluo/liJdcblx0XHRcdFx0XHR2YXIgaGFsZl94ID0gdGhpcy5yYW5nZS53aWR0aCowLjU7XG5cdFx0XHRcdFx0dmFyIGhhbGZfeSA9IHRoaXMucmFuZ2UuaGVpZ2h0KjAuNTsgXG5cdFx0XHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuY2VudGVyUG9pbnRzKCk7XG5cblxuXG5cdFx0XHRcdFx0Ly8gdmFyIHBvczF4ID0gMCxwb3MxeSA9IDAscG9zMnggPSAwLHBvczJ5ID0gMCxwb3MzeCA9IDAscG9zM3kgPSAwLHBvczR4ID0gMCxwb3M0eSA9IDA7XG5cblxuXHRcdFx0XHRcdC8vIGlmKHRoaXMudGV4dEFsaWduID09ICdjZW50ZXInKXtcblx0XHRcdFx0XHQvLyBcdHBvczF4ID0gdGhpcy5zdGFydFswXS1oYWxmX3g7XG5cdFx0XHRcdFx0Ly8gXHRwb3MyeCA9IHRoaXMuc3RhcnRbMF0raGFsZl94O1xuXHRcdFx0XHRcdC8vIFx0cG9zM3ggPSB0aGlzLnN0YXJ0WzBdK2hhbGZfeDtcblx0XHRcdFx0XHQvLyBcdHBvczR4ID0gdGhpcy5zdGFydFswXS1oYWxmX3g7XG5cdFx0XHRcdFx0Ly8gfWVsc2UgaWYodGhpcy50ZXh0QWxpZ24gPT0gJ2xlZnQnKXtcblx0XHRcdFx0XHQvLyBcdHBvczF4ID0gdGhpcy5zdGFydFswXTtcblx0XHRcdFx0XHQvLyBcdHBvczJ4ID0gdGhpcy5zdGFydFswXStoYWxmX3gqMjtcblx0XHRcdFx0XHQvLyBcdHBvczN4ID0gdGhpcy5zdGFydFswXTtcblx0XHRcdFx0XHQvLyBcdHBvczR4ID0gdGhpcy5zdGFydFswXStoYWxmX3gqMjtcblx0XHRcdFx0XHQvLyB9ZWxzZSBpZih0aGlzLnRleHRBbGlnbiA9PSAncmlnaHQnKXtcblx0XHRcdFx0XHQvLyBcdHBvczF4ID0gdGhpcy5zdGFydFswXS1oYWxmX3gqMjtcblx0XHRcdFx0XHQvLyBcdHBvczJ4ID0gdGhpcy5zdGFydFswXTtcblx0XHRcdFx0XHQvLyBcdHBvczN4ID0gdGhpcy5zdGFydFswXTtcblx0XHRcdFx0XHQvLyBcdHBvczR4ID0gdGhpcy5zdGFydFswXS1oYWxmX3gqMjtcblx0XHRcdFx0XHQvLyB9XG5cblx0XHRcdFx0XHQvLyBpZih0aGlzLnRleHRCYXNlbGluZSA9PSAnbWlkZGxlJyl7XG5cdFx0XHRcdFx0Ly8gXHRwb3MxeSA9IHRoaXMuc3RhcnRbMV0taGFsZl95O1xuXHRcdFx0XHRcdC8vIFx0cG9zMnkgPSB0aGlzLnN0YXJ0WzFdLWhhbGZfeTtcblx0XHRcdFx0XHQvLyBcdHBvczN5ID0gdGhpcy5zdGFydFsxXStoYWxmX3k7XG5cdFx0XHRcdFx0Ly8gXHRwb3M0eSA9IHRoaXMuc3RhcnRbMV0raGFsZl95O1xuXHRcdFx0XHRcdC8vIH1lbHNlIGlmKHRoaXMudGV4dEJhc2VsaW5lID09ICd0b3AnKXtcblx0XHRcdFx0XHQvLyBcdHBvczF5ID0gdGhpcy5zdGFydFsxXTtcblx0XHRcdFx0XHQvLyBcdHBvczJ5ID0gdGhpcy5zdGFydFsxXTtcblx0XHRcdFx0XHQvLyBcdHBvczN5ID0gdGhpcy5zdGFydFsxXStoYWxmX3kqMjtcblx0XHRcdFx0XHQvLyBcdHBvczR5ID0gdGhpcy5zdGFydFsxXStoYWxmX3kqMjtcblx0XHRcdFx0XHQvLyB9ZWxzZSBpZih0aGlzLnRleHRCYXNlbGluZSA9PSAnYm90dG9tJyl7XG5cdFx0XHRcdFx0Ly8gXHRwb3MxeSA9IHRoaXMuc3RhcnRbMV0taGFsZl95KjI7XG5cdFx0XHRcdFx0Ly8gXHRwb3MyeSA9IHRoaXMuc3RhcnRbMV0taGFsZl95KjI7XG5cdFx0XHRcdFx0Ly8gXHRwb3MzeSA9IHRoaXMuc3RhcnRbMV07XG5cdFx0XHRcdFx0Ly8gXHRwb3M0eSA9IHRoaXMuc3RhcnRbMV07XG5cdFx0XHRcdFx0Ly8gfVxuXG5cdFx0XHRcdFx0Ly8gcmV0dXJuIFtcblx0XHRcdFx0XHQvLyBcdHtcInhcIjpwb3MxeCxcInlcIjpwb3MxeX0sXG5cdFx0XHRcdFx0Ly8gXHR7XCJ4XCI6cG9zMngsXCJ5XCI6cG9zMnl9LFxuXHRcdFx0XHRcdC8vIFx0e1wieFwiOnBvczN4LFwieVwiOnBvczN5fSxcblx0XHRcdFx0XHQvLyBcdHtcInhcIjpwb3M0eCxcInlcIjpwb3M0eX1cblxuXHRcdFx0XHRcdC8vIF1cblxuXG5cdFx0XHRcdFx0Ly8gcmV0dXJuIFtcblx0XHRcdFx0XHQvLyBcdHtcInhcIjp0aGlzLnN0YXJ0WzBdLWhhbGZfeCxcInlcIjp0aGlzLnN0YXJ0WzFdLWhhbGZfeX0sXG5cdFx0XHRcdFx0Ly8gXHR7XCJ4XCI6dGhpcy5zdGFydFswXStoYWxmX3gsXCJ5XCI6dGhpcy5zdGFydFsxXS1oYWxmX3l9LFxuXHRcdFx0XHRcdC8vIFx0e1wieFwiOnRoaXMuc3RhcnRbMF0raGFsZl94LFwieVwiOnRoaXMuc3RhcnRbMV0raGFsZl95fSxcblx0XHRcdFx0XHQvLyBcdHtcInhcIjp0aGlzLnN0YXJ0WzBdLWhhbGZfeCxcInlcIjp0aGlzLnN0YXJ0WzFdK2hhbGZfeX0sXG5cdFx0XHRcdFx0Ly8gXVxuXHRcdFx0XHRcdHZhciB0ZW1wID0gMDtcblx0XHRcdFx0XHRpZih0aGlzLmRlZ3JlZSA8MCl7IFxuXHRcdFx0XHRcdFx0dGVtcCA9IDM2MCt0aGlzLmRlZ3JlZTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdHRlbXAgPSB0aGlzLmRlZ3JlZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYoKHRlbXA+MCAmJiB0ZW1wPD05MCkgfHwgKHRlbXA+MTgwICYmIHRlbXA8PTI3MCkpe1xuXG5cdFx0XHRcdFx0XHRpZih0ZW1wID4xODApe1xuXHRcdFx0XHRcdFx0XHR0ZW1wID0gdGVtcC0xODA7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciBFX3ggPSBjZW50ZXIueC1NYXRoLmNvcyh0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3g7XG5cdFx0XHRcdFx0XHR2YXIgRV95ID0gY2VudGVyLnktTWF0aC5zaW4odGVtcCpNYXRoLlBJLzE4MCkqaGFsZl94O1xuXHRcdFx0XHRcdFx0IFxuXHRcdFx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRcdFx0e3g6RV94K01hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSx5OkVfeS1NYXRoLmNvcyh0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3l9LFxuXHRcdFx0XHRcdFx0XHR7eDpjZW50ZXIueC0oRV94LU1hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLngseTpjZW50ZXIueS0oRV95K01hdGguY29zKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLnl9LFxuXHRcdFx0XHRcdFx0XHR7eDpjZW50ZXIueC0oRV94K01hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLngseTpjZW50ZXIueS0oRV95LU1hdGguY29zKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLnl9LFxuXHRcdFx0XHRcdFx0XHR7eDpFX3gtTWF0aC5zaW4odGVtcCpNYXRoLlBJLzE4MCkqaGFsZl95LHk6RV95K01hdGguY29zKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeX0sXG5cdFx0XHRcdFx0XHRdO1xuXG5cblxuXHRcdFx0XHRcdH1lbHNlIGlmKCh0ZW1wPjkwICYmIHRlbXA8MTgwKSB8fCAodGVtcD4yNzAgJiYgdGVtcDwzNjApKXtcblxuXHRcdFx0XHRcdFx0aWYodGVtcD4yNzApe1xuXHRcdFx0XHRcdFx0XHR0ZW1wID0gdGVtcC0xODA7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRlbXAgPSAxODAgLSB0ZW1wO1xuXHRcdFx0XHRcdFx0dmFyIEVfeCA9IGNlbnRlci54K01hdGguY29zKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeDtcblx0XHRcdFx0XHRcdHZhciBFX3kgPSBjZW50ZXIueS1NYXRoLnNpbih0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3g7XG4gXG5cblx0XHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHRcdHt4OkVfeCtNYXRoLnNpbih0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3kseTpFX3krTWF0aC5jb3ModGVtcCpNYXRoLlBJLzE4MCkqaGFsZl95fSxcblx0XHRcdFx0XHRcdFx0e3g6Y2VudGVyLngtKEVfeC1NYXRoLnNpbih0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3kpK2NlbnRlci54LHk6Y2VudGVyLnktKEVfeS1NYXRoLmNvcyh0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3kpK2NlbnRlci55fSxcblx0XHRcdFx0XHRcdFx0e3g6Y2VudGVyLngtKEVfeCtNYXRoLnNpbih0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3kpK2NlbnRlci54LHk6Y2VudGVyLnktKEVfeStNYXRoLmNvcyh0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3kpK2NlbnRlci55fSxcblx0XHRcdFx0XHRcdFx0e3g6RV94LU1hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSx5OkVfeS1NYXRoLmNvcyh0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3l9LFxuXHRcdFx0XHRcdFx0XVxuXG5cblxuXG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdFx0XHR7XCJ4XCI6Y2VudGVyLngtaGFsZl94LFwieVwiOmNlbnRlci55LWhhbGZfeX0sXG5cdFx0XHRcdFx0XHRcdHtcInhcIjpjZW50ZXIueCtoYWxmX3gsXCJ5XCI6Y2VudGVyLnktaGFsZl95fSxcblx0XHRcdFx0XHRcdFx0e1wieFwiOmNlbnRlci54K2hhbGZfeCxcInlcIjpjZW50ZXIueStoYWxmX3l9LFxuXHRcdFx0XHRcdFx0XHR7XCJ4XCI6Y2VudGVyLngtaGFsZl94LFwieVwiOmNlbnRlci55K2hhbGZfeX1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHR9LFx0XG5cdFx0XHRkb3duRnVuOmZ1bmN0aW9uKGUscG9zaXRpb24pe1xuXHRcdFx0XHR2YXIgc3RhcnQgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuc3RhcnQpP3RoaXMuc3RhcnQoKTp0aGlzLnN0YXJ0O1xuXHRcdFx0XHR0aGlzLmRpcyA9IFtwb3NpdGlvbi54LXN0YXJ0WzBdLHBvc2l0aW9uLnktc3RhcnRbMV1dO1xuXHRcdFx0fSxcblx0XHRcdG1vdmVGdW46ZnVuY3Rpb24oZSxwb3NpdGlvbil7ICAvL+W9k+mFjee9rmRyYWdlUmFuZ2Xml7YgIOW8gOWni+mZkOWItuWdkOagh1xuXG5cdFx0XHRcdHZhciBkcmFnSXNCb29sID0gX3RoaXMucWNhbnZhcy5pc0Jvb2wodGhpcy5kcmFnKTtcblx0XHRcdFx0dmFyIGRpcyAgPSB0aGlzLmRpcztcblx0XHRcdFx0dmFyIHN0YXJ0ID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLnN0YXJ0KT90aGlzLnN0YXJ0KCk6dGhpcy5zdGFydDtcblx0XHRcdFx0dmFyIHJhbmdlID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLmRyYWdSYW5nZSk/dGhpcy5kcmFnUmFuZ2UoKTp0aGlzLmRyYWdSYW5nZTtcblxuXHRcdFx0XHR2YXIgeCx5O1xuXHRcdFx0XHRpZihkcmFnSXNCb29sICYmIHRoaXMuZHJhZyl7XG5cdFx0XHRcdFx0IHggPSBwb3NpdGlvbi54LWRpc1swXTtcblx0XHRcdFx0XHQgeSA9IHBvc2l0aW9uLnktZGlzWzFdO1xuXG5cdFx0XHRcdFx0IGlmKHJhbmdlLmxlbmd0aCA9PSAyKXsgIFxuXHRcdFx0XHRcdFx0eCA9IHg+PXJhbmdlWzFdWzBdP3JhbmdlWzFdWzBdOng7XG5cdFx0XHRcdFx0XHR4ID0geDw9cmFuZ2VbMF1bMF0/cmFuZ2VbMF1bMF06eDtcblxuXHRcdFx0XHRcdFx0eSA9IHk+PXJhbmdlWzFdWzFdP3JhbmdlWzFdWzFdOnk7XG5cdFx0XHRcdFx0XHR5ID0geTw9cmFuZ2VbMF1bMV0/cmFuZ2VbMF1bMV06eTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fWVsc2UgaWYodGhpcy5kcmFnID09ICd2ZXJ0aWNhbCcpe1xuXHRcdFx0XHRcdCB4ID0gdGhpcy5zdGFydFswXTtcblx0XHRcdFx0XHQgeSA9IHBvc2l0aW9uLnktZGlzWzFdO1xuXG5cblx0XHRcdFx0XHQgaWYocmFuZ2UubGVuZ3RoID09IDIpeyAgIFxuXG5cdFx0XHRcdFx0XHR5ID0geT49cmFuZ2VbMV1bMV0/cmFuZ2VbMV1bMV06eTtcblx0XHRcdFx0XHRcdHkgPSB5PD1yYW5nZVswXVsxXT9yYW5nZVswXVsxXTp5O1xuXHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdH1lbHNlIGlmKHRoaXMuZHJhZyA9PSAnaG9yaXpvbnRhbCcpe1xuXHRcdFx0XHRcdCB4ID0gcG9zaXRpb24ueC1kaXNbMF07XG5cdFx0XHRcdFx0IHkgPSB0aGlzLnN0YXJ0WzFdOyBcblxuXG5cdFx0XHRcdFx0IGlmKHJhbmdlLmxlbmd0aCA9PSAyKXsgIFxuXHRcdFx0XHRcdFx0eCA9IHg+PXJhbmdlWzFdWzBdP3JhbmdlWzFdWzBdOng7XG5cdFx0XHRcdFx0XHR4ID0geDw9cmFuZ2VbMF1bMF0/cmFuZ2VbMF1bMF06eDsgXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IFxuXHRcdFx0IFx0Ly/lpoLmnpzliJvlu7rml7bkvY3nva7mlbDmja7kvp3otZbkuo7liKvnmoTlhYPntKAg6YKj5LmI5LiA5pem5ouW5Yqo6K+l5YWD57SgIOaVsOaNrueahOS+nei1luWFs+ezu+WwseS8muaWreW8gCDliIforrBcblx0XHRcdFx0dGhpcy5zdGFydCA9IFt4LHldO1xuXHRcdFx0fSxcblx0XHRcdGZvcm1hdFRleHQ6ZnVuY3Rpb24ob2JqKSB7ICAvL+WkhOeQhuWkmuihjOaWh+acrFxuXHRcdFx0XHR2YXIgdGV4dCA9IF90aGlzLnFjYW52YXMuaXNGdW4ob2JqLnRleHQpP29iai50ZXh0KCk6b2JqLnRleHQ7XG5cdFx0XHRcdHZhciB0O1xuXHRcdFx0XHRpZigodGV4dCsnJykuaW5kZXhPZignXFxuJykgPiAtMSl7XG5cdFx0XHRcdFx0dCA9ICB0ZXh0LnNwbGl0KCdcXG4nKTtcblx0XHRcdFx0fWVsc2V7XG5cblx0XHRcdFx0XHR0ID0gW3RleHRdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly/orqHnrpfmr4/ooYznmoTlrr3luqZcblx0XHRcdFx0dmFyIHcgPSBbXTtcblx0XHRcdFx0dC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdFx0XHRcdHcucHVzaChfdGhpcy5xY2FudmFzLmNvbnRleHQubWVhc3VyZVRleHQoaXRlbSkud2lkdGgpO1xuXHRcdFx0XHR9KVxuXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dGV4dDp0LFxuXHRcdFx0XHRcdHdpZHRoOndcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcdFxuXHR0aGlzLnFjYW52YXMuZXh0ZW5kKE9QVElPTlMsb3B0aW9ucyk7XG5cdHRoaXMucWNhbnZhcy5hcHBlbmRTZXRGdW4oT1BUSU9OUyk7XG5cdFxuXHRyZXR1cm4gT1BUSU9OUztcbn1cbiBcblF0ZXh0LnByb3RvdHlwZS5wYWludFRleHQgPSBmdW5jdGlvbihvYmope1xuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXHR2YXIgdGV4dEFyciA9IG9iai5mb3JtYXRUZXh0KG9iaik7ICBcblxuXHRvYmoucmFuZ2UgPSB7XG5cdFx0Ly8gd2lkdGg6dGhpcy5xY2FudmFzLmNvbnRleHQubWVhc3VyZVRleHQodGhpcy5xY2FudmFzLmlzRnVuKG9iai50ZXh0KT9vYmoudGV4dCgpOm9iai50ZXh0KS53aWR0aCxcblx0IC8vICAgIGhlaWdodDpwYXJzZUludChvYmouZm9udFNpemUpLFxuXHQgICAgd2lkdGg6TWF0aC5tYXguYXBwbHkobnVsbCx0ZXh0QXJyLndpZHRoKSxcblx0ICAgIGhlaWdodDpwYXJzZUludChvYmoubGluZUhlaWdodCkqdGV4dEFyci50ZXh0Lmxlbmd0aFxuXHR9O1xuXHRcdC8v5pyJ6KeS5bqm5pe2IOenu+WKqOeUu+W4g+WOn+eCuSDml4vovaznlLvluINcblx0XHR2YXIgY2VudGVyUG9zID0gdGhpcy5xY2FudmFzLnNldERlZ3JlZShvYmopOyAgXG5cblx0XHQvL+iuvue9ruWtl+S9k+minOiJslxuICAgIFx0Ly8gdGhpcy5xY2FudmFzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSBvYmouY29sb3I7XG4gICAgXHR0aGlzLnFjYW52YXMuY29udGV4dC5maWxsU3R5bGUgPSBvYmouY29sb3I7XG4gXG5cdFx0Ly/lj6/og73ot6/lvoTmmK/omZrnur/lvaLlvI/nmoQg6K6+572u5oiQ5a6e57q/XG5cdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc2V0TGluZURhc2goW10pOyBcblx0XHRcblx0XHR2YXIgc3RhcnQgPSB0aGlzLnFjYW52YXMuaXNGdW4ob2JqLnN0YXJ0KT9vYmouc3RhcnQoKTpvYmouc3RhcnQ7XG5cdFx0dGhpcy5xY2FudmFzLmNvbnRleHQudGV4dEJhc2VsaW5lID0gb2JqLnRleHRCYXNlbGluZTtcblx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5mb250ID0gb2JqLmZvbnRTaXplICsgJyAnK29iai5mb250RmFtaWx5O1xuXHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnRleHRBbGlnbiA9IG9iai50ZXh0QWxpZ247XG4gICAgXHQvLyB0aGlzLnFjYW52YXMuY29udGV4dC5zdHJva2VUZXh0KHRoaXMucWNhbnZhcy5pc0Z1bihvYmoudGV4dCk/b2JqLnRleHQoKTpvYmoudGV4dCwgIHN0YXJ0WzBdLCAgc3RhcnRbMV0pO1xuICAgIFx0Ly8gdGhpcy5xY2FudmFzLmNvbnRleHQuZmlsbFRleHQodGhpcy5xY2FudmFzLmlzRnVuKG9iai50ZXh0KT9vYmoudGV4dCgpOm9iai50ZXh0LCAgc3RhcnRbMF0sICBzdGFydFsxXSk7XG5cbiAgICBcdHRleHRBcnIudGV4dC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0saW5kZXgpe1xuXHQgICAgXHRfdGhpcy5xY2FudmFzLmNvbnRleHQuZmlsbFRleHQoaXRlbSwgIHN0YXJ0WzBdLCAgc3RhcnRbMV0rcGFyc2VJbnQob2JqLmxpbmVIZWlnaHQpKmluZGV4KTtcbiAgICBcdH0pXG5cblxuICAgIFx0XG5cblx0XHQvLyAvL+mHjee9rueUu+W4g+WOn+eCuSDml4vovazlpI3ljp9cblx0XHR0aGlzLnFjYW52YXMucmVzZXREZWdyZWUob2JqLGNlbnRlclBvcyk7IFxuXHRcdFxuXG5cdFx0Ly/ph43nva5cblx0XHR0aGlzLnFjYW52YXMuY29udGV4dC50ZXh0QWxpZ24gPSdjZW50ZXInO1xuXHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnRleHRCYXNlbGluZSA9J21pZGRsZSc7XG5cdFxuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdFxufVxuXG5cbi8q55+p5b2i57G7LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gUXJlY3QocWNhbnZhcyl7XG5cdHRoaXMucXJlY3RWZXJzaW9uID0gJzEuMCc7XG5cdHRoaXMucWNhbnZhcyA9IHFjYW52YXM7XG5cbn1cblxuUXJlY3QucHJvdG90eXBlLnJlY3QgPSBmdW5jdGlvbihvcHRpb25zKXtcblx0dmFyIF90aGlzID0gdGhpcztcblx0dmFyIE9QVElPTlMgPSB7XG5cdFx0XHRUWVBFOidyZWN0Jyxcblx0XHRcdGxpbmVXaWR0aDoxLFxuXHRcdFx0c3RhcnQ6WzAsMF0sXG5cdFx0XHR3aWR0aDoxMDAsXG5cdFx0XHRoZWlnaHQ6NTAsXG5cdFx0XHRib3JkZXJDb2xvcjonIzAwMCcsIFxuXHRcdFx0ZmlsbENvbG9yOicnLFxuXHRcdFx0ZHJhZzp0cnVlLFxuXHRcdFx0ZHJhZ1JhbmdlOltdLFxuXHRcdFx0ZGFzaGVkOmZhbHNlLFxuXHRcdFx0ZGVncmVlOjAsXG5cdFx0XHRyYWRpdXM6MCxcblx0XHRcdHBvaW50ZXJFdmVudDonYXV0bycsXG5cdFx0XHRyZXNpemU6ZmFsc2UsXG5cdFx0XHRyb3RhdGU6ZmFsc2UsXG5cdFx0XHRjZW50ZXJQb2ludHM6ZnVuY3Rpb24oKXsgLy/lhYPntKDkuK3lv4Pngrnnm7jlr7nkuo7mlbTkuKrnlLvluIPnmoTlnZDmoIdcblx0XHRcdFx0XHR2YXIgc3RhcnQgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuc3RhcnQpP3RoaXMuc3RhcnQoKTp0aGlzLnN0YXJ0O1xuXHRcdFx0XHRcdHZhciB3aWR0aCA9IF90aGlzLnFjYW52YXMuaXNGdW4odGhpcy53aWR0aCk/dGhpcy53aWR0aCgpOnRoaXMud2lkdGg7XG5cdFx0XHRcdFx0dmFyIGhlaWdodCA9IF90aGlzLnFjYW52YXMuaXNGdW4odGhpcy5oZWlnaHQpP3RoaXMuaGVpZ2h0KCk6dGhpcy5oZWlnaHQ7XG5cblxuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR4OnN0YXJ0WzBdK3dpZHRoKjAuNSxcblx0XHRcdFx0XHRcdHk6c3RhcnRbMV0raGVpZ2h0KjAuNVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0fSxcblx0XHRcdHBvbHlQb2ludHM6ZnVuY3Rpb24oKXsgIC8v6aG254K55Z2Q5qCH5bqP5YiXXG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLnN0YXJ0KT90aGlzLnN0YXJ0KCk6dGhpcy5zdGFydDtcblx0XHRcdFx0XHR2YXIgd2lkdGggPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMud2lkdGgpP3RoaXMud2lkdGgoKTp0aGlzLndpZHRoO1xuXHRcdFx0XHRcdHZhciBoZWlnaHQgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuaGVpZ2h0KT90aGlzLmhlaWdodCgpOnRoaXMuaGVpZ2h0O1xuXG5cdFx0XHRcdFx0dmFyIGhhbGZfeCA9IHdpZHRoKjAuNTtcblx0XHRcdFx0XHR2YXIgaGFsZl95ID0gaGVpZ2h0KjAuNTsgXG5cdFx0XHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuY2VudGVyUG9pbnRzKCk7XG5cblxuXHRcdFx0XHRcdHZhciB0ZW1wID0gMDtcblx0XHRcdFx0XHRpZih0aGlzLmRlZ3JlZSA8MCl7IFxuXHRcdFx0XHRcdFx0dGVtcCA9IDM2MCt0aGlzLmRlZ3JlZTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdHRlbXAgPSB0aGlzLmRlZ3JlZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYoKHRlbXA+MCAmJiB0ZW1wPD05MCkgfHwgKHRlbXA+MTgwICYmIHRlbXA8PTI3MCkpe1xuXG5cdFx0XHRcdFx0XHRpZih0ZW1wID4xODApe1xuXHRcdFx0XHRcdFx0XHR0ZW1wID0gdGVtcC0xODA7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciBFX3ggPSBjZW50ZXIueC1NYXRoLmNvcyh0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3g7XG5cdFx0XHRcdFx0XHR2YXIgRV95ID0gY2VudGVyLnktTWF0aC5zaW4odGVtcCpNYXRoLlBJLzE4MCkqaGFsZl94O1xuXHRcdFx0XHRcdFx0IFxuXHRcdFx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRcdFx0e3g6RV94K01hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSx5OkVfeS1NYXRoLmNvcyh0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3l9LFxuXHRcdFx0XHRcdFx0XHR7eDpjZW50ZXIueC0oRV94LU1hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLngseTpjZW50ZXIueS0oRV95K01hdGguY29zKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLnl9LFxuXHRcdFx0XHRcdFx0XHR7eDpjZW50ZXIueC0oRV94K01hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLngseTpjZW50ZXIueS0oRV95LU1hdGguY29zKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLnl9LFxuXHRcdFx0XHRcdFx0XHR7eDpFX3gtTWF0aC5zaW4odGVtcCpNYXRoLlBJLzE4MCkqaGFsZl95LHk6RV95K01hdGguY29zKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeX0sXG5cdFx0XHRcdFx0XHRdO1xuXG5cblxuXHRcdFx0XHRcdH1lbHNlIGlmKCh0ZW1wPjkwICYmIHRlbXA8MTgwKSB8fCAodGVtcD4yNzAgJiYgdGVtcDwzNjApKXtcblxuXHRcdFx0XHRcdFx0aWYodGVtcD4yNzApe1xuXHRcdFx0XHRcdFx0XHR0ZW1wID0gdGVtcC0xODA7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRlbXAgPSAxODAgLSB0ZW1wO1xuXHRcdFx0XHRcdFx0dmFyIEVfeCA9IGNlbnRlci54K01hdGguY29zKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeDtcblx0XHRcdFx0XHRcdHZhciBFX3kgPSBjZW50ZXIueS1NYXRoLnNpbih0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3g7XG4gXG5cblx0XHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHRcdHt4OkVfeCtNYXRoLnNpbih0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3kseTpFX3krTWF0aC5jb3ModGVtcCpNYXRoLlBJLzE4MCkqaGFsZl95fSxcblx0XHRcdFx0XHRcdFx0e3g6Y2VudGVyLngtKEVfeC1NYXRoLnNpbih0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3kpK2NlbnRlci54LHk6Y2VudGVyLnktKEVfeS1NYXRoLmNvcyh0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3kpK2NlbnRlci55fSxcblx0XHRcdFx0XHRcdFx0e3g6Y2VudGVyLngtKEVfeCtNYXRoLnNpbih0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3kpK2NlbnRlci54LHk6Y2VudGVyLnktKEVfeStNYXRoLmNvcyh0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3kpK2NlbnRlci55fSxcblx0XHRcdFx0XHRcdFx0e3g6RV94LU1hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSx5OkVfeS1NYXRoLmNvcyh0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3l9LFxuXHRcdFx0XHRcdFx0XVxuXG5cblxuXG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHRcdHtcInhcIjpzdGFydFswXSxcInlcIjpzdGFydFsxXX0sXG5cdFx0XHRcdFx0XHRcdHtcInhcIjpzdGFydFswXSt3aWR0aCxcInlcIjpzdGFydFsxXX0sXG5cdFx0XHRcdFx0XHRcdHtcInhcIjpzdGFydFswXSt3aWR0aCxcInlcIjpzdGFydFsxXStoZWlnaHR9LFxuXHRcdFx0XHRcdFx0XHR7XCJ4XCI6c3RhcnRbMF0sXCJ5XCI6c3RhcnRbMV0raGVpZ2h0fSxcblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHR9LFx0XG5cdFx0XHRkb3duRnVuOmZ1bmN0aW9uKGUscG9zaXRpb24pe1xuXHRcdFx0XHR2YXIgc3RhcnQgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuc3RhcnQpP3RoaXMuc3RhcnQoKTp0aGlzLnN0YXJ0O1xuXHRcdFx0XHR0aGlzLmRpcyA9IFtwb3NpdGlvbi54LXN0YXJ0WzBdLHBvc2l0aW9uLnktc3RhcnRbMV1dO1xuXHRcdFx0fSxcblx0XHRcdG1vdmVGdW46ZnVuY3Rpb24oZSxwb3NpdGlvbil7ICAvL+W9k+mFjee9rmRyYWdlUmFuZ2Xml7YgIOW8gOWni+mZkOWItuWdkOagh1xuXG5cdFx0XHRcdHZhciBkcmFnSXNCb29sID0gX3RoaXMucWNhbnZhcy5pc0Jvb2wodGhpcy5kcmFnKTtcblx0XHRcdFx0dmFyIGRpcyAgPSB0aGlzLmRpcztcblx0XHRcdFx0dmFyIHN0YXJ0ID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLnN0YXJ0KT90aGlzLnN0YXJ0KCk6dGhpcy5zdGFydDtcblx0XHRcdFx0Ly8gdmFyIHJhbmdlID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLmRyYWdSYW5nZSk/dGhpcy5kcmFnUmFuZ2UoKTp0aGlzLmRyYWdSYW5nZTtcblxuXG5cdFx0XHRcdHZhciB4LHk7XG5cdFx0XHRcdGlmKGRyYWdJc0Jvb2wgJiYgdGhpcy5kcmFnKXtcblx0XHRcdFx0XHQgeCA9IHBvc2l0aW9uLngtZGlzWzBdO1xuXHRcdFx0XHRcdCB5ID0gcG9zaXRpb24ueS1kaXNbMV07XG5cblx0XHRcdFx0XHQvLyAgaWYocmFuZ2UubGVuZ3RoID09IDIpeyAgXG5cdFx0XHRcdFx0Ly8gXHR4ID0geD49cmFuZ2VbMV1bMF0/cmFuZ2VbMV1bMF06eDtcblx0XHRcdFx0XHQvLyBcdHggPSB4PD1yYW5nZVswXVswXT9yYW5nZVswXVswXTp4O1xuXG5cdFx0XHRcdFx0Ly8gXHR5ID0geT49cmFuZ2VbMV1bMV0/cmFuZ2VbMV1bMV06eTtcblx0XHRcdFx0XHQvLyBcdHkgPSB5PD1yYW5nZVswXVsxXT9yYW5nZVswXVsxXTp5O1xuXHRcdFx0XHRcdC8vIH1cblxuXHRcdFx0XHR9ZWxzZSBpZih0aGlzLmRyYWcgPT0gJ3ZlcnRpY2FsJyl7XG5cdFx0XHRcdFx0IHggPSB0aGlzLnN0YXJ0WzBdO1xuXHRcdFx0XHRcdCB5ID0gcG9zaXRpb24ueS1kaXNbMV07XG5cblxuXHRcdFx0XHRcdC8vICBpZihyYW5nZS5sZW5ndGggPT0gMil7ICAgXG5cblx0XHRcdFx0XHQvLyBcdHkgPSB5Pj1yYW5nZVsxXVsxXT9yYW5nZVsxXVsxXTp5O1xuXHRcdFx0XHRcdC8vIFx0eSA9IHk8PXJhbmdlWzBdWzFdP3JhbmdlWzBdWzFdOnk7XG5cdFx0XHRcdFx0Ly8gfVxuXG5cblx0XHRcdFx0fWVsc2UgaWYodGhpcy5kcmFnID09ICdob3Jpem9udGFsJyl7XG5cdFx0XHRcdFx0IHggPSBwb3NpdGlvbi54LWRpc1swXTtcblx0XHRcdFx0XHQgeSA9IHRoaXMuc3RhcnRbMV07IFxuXG5cblx0XHRcdFx0XHQvLyAgaWYocmFuZ2UubGVuZ3RoID09IDIpeyAgXG5cdFx0XHRcdFx0Ly8gXHR4ID0geD49cmFuZ2VbMV1bMF0/cmFuZ2VbMV1bMF06eDtcblx0XHRcdFx0XHQvLyBcdHggPSB4PD1yYW5nZVswXVswXT9yYW5nZVswXVswXTp4OyBcblx0XHRcdFx0XHQvLyB9XG5cdFx0XHRcdH0gXG5cdFx0XHQgXHQvL+WmguaenOWIm+W7uuaXtuS9jee9ruaVsOaNruS+nei1luS6juWIq+eahOWFg+e0oCDpgqPkuYjkuIDml6bmi5bliqjor6XlhYPntKAg5pWw5o2u55qE5L6d6LWW5YWz57O75bCx5Lya5pat5byAIOWIh+iusFxuXHRcdFx0XHR0aGlzLnN0YXJ0ID0gW3gseV07XG5cdFx0XHR9XG5cdFx0XHQvLyBtb3VzZXVwOmZ1bmN0aW9uKHBvc2l0aW9uKXtcblx0XHRcdC8vIFx0XHRjb25zb2xlLmxvZygn5re75Yqg5LiA5Lqb54K55Ye755qE5LqL5Lu2Jyk7XG5cdFx0XHQvLyB9XHRcdFx0XG5cblx0XHRcblx0XHRcdFxuXHRcdH1cblx0XHRcdFxuXHR0aGlzLnFjYW52YXMuZXh0ZW5kKE9QVElPTlMsb3B0aW9ucyk7XG5cdHRoaXMucWNhbnZhcy5hcHBlbmRTZXRGdW4oT1BUSU9OUyk7XG5cdFxuXHRyZXR1cm4gT1BUSU9OUztcbn1cblxuUXJlY3QucHJvdG90eXBlLmRyYXdSb3VuZGVkUmVjdCA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgb2JqKSB7XG5cdFx0XHRcblxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpOyAvLyBkcmF3IHRvcCBhbmQgdG9wIHJpZ2h0IGNvcm5lciBcblxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aD1vYmoubGluZVdpZHRoO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlPW9iai5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgXG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyBvYmoucmFkaXVzLCB5KTtcbiAgICAgICAgICAgIGN0eC5hcmNUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIG9iai5yYWRpdXMsIG9iai5yYWRpdXMpOyAvLyBkcmF3IHJpZ2h0IHNpZGUgYW5kIGJvdHRvbSByaWdodCBjb3JuZXIgXG4gICAgICAgICAgICBjdHguYXJjVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSBvYmoucmFkaXVzLCB5ICsgaGVpZ2h0LCBvYmoucmFkaXVzKTsgLy8gZHJhdyBib3R0b20gYW5kIGJvdHRvbSBsZWZ0IGNvcm5lciBcbiAgICAgICAgICAgIGN0eC5hcmNUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gb2JqLnJhZGl1cywgb2JqLnJhZGl1cyk7IC8vIGRyYXcgbGVmdCBhbmQgdG9wIGxlZnQgY29ybmVyIFxuICAgICAgICAgICAgY3R4LmFyY1RvKHgsIHksIHggKyBvYmoucmFkaXVzLCB5LCBvYmoucmFkaXVzKTtcbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cblxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcmdiID0gdGhpcy5xY2FudmFzLmNvbG9yUmdiKG9iai5maWxsQ29sb3IpLnJlcGxhY2UoJ1JHQignLCcnKS5yZXBsYWNlKCcpJywnJyk7XG5cblx0XHQob2JqLmZpbGxDb2xvciE9JycpICYmIFxuXHRcdFx0KG9iai5vcGFjaXR5ICYmIChjdHguZmlsbFN0eWxlPVwicmdiYShcIityZ2IrJywnK29iai5vcGFjaXR5K1wiKVwiKSB8fFxuXHRcdFx0KGN0eC5maWxsU3R5bGUgPSBvYmouZmlsbENvbG9yKSkgJiZcblx0XHRcdGN0eC5maWxsKCk7XG4gXG4gICAgICAgIH1cblxuUXJlY3QucHJvdG90eXBlLnBhaW50UmVjdCA9IGZ1bmN0aW9uKG9iail7XG5cdFx0Ly8gY29uc29sZS5sb2codGhpcyk7XG5cdFx0dGhpcy5xY2FudmFzLnFhbmltYXRpb24uY3JlYXRlQW5pbWF0aW9uKG9iaik7XHRcblxuXHRcdHZhciBzdGFydCA9IHRoaXMucWNhbnZhcy5pc0Z1bihvYmouc3RhcnQpP29iai5zdGFydCgpOm9iai5zdGFydDtcblx0XHR2YXIgd2lkdGggPSB0aGlzLnFjYW52YXMuaXNGdW4ob2JqLndpZHRoKT9vYmoud2lkdGgoKTpvYmoud2lkdGg7XG5cdFx0dmFyIGhlaWdodCA9IHRoaXMucWNhbnZhcy5pc0Z1bihvYmouaGVpZ2h0KT9vYmouaGVpZ2h0KCk6b2JqLmhlaWdodDtcblxuXG5cdFx0Ly/mnInop5Lluqbml7Yg56e75Yqo55S75biD5Y6f54K5IOaXi+i9rOeUu+W4g1xuXHRcdHZhciBjZW50ZXJQb3MgPSB0aGlzLnFjYW52YXMuc2V0RGVncmVlKG9iaik7ICAgXG5cblx0XHRpZihvYmouZGFzaGVkKXtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnNldExpbmVEYXNoKFszXSk7XG5cdFx0fVxuXG5cblx0XHRpZih0aGlzLnFjYW52YXMuaXNOdW0ob2JqLnJhZGl1cykgJiYgKG9iai5yYWRpdXM+MCkpeyAgLy/lnIbop5Lnn6nlvaJcblxuXHRcdFx0dGhpcy5kcmF3Um91bmRlZFJlY3QodGhpcy5xY2FudmFzLmNvbnRleHQsc3RhcnRbMF0sc3RhcnRbMV0sd2lkdGgsaGVpZ2h0LG9iaik7XG5cdFx0fWVsc2V7XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5iZWdpblBhdGgoKTtcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LmxpbmVXaWR0aD1vYmoubGluZVdpZHRoO1xuXHRcdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc3Ryb2tlU3R5bGU9b2JqLmJvcmRlckNvbG9yO1xuXHRcdFxuXHRcdFx0XG5cdFx0XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5yZWN0KHN0YXJ0WzBdLHN0YXJ0WzFdLHdpZHRoLGhlaWdodCk7XG5cdFx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zdHJva2UoKTtcblxuXHRcdFx0dmFyIHJnYiA9IHRoaXMucWNhbnZhcy5jb2xvclJnYihvYmouZmlsbENvbG9yKS5yZXBsYWNlKCdSR0IoJywnJykucmVwbGFjZSgnKScsJycpO1xuXHRcdFxuXHRcdChvYmouZmlsbENvbG9yIT0nJykgJiYgXG5cdFx0XHQob2JqLm9wYWNpdHkgJiYgKHRoaXMucWNhbnZhcy5jb250ZXh0LmZpbGxTdHlsZT1cInJnYmEoXCIrcmdiKycsJytvYmoub3BhY2l0eStcIilcIikgfHxcblx0XHRcdCh0aGlzLnFjYW52YXMuY29udGV4dC5maWxsU3R5bGUgPSBvYmouZmlsbENvbG9yKSkgJiZcblx0XHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LmZpbGwoKTtcblx0XHR9XG5cblx0XHRcblx0XG5cdFxuXHRcdC8vIChvYmouZmlsbENvbG9yIT0nJykgJiYgKHRoaXMucWNhbnZhcy5jb250ZXh0LmZpbGxTdHlsZSA9IG9iai5maWxsQ29sb3IpICYmIHRoaXMucWNhbnZhcy5jb250ZXh0LmZpbGwoKTtcblxuXHRcdC8vIC8v6YeN572u55S75biD5Y6f54K5IOaXi+i9rOWkjeWOn1xuXHRcdHRoaXMucWNhbnZhcy5yZXNldERlZ3JlZShvYmosY2VudGVyUG9zKTsgXG5cblx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG5cblxufVxuXG5cdFx0XG4vKuS4jeinhOWImeWbvuW9ouexuyovXG5mdW5jdGlvbiBRc2hhcGUocWNhbnZhcyl7XG5cdHRoaXMucXNoYXBlVmVyc2lvbiA9ICcxLjAnO1xuXHR0aGlzLnFjYW52YXMgPSBxY2FudmFzO1xuXHRcblx0XG59XHRcblxuUXNoYXBlLnByb3RvdHlwZS5zaGFwZSA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIE9QVElPTlMgPSB7XG5cdFx0XHRUWVBFOidzaGFwZScsXG5cdFx0XHRmaWxsQ29sb3I6JyM2NjYnLFxuXHRcdFx0cG9pbnRzOltcblx0XHRcdFx0WzMxMCwyMF0sXG5cdFx0XHRcdFs1NTYsMTAwXSxcblx0XHRcdFx0WzUzMCwxOTFdLFxuXHRcdFx0XHRbMzUwLDE4MF1cblx0XHRcdF0sXG5cdFx0XHRkcmFnOnRydWUsXG5cdFx0XHRwb2ludGVyRXZlbnQ6J2F1dG8nLFxuXHRcdFx0cG9seVBvaW50czpmdW5jdGlvbigpeyAgLy/pobbngrnlnZDmoIfluo/liJdcblx0XHRcdFx0XHRcblx0XHRcdFx0dmFyIHRlbXAgPSBbXTtcblx0XHRcdFx0dmFyIHBvaW50cyA9IF90aGlzLnFjYW52YXMuaXNGdW4odGhpcy5wb2ludHMpP3RoaXMucG9pbnRzKCk6dGhpcy5wb2ludHM7XG5cdFx0XHRcdHBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKHYsaW5kZXgpe1xuXHRcdFx0XHRcdHRlbXAucHVzaCh7XG5cdFx0XHRcdFx0XHRcInhcIjp2WzBdLFxuXHRcdFx0XHRcdFx0XCJ5XCI6dlsxXVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH0pXG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gdGVtcDtcblx0XHRcdFx0XHRcblx0XHRcdH0sXHRcblx0XHRcdGRvd25GdW46ZnVuY3Rpb24oZSxwb3NpdGlvbil7XG5cdFx0XHRcdHZhciBfc2VsZiA9IHRoaXM7XG5cdFx0XHRcdHRoaXMuZGlzID0gW107XG5cdFx0XHRcdHZhciBwb2ludHMgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMucG9pbnRzKT90aGlzLnBvaW50cygpOnRoaXMucG9pbnRzO1xuXHRcdFx0XHRwb2ludHMuZm9yRWFjaChmdW5jdGlvbih2LGluZGV4KXtcblx0XHRcdFx0XHRcdF9zZWxmLmRpcy5wdXNoKFtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24ueC1wb2ludHNbaW5kZXhdWzBdLFxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbi55LXBvaW50c1tpbmRleF1bMV1cblx0XHRcdFx0XHRcdF0pXHRcdFx0XHRcblx0XHRcdFx0fSlcblx0XHRcdH0sXG5cdFx0XHRtb3ZlRnVuOmZ1bmN0aW9uKGUscG9zaXRpb24pe1xuXHRcdFx0XHR2YXIgZHJhZ0lzQm9vbCA9IF90aGlzLnFjYW52YXMuaXNCb29sKHRoaXMuZHJhZyk7XG5cdFx0XHRcdHZhciBkaXMgID10aGlzLmRpcztcblx0XHRcdFx0dmFyIHBvaW50cyA9IF90aGlzLnFjYW52YXMuaXNGdW4odGhpcy5wb2ludHMpP3RoaXMucG9pbnRzKCk6dGhpcy5wb2ludHM7XG5cdFx0XHRcdHBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKHYsaW5kZXgpe1xuXHRcdFx0XHRcdFx0cG9pbnRzW2luZGV4XVswXSA9IHBvc2l0aW9uLngtIGRpc1tpbmRleF1bMF07XG5cdFx0XHRcdFx0XHRwb2ludHNbaW5kZXhdWzFdID0gcG9zaXRpb24ueS0gZGlzW2luZGV4XVsxXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0fSlcblx0XHRcdFx0XG5cdFx0XHRcdGlmKGRyYWdJc0Jvb2wgJiYgdGhpcy5kcmFnKXtcblx0XHRcdFx0XHRwb2ludHMuZm9yRWFjaChmdW5jdGlvbih2LGluZGV4KXtcblx0XHRcdFx0XHRcdFx0cG9pbnRzW2luZGV4XVswXSA9IHBvc2l0aW9uLngtIGRpc1tpbmRleF1bMF07XG5cdFx0XHRcdFx0XHRcdHBvaW50c1tpbmRleF1bMV0gPSBwb3NpdGlvbi55LSBkaXNbaW5kZXhdWzFdO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fWVsc2UgaWYodGhpcy5kcmFnID09ICd2ZXJ0aWNhbCcpe1xuXHRcdFx0XHRcdCBwb2ludHMuZm9yRWFjaChmdW5jdGlvbih2LGluZGV4KXtcblx0XHRcdFx0XHRcdFx0Ly8gcG9pbnRzW2luZGV4XVswXSA9IHBvc2l0aW9uLngtIGRpc1tpbmRleF1bMF07XG5cdFx0XHRcdFx0XHRcdHBvaW50c1tpbmRleF1bMV0gPSBwb3NpdGlvbi55LSBkaXNbaW5kZXhdWzFdO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0fSlcblxuXHRcdFx0XHR9ZWxzZSBpZih0aGlzLmRyYWcgPT0gJ2hvcml6b250YWwnKXtcblx0XHRcdFx0XHQgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24odixpbmRleCl7XG5cdFx0XHRcdFx0XHRcdHBvaW50c1tpbmRleF1bMF0gPSBwb3NpdGlvbi54LSBkaXNbaW5kZXhdWzBdO1xuXHRcdFx0XHRcdFx0XHQvLyBwb2ludHNbaW5kZXhdWzFdID0gcG9zaXRpb24ueS0gZGlzW2luZGV4XVsxXTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdHRoaXMucG9pbnRzID0gcG9pbnRzO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fVxuXHRcdFx0XG5cdHRoaXMucWNhbnZhcy5leHRlbmQoT1BUSU9OUyxvcHRpb25zKTtcblx0dGhpcy5xY2FudmFzLmFwcGVuZFNldEZ1bihPUFRJT05TKTtcblx0XG5cdHJldHVybiBPUFRJT05TO1xufVxuXG5Rc2hhcGUucHJvdG90eXBlLnBhaW50U2hhcGUgPSBmdW5jdGlvbihvYmope1xuXHR0aGlzLnFjYW52YXMuY29udGV4dC5saW5lV2lkdGg9MTtcblx0dGhpcy5xY2FudmFzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcIiMwMDBcIjtcblx0dGhpcy5xY2FudmFzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFxuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXHR2YXIgcG9pbnRzID0gdGhpcy5xY2FudmFzLmlzRnVuKG9iai5wb2ludHMpP29iai5wb2ludHMoKTpvYmoucG9pbnRzO1xuXHRwb2ludHMuZm9yRWFjaChmdW5jdGlvbih2LGluZGV4KXtcblx0XHRpZihpbmRleD09MCl7XG5cdFx0XHRfdGhpcy5xY2FudmFzLmNvbnRleHQubW92ZVRvKHZbMF0sIHZbMV0pO1xuXHRcdH1lbHNle1xuXHRcdFx0X3RoaXMucWNhbnZhcy5jb250ZXh0LmxpbmVUbyh2WzBdLCB2WzFdKTtcblx0XHR9XG5cdH0pXG5cdFxuXHRcblx0Ly/lhYjlhbPpl63nu5jliLbot6/lvoTjgILms6jmhI/vvIzmraTml7blsIbkvJrkvb/nlKjnm7Tnur/ov57mjqXlvZPliY3nq6/ngrnlkozotbflp4vnq6/ngrnjgIJcblx0dGhpcy5xY2FudmFzLmNvbnRleHQuY2xvc2VQYXRoKCk7XG5cdHRoaXMucWNhbnZhcy5jb250ZXh0LnN0cm9rZSgpO1xuXHRcblx0dmFyIHJnYiA9IHRoaXMucWNhbnZhcy5jb2xvclJnYihvYmouZmlsbENvbG9yKS5yZXBsYWNlKCdSR0IoJywnJykucmVwbGFjZSgnKScsJycpO1xuXHRcblx0KG9iai5maWxsQ29sb3IhPScnKSAmJiBcblx0XHQob2JqLm9wYWNpdHkgJiYgKHRoaXMucWNhbnZhcy5jb250ZXh0LmZpbGxTdHlsZT1cInJnYmEoXCIrcmdiKycsJytvYmoub3BhY2l0eStcIilcIikgfHxcblx0XHQodGhpcy5xY2FudmFzLmNvbnRleHQuZmlsbFN0eWxlID0gb2JqLmZpbGxDb2xvcikpICYmXG5cdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuZmlsbCgpO1xufVxuXHRcdFxuXHRcblxuLyrlnIbnsbstLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBRYXJjKHFjYW52YXMpe1xuXHR0aGlzLnFhcmNWZXJzaW9uID0gJzEuMCc7XG5cdHRoaXMucWNhbnZhcyA9IHFjYW52YXM7IFxufVxuXG5RYXJjLnByb3RvdHlwZS5hcmMgPSBmdW5jdGlvbihvcHRpb25zKXtcblx0dmFyICBfdGhpcyA9IHRoaXM7XG5cdHZhciBPUFRJT05TID0ge1xuXHRcdFx0VFlQRTonYXJjJyxcblx0XHRcdGxpbmVXaWR0aDoxLFxuXHRcdFx0Ym9yZGVyQ29sb3I6JyMwMDAnLFxuXHRcdFx0ZmlsbENvbG9yOidyZWQnLFxuXHRcdFx0c3RhcnQ6WzAsMF0sXG5cdFx0XHRyOjIwLFxuXHRcdFx0c0FuZ2xlOjAsXG5cdFx0XHRlQW5nbGU6MCxcblx0XHRcdGNvdW50ZXJjbG9ja3dpc2U6ZmFsc2UsXG5cdFx0ICBkcmFnOnRydWUsXG5cdFx0ICBkcmFnUmFuZ2U6W10sICAvL+mZkOWItuaLluWKqOeahOWMuuWfnyDlv4XpobvkuLrkuKTkuKrlnZDmoIfngrlbW+W3puS4iuinkngs5bem5LiK6KeSeV3vvIxb5Y+z5LiL6KeSeCzlj7PkuIvop5J5XV1cblx0XHQgIHBvaW50ZXJFdmVudDonYXV0bycsXG5cdFx0ICBsaWtlOictJyxcblx0XHRcdHBvbHlQb2ludHM6ZnVuY3Rpb24oKXsgIC8v6aG254K55Z2Q5qCH5bqP5YiXICjms6jmhI/pobrluo8g6KaB5b2i5oiQ5LiA5Liq6Zet5ZCI55qE5Yy65Z+fKVxuXHRcdFx0XHRcblx0XHRcdFx0dmFyIHN0YXJ0ID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLnN0YXJ0KT90aGlzLnN0YXJ0KCk6dGhpcy5zdGFydDtcblx0XHRcdFx0Ly/lubPlnYfliIblhavkuKrngrkg5pyJNDXluqbnmoRcblx0XHRcdFx0dmFyIHRlbXAgPSAgW1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHsneCc6c3RhcnRbMF0rdGhpcy5yLCd5JzpzdGFydFsxXX0sXG5cdFx0XHRcdFx0eyd4JzpzdGFydFswXSswLjcwNzEqdGhpcy5yLCd5JzpzdGFydFsxXS0wLjcwNzEqdGhpcy5yfSwgLy/nrKzkuIDosaHpmZDnmoQ0NeW6pueahOeCuVxuXHRcdFx0XHRcdHsneCc6c3RhcnRbMF0sJ3knOnN0YXJ0WzFdLXRoaXMucn0sXG5cdFx0XHRcdFx0eyd4JzpzdGFydFswXS0wLjcwNzEqdGhpcy5yLCd5JzpzdGFydFsxXS0wLjcwNzEqdGhpcy5yfSwgLy/nrKzkuozosaHpmZDnmoQ0NeW6pueahOeCuVxuXHRcdFx0XHRcdHsneCc6c3RhcnRbMF0tdGhpcy5yLCd5JzpzdGFydFsxXX0sXG5cdFx0XHRcdFx0eyd4JzpzdGFydFswXS0wLjcwNzEqdGhpcy5yLCd5JzpzdGFydFsxXSswLjcwNzEqdGhpcy5yfSwgLy/nrKzkuInosaHpmZDnmoQ0NeW6pueahOW6plxuXHRcdFx0XHRcdHsneCc6c3RhcnRbMF0sJ3knOnN0YXJ0WzFdK3RoaXMucn0sXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0eyd4JzpzdGFydFswXSswLjcwNzEqdGhpcy5yLCd5JzpzdGFydFsxXSswLjcwNzEqdGhpcy5yfSwgLy/nrKzlm5vosaHpmZDnmoQ0NeW6pueahOW6plxuXHRcdFx0XHRdO1xuXHRcdFx0XHRyZXR1cm4gdGVtcDtcdFxuXHRcdFx0XHRcdFxuXHRcdFx0fSxcdFxuXHRcdFx0ZG93bkZ1bjpmdW5jdGlvbihlLHBvc2l0aW9uKXtcblx0XHRcdFx0dmFyIHN0YXJ0ID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLnN0YXJ0KT90aGlzLnN0YXJ0KCk6dGhpcy5zdGFydDsgXG5cdFx0XHRcdHRoaXMuZGlzID0gW3Bvc2l0aW9uLngtc3RhcnRbMF0scG9zaXRpb24ueS1zdGFydFsxXV07XG5cdFx0XHR9LFxuXHRcdFx0bW92ZUZ1bjpmdW5jdGlvbihlLHBvc2l0aW9uKXsgIC8v5b2T6YWN572uZHJhZ2VSYW5nZeaXtiAg5byA5aeL6ZmQ5Yi25Z2Q5qCHXG5cblx0XHRcdFx0dmFyIGRyYWdJc0Jvb2wgPSBfdGhpcy5xY2FudmFzLmlzQm9vbCh0aGlzLmRyYWcpO1xuXHRcdFx0XHR2YXIgZGlzICA9IHRoaXMuZGlzO1xuXHRcdFx0XHR2YXIgc3RhcnQgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuc3RhcnQpP3RoaXMuc3RhcnQoKTp0aGlzLnN0YXJ0O1xuXHRcdFx0XHR2YXIgcmFuZ2UgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuZHJhZ1JhbmdlKT90aGlzLmRyYWdSYW5nZSgpOnRoaXMuZHJhZ1JhbmdlO1xuXG5cblx0XHRcdFx0dmFyIHgseTtcblx0XHRcdFx0aWYoZHJhZ0lzQm9vbCAmJiB0aGlzLmRyYWcpe1xuXHRcdFx0XHRcdCB4ID0gcG9zaXRpb24ueC1kaXNbMF07XG5cdFx0XHRcdFx0IHkgPSBwb3NpdGlvbi55LWRpc1sxXTtcblxuXHRcdFx0XHRcdCBpZihyYW5nZS5sZW5ndGggPT0gMil7ICBcblx0XHRcdFx0XHRcdHggPSB4Pj1yYW5nZVsxXVswXT9yYW5nZVsxXVswXTp4O1xuXHRcdFx0XHRcdFx0eCA9IHg8PXJhbmdlWzBdWzBdP3JhbmdlWzBdWzBdOng7XG5cblx0XHRcdFx0XHRcdHkgPSB5Pj1yYW5nZVsxXVsxXT9yYW5nZVsxXVsxXTp5O1xuXHRcdFx0XHRcdFx0eSA9IHk8PXJhbmdlWzBdWzFdP3JhbmdlWzBdWzFdOnk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1lbHNlIGlmKHRoaXMuZHJhZyA9PSAndmVydGljYWwnKXtcblx0XHRcdFx0XHQgeCA9IHRoaXMuc3RhcnRbMF07XG5cdFx0XHRcdFx0IHkgPSBwb3NpdGlvbi55LWRpc1sxXTtcblxuXG5cdFx0XHRcdFx0IGlmKHJhbmdlLmxlbmd0aCA9PSAyKXsgICBcblxuXHRcdFx0XHRcdFx0eSA9IHk+PXJhbmdlWzFdWzFdP3JhbmdlWzFdWzFdOnk7XG5cdFx0XHRcdFx0XHR5ID0geTw9cmFuZ2VbMF1bMV0/cmFuZ2VbMF1bMV06eTtcblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHR9ZWxzZSBpZih0aGlzLmRyYWcgPT0gJ2hvcml6b250YWwnKXtcblx0XHRcdFx0XHQgeCA9IHBvc2l0aW9uLngtZGlzWzBdO1xuXHRcdFx0XHRcdCB5ID0gdGhpcy5zdGFydFsxXTsgXG5cblxuXHRcdFx0XHRcdCBpZihyYW5nZS5sZW5ndGggPT0gMil7ICBcblx0XHRcdFx0XHRcdHggPSB4Pj1yYW5nZVsxXVswXT9yYW5nZVsxXVswXTp4O1xuXHRcdFx0XHRcdFx0eCA9IHg8PXJhbmdlWzBdWzBdP3JhbmdlWzBdWzBdOng7IFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBcblx0XHRcdCBcdC8v5aaC5p6c5Yib5bu65pe25L2N572u5pWw5o2u5L6d6LWW5LqO5Yir55qE5YWD57SgIOmCo+S5iOS4gOaXpuaLluWKqOivpeWFg+e0oCDmlbDmja7nmoTkvp3otZblhbPns7vlsLHkvJrmlq3lvIAg5YiH6K6wXG5cdFx0XHRcdHRoaXMuc3RhcnQgPSBbeCx5XTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XHRcblx0dGhpcy5xY2FudmFzLmV4dGVuZChPUFRJT05TLG9wdGlvbnMpO1xuXHR0aGlzLnFjYW52YXMuYXBwZW5kU2V0RnVuKE9QVElPTlMpO1xuXHRcblx0cmV0dXJuIE9QVElPTlM7XG59XHRcblx0XG5RYXJjLnByb3RvdHlwZS5wYWludEFyYyA9IGZ1bmN0aW9uKG9iail7XG5cblx0aWYob2JqLmxpa2U9PSctLScpe1xuXHRcdHRoaXMucWNhbnZhcy5jb250ZXh0LnNldExpbmVEYXNoKFszXSk7XG5cdH1cblxuXHR2YXIgdW5pdCA9IE1hdGguUEkgLyAxODA7XG5cdHRoaXMucWNhbnZhcy5xYW5pbWF0aW9uLmNyZWF0ZUFuaW1hdGlvbihvYmopO1xuXHR0aGlzLnFjYW52YXMuY29udGV4dC5iZWdpblBhdGgoKTtcblx0dGhpcy5xY2FudmFzLmNvbnRleHQubGluZVdpZHRoPW9iai5saW5lV2lkdGg7XG5cdHRoaXMucWNhbnZhcy5jb250ZXh0LnN0cm9rZVN0eWxlPW9iai5ib3JkZXJDb2xvcjtcblx0dmFyIHN0YXJ0ID0gdGhpcy5xY2FudmFzLmlzRnVuKG9iai5zdGFydCk/b2JqLnN0YXJ0KCk6b2JqLnN0YXJ0O1xuXHR0aGlzLnFjYW52YXMuY29udGV4dC5hcmMoc3RhcnRbMF0sc3RhcnRbMV0sb2JqLnIsb2JqLnNBbmdsZSp1bml0LG9iai5lQW5nbGUqdW5pdCk7XG5cblx0dGhpcy5xY2FudmFzLmNvbnRleHQuc3Ryb2tlKCk7XG5cdFxuXHR2YXIgcmdiID0gdGhpcy5xY2FudmFzLmNvbG9yUmdiKG9iai5maWxsQ29sb3IpLnJlcGxhY2UoJ1JHQignLCcnKS5yZXBsYWNlKCcpJywnJyk7XG5cdFxuXHQob2JqLmZpbGxDb2xvciE9JycpICYmIFxuXHRcdChvYmoub3BhY2l0eSAmJiAodGhpcy5xY2FudmFzLmNvbnRleHQuZmlsbFN0eWxlPVwicmdiYShcIityZ2IrJywnK29iai5vcGFjaXR5K1wiKVwiKSB8fFxuXHRcdCh0aGlzLnFjYW52YXMuY29udGV4dC5maWxsU3R5bGUgPSBvYmouZmlsbENvbG9yKSkgJiZcblx0XHR0aGlzLnFjYW52YXMuY29udGV4dC5maWxsKCk7XG5cblx0dGhpcy5xY2FudmFzLmNvbnRleHQuc2V0TGluZURhc2goW10pO1xuXHRcbn1cdFxuXHRcblx0XG4vKuato+Wkmui+ueW9ouexuy0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gUXBvbHlnb24ocWNhbnZhcyl7XG5cdHRoaXMucXBvbHlnb25WZXJzaW9uID0gJzEuMCc7XG5cdHRoaXMucWNhbnZhcyA9IHFjYW52YXM7XG59XG5RcG9seWdvbi5wcm90b3R5cGUucG9seWdvbiA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXHR2YXIgT1BUSU9OUyA9IHtcblx0XHRcdFRZUEU6J3BvbHlnb24nLFxuXHRcdFx0bGluZVdpZHRoOjEsXG5cdFx0XHRib3JkZXJDb2xvcjonIzAwMCcsXG5cdFx0XHRmaWxsQ29sb3I6J3JlZCcsXG5cdFx0XHRzdGFydDpbMCwwXSxcblx0XHRcdHI6MjAsXG5cdFx0XHRudW06NCxcblx0XHRcdGRyYWc6dHJ1ZSxcblx0XHRcdGRyYWdSYW5nZTpbXSxcblx0XHRcdG9wYWNpdHk6MSxcblx0XHRcdHBvaW50ZXJFdmVudDonYXV0bycsXG5cdFx0XHRkb3duRnVuOmZ1bmN0aW9uKGUscG9zaXRpb24pe1xuXHRcdFx0XHR2YXIgc3RhcnQgPSBfdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMuc3RhcnQpP3RoaXMuc3RhcnQoKTp0aGlzLnN0YXJ0O1xuXHRcdFx0XHR0aGlzLmRpcyA9IFtwb3NpdGlvbi54LXN0YXJ0WzBdLHBvc2l0aW9uLnktc3RhcnRbMV1dO1xuXHRcdFx0fSxcblx0XHRcdG1vdmVGdW46ZnVuY3Rpb24oZSxwb3NpdGlvbil7ICAvL+W9k+mFjee9rmRyYWdlUmFuZ2Xml7YgIOW8gOWni+mZkOWItuWdkOagh1xuXG5cdFx0XHRcdHZhciBkcmFnSXNCb29sID0gX3RoaXMucWNhbnZhcy5pc0Jvb2wodGhpcy5kcmFnKTtcblx0XHRcdFx0dmFyIGRpcyAgPSB0aGlzLmRpcztcblx0XHRcdFx0dmFyIHN0YXJ0ID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLnN0YXJ0KT90aGlzLnN0YXJ0KCk6dGhpcy5zdGFydDtcblx0XHRcdFx0dmFyIHJhbmdlID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLmRyYWdSYW5nZSk/dGhpcy5kcmFnUmFuZ2UoKTp0aGlzLmRyYWdSYW5nZTtcblxuXG5cdFx0XHRcdHZhciB4LHk7XG5cdFx0XHRcdGlmKGRyYWdJc0Jvb2wgJiYgdGhpcy5kcmFnKXtcblx0XHRcdFx0XHQgeCA9IHBvc2l0aW9uLngtZGlzWzBdO1xuXHRcdFx0XHRcdCB5ID0gcG9zaXRpb24ueS1kaXNbMV07XG5cblx0XHRcdFx0XHQgaWYocmFuZ2UubGVuZ3RoID09IDIpeyAgXG5cdFx0XHRcdFx0XHR4ID0geD49cmFuZ2VbMV1bMF0/cmFuZ2VbMV1bMF06eDtcblx0XHRcdFx0XHRcdHggPSB4PD1yYW5nZVswXVswXT9yYW5nZVswXVswXTp4O1xuXG5cdFx0XHRcdFx0XHR5ID0geT49cmFuZ2VbMV1bMV0/cmFuZ2VbMV1bMV06eTtcblx0XHRcdFx0XHRcdHkgPSB5PD1yYW5nZVswXVsxXT9yYW5nZVswXVsxXTp5O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ZWxzZSBpZih0aGlzLmRyYWcgPT0gJ3ZlcnRpY2FsJyl7XG5cdFx0XHRcdFx0IHggPSB0aGlzLnN0YXJ0WzBdO1xuXHRcdFx0XHRcdCB5ID0gcG9zaXRpb24ueS1kaXNbMV07XG5cblxuXHRcdFx0XHRcdCBpZihyYW5nZS5sZW5ndGggPT0gMil7ICAgXG5cblx0XHRcdFx0XHRcdHkgPSB5Pj1yYW5nZVsxXVsxXT9yYW5nZVsxXVsxXTp5O1xuXHRcdFx0XHRcdFx0eSA9IHk8PXJhbmdlWzBdWzFdP3JhbmdlWzBdWzFdOnk7XG5cdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0fWVsc2UgaWYodGhpcy5kcmFnID09ICdob3Jpem9udGFsJyl7XG5cdFx0XHRcdFx0IHggPSBwb3NpdGlvbi54LWRpc1swXTtcblx0XHRcdFx0XHQgeSA9IHRoaXMuc3RhcnRbMV07IFxuXG5cblx0XHRcdFx0XHQgaWYocmFuZ2UubGVuZ3RoID09IDIpeyAgXG5cdFx0XHRcdFx0XHR4ID0geD49cmFuZ2VbMV1bMF0/cmFuZ2VbMV1bMF06eDtcblx0XHRcdFx0XHRcdHggPSB4PD1yYW5nZVswXVswXT9yYW5nZVswXVswXTp4OyBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gXG5cdFx0XHQgXHQvL+WmguaenOWIm+W7uuaXtuS9jee9ruaVsOaNruS+nei1luS6juWIq+eahOWFg+e0oCDpgqPkuYjkuIDml6bmi5bliqjor6XlhYPntKAg5pWw5o2u55qE5L6d6LWW5YWz57O75bCx5Lya5pat5byAIOWIh+iusFxuXHRcdFx0XHR0aGlzLnN0YXJ0ID0gW3gseV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFx0XG5cdHRoaXMucWNhbnZhcy5leHRlbmQoT1BUSU9OUyxvcHRpb25zKTtcblx0dGhpcy5xY2FudmFzLmFwcGVuZFNldEZ1bihPUFRJT05TKTtcblx0XG5cdHJldHVybiBPUFRJT05TO1xufVx0XG5cdFxuXHRcblFwb2x5Z29uLnByb3RvdHlwZS5wYWludFBvbHlnb24gPSBmdW5jdGlvbihvYmope1xuXHR2YXIgY3R4ID0gdGhpcy5xY2FudmFzLmNvbnRleHQ7XG5cdFxuXHR2YXIgeCA9IG9iaiAmJiBvYmouc3RhcnRbMF0gfHwgMDsgIC8v5Lit5b+D54K5eOWdkOagh1xuICAgIHZhciB5ID0gb2JqICYmIG9iai5zdGFydFsxXSB8fCAwOyAgLy/kuK3lv4Pngrl55Z2Q5qCHXG4gICAgdmFyIG51bSA9IG9iaiAmJiBvYmoubnVtIHx8IDM7ICAgLy/lm77lvaLovrnnmoTkuKrmlbBcbiAgICB2YXIgciA9IG9iaiAmJiBvYmouciB8fCAxMDA7ICAgLy/lm77lvaLnmoTljYrlvoRcbiAgICB2YXIgd2lkdGggPSBvYmogJiYgb2JqLmxpbmVXaWR0aCB8fCAxO1xuICAgIHZhciBzdHJva2VTdHlsZSA9IG9iaiAmJiBvYmouYm9yZGVyQ29sb3I7XG4gICAgdmFyIGZpbGxTdHlsZSA9IG9iaiAmJiBvYmouZmlsbENvbG9yO1xuICAgIHZhciBvcGFjaXR5ID0gb2JqICYmIG9iai5vcGFjaXR5O1xuICAgIC8v5byA5aeL6Lev5b6EXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICB2YXIgc3RhcnRYID0geCArIHIgKiBNYXRoLmNvcygyKk1hdGguUEkqMC9udW0pO1xuICAgIHZhciBzdGFydFkgPSB5ICsgciAqIE1hdGguc2luKDIqTWF0aC5QSSowL251bSk7XG4gICAgY3R4Lm1vdmVUbyhzdGFydFgsIHN0YXJ0WSk7XG4gICAgcG9pbnRzLnB1c2goe3g6c3RhcnRYLHk6c3RhcnRZfSk7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8PSBudW07IGkrKykge1xuICAgICAgICB2YXIgbmV3WCA9IHggKyByICogTWF0aC5jb3MoMipNYXRoLlBJKmkvbnVtKTtcbiAgICAgICAgdmFyIG5ld1kgPSB5ICsgciAqIE1hdGguc2luKDIqTWF0aC5QSSppL251bSk7XG4gICAgICAgIGN0eC5saW5lVG8obmV3WCwgbmV3WSk7XG4gICAgICAgIHBvaW50cy5wdXNoKHt4Om5ld1gseTpuZXdZfSk7XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuXG4gICAgLy/pobbngrnlnZDmoIfluo/liJcg55So5LqO54K55Ye75pe255uu5qCH5YWD57Sg55qE5Yik5patXG4gICAgb2JqLnBvbHlQb2ludHMgPSBmdW5jdGlvbigpe1xuICAgIFx0cmV0dXJuIHBvaW50cztcbiAgICB9XG5cblxuXG4gICAgLy/ot6/lvoTpl63lkIhcbiAgICBpZihzdHJva2VTdHlsZSkge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgICAgICBjdHgubGluZUpvaW4gPSAncm91bmQnO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIGlmKGZpbGxTdHlsZSkge1xuXG5cdFx0dmFyIHJnYiA9IHRoaXMucWNhbnZhcy5jb2xvclJnYihmaWxsU3R5bGUpLnJlcGxhY2UoJ1JHQignLCcnKS5yZXBsYWNlKCcpJywnJyk7XG4gXG5cdCAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKFwiK3JnYisnLCcrb2JqLm9wYWNpdHkrXCIpXCI7XG5cdFx0XG5cbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG5cbiBcblx0XG59XHRcdFxuXG4vKuWKqOeUu+exuy0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gUWFuaW1hdGlvbihxY2FudmFzKXtcblx0dGhpcy5xYW5pbWF0aW9uVmVyc2lvbiA9ICcxLjAnO1xuXHR0aGlzLnFjYW52YXMgPSBxY2FudmFzO1xufVx0XG5cblFhbmltYXRpb24ucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbihhaW0sc3RhcnRTdHlsZSxlbmRTdHlsZSxkdXJpbmcsaXNMb29wLHR3ZWVuVHlwZSxmaW5pc2hDYWxsYmFjayl7XG5cdFxuXHQvL+imgeaxgiBzdGFydFN0eWxl5a+56LGh5ZKMZW5kU3R5bGXlr7nosaHlsZ7mgKflv4XpobvmmK/kuIDmoLfnmoRcblx0Ly/luo/liJfluKflr7nosaEo5bGe5oCnPT7lgLwpICBcblx0dmFyIGZyYW1lcyA9IHt9O1xuXHR2YXIgZnJhbWVzQ291bnQgPSB0aGlzLnFjYW52YXMuZnBzICogZHVyaW5nO1xuXHR2YXIgdHdlZW5UeXBlID0gdHlwZW9mIHR3ZWVuVHlwZSAhPSd1bmRlZmluZWQnPyh0d2VlblR5cGU9PScnPydMaW5lYXInOnR3ZWVuVHlwZSk6J0xpbmVhcic7XG5cdC8vIGNvbnNvbGUubG9nKHR3ZWVuVHlwZSk7XG5cdFxuXHR2YXIgdHdlZW4gPSBldmFsKCd0aGlzLnFjYW52YXMuVHdlZW5bXCInK3R3ZWVuVHlwZS5zcGxpdCgnLicpLmpvaW4oJ1wiXVtcIicpKydcIl0nKTtcblx0Ly8gY29uc29sZS5sb2codHdlZW4pO1xuXHRcblx0Zm9yKHZhciBpIGluIHN0YXJ0U3R5bGUpe1xuXHRcdFx0XG5cdFx0XHQvL+WmguaenOaYr+WxnuaAp+eahOWAvOaYr+aVsOe7hOeahCDnlJ/miJDmiJDlr7nnmoTmlbDnu4Tluo/liJcg55So5LqO5riy5p+T5Yqo55S7XG5cdFx0XHRpZih0aGlzLnFjYW52YXMuaXNBcnIoc3RhcnRTdHlsZVtpXSkpe1xuXHRcdFx0XHRmcmFtZXNbaV0gPSBbXTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBwZXJBcnIgPSBbXTtcblx0XHRcdFx0Zm9yKHZhciBqPTA7ajxzdGFydFN0eWxlW2ldLmxlbmd0aDtqKyspe1xuXHRcdFx0XHRcdFx0cGVyQXJyLnB1c2goKGVuZFN0eWxlW2ldW2pdIC0gc3RhcnRTdHlsZVtpXVtqXSkvZnJhbWVzQ291bnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdGZvcih2YXIgdD0wO3Q8ZnJhbWVzQ291bnQ7dCsrKXtcblx0XHRcdFx0XHR2YXIgdGVtcCA9IFtdO1xuXHRcdFx0XHRcdGZvcih2YXIgcD0wO3A8cGVyQXJyLmxlbmd0aDtwKyspe1xuXHRcdFx0XHRcdFx0XHQvL3RlbXAucHVzaChzdGFydFN0eWxlW2ldW3BdKyB0KnBlckFycltwXSk7ICAvL+aaguaXtumDveaYr+e6v+aAp+WPmOWMliBcblx0XHRcdFx0XHRcdHRlbXAucHVzaCh0d2Vlbih0LHN0YXJ0U3R5bGVbaV1bcF0scGVyQXJyW3BdKmZyYW1lc0NvdW50LGZyYW1lc0NvdW50KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGZyYW1lc1tpXS5wdXNoKHRlbXApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvL+WxnuaAp+eahOWAvOaYr+aVsOWtl+eahFxuXHRcdFx0aWYodGhpcy5xY2FudmFzLmlzTnVtKHN0YXJ0U3R5bGVbaV0pKXtcblx0XHRcdFx0ZnJhbWVzW2ldID0gW107XG5cdFx0XHRcdHZhciBwZXIgPSAoZW5kU3R5bGVbaV0gLSBzdGFydFN0eWxlW2ldKS9mcmFtZXNDb3VudDtcblx0XHRcdFx0XG5cdFx0XHRcdGZvcih2YXIgdD0wO3Q8ZnJhbWVzQ291bnQ7dCsrKXtcblx0XHRcdFx0XHRmcmFtZXNbaV0ucHVzaCh0d2Vlbih0LHN0YXJ0U3R5bGVbaV0sZW5kU3R5bGVbaV0gLSBzdGFydFN0eWxlW2ldLGZyYW1lc0NvdW50KSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly9mcmFtZXNbaV0ucHVzaChzdGFydFN0eWxlW2ldKyB0KnBlcik7XG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdH1cblx0XHRcblx0XHRcblx0XHRcblx0XHRcblx0fVxuXHRcblx0YWltLmFuaW1hdGlvbiA9IHtcblx0XHQnZnJhbWVzSW5kZXgnOjAsXG5cdFx0J2ZyYW1lc0NvdW50JzpmcmFtZXNDb3VudCxcblx0XHQnZHVyaW5nJzpkdXJpbmcsXG5cdFx0J2ZyYW1lcyc6ZnJhbWVzLFxuXHRcdCdpc0xvb3AnOmlzTG9vcD9pc0xvb3A6ZmFsc2UsXG5cdFx0J2lzRXhlQ2FsbGJhY2snOmZhbHNlLCAgLy/mmK/lkKblt7LmiafooYzkuoZmaW5pc2hDYWxsYmFja1xuXHRcdCdmaW5pc2hDYWxsYmFjayc6ZmluaXNoQ2FsbGJhY2s/ZmluaXNoQ2FsbGJhY2s6ZnVuY3Rpb24oKXt9XG5cdH1cblx0XG59XG4vL+mAmui/h+WvueixoeeahGFuaW1hdGlvbuWxnuaAp+S4reW6j+WIl+WvueixoWZyYW1lcyDmlLnlj5jnm7jlupTnmoTlsZ7mgKflgLxcbi8v5L2/5riy5p+T6L+H56iL5Lit55Sf5oiQ5Yqo55S7XHRcdFxuUWFuaW1hdGlvbi5wcm90b3R5cGUuY3JlYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24ob2JqKXtcblx0XHRcblx0XHRpZih0eXBlb2Ygb2JqLmFuaW1hdGlvbiAhPSd1bmRlZmluZWQnICYmIG9iai5hbmltYXRpb24gJiYgb2JqLmFuaW1hdGlvbi5mcmFtZXMpe1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGZyYW1lc0luZGV4ID0gb2JqLmFuaW1hdGlvbi5mcmFtZXNJbmRleDtcblx0XHRcdFx0dmFyIGZyYW1lc0NvdW50ID0gb2JqLmFuaW1hdGlvbi5mcmFtZXNDb3VudDtcblx0XHRcdFx0dmFyIGZyYW1lcyA9IG9iai5hbmltYXRpb24uZnJhbWVzO1xuXHRcdFx0XHR2YXIgaXNMb29wID0gb2JqLmFuaW1hdGlvbi5pc0xvb3A7XG5cdFx0XG5cdFx0XHRcdG9iai5hbmltYXRpb24uc3RlcCA9IHR5cGVvZiBvYmouYW5pbWF0aW9uLnN0ZXAgIT0ndW5kZWZpbmVkJz9vYmouYW5pbWF0aW9uLnN0ZXA6MTsvL+aOp+WItuaWueWQkSAgXG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgc3RlcCA9IG9iai5hbmltYXRpb24uc3RlcDtcblx0XHRcdFx0XG5cdFx0XHRcdG9iai5hbmltYXRpb24uZnJhbWVzSW5kZXg9b2JqLmFuaW1hdGlvbi5mcmFtZXNJbmRleCtzdGVwO1xuXHRcdFxuXHRcdFx0XHRvYmouYW5pbWF0aW9uLmZyYW1lc0luZGV4ID0gb2JqLmFuaW1hdGlvbi5mcmFtZXNJbmRleDw9MD8wOm9iai5hbmltYXRpb24uZnJhbWVzSW5kZXg7XG5cdFx0XG5cdFx0XHRcdG9iai5hbmltYXRpb24uZnJhbWVzSW5kZXggPSBvYmouYW5pbWF0aW9uLmZyYW1lc0luZGV4Pj1mcmFtZXNDb3VudD8oZnJhbWVzQ291bnQtMSk6b2JqLmFuaW1hdGlvbi5mcmFtZXNJbmRleDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmKHR5cGVvZiBpc0xvb3AgIT0ndW5kZWZpbmVkJyl7XG5cblx0XHRcdFx0XHRpZih0aGlzLnFjYW52YXMuaXNOdW0oaXNMb29wKSl7IC8v5b6q546v5qyh5pWwXG5cblx0XHRcdFx0XHRcdGlzTG9vcCA9IGlzTG9vcCA+IDA/aXNMb29wOjE7XG5cblx0XHRcdFx0XHRcdGlmKHR5cGVvZiBvYmouYW5pbWF0aW9uLmxvb3BOdW0gPT0ndW5kZWZpbmVkJyl7XG5cdFx0XHRcdFx0XHRcdG9iai5hbmltYXRpb24ubG9vcE51bSA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmKG9iai5hbmltYXRpb24uZnJhbWVzSW5kZXg9PShmcmFtZXNDb3VudC0xKSl7XG5cdFx0XHRcdFx0XHRcdFx0b2JqLmFuaW1hdGlvbi5sb29wTnVtICsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYob2JqLmFuaW1hdGlvbi5sb29wTnVtIDw9IGlzTG9vcCl7XG5cdFx0XHRcdFx0XHRcdFx0XHRvYmouYW5pbWF0aW9uLnN0ZXAgPSAtMTsgLy/lj43mlrnlkJHov5Dliqjlm57ljrtcdFxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGlmKChvYmouYW5pbWF0aW9uLmxvb3BOdW0gLTEpID09IGlzTG9vcCl7XG5cdFx0XHRcdFx0XHRcdFx0XHRvYmouYW5pbWF0aW9uLmZpbmlzaENhbGxiYWNrKG9iaik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZihvYmouYW5pbWF0aW9uLmZyYW1lc0luZGV4ID09IDApe1xuXHRcdFx0XHRcdFx0XHRvYmouYW5pbWF0aW9uLmxvb3BOdW0gKys7XG5cblxuXHRcdFx0XHRcdFx0XHRpZihvYmouYW5pbWF0aW9uLmxvb3BOdW0gPD0gaXNMb29wKXtcblx0XHRcdFx0XHRcdFx0XHRvYmouYW5pbWF0aW9uLnN0ZXAgPSAxOyAvL+WPjeaWueWQkei/kOWKqOWbnuWOu1x0XG5cdFx0XHRcdFx0XHRcdFx0Ly8gb2JqLmFuaW1hdGlvbi5mcmFtZXNJbmRleCA9IDA7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZigob2JqLmFuaW1hdGlvbi5sb29wTnVtIC0xKSA9PSBpc0xvb3Ape1xuXHRcdFx0XHRcdFx0XHRcdG9iai5hbmltYXRpb24uZmluaXNoQ2FsbGJhY2sob2JqKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cblxuXHRcdFx0XHRcdH1lbHNle1xuXG5cdFx0XHRcdFx0XHRpZihpc0xvb3Ape1xuXHRcdFx0XHRcdFx0XHRpZihvYmouYW5pbWF0aW9uLmZyYW1lc0luZGV4PT0oZnJhbWVzQ291bnQtMSkpe1xuXHRcdFx0XHRcdFx0XHRcdG9iai5hbmltYXRpb24uc3RlcCA9IC0xOyAvL+WPjeaWueWQkei/kOWKqOWbnuWOu1x0XG5cdFx0XHRcdFx0XHRcdFx0Ly8gb2JqLmFuaW1hdGlvbi5mcmFtZXNJbmRleCA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0b2JqLmFuaW1hdGlvbi5maW5pc2hDYWxsYmFjayhvYmopO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0aWYob2JqLmFuaW1hdGlvbi5mcmFtZXNJbmRleD09MCl7XG5cdFx0XHRcdFx0XHRcdFx0b2JqLmFuaW1hdGlvbi5zdGVwID0gMTsgXG5cdFx0XHRcdFx0XHRcdFx0b2JqLmFuaW1hdGlvbi5maW5pc2hDYWxsYmFjayhvYmopO1x0XHRcblx0XHRcdFx0XHRcdFx0fVx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0aWYob2JqLmFuaW1hdGlvbi5mcmFtZXNJbmRleD09KGZyYW1lc0NvdW50LTEpKXtcblx0XHRcdFx0XHRcdFx0XHQhb2JqLmFuaW1hdGlvbi5pc0V4ZUNhbGxiYWNrICYmIChvYmouYW5pbWF0aW9uLmlzRXhlQ2FsbGJhY2sgPSB0cnVlKSAmJiBcblx0XHRcdFx0XHRcdFx0XHRvYmouYW5pbWF0aW9uLmZpbmlzaENhbGxiYWNrKG9iaik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblxuXHRcdFxuXHRcdFx0XHR9ZWxzZXtcblxuXHRcdFx0XHRcdGlmKG9iai5hbmltYXRpb24uZnJhbWVzSW5kZXg9PShmcmFtZXNDb3VudC0xKSl7XG5cdFx0XHRcdFx0XHQhb2JqLmFuaW1hdGlvbi5pc0V4ZUNhbGxiYWNrICYmIChvYmouYW5pbWF0aW9uLmlzRXhlQ2FsbGJhY2sgPSB0cnVlKSAmJiBcblx0XHRcdFx0XHRcdG9iai5hbmltYXRpb24uZmluaXNoQ2FsbGJhY2sob2JqKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKGZyYW1lc0luZGV4KTtcblx0XHRcdFx0XG5cdFx0XHRcblx0XHRcdFx0Zm9yKHZhciBpIGluIG9iai5hbmltYXRpb24uZnJhbWVzKXtcblx0XHRcdFx0XHRcdG9ialtpXSA9ICBvYmouYW5pbWF0aW9uLmZyYW1lc1tpXVtmcmFtZXNJbmRleF07XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XG5cdFx0fVxuXHRcdFxufVx0XG5cblx0XG4vKueUu+WbvueJh+exuyovXG5mdW5jdGlvbiBRaW1nKHFjYW52YXMpe1xuXHR0aGlzLnFpbWdWZXJzaW9uID0gJzEuMCc7XG5cdHRoaXMucWNhbnZhcyA9IHFjYW52YXM7XG59XHRcblxuUWltZy5wcm90b3R5cGUuc291cmNlUG9zaXRpb24gPSBmdW5jdGlvbihwaWMsdyxoKXtcblx0XHRcdFxuXHRcdFx0Ly/ljp/lm77lj4rnm67moIfljLrln5/nmoTlrr3pq5jmr5Rcblx0XHRcdHZhciBzb3VyY2VSYXRlID0gcGljLndpZHRoL3BpYy5oZWlnaHQ7XG5cdFx0XHR2YXIgdGFyZ2V0UmF0ZSA9IHcvaDtcblx0XHRcdHZhciB4LHksdyxoO1xuXHRcdFx0XG5cdFx0XHRpZihzb3VyY2VSYXRlPj10YXJnZXRSYXRlKXtcblx0XHRcdFx0XHRoID0gcGljLmhlaWdodDtcblx0XHRcdFx0XHR3ID0gdGFyZ2V0UmF0ZSpwaWMuaGVpZ2h0O1xuXHRcdFx0XHRcdHkgPSAwO1xuXHRcdFx0XHRcdHggPSAocGljLndpZHRoIC0gdykqMC41O1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0dyA9IHBpYy53aWR0aDtcblx0XHRcdFx0XHRoID0gcGljLndpZHRoL3RhcmdldFJhdGU7XG5cdFx0XHRcdFx0eCA9IDA7XG5cdFx0XHRcdFx0eSA9IChwaWMuaGVpZ2h0IC0gaCkqMC41O1xuXHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRcblx0cmV0dXJuIHtcblx0XHRzU3RhcnQ6W3gseV0sXG5cdFx0c1dpZHRoOncsXG5cdFx0c0hlaWdodDpoLFxuXHRcdHNvdXJjZVJhdGU6c291cmNlUmF0ZSxcblx0XHR0YXJnZXRSYXRlOnRhcmdldFJhdGVcblx0fVxuXHRcblx0XG59XG5cblFpbWcucHJvdG90eXBlLmltZyA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXHR2YXIgT1BUSU9OUyA9IHtcblx0XHRcdFRZUEU6J2ltZycsXG5cdFx0XHRpbWc6e30sXG5cdFx0XHRzaXplOlwiXCIsXG5cdFx0XHRkcmFnOnRydWUsXG5cdFx0XHRwb2ludGVyRXZlbnQ6J2F1dG8nLFxuXHRcdFx0ZGVncmVlOjAsXG5cdFx0XHQvKnNTdGFydDpbMCwwXSxcblx0XHRcdHNXaWR0aDpvcHRpb25zLndpZHRoLFxuXHRcdFx0c0hlaWdodDpvcHRpb25zLmhlaWdodCxcblx0XHRcdHRTdGFydDpbMCwwXSxcblx0XHRcdHRXaWR0aDpvcHRpb25zLndpZHRoLFxuXHRcdFx0dEhlaWdodDpvcHRpb25zLmhlaWdodCwqL1xuXHRcdFx0Y2VudGVyUG9pbnRzOmZ1bmN0aW9uKCl7IC8v5YWD57Sg5Lit5b+D54K555u45a+55LqO5pW05Liq55S75biD55qE5Z2Q5qCHXG5cdFx0XHRcdFx0dmFyIHRTdGFydCA9IF90aGlzLnFjYW52YXMuaXNGdW4odGhpcy50U3RhcnQpP3RoaXMudFN0YXJ0KCk6dGhpcy50U3RhcnQ7IFxuXG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHg6dFN0YXJ0WzBdK3RoaXMudFdpZHRoKjAuNSxcblx0XHRcdFx0XHRcdHk6dFN0YXJ0WzFdK3RoaXMudEhlaWdodCowLjVcblx0XHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cdFx0XHRwb2x5UG9pbnRzOmZ1bmN0aW9uKCl7ICAvL+mhtueCueWdkOagh+W6j+WIlyBcblx0XHRcdFx0dmFyIHRTdGFydCA9IF90aGlzLnFjYW52YXMuaXNGdW4odGhpcy50U3RhcnQpP3RoaXMudFN0YXJ0KCk6dGhpcy50U3RhcnQ7XG5cblxuXHRcdFx0XHRcdHZhciBoYWxmX3ggPSB0aGlzLnRXaWR0aCowLjU7XG5cdFx0XHRcdFx0dmFyIGhhbGZfeSA9IHRoaXMudEhlaWdodCowLjU7IFxuXHRcdFx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmNlbnRlclBvaW50cygpO1xuXG5cblx0XHRcdFx0XHR2YXIgdGVtcCA9IDA7XG5cdFx0XHRcdFx0aWYodGhpcy5kZWdyZWUgPDApeyBcblx0XHRcdFx0XHRcdHRlbXAgPSAzNjArdGhpcy5kZWdyZWU7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHR0ZW1wID0gdGhpcy5kZWdyZWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmKCh0ZW1wPjAgJiYgdGVtcDw9OTApIHx8ICh0ZW1wPjE4MCAmJiB0ZW1wPD0yNzApKXtcblxuXHRcdFx0XHRcdFx0aWYodGVtcCA+MTgwKXtcblx0XHRcdFx0XHRcdFx0dGVtcCA9IHRlbXAtMTgwO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgRV94ID0gY2VudGVyLngtTWF0aC5jb3ModGVtcCpNYXRoLlBJLzE4MCkqaGFsZl94O1xuXHRcdFx0XHRcdFx0dmFyIEVfeSA9IGNlbnRlci55LU1hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeDtcblx0XHRcdFx0XHRcdCBcblx0XHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHRcdHt4OkVfeC1NYXRoLnNpbih0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3kseTpFX3krTWF0aC5jb3ModGVtcCpNYXRoLlBJLzE4MCkqaGFsZl95fSxcblx0XHRcdFx0XHRcdFx0e3g6RV94K01hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSx5OkVfeS1NYXRoLmNvcyh0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3l9LFxuXHRcdFx0XHRcdFx0XHR7eDpjZW50ZXIueC0oRV94LU1hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLngseTpjZW50ZXIueS0oRV95K01hdGguY29zKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLnl9LFxuXHRcdFx0XHRcdFx0XHR7eDpjZW50ZXIueC0oRV94K01hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLngseTpjZW50ZXIueS0oRV95LU1hdGguY29zKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLnl9XG5cdFx0XHRcdFx0XHRdO1xuXG5cblxuXHRcdFx0XHRcdH1lbHNlIGlmKCh0ZW1wPjkwICYmIHRlbXA8MTgwKSB8fCAodGVtcD4yNzAgJiYgdGVtcDwzNjApKXtcblxuXHRcdFx0XHRcdFx0aWYodGVtcD4yNzApe1xuXHRcdFx0XHRcdFx0XHR0ZW1wID0gdGVtcC0xODA7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRlbXAgPSAxODAgLSB0ZW1wO1xuXHRcdFx0XHRcdFx0dmFyIEVfeCA9IGNlbnRlci54K01hdGguY29zKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeDtcblx0XHRcdFx0XHRcdHZhciBFX3kgPSBjZW50ZXIueS1NYXRoLnNpbih0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3g7XG4gXG5cblx0XHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHRcdHt4OkVfeC1NYXRoLnNpbih0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3kseTpFX3ktTWF0aC5jb3ModGVtcCpNYXRoLlBJLzE4MCkqaGFsZl95fSxcblx0XHRcdFx0XHRcdFx0e3g6RV94K01hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSx5OkVfeStNYXRoLmNvcyh0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3l9LFxuXHRcdFx0XHRcdFx0XHR7eDpjZW50ZXIueC0oRV94LU1hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLngseTpjZW50ZXIueS0oRV95LU1hdGguY29zKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLnl9LFxuXHRcdFx0XHRcdFx0XHR7eDpjZW50ZXIueC0oRV94K01hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLngseTpjZW50ZXIueS0oRV95K01hdGguY29zKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLnl9XG5cdFx0XHRcdFx0XHRdXG5cblxuXG5cblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRcdFx0e1wieFwiOnRTdGFydFswXSxcInlcIjp0U3RhcnRbMV19LFxuXHRcdFx0XHRcdFx0XHR7XCJ4XCI6dFN0YXJ0WzBdK3RoaXMudFdpZHRoLFwieVwiOnRTdGFydFsxXX0sXG5cdFx0XHRcdFx0XHRcdHtcInhcIjp0U3RhcnRbMF0rdGhpcy50V2lkdGgsXCJ5XCI6dFN0YXJ0WzFdK3RoaXMudEhlaWdodH0sXG5cdFx0XHRcdFx0XHRcdHtcInhcIjp0U3RhcnRbMF0sXCJ5XCI6dFN0YXJ0WzFdK3RoaXMudEhlaWdodH0sXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0fSxcdFxuXHRcdFx0ZG93bkZ1bjpmdW5jdGlvbihlLHBvc2l0aW9uKXtcblx0XHRcdFx0dmFyIHRTdGFydCA9IF90aGlzLnFjYW52YXMuaXNGdW4odGhpcy50U3RhcnQpP3RoaXMudFN0YXJ0KCk6dGhpcy50U3RhcnQ7XG5cdFx0XHRcdHRoaXMuZGlzID0gW3Bvc2l0aW9uLngtdFN0YXJ0WzBdLHBvc2l0aW9uLnktdFN0YXJ0WzFdXTtcblx0XHRcdH0sXG5cdFx0XHRtb3ZlRnVuOmZ1bmN0aW9uKGUscG9zaXRpb24pe1xuXHRcdFx0XHRcdHZhciBkcmFnSXNCb29sID0gX3RoaXMucWNhbnZhcy5pc0Jvb2wodGhpcy5kcmFnKTtcblx0XHRcdFx0XHR2YXIgZGlzICA9IHRoaXMuZGlzOyBcblxuXHRcdFx0XHRcdGlmKGRyYWdJc0Jvb2wgJiYgdGhpcy5kcmFnKXtcblx0XHRcdFx0XHRcdHRoaXMudFN0YXJ0WzBdID0gcG9zaXRpb24ueC1kaXNbMF07XG5cdFx0XHRcdFx0XHR0aGlzLnRTdGFydFsxXSA9IHBvc2l0aW9uLnktZGlzWzFdO1xuXHRcdFx0XHRcdH1lbHNlIGlmKHRoaXMuZHJhZyA9PSAndmVydGljYWwnKXtcblx0XHRcdFx0XHRcdCB0aGlzLnRTdGFydFsxXSA9IHBvc2l0aW9uLnktZGlzWzFdO1xuXG5cdFx0XHRcdFx0fWVsc2UgaWYodGhpcy5kcmFnID09ICdob3Jpem9udGFsJyl7XG5cdFx0XHRcdFx0XHQgdGhpcy50U3RhcnRbMF0gPSBwb3NpdGlvbi54LWRpc1swXTtcblx0XHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdC8v5Y2g5L2N5Zu+5pu/5o2i5o6Jb3B0aW9ucy5pbWdcblx0dmFyIHRtcCA9ICcnO1xuXHRpZih0aGlzLnFjYW52YXMuaXNTdHIob3B0aW9ucy5pbWcpKXtcblx0XHR0bXAgPSBvcHRpb25zLmltZztcblx0XHRvcHRpb25zLmltZyA9IHRoaXMucWNhbnZhcy5wbGFjZUhvbGRlckltZztcblx0fVxuXHRcdFxuXHRcdFx0XG5cdHRoaXMucWNhbnZhcy5leHRlbmQoT1BUSU9OUyxvcHRpb25zKTtcblx0dGhpcy5xY2FudmFzLmFwcGVuZFNldEZ1bihPUFRJT05TKTtcblxuXG5cdC8v5aaC5p6c5oyH5a6a55qEaW1n5Y+C5pWw5piv5LiA5Liq5Zu+54mH5Zyw5Z2AIOWImemcgOimgeWOu+WKoOi9vSDlrozmiJDlkI7mm7/mib7mjolPUFRJT05TLmltZ1xuXHRpZih0bXAgIT0nJyl7XG5cdFx0T1BUSU9OUy5zV2lkdGggPSAxO1xuXHRcdE9QVElPTlMuc0hlaWdodCA9IDE7XG4gXG5cdFx0dGhpcy5xY2FudmFzLmxvYWRJbWdTb3VyY2UodG1wKS50aGVuKGZ1bmN0aW9uKGltZyl7XG5cdFx0XHR2YXIgaW1nID0gaW1nWzBdO1xuXHRcdFx0T1BUSU9OUy5zV2lkdGggPSBpbWcud2lkdGg7XG5cdFx0XHRPUFRJT05TLnNIZWlnaHQgPSBpbWcuaGVpZ2h0O1xuXHRcdFx0T1BUSU9OUy5pbWcgPSBpbWc7XG5cblxuXHRcdFx0aWYoT1BUSU9OUy5zaXplIT0nJyl7XG5cdFx0XHRcdFxuXHRcdFx0XHQvL+mHjeaWsOiuoeeul3NTdGFydCBzV2lkdGggc0hlaWdodFxuXHRcdFx0XHQvL+WFqOimhuebluebruagh+WMuuWfnyDlm77lg4/nmoTmn5Dkupvpg6jliIbkuZ/orrjml6Dms5XmmL7npLrlnKjnm67moIfljLrln5/kuK1cblx0XHRcdFx0aWYoT1BUSU9OUy5zaXplID09J2NvdmVyJyl7IFxuXHRcdFx0XHRcdFx0ZGVsZXRlIE9QVElPTlMuc1N0YXJ0O1xuXHRcdFx0XHRcdCAgXHRkZWxldGUgT1BUSU9OUy5zV2lkdGg7XG5cdFx0XHRcdFx0XHRkZWxldGUgT1BUSU9OUy5zSGVpZ2h0O1xuXHRcdFx0XHRcdCAgXG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHZhciBzb3VyY2VPYmogPSBfdGhpcy5zb3VyY2VQb3NpdGlvbihPUFRJT05TLmltZyxPUFRJT05TLnRXaWR0aCxPUFRJT05TLnRIZWlnaHQpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdE9QVElPTlMuc1N0YXJ0ID0gc291cmNlT2JqLnNTdGFydDtcblx0XHRcdFx0XHRcdE9QVElPTlMuc1dpZHRoID0gc291cmNlT2JqLnNXaWR0aDtcblx0XHRcdFx0XHRcdE9QVElPTlMuc0hlaWdodCA9IHNvdXJjZU9iai5zSGVpZ2h0O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0fVxuXG5cdFx0fSxmdW5jdGlvbigpe1xuXHRcdFx0Y29uc29sZS5sb2coJ+WKoOi9vei1hOa6kOWksei0pScpXG5cdFx0fSlcblx0XHQvLyB0aGlzLnFjYW52YXMubG9hZCh7aW1nOnRtcH0sZnVuY3Rpb24oKXtcblx0XHQvLyBcdHZhciBpbWcgPSBfdGhpcy5xY2FudmFzLmdldFNvdXJjZUJ5TmFtZShcImltZ1wiKTtcblxuXHRcdC8vIFx0T1BUSU9OUy5zV2lkdGggPSBpbWcud2lkdGg7XG5cdFx0Ly8gXHRPUFRJT05TLnNIZWlnaHQgPSBpbWcuaGVpZ2h0O1xuXHRcdC8vIFx0T1BUSU9OUy5pbWcgPSBpbWc7XG5cblxuXHRcdC8vIFx0aWYoT1BUSU9OUy5zaXplIT0nJyl7XG5cdFx0XHRcdFxuXHRcdC8vIFx0XHQvL+mHjeaWsOiuoeeul3NTdGFydCBzV2lkdGggc0hlaWdodFxuXHRcdC8vIFx0XHQvL+WFqOimhuebluebruagh+WMuuWfnyDlm77lg4/nmoTmn5Dkupvpg6jliIbkuZ/orrjml6Dms5XmmL7npLrlnKjnm67moIfljLrln5/kuK1cblx0XHQvLyBcdFx0aWYoT1BUSU9OUy5zaXplID09J2NvdmVyJyl7IFxuXHRcdC8vIFx0XHRcdFx0ZGVsZXRlIE9QVElPTlMuc1N0YXJ0O1xuXHRcdC8vIFx0XHRcdCAgXHRkZWxldGUgT1BUSU9OUy5zV2lkdGg7XG5cdFx0Ly8gXHRcdFx0XHRkZWxldGUgT1BUSU9OUy5zSGVpZ2h0O1xuXHRcdFx0XHRcdCAgXG5cdFx0XHRcdFx0XHRcblx0XHQvLyBcdFx0XHRcdHZhciBzb3VyY2VPYmogPSBfdGhpcy5zb3VyY2VQb3NpdGlvbihPUFRJT05TLmltZyxPUFRJT05TLnRXaWR0aCxPUFRJT05TLnRIZWlnaHQpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcblx0XHQvLyBcdFx0XHRcdE9QVElPTlMuc1N0YXJ0ID0gc291cmNlT2JqLnNTdGFydDtcblx0XHQvLyBcdFx0XHRcdE9QVElPTlMuc1dpZHRoID0gc291cmNlT2JqLnNXaWR0aDtcblx0XHQvLyBcdFx0XHRcdE9QVElPTlMuc0hlaWdodCA9IHNvdXJjZU9iai5zSGVpZ2h0O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdC8vIFx0XHR9XG5cdFx0XHRcblx0XHRcdFxuXHRcdC8vIFx0fVxuXG5cblxuXHRcdC8vIH0pXG4gICAgfSBcblx0XG5cdFxuXHRpZihPUFRJT05TLnNpemUhPScnKXtcblx0XHRcblx0XHQvL+mHjeaWsOiuoeeul3NTdGFydCBzV2lkdGggc0hlaWdodFxuXHRcdC8v5YWo6KaG55uW55uu5qCH5Yy65Z+fIOWbvuWDj+eahOafkOS6m+mDqOWIhuS5n+iuuOaXoOazleaYvuekuuWcqOebruagh+WMuuWfn+S4rVxuXHRcdGlmKE9QVElPTlMuc2l6ZSA9PSdjb3ZlcicpeyBcblx0XHRcdFx0ZGVsZXRlIE9QVElPTlMuc1N0YXJ0O1xuXHRcdFx0ICBcdGRlbGV0ZSBPUFRJT05TLnNXaWR0aDtcblx0XHRcdFx0ZGVsZXRlIE9QVElPTlMuc0hlaWdodDtcblx0XHRcdCAgXG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgc291cmNlT2JqID0gdGhpcy5zb3VyY2VQb3NpdGlvbihPUFRJT05TLmltZyxPUFRJT05TLnRXaWR0aCxPUFRJT05TLnRIZWlnaHQpO1xuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdE9QVElPTlMuc1N0YXJ0ID0gc291cmNlT2JqLnNTdGFydDtcblx0XHRcdFx0T1BUSU9OUy5zV2lkdGggPSBzb3VyY2VPYmouc1dpZHRoO1xuXHRcdFx0XHRPUFRJT05TLnNIZWlnaHQgPSBzb3VyY2VPYmouc0hlaWdodDtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRcblx0XHR9XG5cdFxuXHRcblx0fVxuXHRcblx0cmV0dXJuIE9QVElPTlM7XG59XHRcblFpbWcucHJvdG90eXBlLnBhaW50SW1nID0gZnVuY3Rpb24ob2JqKXsgXG5cdFxuXHR2YXIgdFN0YXJ0ID0gdGhpcy5xY2FudmFzLmlzRnVuKG9iai50U3RhcnQpP29iai50U3RhcnQoKTpvYmoudFN0YXJ0O1xuXG5cblx0Ly/mnInop5Lluqbml7Yg56e75Yqo55S75biD5Y6f54K5IOaXi+i9rOeUu+W4g1xuXHR2YXIgY2VudGVyUG9zID0gdGhpcy5xY2FudmFzLnNldERlZ3JlZShvYmopOyAgIFxuXHQgXG5cblx0dGhpcy5xY2FudmFzLmNvbnRleHQuZHJhd0ltYWdlKG9iai5pbWcsb2JqLnNTdGFydFswXSxvYmouc1N0YXJ0WzFdLG9iai5zV2lkdGgsb2JqLnNIZWlnaHQsdFN0YXJ0WzBdLHRTdGFydFsxXSxvYmoudFdpZHRoLG9iai50SGVpZ2h0KTtcblx0XG5cblx0Ly8gLy/ph43nva7nlLvluIPljp/ngrkg5peL6L2s5aSN5Y6fXG5cdHRoaXMucWNhbnZhcy5yZXNldERlZ3JlZShvYmosY2VudGVyUG9zKTsgXG59XHRcblx0XG4vKueyvueBteexuy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gUXNwaXJpdChxY2FudmFzKXtcblx0dGhpcy5xc3Bpcml0VmVyc2lvbiA9ICcxLjAnO1xuXHR0aGlzLnFjYW52YXMgPSBxY2FudmFzO1xufVxuUXNwaXJpdC5wcm90b3R5cGUuc3Bpcml0ID0gZnVuY3Rpb24ob3B0aW9ucyl7XG5cdHZhciBfdGhpcyA9IHRoaXM7XG5cdHZhciBPUFRJT05TID0ge1xuXHRcdFx0VFlQRTonc3Bpcml0Jyxcblx0XHRcdHN0b3A6ZnVuY3Rpb24oKXt0aGlzLmlzTG9vcCA9IGZhbHNlfSxcblx0XHRcdHBsYXk6ZnVuY3Rpb24oKXt0aGlzLmlzTG9vcCA9IHRydWV9LFxuXHRcdCAgXHRkcmFnOnRydWUsXG5cdFx0ICBcdHBvaW50ZXJFdmVudDonYXV0bycsXG5cdFx0XHRkZWdyZWU6MCxcblxuXHRcdFx0LyppbWc6e30sXG5cdFx0XHRyb3c6MCxcblx0XHRcdGNvbHVtbjowLFxuXHRcdFx0ZnJhbWVJbmRleDpbXSxcblx0XHRcdGlzTG9vcDp0cnVlLFxuXHRcdFx0ZHVyaW5nOjIqL1xuXHRcdFx0Y2VudGVyUG9pbnRzOmZ1bmN0aW9uKCl7IC8v5YWD57Sg5Lit5b+D54K555u45a+55LqO5pW05Liq55S75biD55qE5Z2Q5qCHXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHg6dGhpcy50U3RhcnRbMF0rdGhpcy50V2lkdGgqMC41LFxuXHRcdFx0XHRcdFx0eTp0aGlzLnRTdGFydFsxXSt0aGlzLnRIZWlnaHQqMC41XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHR9LFxuXHRcdFx0cG9seVBvaW50czpmdW5jdGlvbigpeyAgLy/pobbngrnlnZDmoIfluo/liJdcblxuXHRcdFx0XHRcdHZhciBoYWxmX3ggPSB0aGlzLnRXaWR0aCowLjU7XG5cdFx0XHRcdFx0dmFyIGhhbGZfeSA9IHRoaXMudEhlaWdodCowLjU7IFxuXHRcdFx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmNlbnRlclBvaW50cygpO1xuXG5cblx0XHRcdFx0XHR2YXIgdGVtcCA9IDA7XG5cdFx0XHRcdFx0aWYodGhpcy5kZWdyZWUgPDApeyBcblx0XHRcdFx0XHRcdHRlbXAgPSAzNjArdGhpcy5kZWdyZWU7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHR0ZW1wID0gdGhpcy5kZWdyZWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmKCh0ZW1wPjAgJiYgdGVtcDw9OTApIHx8ICh0ZW1wPjE4MCAmJiB0ZW1wPD0yNzApKXtcblxuXHRcdFx0XHRcdFx0aWYodGVtcCA+MTgwKXtcblx0XHRcdFx0XHRcdFx0dGVtcCA9IHRlbXAtMTgwO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgRV94ID0gY2VudGVyLngtTWF0aC5jb3ModGVtcCpNYXRoLlBJLzE4MCkqaGFsZl94O1xuXHRcdFx0XHRcdFx0dmFyIEVfeSA9IGNlbnRlci55LU1hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeDtcblx0XHRcdFx0XHRcdCBcblx0XHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHRcdHt4OkVfeC1NYXRoLnNpbih0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3kseTpFX3krTWF0aC5jb3ModGVtcCpNYXRoLlBJLzE4MCkqaGFsZl95fSxcblx0XHRcdFx0XHRcdFx0e3g6RV94K01hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSx5OkVfeS1NYXRoLmNvcyh0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3l9LFxuXHRcdFx0XHRcdFx0XHR7eDpjZW50ZXIueC0oRV94LU1hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLngseTpjZW50ZXIueS0oRV95K01hdGguY29zKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLnl9LFxuXHRcdFx0XHRcdFx0XHR7eDpjZW50ZXIueC0oRV94K01hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLngseTpjZW50ZXIueS0oRV95LU1hdGguY29zKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLnl9XG5cdFx0XHRcdFx0XHRdO1xuXG5cblxuXHRcdFx0XHRcdH1lbHNlIGlmKCh0ZW1wPjkwICYmIHRlbXA8MTgwKSB8fCAodGVtcD4yNzAgJiYgdGVtcDwzNjApKXtcblxuXHRcdFx0XHRcdFx0aWYodGVtcD4yNzApe1xuXHRcdFx0XHRcdFx0XHR0ZW1wID0gdGVtcC0xODA7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRlbXAgPSAxODAgLSB0ZW1wO1xuXHRcdFx0XHRcdFx0dmFyIEVfeCA9IGNlbnRlci54K01hdGguY29zKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeDtcblx0XHRcdFx0XHRcdHZhciBFX3kgPSBjZW50ZXIueS1NYXRoLnNpbih0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3g7XG4gXG5cblx0XHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHRcdHt4OkVfeC1NYXRoLnNpbih0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3kseTpFX3ktTWF0aC5jb3ModGVtcCpNYXRoLlBJLzE4MCkqaGFsZl95fSxcblx0XHRcdFx0XHRcdFx0e3g6RV94K01hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSx5OkVfeStNYXRoLmNvcyh0ZW1wKk1hdGguUEkvMTgwKSpoYWxmX3l9LFxuXHRcdFx0XHRcdFx0XHR7eDpjZW50ZXIueC0oRV94LU1hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLngseTpjZW50ZXIueS0oRV95LU1hdGguY29zKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLnl9LFxuXHRcdFx0XHRcdFx0XHR7eDpjZW50ZXIueC0oRV94K01hdGguc2luKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLngseTpjZW50ZXIueS0oRV95K01hdGguY29zKHRlbXAqTWF0aC5QSS8xODApKmhhbGZfeSkrY2VudGVyLnl9XG5cdFx0XHRcdFx0XHRdXG5cblxuXG5cblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRcdFx0e1wieFwiOnRoaXMudFN0YXJ0WzBdLFwieVwiOnRoaXMudFN0YXJ0WzFdfSxcblx0XHRcdFx0XHRcdFx0e1wieFwiOnRoaXMudFN0YXJ0WzBdK3RoaXMudFdpZHRoLFwieVwiOnRoaXMudFN0YXJ0WzFdfSxcblx0XHRcdFx0XHRcdFx0e1wieFwiOnRoaXMudFN0YXJ0WzBdK3RoaXMudFdpZHRoLFwieVwiOnRoaXMudFN0YXJ0WzFdK3RoaXMudEhlaWdodH0sXG5cdFx0XHRcdFx0XHRcdHtcInhcIjp0aGlzLnRTdGFydFswXSxcInlcIjp0aGlzLnRTdGFydFsxXSt0aGlzLnRIZWlnaHR9LFxuXHRcdFx0XHRcdFx0XTtcblx0XHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0bW92ZUZyYW1lSW5kZXg6ZnVuY3Rpb24ob2JqKXtcblx0XHRcdFx0b2JqLnN0ZXAgPSB0eXBlb2Ygb2JqLnN0ZXAgIT0ndW5kZWZpbmVkJz9vYmouc3RlcDoxOy8v5o6n5Yi25pa55ZCRICBcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHR2YXIgc3RlcCA9IG9iai5zdGVwO1xuXHRcdFx0XHR2YXIgbWF4ID0gb2JqLmZyYW1lc1tvYmouZnJhbWVzSW5kZXhbMF1dLmxlbmd0aDtcblx0XHRcdFx0XG5cdFx0XHRcdG9iai5mcmFtZXNJbmRleFsxXSA9IG9iai5mcmFtZXNJbmRleFsxXStzdGVwO1xuXHRcdFx0ICBcdG9iai5mcmFtZXNJbmRleFsxXSA9IG9iai5mcmFtZXNJbmRleFsxXTw9MD8wOm9iai5mcmFtZXNJbmRleFsxXTtcblx0XHRcdFx0b2JqLmZyYW1lc0luZGV4WzFdID0gb2JqLmZyYW1lc0luZGV4WzFdPj1tYXg/KG1heC0xKTpvYmouZnJhbWVzSW5kZXhbMV07XG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFxuXHRcdFx0XHRpZihvYmouaXNMb29wKXtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZihvYmouZnJhbWVzSW5kZXhbMV09PShtYXgtMSkpe1xuXHRcdFx0XHRcdFx0XHQvL29iai5zdGVwPS0xO1xuXHRcdFx0XHRcdFx0XHRvYmouZnJhbWVzSW5kZXhbMV0gPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZihvYmouZnJhbWVzSW5kZXhbMV09PTApe1xuXHRcdFx0XHRcdFx0XHRcdG9iai5zdGVwID0gMTsgXHRcdFxuXHRcdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0XHR9XHRcblx0XHRcdH0sXG5cdFx0XHRkb3duRnVuOmZ1bmN0aW9uKGUscG9zaXRpb24pe1xuXHRcdFx0XHR2YXIgdFN0YXJ0ID0gX3RoaXMucWNhbnZhcy5pc0Z1bih0aGlzLnRTdGFydCk/dGhpcy50U3RhcnQoKTp0aGlzLnRTdGFydDtcblx0XHRcdFx0dGhpcy5kaXMgPSBbcG9zaXRpb24ueC10U3RhcnRbMF0scG9zaXRpb24ueS10U3RhcnRbMV1dO1xuXHRcdFx0fSxcblx0XHRcdG1vdmVGdW46ZnVuY3Rpb24oZSxwb3NpdGlvbil7XG5cdFx0XHRcdFx0dmFyIGRyYWdJc0Jvb2wgPSBfdGhpcy5xY2FudmFzLmlzQm9vbCh0aGlzLmRyYWcpO1xuXHRcdFx0XHRcdHZhciBkaXMgID0gdGhpcy5kaXM7IFxuXG5cdFx0XHRcdFx0aWYoZHJhZ0lzQm9vbCAmJiB0aGlzLmRyYWcpe1xuXHRcdFx0XHRcdFx0dGhpcy50U3RhcnRbMF0gPSBwb3NpdGlvbi54LWRpc1swXTtcblx0XHRcdFx0XHRcdHRoaXMudFN0YXJ0WzFdID0gcG9zaXRpb24ueS1kaXNbMV07XG5cdFx0XHRcdFx0fWVsc2UgaWYodGhpcy5kcmFnID09ICd2ZXJ0aWNhbCcpe1xuXHRcdFx0XHRcdFx0IHRoaXMudFN0YXJ0WzFdID0gcG9zaXRpb24ueS1kaXNbMV07XG5cblx0XHRcdFx0XHR9ZWxzZSBpZih0aGlzLmRyYWcgPT0gJ2hvcml6b250YWwnKXtcblx0XHRcdFx0XHRcdCB0aGlzLnRTdGFydFswXSA9IHBvc2l0aW9uLngtZGlzWzBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0XG5cdFx0fVxuXG5cdC8v5Y2g5L2N5Zu+5pu/5o2i5o6Jb3B0aW9ucy5pbWdcblx0dmFyIHRtcCA9ICcnO1xuXHRpZih0aGlzLnFjYW52YXMuaXNTdHIob3B0aW9ucy5pbWcpKXtcblx0XHR0bXAgPSBvcHRpb25zLmltZztcblx0XHRvcHRpb25zLmltZyA9IHRoaXMucWNhbnZhcy5wbGFjZUhvbGRlckltZztcblx0fVxuXHRcdFx0XG5cdHRoaXMucWNhbnZhcy5leHRlbmQoT1BUSU9OUyxvcHRpb25zKTtcblx0dGhpcy5xY2FudmFzLmFwcGVuZFNldEZ1bihPUFRJT05TKTtcblxuXHQvL+WmguaenOaMh+WumueahGltZ+WPguaVsOaYr+S4gOS4quWbvueJh+WcsOWdgCDliJnpnIDopoHljrvliqDovb0g5a6M5oiQ5ZCO5pu/5om+5o6JT1BUSU9OUy5pbWdcblx0aWYodG1wICE9JycpeyBcblxuXHRcdHRoaXMucWNhbnZhcy5sb2FkKHtpbWc6dG1wfSxmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGltZyA9IF90aGlzLnFjYW52YXMuZ2V0U291cmNlQnlOYW1lKFwiaW1nXCIpO1xuIFxuXHRcdFx0T1BUSU9OUy5pbWcgPSBpbWc7XG5cdFx0XHRfdGhpcy5jcmVhdGVGcmFtZXMoT1BUSU9OUyk7IFxuXG5cdFx0fSlcbiAgICB9IFxuXHRcblx0IFxuXG5cblxuXHRcblx0dGhpcy5jcmVhdGVGcmFtZXMoT1BUSU9OUyk7XG5cdFxuXHRyZXR1cm4gT1BUSU9OUztcbn1cdFxuXG5Rc3Bpcml0LnByb3RvdHlwZS5jcmVhdGVGcmFtZXMgPSBmdW5jdGlvbihvYmope1xuXHRcblx0dmFyIGZyYW1lV2lkdGggPSBvYmouaW1nLndpZHRoL29iai5jb2x1bW47XG5cdHZhciBmcmFtZUhlaWdodCA9IG9iai5pbWcuaGVpZ2h0L29iai5yb3c7XG5cdFxuXHR2YXIgZnJhbWVzQ291bnQgPSB0aGlzLnFjYW52YXMuZnBzICogb2JqLmR1cmluZztcblx0XG5cdHZhciBudW0gPSAxO1xuXHRpZihmcmFtZXNDb3VudD5vYmouY29sdW1uKXtcblx0XHRcdG51bSA9IE1hdGguZmxvb3IoZnJhbWVzQ291bnQvb2JqLmNvbHVtbik7XG5cdH1cblx0XG5cdFxuXHRcblx0Ly/nlJ/miJDkuoznu7TlnZDmoIfmlbDnu4Rcblx0dmFyIGZyYW1lcyA9IFtdO1xuXHRmb3IodmFyIGk9MDsgaTxvYmoucm93O2krKyl7XG5cdFx0ZnJhbWVzW2ldID0gW107XG5cdFx0Zm9yKHZhciBqPTA7IGo8b2JqLmNvbHVtbjtqKyspe1xuXHRcdFx0XG5cdFx0XHQvL+S4uuS6huaOp+WItumAn+W6piDliqDlhaXlkIzmoLfnmoTluo/liJfluKdcblx0XHRcdGZvcih2YXIgdD0wOyB0PG51bTt0Kyspe1xuXHRcdFx0XHRmcmFtZXNbaV0ucHVzaChbaipmcmFtZVdpZHRoLGkqZnJhbWVIZWlnaHRdKTtcblx0XHRcdFx0Ly9mcmFtZXNbaV0ucHVzaChbaSpmcmFtZUhlaWdodCxqKmZyYW1lV2lkdGhdKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdH1cblx0fVxuXHRcblx0b2JqLmZyYW1lc0luZGV4ID0gdHlwZW9mIG9iai5mcmFtZXNJbmRleD09J3VuZGVmaW5lZCc/WzAsMF06b2JqLmZyYW1lc0luZGV4O1xuXHRvYmouZnJhbWVzID0gZnJhbWVzO1xufVxuXHRcblFzcGlyaXQucHJvdG90eXBlLm1vdmVGcmFtZUluZGV4ID0gZnVuY3Rpb24ob2JqKXtcblx0XHRcblx0XHRvYmouc3RlcCA9IHR5cGVvZiBvYmouc3RlcCAhPSd1bmRlZmluZWQnP29iai5zdGVwOjE7Ly/mjqfliLbmlrnlkJEgIFxuXHRcdFx0XHRcblx0XHR2YXIgc3RlcCA9IG9iai5zdGVwO1xuXHRcdHZhciBtYXggPSBvYmouZnJhbWVzW29iai5mcmFtZXNJbmRleFswXV0ubGVuZ3RoO1xuXHRcdFxuXHRcdG9iai5mcmFtZXNJbmRleFsxXSA9IG9iai5mcmFtZXNJbmRleFsxXStzdGVwO1xuXHQgIFx0b2JqLmZyYW1lc0luZGV4WzFdID0gb2JqLmZyYW1lc0luZGV4WzFdPD0wPzA6b2JqLmZyYW1lc0luZGV4WzFdO1xuXHRcdG9iai5mcmFtZXNJbmRleFsxXSA9IG9iai5mcmFtZXNJbmRleFsxXT49bWF4PyhtYXgtMSk6b2JqLmZyYW1lc0luZGV4WzFdO1xuXHRcdFxuXHRcdFxuXHRcblx0XHRpZihvYmouaXNMb29wKXtcblx0XHRcdFxuXHRcdFx0aWYob2JqLmZyYW1lc0luZGV4WzFdPT0obWF4LTEpKXtcblx0XHRcdFx0XHQvL29iai5zdGVwPS0xO1xuXHRcdFx0XHRcdG9iai5mcmFtZXNJbmRleFsxXSA9IDA7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmKG9iai5mcmFtZXNJbmRleFsxXT09MCl7XG5cdFx0XHRcdFx0XHRvYmouc3RlcCA9IDE7IFx0XHRcblx0XHRcdH1cblx0XG5cdFx0fVx0XG5cdFxufVx0XHRcblx0XG5cdFxuUXNwaXJpdC5wcm90b3R5cGUucGFpbnRTcGlyaXQgPSBmdW5jdGlvbihvYmope1xuXHRcdHRoaXMucWNhbnZhcy5xYW5pbWF0aW9uLmNyZWF0ZUFuaW1hdGlvbihvYmopO1xuXG5cdFx0dmFyIG1vdmVGcmFtZUluZGV4ID0gZnVuY3Rpb24ob2JqKXtcblx0XHRcdG9iai5zdGVwID0gdHlwZW9mIG9iai5zdGVwICE9J3VuZGVmaW5lZCc/b2JqLnN0ZXA6MTsvL+aOp+WItuaWueWQkSAgXG5cdFx0XHRcdFx0XG5cdFx0XHR2YXIgc3RlcCA9IG9iai5zdGVwO1xuXHRcdFx0dmFyIG1heCA9IG9iai5mcmFtZXNbb2JqLmZyYW1lc0luZGV4WzBdXS5sZW5ndGg7XG5cdFx0XHRcblx0XHRcdG9iai5mcmFtZXNJbmRleFsxXSA9IG9iai5mcmFtZXNJbmRleFsxXStzdGVwO1xuXHRcdCAgXHRvYmouZnJhbWVzSW5kZXhbMV0gPSBvYmouZnJhbWVzSW5kZXhbMV08PTA/MDpvYmouZnJhbWVzSW5kZXhbMV07XG5cdFx0XHRvYmouZnJhbWVzSW5kZXhbMV0gPSBvYmouZnJhbWVzSW5kZXhbMV0+PW1heD8obWF4LTEpOm9iai5mcmFtZXNJbmRleFsxXTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XG5cdFx0XHRpZihvYmouaXNMb29wKXtcblx0XHRcdFx0XG5cdFx0XHRcdGlmKG9iai5mcmFtZXNJbmRleFsxXT09KG1heC0xKSl7XG5cdFx0XHRcdFx0XHQvL29iai5zdGVwPS0xO1xuXHRcdFx0XHRcdFx0b2JqLmZyYW1lc0luZGV4WzFdID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYob2JqLmZyYW1lc0luZGV4WzFdPT0wKXtcblx0XHRcdFx0XHRcdFx0b2JqLnN0ZXAgPSAxOyBcdFx0XG5cdFx0XHRcdH1cblx0XHRcblx0XHRcdH1cdFxuXHRcdH1cblx0XHQvLyB0aGlzLm1vdmVGcmFtZUluZGV4KG9iaik7XG5cdFx0b2JqLm1vdmVGcmFtZUluZGV4KG9iaik7XG5cblx0XHRcblx0Ly9jb25zb2xlLmxvZyhvYmouZnJhbWVzSW5kZXgpO1xuXHRcblx0XG5cdFx0dmFyIHN4ID0gb2JqLmZyYW1lc1tvYmouZnJhbWVzSW5kZXhbMF1dW29iai5mcmFtZXNJbmRleFsxXV1bMF07XG5cdFx0dmFyIHN5ID0gb2JqLmZyYW1lc1tvYmouZnJhbWVzSW5kZXhbMF1dW29iai5mcmFtZXNJbmRleFsxXV1bMV07XG5cdFx0dmFyIHNXaWR0aCA9IG9iai5pbWcud2lkdGgvb2JqLmNvbHVtbjsvL29iai50V2lkdGg7XG5cdFx0dmFyIHNIZWlnaHQgPSBvYmouaW1nLmhlaWdodC9vYmoucm93Oy8vb2JqLnRIZWlnaHQ7XG5cdFxuXHRcdC8vY29uc29sZS5sb2cob2JqLmZyYW1lc1tvYmouZnJhbWVzSW5kZXhbMV1dW29iai5mcmFtZXNJbmRleFswXV0pO1xuXHRcdFxuXHRcdC8v5pyJ6KeS5bqm5pe2IOenu+WKqOeUu+W4g+WOn+eCuSDml4vovaznlLvluINcblx0XHR2YXIgY2VudGVyUG9zID0gdGhpcy5xY2FudmFzLnNldERlZ3JlZShvYmopOyAgIFxuXHRcdCBcblx0XG5cdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuZHJhd0ltYWdlKG9iai5pbWcsc3gsc3ksc1dpZHRoLHNIZWlnaHQsb2JqLnRTdGFydFswXSxvYmoudFN0YXJ0WzFdLG9iai50V2lkdGgsb2JqLnRIZWlnaHQpO1xuXG5cdFx0Ly8gLy/ph43nva7nlLvluIPljp/ngrkg5peL6L2s5aSN5Y6fXG5cdFx0dGhpcy5xY2FudmFzLnJlc2V0RGVncmVlKG9iaixjZW50ZXJQb3MpO1xufVx0XG5cdFxuXG4vKlFldmVudOexuy0tLS0tLS0tLSovXG5mdW5jdGlvbiBRZXZlbnQocWNhbnZhcyl7XG5cdHRoaXMucWV2ZW50VmVyc2lvbiA9ICcxLjAnO1xuXHR0aGlzLnFjYW52YXMgPSBxY2FudmFzO1xuXHR0aGlzLnRyaWdnZXJFbGVUeXBlID0geyAgLy/op6blj5Hkuovku7bnmoTlhYPntKDnsbvlnotcblx0XHRcInJlY3RcIjoxLFxuXHRcdFwic3Bpcml0XCI6MSxcblx0XHRcImltZ1wiOjEsXG5cdFx0XCJ0ZXh0XCI6MSxcblx0XHRcInNoYXBlXCI6MSxcblx0XHRcImFyY1wiOjEsXG5cdFx0XCJwb2x5Z29uXCI6MSwgIFxuXHRcdFwibGF5ZXJcIjoxLCAgICAvL+aYr+WuueWZqCDmnKzouqvkuI3lk43lupTkuovku7Yg5Y+q5Yik5pat5YW25Lit55qE5YWD57SgXG5cdFx0XCJncm91cFwiOjEsICAgIC8v5piv5a655ZmoIOacrOi6q+S4jeWTjeW6lOS6i+S7tiDlj6rliKTmlq3lhbbkuK3nmoTlhYPntKBcblx0XHRcImxpbmVcIjoxLFxuXHRcdFwicXVhZHJhdGljQ3VydmVcIjoxLCAvL+S6jOasoeabsue6v1xuXHRcdFwiYmV6aWVyQ3VydmVcIjoxIC8v5LiJ5qyh5puy57q/XG5cdH1cblx0dmFyIF90aGlzID0gdGhpcztcblxuXG5cdHZhciBpbml0UmVzaXplTGF5ZXIgPSBmdW5jdGlvbihpZCl7XG5cdFx0aWYoX3RoaXMucWNhbnZhcy5xcmVzaXplID09PSBudWxsKXsgIFxuXHRcdFx0X3RoaXMucWNhbnZhcy5xcmVzaXplID0gbmV3IFFyZXNpemUocWNhbnZhcyxpZCk7XG5cdFx0fWVsc2V7XG5cdFx0XHRfdGhpcy5xY2FudmFzLnFyZXNpemUuc2hvd0hhbmRsZXIoX3RoaXMucWNhbnZhcy5kcmFnQWltKTtcblx0XHR9XG5cdH1cblxuXHR2YXIgaW5pdFJvdGF0ZUxheWVyID0gZnVuY3Rpb24oaWQpe1xuXHRcdGlmKF90aGlzLnFjYW52YXMucXJvdGF0ZSA9PT0gbnVsbCl7ICBcblx0XHRcdF90aGlzLnFjYW52YXMucXJvdGF0ZSA9IG5ldyBRcm90YXRlKHFjYW52YXMsaWQpO1xuXHRcdH1lbHNle1xuXHRcdFx0X3RoaXMucWNhbnZhcy5xcm90YXRlLnNob3dIYW5kbGVyKF90aGlzLnFjYW52YXMuZHJhZ0FpbSk7XG5cdFx0fVxuXHR9XG5cblxuXHR2YXIgZXZlbnRDYWxsYmFjayA9IHtcblx0XHQnbW91c2VlbnRlcic6ZnVuY3Rpb24oZSxwb3NpdGlvbil7XG5cblx0XHR9LFxuXHRcdCdtb3VzZWRvd25fb3JfdG91Y2hzdGFydCc6ZnVuY3Rpb24oZSxwb3NpdGlvbil7XG5cdFx0XHQvLyB2YXIgcG9zaXRpb24gPSBfdGhpcy5nZXRFdmVudFBvc2l0aW9uKGUpO1xuXHRcdFx0dmFyIGFpbSAgPSBfdGhpcy5maW5kRWxtQnlFdmVudFBvc2l0aW9uKHBvc2l0aW9uKTsgXG5cblx0XHRcdChhaW0hPT1udWxsICYmIGFpbS5kcmFnICYmIF90aGlzLnRyaWdnZXJFbGVUeXBlW2FpbS5UWVBFXSBcblx0XHRcdCYmIFxuXHRcdFx0KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGFpbS5kb3duRnVuKGUscG9zaXRpb24pO1xuXHRcdFx0XHRfdGhpcy5xY2FudmFzLmRyYWdBaW0gPSBhaW07XG5cblx0XHRcdH0pKCkpIHx8IFxuXHRcdFx0KGFpbSE9PW51bGwgJiYgYWltLlRZUEUgPT0gJ2NhbnZhcycgJiYgKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdF90aGlzLnFjYW52YXMuZHJhZ0FpbSA9IGFpbTtcblx0XHRcdFx0XG5cdFx0XHR9KSgpKVxuICBcblx0XHRcdGlmKGFpbSAhPT0gbnVsbCl7XG5cdFx0XHRcdGFpbS5UWVBFID09ICdyZWN0JyAmJiBhaW0ucmVzaXplICYmIGluaXRSZXNpemVMYXllcihhaW0uaWQpO1xuXHRcdFx0XHRhaW0uVFlQRSA9PSAncmVjdCcgJiYgYWltLnJvdGF0ZSAmJiBpbml0Um90YXRlTGF5ZXIoYWltLmlkKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdH0sXG5cdFx0J21vdXNlbW92ZV9vcl90b3VjaG1vdmUnOmZ1bmN0aW9uKGUscG9zaXRpb24pe1xuXG5cdFx0XHRcdC8vIGlmKF90aGlzLnFjYW52YXMubW92ZUFpbSA9PT0gbnVsbCl7XG5cdFx0XHRcdC8vIFx0X3RoaXMucWNhbnZhcy5tb3ZlQWltID0gX3RoaXMuZmluZEVsbUJ5RXZlbnRQb3NpdGlvbihwb3NpdGlvbik7XG5cdFx0XHRcdC8vIH1cblxuXHRcdFx0XHRpZiggICAgXG5cdFx0XHRcdFx0ICAoX3RoaXMucWNhbnZhcy5kcmFnQWltICE9PSBudWxsKVxuXHRcdFx0XHRcdCYmIChfdGhpcy5xY2FudmFzLnFyZXNpemUgIT09IG51bGwpXG5cdFx0XHRcdFx0JiYgKF90aGlzLnFjYW52YXMucXJvdGF0ZSAhPT0gbnVsbClcblxuXHRcdFx0XHQpeyAgXG5cblx0XHRcdFx0XHQvL+WmguaenOaLluWKqOS4jeaYr3Jlc2l6ZeaIlnJvdGF0ZeWPpeafhCDpgqPkuYjmi5bliqjnmoTlkIzml7bpnIDopoEg5pu05paw5Y+l5p+E5Z2Q5qCHIFxuXHRcdFx0XHRcdCFfdGhpcy5xY2FudmFzLnFyb3RhdGUucm90YXRlTGF5ZXIuaGFzT3duRWxlKF90aGlzLnFjYW52YXMuZHJhZ0FpbSkgXG5cdFx0XHRcdFx0JiYgIV90aGlzLnFjYW52YXMucXJlc2l6ZS5yZXNpemVMYXllci5oYXNPd25FbGUoX3RoaXMucWNhbnZhcy5kcmFnQWltKVxuXHRcdFx0XHRcdCYmIChmdW5jdGlvbigpe1xuXG5cdFx0XHRcdFx0XHRfdGhpcy5xY2FudmFzLnFyb3RhdGUuaGlkZUhhbmRsZXIoKVxuXHRcdFx0XHRcdFx0X3RoaXMucWNhbnZhcy5xcmVzaXplLmhpZGVIYW5kbGVyKCk7XG5cblx0XHRcdFx0XHR9KSgpXG5cblx0XHRcdFx0fWVsc2V7XG5cblx0XHRcdFx0XHRpZigoX3RoaXMucWNhbnZhcy5xcmVzaXplICE9PSBudWxsKSBcblx0XHRcdFx0XHQmJiAoX3RoaXMucWNhbnZhcy5kcmFnQWltICE9PSBudWxsKSl7XG5cblx0XHRcdFx0XHRcdCFfdGhpcy5xY2FudmFzLnFyZXNpemUucmVzaXplTGF5ZXIuaGFzT3duRWxlKF90aGlzLnFjYW52YXMuZHJhZ0FpbSlcblx0XHRcdFx0XHRcdCYmIF90aGlzLnFjYW52YXMucXJlc2l6ZS5oaWRlSGFuZGxlcigpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYoX3RoaXMucWNhbnZhcy5xcm90YXRlICE9PSBudWxsIFxuXHRcdFx0XHRcdCYmIChfdGhpcy5xY2FudmFzLmRyYWdBaW0gIT09IG51bGwpKXtcblxuXHRcdFx0XHRcdFx0IV90aGlzLnFjYW52YXMucXJvdGF0ZS5yb3RhdGVMYXllci5oYXNPd25FbGUoX3RoaXMucWNhbnZhcy5kcmFnQWltKSBcblx0XHRcdFx0XHRcdCYmIF90aGlzLnFjYW52YXMucXJvdGF0ZS5oaWRlSGFuZGxlcigpO1xuXHRcdFx0XHRcdFx0IFxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdGlmKF90aGlzLnFjYW52YXMuZHJhZ0FpbSAhPT0gbnVsbCl7XG5cdFx0XHRcdFx0X3RoaXMudHJpZ2dlckVsZVR5cGVbX3RoaXMucWNhbnZhcy5kcmFnQWltLlRZUEVdIFxuXHRcdFx0XHRcdCYmXG5cdFx0XHRcdFx0X3RoaXMucWNhbnZhcy5kcmFnQWltLm1vdmVGdW4oZSxwb3NpdGlvbik7XG5cblx0XHRcdFx0fVxuXG5cdFx0fSxcblx0XHQnbW91c2V1cF9vcl9tb3VzZW91dF9vcl90b3VjaGVuZCc6ZnVuY3Rpb24oZSxwb3NpdGlvbil7XG5cdFx0XHRfdGhpcy5xY2FudmFzLmRyYWdBaW0gPSBudWxsO1xuXHRcdH1cblx0fTtcblxuXHR0aGlzLlBDX0V2ZW50ID0ge1xuXHRcdFwibW91c2VlbnRlclwiOmV2ZW50Q2FsbGJhY2tbJ21vdXNlZW50ZXInXSxcblx0XHRcIm1vdXNlZG93blwiOmV2ZW50Q2FsbGJhY2tbJ21vdXNlZG93bl9vcl90b3VjaHN0YXJ0J10sXG5cdFx0XCJtb3VzZW1vdmVcIjpldmVudENhbGxiYWNrWydtb3VzZW1vdmVfb3JfdG91Y2htb3ZlJ10sXG5cdFx0XCJtb3VzZXVwXCI6ZXZlbnRDYWxsYmFja1snbW91c2V1cF9vcl9tb3VzZW91dF9vcl90b3VjaGVuZCddLFxuXHRcdFwibW91c2VvdXRcIjpldmVudENhbGxiYWNrWydtb3VzZXVwX29yX21vdXNlb3V0X29yX3RvdWNoZW5kJ10sXG5cdFx0XCJkYmxjbGlja1wiOmZ1bmN0aW9uKCl7fVxuXHR9O1xuXHR0aGlzLk1PQklMRV9FdmVudCA9IHtcblx0XHRcInRvdWNoc3RhcnRcIjpldmVudENhbGxiYWNrWydtb3VzZWRvd25fb3JfdG91Y2hzdGFydCddLFxuXHRcdFwidG91Y2htb3ZlXCI6ZXZlbnRDYWxsYmFja1snbW91c2Vtb3ZlX29yX3RvdWNobW92ZSddLFxuXHRcdFwidG91Y2hlbmRcIjpldmVudENhbGxiYWNrWydtb3VzZXVwX29yX21vdXNlb3V0X29yX3RvdWNoZW5kJ11cblx0fTtcdFxuXHRcblx0dGhpcy5pbml0KCk7XG59XG5cblFldmVudC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCl7XG5cdHZhciBjYW52YXMgPSB0aGlzLnFjYW52YXMuY2FudmFzO1xuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcblxuXHRcblx0aWYoXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW5kb3cpe1xuXHRcdGZvcih2YXIgaSBpbiB0aGlzLk1PQklMRV9FdmVudCl7XG5cdFx0XHQvLyBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihpLGNhbGxiYWNrLGZhbHNlKTtcdFx0XG5cdFx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihpLGZ1bmN0aW9uKGUpe1xuXHRcdFx0XHR2YXIgcG9zaXRpb24gPSBfdGhpcy5nZXRFdmVudFBvc2l0aW9uKGUpO1xuXHRcdFx0XHRfdGhpcy5ldmVudENhbGxiYWNrKGUscG9zaXRpb24pO1x0Ly/nlKjmiLflrprkuYnnmoTlm57osIPlh73mlbBcblx0XHRcdFx0X3RoaXMuTU9CSUxFX0V2ZW50W2UudHlwZV0oZSxwb3NpdGlvbik7IC8v57O757uf5a6a5LmJ55qE5Zue6LCD5Ye95pWwXG5cdFx0XHR9LGZhbHNlKTtcdFx0XG5cblx0XHR9XG5cdFx0XG5cdH1lbHNle1xuXHRcdGZvcih2YXIgaSBpbiB0aGlzLlBDX0V2ZW50KXtcblx0XHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKGksZnVuY3Rpb24oZSl7XG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IF90aGlzLmdldEV2ZW50UG9zaXRpb24oZSk7XG5cdFx0XHRcdF90aGlzLmV2ZW50Q2FsbGJhY2soZSxwb3NpdGlvbik7XHQgLy/nlKjmiLflrprkuYnnmoTlm57osIPlh73mlbBcblx0XHRcdFx0X3RoaXMuUENfRXZlbnRbZS50eXBlXShlLHBvc2l0aW9uKTsgIC8v57O757uf5a6a5LmJ55qE5Zue6LCD5Ye95pWwXG5cdFx0XHR9LGZhbHNlKTtcdFx0XG5cdFx0fVxuXG5cblx0XHRjYW52YXMub25jb250ZXh0bWVudT1mdW5jdGlvbihldil7ICBcblx0ICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgfVxuXHRcdFxuXHR9XG5cdFxufVx0XG5cblFldmVudC5wcm90b3R5cGUuZXhlY3V0ZU1vdXNlT3V0T3JNb3VzZUVudGVyID0gZnVuY3Rpb24oYWltLHBvc2l0aW9uKXsgXG5cdC8v5L+u5aSN5a+56LGhbW91c2VvdXToh6rlrprkuYnkuovku7bkuI3miafooYznmoTpl67popggXG5cdGlmKHRoaXMucWNhbnZhcy5pc09iaihhaW0pKXtcblxuXHRcdGlmKHRoaXMucWNhbnZhcy5tb3ZlQWltID09IG51bGwpe1xuXHRcdFx0XHR0aGlzLnFjYW52YXMubW92ZUFpbSA9IGFpbTtcblx0XHRcdFx0YWltWydtb3VzZWVudGVyJ10gJiYgYWltWydtb3VzZWVudGVyJ10oYWltLHBvc2l0aW9uKTtcblxuXG5cdFx0fWVsc2UgaWYodGhpcy5xY2FudmFzLm1vdmVBaW0uaWQgIT09IGFpbS5pZCl7IC8v5YiS6L+H5LqG5LiN5ZCM55qE5a+56LGhIOmcgOimgeaJp+ihjOS4iuS4gOS4quWvueixoeeahG1vdmVvdXTkuovku7Zcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ+WIkui/h+S6huS4jeWQjOeahOWvueixoScpO1xuXHRcdFx0XHR0aGlzLnFjYW52YXMubW92ZUFpbVsnbW91c2VvdXQnXSAmJiB0aGlzLnFjYW52YXMubW92ZUFpbVsnbW91c2VvdXQnXSh0aGlzLnFjYW52YXMubW92ZUFpbSxwb3NpdGlvbik7XG5cdFx0XHRcdGFpbVsnbW91c2VlbnRlciddICYmIGFpbVsnbW91c2VlbnRlciddKGFpbSxwb3NpdGlvbik7XG5cdFx0XHRcdHRoaXMucWNhbnZhcy5tb3ZlQWltID0gYWltO1xuXHRcdFx0fVxuXG5cdH1lbHNle1xuXG5cblx0XHRpZih0aGlzLnFjYW52YXMuaXNPYmoodGhpcy5xY2FudmFzLm1vdmVBaW0pKXtcblx0XHRcdHRoaXMucWNhbnZhcy5tb3ZlQWltWydtb3VzZW91dCddICYmIHRoaXMucWNhbnZhcy5tb3ZlQWltWydtb3VzZW91dCddKHRoaXMucWNhbnZhcy5tb3ZlQWltLHBvc2l0aW9uKTtcblx0XHRcdHRoaXMucWNhbnZhcy5tb3ZlQWltID0gbnVsbDtcblx0XHR9XG5cdH1cblxufVxuXG5cblxuXG5RZXZlbnQucHJvdG90eXBlLmV2ZW50Q2FsbGJhY2sgPSBmdW5jdGlvbihlLHBvc2l0aW9uKXtcblxuXHQgXHR2YXIgYWltID0gdGhpcy5maW5kRWxtQnlFdmVudFBvc2l0aW9uKHBvc2l0aW9uKTtcblxuXHQgXHQvL+S/ruWkjeWvueixoW1vdXNlb3V0IG1vdXNlcmVudGVy6Ieq5a6a5LmJ5LqL5Lu25LiN5omn6KGM55qE6Zeu6aKYXG5cdCAgXHR0aGlzLmV4ZWN1dGVNb3VzZU91dE9yTW91c2VFbnRlcihhaW0scG9zaXRpb24pO1xuXG5cblx0ICBcdC8v6Kem5Y+RYWlt55qE5LqL5Lu2KOiwg+eUqOeUqOaIt+mFjee9ruWlveeahOS6i+S7tikgXG5cdCAgXHQoYWltICE9PSBudWxsKSAmJiAodHlwZW9mIGFpbVtlLnR5cGVdICE9J3VuZGVmaW5lZCcpICYmICBhaW1bZS50eXBlXShlLHBvc2l0aW9uKTtcblxuXHQgIFx0Ly8gLy/mqKHmi59kcmFn5LqL5Lu2IFxuXHQgIFx0Ly8gKGFpbSAhPT0gbnVsbCkgJiYgXG5cdCAgXHQvLyAodGhpcy5xY2FudmFzLmRyYWdBaW0gIT09bnVsbCkgICYmIFxuXHQgIFx0Ly8gKGUudHlwZSA9PSdtb3VzZW1vdmUnKSAmJiBcblx0ICBcdC8vICh0eXBlb2YgYWltWydkcmFnJ10gIT0ndW5kZWZpbmVkJykgJiYgIGFpbVsnZHJhZyddKGUscG9zaXRpb24pO1xuXHQgIFxufVx0XG5cdFxuXG4vL+agueaNrueCueWHu+eahOWdkOaghyDmib7liLDopoHop6blj5Hkuovku7bnmoTlhYPntKAgXG5RZXZlbnQucHJvdG90eXBlLmZpbmRFbG1CeUV2ZW50UG9zaXRpb24gPSBmdW5jdGlvbihwb3NpdGlvbil7XG5cdFx0dmFyIGVsZW1lbnRzID0gdGhpcy5xY2FudmFzLmVsZW1lbnRzO1xuXHRcdHZhciBhaW0gPSBudWxsO1x0XG5cblx0XG5cdFx0Ly9lbGVtZW50c+aVsOe7hOS7juWQjuW+gOWJjSDnorDliLDnrKzkuIDkuKrlhYPntKAg54K55Ye755qE5Z2Q5qCH5q2j5aW95Zyo5a6D55qE6IyD5Zu05YaFIOmCo+S5iOWwseinpuWPkeWug+eahOS6i+S7tlxuXHRcdC8v6LaK5b6A5ZCO55qE5YWD57SgIOWcqOeUu+W4g+S4iuaYr+i2iuWcqOS4iumdoueahCBcblx0XHR2YXIgbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdFx0aWYobGVuID09IDApe1xuXHRcdFx0cmV0dXJuIHRoaXMucWNhbnZhcztcblx0XHR9XG5cblx0XHRmb3IodmFyIGk9bGVuLTE7aT49MDtpLS0pe1xuXG5cdFx0XHQvL+i3s+i/h+S4jeaYvuekuueahOWFg+e0oOWSjOS4jeWTjeW6lOS6i+S7tueahOWFg+e0oFxuXHRcdFx0aWYoZWxlbWVudHNbaV0uZGlzcGxheT09J25vbmUnIHx8IChlbGVtZW50c1tpXS5wb2ludGVyRXZlbnQgPT0gJ25vbmUnKSl7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYodGhpcy50cmlnZ2VyRWxlVHlwZVtlbGVtZW50c1tpXS5UWVBFXSl7XG5cblxuXHRcdFx0XHQvL+WmguaenOaYr+WuueWZqOWvueixoSDopoHliKTmlq3lsZ7kuo7or6Xlrrnlmajph4znmoTlhYPntKBcblx0XHRcdFx0aWYoKGVsZW1lbnRzW2ldLlRZUEUgPT0gJ2xheWVyJykgfHwgKGVsZW1lbnRzW2ldLlRZUEUgPT0gJ2dyb3VwJykpeyAgXG5cdFx0XHRcdFx0dmFyIGNoaWxkTGVuID0gZWxlbWVudHNbaV0uZWxlbWVudHMubGVuZ3RoO1xuXHRcdFx0XHRcdGlmKGNoaWxkTGVuID09IDApe1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fSBcblxuXHRcdFx0XHRcdGZvciAodmFyIGogPSBjaGlsZExlbi0xOyBqID49IDA7IGotLSkge1xuXG5cblx0XHRcdFx0XHRcdC8v6Lez6L+H5LiN5pi+56S655qE5YWD57Sg5ZKM5LiN5ZON5bqU5LqL5Lu255qE5YWD57SgXG5cdFx0XHRcdFx0XHRpZihlbGVtZW50c1tpXS5lbGVtZW50c1tqXS5kaXNwbGF5PT0nbm9uZScgfHwgKGVsZW1lbnRzW2ldLmVsZW1lbnRzW2pdLnBvaW50ZXJFdmVudCA9PSAnbm9uZScpKXtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9OyBcblxuXHRcdFx0XHRcdFx0aWYoZWxlbWVudHNbaV0uZWxlbWVudHNbal0uVFlQRT09J3F1YWRyYXRpY0N1cnZlJyB8fCBlbGVtZW50c1tpXS5lbGVtZW50c1tqXS5UWVBFPT0nYmV6aWVyQ3VydmUnKXsgXG5cdFx0XHRcdFx0XHRcdC8v5puy57q/55qE5ou+5Y+WIOmcgOimgeeUqOWIsOW9seWtkOeUu+W4g+WunueOsFxuXHRcdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRcdHZhciBjb2xvciA9IHRoaXMucWNhbnZhcy5nZXRTaGFkb3dQaXhlbENvbG9yLmNhbGwodGhpcy5xY2FudmFzLHBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGlmKGNvbG9yLnJnYmEgPT09IGVsZW1lbnRzW2ldLmVsZW1lbnRzW2pdLnNoYWRvd0ZpbGxDb2xvcil7XG5cdFx0XHRcdFx0XHRcdFx0YWltID0gZWxlbWVudHNbaV0uZWxlbWVudHNbal07XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fWVsc2UgaWYodGhpcy5yYXlDYXN0aW5nKHBvc2l0aW9uLGVsZW1lbnRzW2ldLmVsZW1lbnRzW2pdLnBvbHlQb2ludHMoKSk9PSdpbicpe1xuXHRcdFx0XHRcdFx0XHRhaW0gPSBlbGVtZW50c1tpXS5lbGVtZW50c1tqXTsgIFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZihhaW0gIT09IG51bGwpe1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuIFxuXHRcdFx0XHR9ZWxzZXtcblxuXHRcdFx0XHRcdCBpZihlbGVtZW50c1tpXS5UWVBFPT0ncXVhZHJhdGljQ3VydmUnIHx8IGVsZW1lbnRzW2ldLlRZUEU9PSdiZXppZXJDdXJ2ZScpe1xuXHRcdFx0XHRcdFx0XHQvL+absue6v+eahOaLvuWPliDpnIDopoHnlKjliLDlvbHlrZDnlLvluIPlrp7njrBcblx0XHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cocG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0XHR2YXIgY29sb3IgPSB0aGlzLnFjYW52YXMuZ2V0U2hhZG93UGl4ZWxDb2xvci5jYWxsKHRoaXMucWNhbnZhcyxwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRpZihjb2xvci5yZ2JhID09PSBlbGVtZW50c1tpXS5zaGFkb3dGaWxsQ29sb3Ipe1xuXHRcdFx0XHRcdFx0XHRcdGFpbSA9IGVsZW1lbnRzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0IH1lbHNle1xuXG5cdFx0XHRcdFx0IFx0aWYodGhpcy5yYXlDYXN0aW5nKHBvc2l0aW9uLGVsZW1lbnRzW2ldLnBvbHlQb2ludHMoKSk9PSdpbicpe1xuXHRcdFx0XHRcdFx0XHRhaW0gPSBlbGVtZW50c1tpXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQgfVxuXG5cdFx0XHRcdFx0XG5cdFx0XHRcdH0gXG5cblx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHR9IFxuXHRcdH1cbiBcblxuXHRcdC8v5aaC5p6cYWltID09IG51bGzpgqPkuYjngrnkuK3nmoTnm67moIflsLHmmK/kuLtjYW52YXNcblx0XHRhaW0gPT09IG51bGwgJiYgKGFpbSA9IHRoaXMucWNhbnZhcyk7XG5cdFxuXHRcdFxuXHRcdHJldHVybiBhaW07XG5cdFxufVxuXHRcblFldmVudC5wcm90b3R5cGUuZ2V0RXZlbnRQb3NpdGlvbiA9IGZ1bmN0aW9uKGV2KXtcbiAgdmFyIHgsIHk7XG5cdC8vY29uc29sZS5sb2coZXYpO1xuXHRpZih0aGlzLk1PQklMRV9FdmVudFtldi50eXBlXSl7XG5cdFx0dmFyIGMgPSBldi50eXBlIT0ndG91Y2hlbmQnP2V2LnRvdWNoZXNbMF06ZXYuY2hhbmdlZFRvdWNoZXNbMF07XG5cdFx0eD0gYy5jbGllbnRYLWMudGFyZ2V0Lm9mZnNldExlZnQ7XG5cdFx0eT0gYy5jbGllbnRZLWMudGFyZ2V0Lm9mZnNldFRvcDtcblx0XHRcblx0fWVsc2V7XG5cdFx0IGlmIChldi5sYXllclggfHwgZXYubGF5ZXJYID09IDApIHtcblx0XHRcdHggPSBldi5sYXllclg7XG5cdFx0XHR5ID0gZXYubGF5ZXJZO1xuXHRcdH0gZWxzZSBpZiAoZXYub2Zmc2V0WCB8fCBldi5vZmZzZXRYID09IDApIHsgLy8gT3BlcmFcblx0XHRcdHggPSBldi5vZmZzZXRYO1xuXHRcdFx0eSA9IGV2Lm9mZnNldFk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcbiBcbiAgcmV0dXJuIHt4OiB4LCB5OiB5fTtcbn1cblx0XG4vKipcbiAgICogQGRlc2NyaXB0aW9uIOWwhOe6v+azleWIpOaWreeCueaYr+WQpuWcqOWkmui+ueW9ouWGhemDqFxuICAgKiBAcGFyYW0ge09iamVjdH0gcCDlvoXliKTmlq3nmoTngrnvvIzmoLzlvI/vvJp7IHg6IFjlnZDmoIcsIHk6IFnlnZDmoIcgfVxuICAgKiBAcGFyYW0ge0FycmF5fSBwb2x5IOWkmui+ueW9oumhtueCue+8jOaVsOe7hOaIkOWRmOeahOagvOW8j+WQjCBwXG4gICAqIEByZXR1cm4ge1N0cmluZ30g54K5IHAg5ZKM5aSa6L655b2iIHBvbHkg55qE5Yeg5L2V5YWz57O7XG4gICAqL1xuUWV2ZW50LnByb3RvdHlwZS5yYXlDYXN0aW5nID0gZnVuY3Rpb24ocCwgcG9seSkge1xuICAgIHZhciBweCA9IHAueCxcbiAgICAgICAgcHkgPSBwLnksXG4gICAgICAgIGZsYWcgPSBmYWxzZVxuXG4gICAgZm9yKHZhciBpID0gMCwgbCA9IHBvbHkubGVuZ3RoLCBqID0gbCAtIDE7IGkgPCBsOyBqID0gaSwgaSsrKSB7XG4gICAgICB2YXIgc3ggPSBwb2x5W2ldLngsXG4gICAgICAgICAgc3kgPSBwb2x5W2ldLnksXG4gICAgICAgICAgdHggPSBwb2x5W2pdLngsXG4gICAgICAgICAgdHkgPSBwb2x5W2pdLnlcblxuICAgICAgLy8g54K55LiO5aSa6L655b2i6aG254K56YeN5ZCIXG4gICAgICBpZigoc3ggPT09IHB4ICYmIHN5ID09PSBweSkgfHwgKHR4ID09PSBweCAmJiB0eSA9PT0gcHkpKSB7XG4gICAgICAgIHJldHVybiAnb24nXG4gICAgICB9XG5cbiAgICAgIC8vIOWIpOaWree6v+auteS4pOerr+eCueaYr+WQpuWcqOWwhOe6v+S4pOS+p1xuICAgICAgaWYoKHN5IDwgcHkgJiYgdHkgPj0gcHkpIHx8IChzeSA+PSBweSAmJiB0eSA8IHB5KSkge1xuICAgICAgICAvLyDnur/mrrXkuIrkuI7lsITnur8gWSDlnZDmoIfnm7jlkIznmoTngrnnmoQgWCDlnZDmoIdcbiAgICAgICAgdmFyIHggPSBzeCArIChweSAtIHN5KSAqICh0eCAtIHN4KSAvICh0eSAtIHN5KVxuXG4gICAgICAgIC8vIOeCueWcqOWkmui+ueW9oueahOi+ueS4ilxuICAgICAgICBpZih4ID09PSBweCkge1xuICAgICAgICAgIHJldHVybiAnb24nXG4gICAgICAgIH1cblxuICAgICAgICAvLyDlsITnur/nqb/ov4flpJrovrnlvaLnmoTovrnnlYxcbiAgICAgICAgaWYoeCA+IHB4KSB7XG4gICAgICAgICAgZmxhZyA9ICFmbGFnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDlsITnur/nqb/ov4flpJrovrnlvaLovrnnlYznmoTmrKHmlbDkuLrlpYfmlbDml7bngrnlnKjlpJrovrnlvaLlhoVcbiAgICByZXR1cm4gZmxhZyA/ICdpbicgOiAnb3V0J1xuICB9XHRcblxuXG5cbi8v5YWD57Sg5a655Zmo57G7XG5mdW5jdGlvbiBRbGF5ZXIocCl7XG5cdHZhciBfdGhpcyA9IHRoaXM7XG5cdHRoaXMucWxheWVyVmVyc2lvbiA9ICcxLjAnO1xuXHR0aGlzLnBjYW52YXMgPSBwOyAgIC8v5Li7Y2FudmFzIFxuXHR0aGlzLmRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvOyAvLyDlgYforr5kcHLkuLoyXG5cblx0XG5cdFxuXG5cdHRoaXMubGF5ZXIgPSBmdW5jdGlvbigpeyAgIC8v5L2c5Li65LiA5Liq5p6E6YCg5Ye95pWwXG5cblx0XHQvL+avj+S4qmxheWVy6YO95Yib5bu65paw55qE5Li05pe2Y2FudmFzXG5cdFx0Ly/lrp7kvovlsZ7mgKfopobnm5bljp/lnotRY2FudmFz57un5om/6L+H5p2l55qE5bGe5oCnXG5cdFx0X3RoaXMuY2FudmFzRWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cblx0XHRfdGhpcy5jYW52YXNFbGUud2lkdGggPSBfdGhpcy5wY2FudmFzLnN0YWdlLndpZHRoKl90aGlzLmRwcjtcblx0XHRfdGhpcy5jYW52YXNFbGUuaGVpZ2h0ID0gX3RoaXMucGNhbnZhcy5zdGFnZS5oZWlnaHQqX3RoaXMuZHByOyBcblx0XHRfdGhpcy5jYW52YXNFbGUuaWQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpKycnK3BhcnNlSW50KE1hdGgucmFuZG9tKCkqMTAwMDAwMDAwKTtcblxuXG5cdFx0Ly/ph43lhpnnlJ/miJDkuIDkuKpxY2FudmFz5bGe5oCnXG5cdFx0X3RoaXMucWNhbnZhcyA9IHt9OyBcblx0XHRcblx0XHQvL+aKilFjYW52YXPnmoTlsZ7mgKfpg73lpI3liLbov4fmnaUgIOmAmui/h+WOn+Wei+e7p+aJv+eahFxuXHRcdGZvcih2YXIgaSBpbiBwKXtcblx0XHRcdF90aGlzLnFjYW52YXNbaV0gPSBwW2ldO1xuXHRcdH1cblxuXHRcdF90aGlzLnFjYW52YXMuZWxlbWVudHMgPSBbXTtcbiBcblx0XHQvL2xheWVy5omA5pyJ57un5om/6L+H5p2l55qE5YWD57Sg5a+56LGh55u45bqU55qEcGFpbnTmlrnms5Ug6YO95piv5L2/55SoIHRoaXMucWNhbnZhcy5jb250ZXh0IOeUu+WIsOeUu+W4g+S4iueahFxuXHRcdC8v5omA5Lul6YeN5YaZcWNhbnZhcy5jb250ZXh0IOS9v+Wug+aMh+WQkWxheWVy5Li05pe255qEY2FudmFzIOmCo+S5iOWwseS8mueUu+WIsGxheWVy5a+55bqU55qE55S75biD5LiKXG5cdFx0X3RoaXMucWNhbnZhcy5jb250ZXh0ID0gX3RoaXMuY2FudmFzRWxlLmdldENvbnRleHQoJzJkJyk7XG5cdFx0X3RoaXMucWNhbnZhcy5jb250ZXh0LnNjYWxlKF90aGlzLmRwcixfdGhpcy5kcHIpO1xuXG5cblxuXHRcdFxuXHRcdHZhciBvID0geyBcblx0XHRcdFRZUEU6XCJsYXllclwiLFxuXHRcdFx0Y2FudmFzRWxlOl90aGlzLmNhbnZhc0VsZSxcblx0XHRcdHBjYW52YXM6dGhpcy5wY2FudmFzLFxuXHRcdFx0Ly8gZWxlbWVudHM6dGhpcy5xY2FudmFzLmVsZW1lbnRzLFxuXHRcdFx0ZWxlbWVudHM6W10sXG5cdFx0XHRpZDogKG5ldyBEYXRlKCkpLmdldFRpbWUoKSsnJytwYXJzZUludChNYXRoLnJhbmRvbSgpKjEwMDAwMDAwMCksXG5cdFx0XHRkaXNwbGF5OidibG9jaycsIFxuXHRcdFx0cHVzaDpmdW5jdGlvbihlbGUpe1xuXHRcdFx0XHR2YXIgdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMpO1xuXHRcdFx0XHR2YXIgbCA9IHQubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuXG5cdFx0XHRcdFx0Ly/kuI3mlK/mjIFsYXllcuWvueixoeS4iuWGjeaUvuWFpWxheWVy5oiWZ3JvdXBcblx0XHRcdFx0XHRpZigodFtpXS5UWVBFID09ICdsYXllcicpIHx8ICh0W2ldLlRZUEUgPT0gJ2dyb3VwJykpeyAgIFxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuIFxuXHRcdFx0XHRcdGlmKHRoaXMucGNhbnZhcy5pc09iaih0W2ldKSl7XG5cdFx0XHRcdFx0XHR0aGlzLnBjYW52YXMucmVtb3ZlRWxlLmNhbGwodGhpcy5wY2FudmFzLHRbaV0pO1xuXHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50cy5wdXNoKHRbaV0pO1xuXHRcdFx0XHRcdFx0Ly8gdGhpcy5xY2FudmFzLmVsZW1lbnRzLnB1c2godFtpXSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmKCh0W2ldLlRZUEUgPT0nbGluZScgfHwgdFtpXS5UWVBFPT0nYmV6aWVyQ3VydmUnIHx8IHRbaV0uVFlQRT09J3F1YWRyYXRpY0N1cnZlJykgJiYgdHlwZW9mIHRbaV0ud2l0aFRleHRJZCAhPSd1bmRlZmluZWQnKXsgIFxuXHRcdFx0XHRcdFx0XHQvL+WmguaenOe6v+auteS4iuW4puacieaWh+acrCDkuZ/pnIDopoHmiormlofmnKzliqDlhaXliLDor6VsYXllcumHjCBcblx0XHRcdFx0XHRcdFx0dmFyIHdpdGhUZXh0T2JqID0gdGhpcy5wY2FudmFzLmdldEVsZUJ5SWQuY2FsbCh0aGlzLnBjYW52YXMsdFtpXS53aXRoVGV4dElkKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5wY2FudmFzLnJlbW92ZUVsZS5jYWxsKHRoaXMucGNhbnZhcyx3aXRoVGV4dE9iaik7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudHMucHVzaCh3aXRoVGV4dE9iaik7XG5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHRoaXMuZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLmNvbmNhdCh0bXApO1xuXHRcdFx0XHRcblx0XHRcdH0sXG5cdFx0XHRoYXNPd25FbGU6ZnVuY3Rpb24oZWxlKXsgIC8v5b2T5YmNbGF5ZXLlr7nosaHph4zmmK/lrZjlnKhlbGXlhYPntKBcblx0XHRcdFx0dmFyIHRtcCA9IHRoaXMuZWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdFx0XHRcdHJldHVybiBpdGVtLmlkID09IGVsZS5pZDtcblx0XHRcdFx0fSlcblxuXHRcdFx0XHRyZXR1cm4gdG1wLmxlbmd0aD4wO1xuXHRcdFx0fSxcblxuXHRcdFx0Z2V0RWxlQnlJZDogdGhpcy5wY2FudmFzLmdldEVsZUJ5SWQsXG5cdFx0XHRyZW1vdmVFbGU6IHRoaXMucGNhbnZhcy5yZW1vdmVFbGUsXG5cdFx0XHRyZW1vdmVFbGVCeUlkOiB0aGlzLnBjYW52YXMucmVtb3ZlRWxlQnlJZCxcblxuXG5cdFx0XHRnZXRJbmRleEJ5SWQ6IHRoaXMucGNhbnZhcy5nZXRJbmRleEJ5SWQsXG5cdFx0XHRsb3dlcjogdGhpcy5wY2FudmFzLmxvd2VyLFxuXHRcdFx0bG93ZXJUb0JvdHRvbTogdGhpcy5wY2FudmFzLmxvd2VyVG9Cb3R0b20sXG5cdFx0XHRyYWlzZTogdGhpcy5wY2FudmFzLnJhaXNlLFxuXHRcdFx0cmFpc2VUb1RvcDogdGhpcy5wY2FudmFzLnJhaXNlVG9Ub3AsXG5cdFx0XHRkZXN0cm95OnRoaXMucGNhbnZhcy5kZXN0cm95XG5cblx0XHR9XG5cdFx0XG5cdFx0XG5cdFx0Ly8gdmFyIG8gPSBuZXcgZigpO1xuXHRcdFxuXG5cdFx0dGhpcy5wY2FudmFzLmFwcGVuZFNldEZ1bihvKTtcblx0XHR0aGlzLnBjYW52YXMuZWxlbWVudHMucHVzaChvKTtcblxuXG5cblx0XHQvLyB0aGlzLnBjYW52YXMucHVzaEVsZW1lbnRzLmNhbGwodGhpcy5wY2FudmFzLHRoaXMpO1xuXHRcdHJldHVybiBvO1xuXG5cdH1cblxuXHR0aGlzLnBhaW50TGF5ZXIgPSBmdW5jdGlvbihvKXtcblx0XHR0aGlzLnN0YXJ0KG8pO1xuXHRcdC8vIG8uZGlzcGxheSA9PSAnYmxvY2snICYmICB0aGlzLnBjYW52YXMuY29udGV4dC5kcmF3SW1hZ2UodCwwLDAsdGhpcy5wY2FudmFzLnN0YWdlLndpZHRoKnRoaXMuZHByLHRoaXMucGNhbnZhcy5zdGFnZS5oZWlnaHQqdGhpcy5kcHIsMCwwLHRoaXMucGNhbnZhcy5zdGFnZS53aWR0aCx0aGlzLnBjYW52YXMuc3RhZ2UuaGVpZ2h0KTtcblx0XHRvLmRpc3BsYXkgPT0gJ2Jsb2NrJyAmJiAgdGhpcy5wY2FudmFzLmNvbnRleHQuZHJhd0ltYWdlKHRoaXMuY2FudmFzRWxlLDAsMCx0aGlzLmNhbnZhc0VsZS53aWR0aCx0aGlzLmNhbnZhc0VsZS5oZWlnaHQsMCwwLHRoaXMucGNhbnZhcy5zdGFnZS53aWR0aCx0aGlzLnBjYW52YXMuc3RhZ2UuaGVpZ2h0KTtcblx0XHRcblx0fVxuXG5cdHRoaXMucGFpbnQgPSBmdW5jdGlvbihsYXllcil7XG5cblx0XHRpZihsYXllci5kaXNwbGF5ID09ICdub25lJyl7cmV0dXJuO307XG5cdFx0dmFyIGwgPSBsYXllci5lbGVtZW50cy5sZW5ndGg7XG5cdFx0Zm9yKHZhciBpID0gMDsgaTxsOyBpKyspe1xuXHRcdFx0dmFyIG8gPSBsYXllci5lbGVtZW50c1tpXTtcblxuXHRcdFx0aWYoby5kaXNwbGF5PT0nbm9uZScpe1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuVHlwZUdyb3VwW28uVFlQRV0uY2FsbCh0aGlzLG8pOyBcblx0XHRcdFx0XHRcblx0XHR9XG5cdFx0XHRcblxuXG5cdFx0Ly8gdGhpcy5wY2FudmFzLmNvbnRleHQuZHJhd0ltYWdlKHQsMCwwKTtcblxuXHR9XG5cdHRoaXMuY2xlYXIgPSBmdW5jdGlvbihsYXllcil7XG5cdFx0aWYobGF5ZXIuZGlzcGxheSA9PSAnbm9uZScpe3JldHVybjt9O1xuXHRcdHRoaXMuY2FudmFzRWxlLndpZHRoID0gdGhpcy5jYW52YXNFbGUud2lkdGg7XG5cdFx0dGhpcy5xY2FudmFzLmNvbnRleHQuc2NhbGUodGhpcy5kcHIsdGhpcy5kcHIpO1xuXG5cdFx0Ly8gdGhpcy5xY2FudmFzLmNvbnRleHQuY2xlYXJSZWN0KDAsMCx0aGlzLmNhbnZhc0VsZS53aWR0aCx0aGlzLmNhbnZhc0VsZS5oZWlnaHQpO1xuXHR9XG5cblx0dGhpcy5zdGFydCA9IGZ1bmN0aW9uKG8pe1xuXHRcdHRoaXMuY2xlYXIobyk7XG5cdFx0dGhpcy5wYWludChvKTtcdFx0XHRcblx0XHRcblx0XHR2YXIgY3VycmVudExvb3AgPSAobmV3IERhdGUoKSkuZ2V0TWlsbGlzZWNvbmRzKCk7XG5cdCAgICBpZiAodGhpcy5sYXN0TG9vcCA+IGN1cnJlbnRMb29wKSB7XG5cdFx0XHRcdHRoaXMuY3VyckZwcyA9IHRoaXMuY291bnQ7XG5cdCAgICAgIHRoaXMuY291bnQgPSAxO1xuXHQgICAgfSBlbHNlIHtcblx0XHRcdFx0dGhpcy5jb3VudCAgKz0gMTtcdFxuXHQgICAgfVxuXHRcdFx0XHRcdFxuXHRcdHRoaXMubGFzdExvb3AgPSBjdXJyZW50TG9vcDtcdFx0XG5cdFx0IFxuXHRcdFxuXHR9XHQgXG5cblx0Ly8gd2luZG93LnJlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUodGhpcy5zdGFydC5iaW5kKHRoaXMpKTtcblxuXG59IFxuXG5cdFxuLyotLS0tLS0tZW5kLS0tLS0tLS0tKi9cdFxuXG4vL+WFg+e0oOWIhue7hOexu1xuZnVuY3Rpb24gUWdyb3VwKHFjYW52YXMpe1xuXHR0aGlzLnFncm91cFZlcnNpb24gPSAnMS4wJztcblx0dGhpcy5xY2FudmFzID0gcWNhbnZhcztcbn1cblFncm91cC5wcm90b3R5cGUuZ3JvdXAgPSBmdW5jdGlvbihvcHRpb25zKXtcblx0dmFyIF90aGlzID0gdGhpcztcblx0dmFyIE9QVElPTlMgPSB7XG5cdFx0XHRUWVBFOidncm91cCcsXG5cdFx0XHRkaXNwbGF5OidibG9jaycsXG5cdFx0XHR3aWR0aDpfdGhpcy5xY2FudmFzLnN0YWdlLndpZHRoLFxuXHRcdFx0aGVpZ2h0Ol90aGlzLnFjYW52YXMuc3RhZ2UuaGVpZ2h0LFxuXHRcdFx0ZWxlbWVudHM6W10sICAgLy/lrrnlmajph4zljIXlkKvnmoTlhYPntKBcblx0XHRcdC8vIGNhbnZhc0VsZTpfdGhpcy5jcmVhdGVDYW52YXMoKSxcblx0XHRcdHB1c2g6dGhpcy5wdXNoLFxuXHRcdFx0cWNhbnZhczp0aGlzLnFjYW52YXMsXG5cdFx0XHRnZXRFbGVCeUlkOnRoaXMucWNhbnZhcy5nZXRFbGVCeUlkLFxuXHRcdFx0cmVtb3ZlRWxlOnRoaXMucWNhbnZhcy5yZW1vdmVFbGUsXG5cdFx0XHRyZW1vdmVFbGVCeUlkOnRoaXMucWNhbnZhcy5yZW1vdmVFbGVCeUlkLFxuXG5cdFx0XHRnZXRJbmRleEJ5SWQ6dGhpcy5xY2FudmFzLmdldEluZGV4QnlJZCxcblx0XHRcdGxvd2VyOnRoaXMucWNhbnZhcy5sb3dlcixcblx0XHRcdGxvd2VyVG9Cb3R0b206dGhpcy5xY2FudmFzLmxvd2VyVG9Cb3R0b20sXG5cdFx0XHRyYWlzZTp0aGlzLnFjYW52YXMucmFpc2UsXG5cdFx0XHRyYWlzZVRvVG9wOnRoaXMucWNhbnZhcy5yYWlzZVRvVG9wXG5cblx0XHR9XG5cblx0dGhpcy5xY2FudmFzLmV4dGVuZChPUFRJT05TLG9wdGlvbnMpO1xuXHR0aGlzLnFjYW52YXMuYXBwZW5kU2V0RnVuKE9QVElPTlMpO1xuXG5cblx0cmV0dXJuIE9QVElPTlM7XHRcblxufSBcblxuUWdyb3VwLnByb3RvdHlwZS5wYWludEdyb3VwID0gZnVuY3Rpb24ob2JqKXtcblxuXHQvL+aKiuWxnuS6juivpeWuueWZqOeahOWFg+e0oOe7mOWcqGxheWVyQ2FudmFzXG5cdHZhciBsID0gb2JqLmVsZW1lbnRzLmxlbmd0aDtcblx0Zm9yKHZhciBpID0gMDsgaTxsOyBpKyspe1xuXHRcdHZhciBvID0gb2JqLmVsZW1lbnRzW2ldO1xuXG5cdFx0aWYoby5kaXNwbGF5PT0nbm9uZScpe1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dGhpcy5xY2FudmFzLlR5cGVHcm91cFtvLlRZUEVdLmNhbGwodGhpcy5xY2FudmFzWydxJytvLlRZUEVdLG8pO1xuXG5cdH0gXG59XG5RZ3JvdXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihlbGUpe1xuXHR2YXIgdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMpO1xuXHR2YXIgbCA9IHQubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuXG5cdFx0Ly/kuI3mlK/mjIFncm91cOWvueixoeS4iuWGjeaUvuWFpWdyb3VwXG5cdFx0aWYodFtpXS5UWVBFID09ICdncm91cCcgfHwgdFtpXS5UWVBFID09ICdsYXllcicpeyAgIFxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5xY2FudmFzLmlzT2JqKHRbaV0pKXtcblx0XHRcdHRoaXMucWNhbnZhcy5yZW1vdmVFbGUodFtpXSk7XG5cdFx0XHR0aGlzLmVsZW1lbnRzLnB1c2godFtpXSk7XG5cdFx0fSBcblx0fVxuXG5cblxuXHQvL+aguOW/g1FjYW52YXPnsbvmiJDlkZggZWxlbWVudHPkuK0g5Yig5o6J6K+l5YWD57SgXG5cdC8vIHRoaXMucWNhbnZhcy5yZW1vdmVFbGUoZWxlKTtcblxuXG5cdC8v5re75Yqg5YiwUWxheWVy57G75oiQ5ZGYZWxlbWVudHPkuK1cblx0Ly8gdGhpcy5lbGVtZW50cy5wdXNoKGVsZSk7XG5cbn0gXG4gXG4vKi0tLS0tLS1lbmQtLS0tLS0tLS0qL1x0XG5cbi8qKlxuICog6KeS5bqm5o6n5Lu257G7XG4gKiBAcGFyYW0ge1t0eXBlXX0gcWNhbnZhcyBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge1t0eXBlXX0gaWQgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIFFyb3RhdGUocWNhbnZhcyxpZCl7XG5cdHRoaXMucXJvdGF0ZVZlcnNpb24gPSAnMS4wJztcblx0dGhpcy5xY2FudmFzID0gcWNhbnZhcztcblx0dGhpcy5yb3RhdGVMYXllciA9IG51bGw7XG5cdHRoaXMucm90YXRlT2JqID0gbnVsbDtcblxuXHR0aGlzLmluaXQoaWQpO1xufVxuXG4vL+WPluW+l+mhtueCueWdkOagh+S4rSDku6XlhYPntKDkuK3lv4PngrnliKTmlq0g77yI5Y+z6L655LiU6Z2g5LiL55qE5LiA5Liq54K577yJXG5Rcm90YXRlLnByb3RvdHlwZS5yaWdodEJvdHRvbVBvaW50ID0gZnVuY3Rpb24ob2JqKXtcblx0dmFyIHBvbHlQb2ludHMgPSBvYmoucG9seVBvaW50cygpO1xuXHR2YXIgeEFyciA9IHBvbHlQb2ludHMubWFwKGZ1bmN0aW9uKGl0ZW0pe3JldHVybiBpdGVtLnh9KTtcblx0dmFyIHlBcnIgPSBwb2x5UG9pbnRzLm1hcChmdW5jdGlvbihpdGVtKXtyZXR1cm4gaXRlbS55fSk7XG4gXG5cdHZhciBtYXhYID0gTWF0aC5tYXguYXBwbHkoe30seEFycik7XG5cdHZhciBtYXhZID0gTWF0aC5tYXguYXBwbHkoe30seUFycik7XG4gXG5cdHJldHVybiBbXG5cdFx0W01hdGgubWluLmFwcGx5KHt9LHhBcnIpLE1hdGgubWluLmFwcGx5KHt9LHlBcnIpXSxcblx0XHRbTWF0aC5tYXguYXBwbHkoe30seEFyciksTWF0aC5tYXguYXBwbHkoe30seUFycildLFxuXG5cdF1cblxuXG59XG4gXG5cblFyb3RhdGUucHJvdG90eXBlLnJlY3RSb3RhdGUgPSBmdW5jdGlvbihvYmopIHtcblx0dmFyIF90aGlzID0gdGhpcztcblx0dmFyIG9iaiA9IHRoaXMucm90YXRlT2JqO1xuXHR2YXIgYyA9IG9iai5jZW50ZXJQb2ludHMoKTtcblx0Ly8gdmFyIHN0YXJ0QW5kRW5kUG9zaXRpb24gPSBfdGhpcy5yaWdodEJvdHRvbVBvaW50KG9iaik7XG5cdHZhciBzdGFydCA9IHRoaXMucWNhbnZhcy5pc0Z1bihvYmouc3RhcnQpP29iai5zdGFydCgpOm9iai5zdGFydDtcblx0dmFyIHIgPSBNYXRoLnNxcnQoTWF0aC5wb3coTWF0aC5hYnMoYy54LXN0YXJ0WzBdKSwyKStNYXRoLnBvdyhNYXRoLmFicyhjLnktc3RhcnRbMV0pLDIpKTtcblxuXHR2YXIgZG93biA9IGZhbHNlO1xuXHR0aGlzLmJnID0gdGhpcy5xY2FudmFzLnFyZWN0LnJlY3Qoe1xuXHRcdHN0YXJ0OltjLngrcisxMCxjLnktMThdLFxuXHRcdHdpZHRoOjQsXG5cdFx0aGVpZ2h0OjM2LFxuXHRcdGJvcmRlckNvbG9yOidibHVlJyxcblx0XHQvLyBkaXNwbGF5Oidub25lJyxcblx0XHRmaWxsQ29sb3I6J2JsdWUnLFxuXHRcdHRpdGxlOidyb3RhdGXog4zmma8nLFxuXHRcdGRyYWc6ZmFsc2UsXG5cdFx0Ly8gbW91c2Vkb3duOmZ1bmN0aW9uKHBvcyl7XG5cdFx0Ly8gXHRfdGhpcy5oYW5kbGVyLnNldFN0YXJ0KFt0aGlzLnN0YXJ0WzBdKzUscG9zLnldKTtcblx0XHQvLyBcdHZhciBkaXMgPSBwb3MueSAtIHRoaXMuc3RhcnRbMV07XG5cblx0XHQvLyBcdG9iai5zZXREZWdyZWUoZGlzKjEwKTtcblxuXHRcdC8vIFx0dmFyIGRvd24gPSB0cnVlO1xuXG5cdFx0Ly8gfSxcblx0XHQvLyBtb3VzZW1vdmU6ZnVuY3Rpb24ocG9zKXtcblxuXHRcdC8vIFx0aWYoZG93bil7XG5cdFx0Ly8gXHRcdF90aGlzLmhhbmRsZXIuc2V0U3RhcnQoW3RoaXMuc3RhcnRbMF0rNSxwb3MueV0pO1xuXHRcdC8vIFx0XHR2YXIgZGlzID0gcG9zLnkgLSB0aGlzLnN0YXJ0WzFdO1xuXG5cdFx0Ly8gXHRcdG9iai5zZXREZWdyZWUoZGlzKjEwKTtcblxuXHRcdC8vIFx0fVxuXHRcdC8vIH0sXG5cdFx0Ly8gbW91c2V1cDpmdW5jdGlvbigpe1xuXHRcdC8vIFx0dmFyIGRvd24gPSBmYWxzZTtcblxuXHRcdC8vIH1cblx0fSlcdFxuXG5cdHRoaXMuaGFuZGxlciA9IHRoaXMucWNhbnZhcy5xYXJjLmFyYyh7XG5cdFx0XHRcdHN0YXJ0OltjLngrcisxMCsyLGMueS0xOCsob2JqLmRlZ3JlZTwwPyhvYmouZGVncmVlKzM2MCk6b2JqLmRlZ3JlZSkvMTBdLFxuXHRcdFx0XHRzQW5nbGU6MCxcblx0XHRcdFx0ZUFuZ2xlOjM2MCxcblx0XHRcdFx0ZmlsbENvbG9yOidyZWQnLFxuXHRcdFx0XHRvcGFjaXR5OjAuMiwgXG5cdFx0XHRcdHI6MTAsXG5cdFx0XHRcdHRpdGxlOidyb3RhdGXlj6Xmn4QnLFxuXHRcdFx0XHRkcmFnOid2ZXJ0aWNhbCcsXG5cdFx0XHRcdC8vIHBvaW50ZXJFdmVudDonbm9uZScsXG5cdFx0XHRcdGRyYWdSYW5nZTpmdW5jdGlvbigpe1xuXG5cdFx0XHRcdFx0cmV0dXJuIFtfdGhpcy5iZy5zdGFydCxbX3RoaXMuYmcuc3RhcnRbMF0rX3RoaXMuYmcud2lkdGgsX3RoaXMuYmcuc3RhcnRbMV0rX3RoaXMuYmcuaGVpZ2h0XV07XG5cblx0XHRcdFx0fSxcblx0XHRcdFx0bW91c2Vtb3ZlOmZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0dmFyIGRpcyA9IHRoaXMuc3RhcnRbMV0gLSBfdGhpcy5iZy5zdGFydFsxXTtcblxuXHRcdFx0XHRcdGRpcyA9IGRpczwwPzA6ZGlzO1xuXHRcdFx0XHRcdGRpcyA9IGRpcz4zNj8zNjpkaXM7XG5cblx0XHRcdFx0XHRvYmouc2V0RGVncmVlKGRpcyoxMCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG1vdXNldXA6ZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR2YXIgeSA9IHRoaXMuc3RhcnRbMV0gPD0gX3RoaXMuYmcuc3RhcnRbMV0/X3RoaXMuYmcuc3RhcnRbMV06dGhpcy5zdGFydFsxXTtcblx0XHRcdFx0XHR5ID0gdGhpcy5zdGFydFsxXSA+PSAoX3RoaXMuYmcuc3RhcnRbMV0rMzYpPyhfdGhpcy5iZy5zdGFydFsxXSszNik6eTtcblxuXHRcdFx0XHRcdHRoaXMuc2V0U3RhcnQoW3RoaXMuc3RhcnRbMF0seV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcblx0dGhpcy50ZXh0ID0gdGhpcy5xY2FudmFzLnF0ZXh0LnRleHQoe1xuXHRcdHN0YXJ0OmZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgYyA9IF90aGlzLnJvdGF0ZU9iai5jZW50ZXJQb2ludHMoKTtcblx0XHRcdHJldHVybiBbYy54LGMueV07XG5cdFx0fSxcblx0XHQvLyBbYy54LGMueV0sXG5cdFx0dGV4dDpmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIChfdGhpcy5yb3RhdGVPYmouZGVncmVlPDA/KF90aGlzLnJvdGF0ZU9iai5kZWdyZWUrMzYwKTpfdGhpcy5yb3RhdGVPYmouZGVncmVlKSsny5onO1xuXHRcdH1cblx0fSlcdFxuXG5cdFxuXHR0aGlzLnJvdGF0ZUxheWVyLnB1c2godGhpcy5iZyx0aGlzLmhhbmRsZXIsdGhpcy50ZXh0KTtcdCBcbn1cblxuUXJvdGF0ZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGlkKSB7XG5cdHRoaXMucm90YXRlTGF5ZXIgPSB0aGlzLnFjYW52YXMucWxheWVyLmxheWVyKCk7XG5cdHRoaXMucm90YXRlT2JqID0gdGhpcy5xY2FudmFzLmdldEVsZUJ5SWQoaWQpO1xuXG5cblx0c3dpdGNoKHRoaXMucm90YXRlT2JqLlRZUEUpe1xuXHRcdGNhc2UgJ3JlY3QnOlxuXHRcdFx0dGhpcy5yZWN0Um90YXRlKCk7XG5cdFx0YnJlYWs7XG5cdH1cblxuXG5cblx0dGhpcy5yb3RhdGVMYXllci5zZXREaXNwbGF5KCdibG9jaycpO1xuXG5cdHRoaXMucWNhbnZhcy5yYWlzZVRvVG9wKHRoaXMucm90YXRlTGF5ZXIpO1xuXG59O1xuXG5Rcm90YXRlLnByb3RvdHlwZS51cGRhdGVFbGVQb3NpdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuXHQvLyB2YXIgb2JqID0gdGhpcy5xY2FudmFzLmRyYWdBaW07XG5cdHZhciBvYmogPSB0aGlzLnJvdGF0ZU9iajtcblx0dmFyIGMgPSAgb2JqLmNlbnRlclBvaW50cygpO1xuXHR2YXIgc3RhcnQgPSB0aGlzLnFjYW52YXMuaXNGdW4ob2JqLnN0YXJ0KT9vYmouc3RhcnQoKTpvYmouc3RhcnQ7XG5cblx0dmFyIHIgPSBNYXRoLnNxcnQoTWF0aC5wb3coTWF0aC5hYnMoYy54LXN0YXJ0WzBdKSwyKStNYXRoLnBvdyhNYXRoLmFicyhjLnktc3RhcnRbMV0pLDIpKTtcblx0IFxuXHR0aGlzLmJnLnNldFN0YXJ0KFtjLngrcisxMCxjLnktMThdKTtcblx0dGhpcy5oYW5kbGVyLnNldFN0YXJ0KFtjLngrcisxMCsyLGMueS0xOCsob2JqLmRlZ3JlZTwwPyhvYmouZGVncmVlKzM2MCk6b2JqLmRlZ3JlZSkvMTBdKTtcblxufVxuXG5Rcm90YXRlLnByb3RvdHlwZS5zaG93SGFuZGxlciA9IGZ1bmN0aW9uKG9iaikge1xuXHR0aGlzLnJvdGF0ZU9iaiA9IG9iajtcblx0dGhpcy51cGRhdGVFbGVQb3NpdGlvbihvYmopO1xuXHR0aGlzLnJvdGF0ZUxheWVyLnNldERpc3BsYXkoJ2Jsb2NrJyk7XG5cdHRoaXMucWNhbnZhcy5yYWlzZVRvVG9wKHRoaXMucm90YXRlTGF5ZXIpO1xuXG5cdFxufTtcblxuUXJvdGF0ZS5wcm90b3R5cGUuaGlkZUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5yb3RhdGVMYXllci5zZXREaXNwbGF5KCdub25lJyk7XG59XG5cbi8qKlxuICog57yp5pS+5o6n5Lu257G7XG4gKiBAcGFyYW0ge1t0eXBlXX0gcWNhbnZhcyBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge1t0eXBlXX0gaWQgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIFFyZXNpemUocWNhbnZhcyxpZCl7XG5cdHRoaXMucXJvdGF0ZVZlcnNpb24gPSAnMS4wJztcblx0dGhpcy5xY2FudmFzID0gcWNhbnZhcztcblx0dGhpcy5yZXNpemVMYXllciA9IG51bGw7XG5cdHRoaXMucmVzaXplT2JqID0gbnVsbDtcblxuXHR0aGlzLmluaXQoaWQpO1xufVxuXG4vL+WPluW+l+mhtueCueWdkOagh+S4rSDku6XlhYPntKDkuK3lv4PngrnliKTmlq0g77yI5Y+z6L655LiU6Z2g5LiL55qE5LiA5Liq54K577yJXG5RcmVzaXplLnByb3RvdHlwZS5yaWdodEJvdHRvbVBvaW50ID0gZnVuY3Rpb24ob2JqKXtcblx0dmFyIHBvbHlQb2ludHMgPSBvYmoucG9seVBvaW50cygpO1xuXHR2YXIgeEFyciA9IHBvbHlQb2ludHMubWFwKGZ1bmN0aW9uKGl0ZW0pe3JldHVybiBpdGVtLnh9KTtcblx0dmFyIHlBcnIgPSBwb2x5UG9pbnRzLm1hcChmdW5jdGlvbihpdGVtKXtyZXR1cm4gaXRlbS55fSk7XG4gXG5cdHZhciBtYXhYID0gTWF0aC5tYXguYXBwbHkoe30seEFycik7XG5cdHZhciBtYXhZID0gTWF0aC5tYXguYXBwbHkoe30seUFycik7XG4gXG5cdHJldHVybiBbXG5cdFx0W01hdGgubWluLmFwcGx5KHt9LHhBcnIpLE1hdGgubWluLmFwcGx5KHt9LHlBcnIpXSxcblx0XHRbTWF0aC5tYXguYXBwbHkoe30seEFyciksTWF0aC5tYXguYXBwbHkoe30seUFycildLFxuXG5cdF1cblxuXG59XG4gXG5cblFyZXNpemUucHJvdG90eXBlLnJlY3RSZXNpemUgPSBmdW5jdGlvbihvYmopIHtcblx0dmFyIF90aGlzID0gdGhpcztcblx0Ly8gdmFyIHN0YXJ0QW5kRW5kUG9zaXRpb24gPSB0aGlzLnJpZ2h0Qm90dG9tUG9pbnQob2JqKTtcblx0dmFyIGMgPSB0aGlzLnJlc2l6ZU9iai5jZW50ZXJQb2ludHMoKTtcblx0dmFyIHN0YXJ0ID0gdGhpcy5xY2FudmFzLmlzRnVuKHRoaXMucmVzaXplT2JqLnN0YXJ0KT90aGlzLnJlc2l6ZU9iai5zdGFydCgpOnRoaXMucmVzaXplT2JqLnN0YXJ0O1xuXG5cdHZhciBvbGRIZWlnaHQgPSBudWxsO1xuXHR2YXIgb2xkV2lkdGggPSBudWxsO1xuXHR2YXIgcmF0ZSA9IG51bGw7IC8v5a696auY5q+UXG5cblx0Ly/nn6nlvaLkuK3lv4PngrnliLDlvIDlp4vlnZDmoIfngrnnmoTot53nprvvvIjkuKTngrnkuYvnmoTot53nprvlgZrkuLrkuIDkuKrlnIbnmoTljYrlvoTvvIlcblx0dmFyIHIgPSBNYXRoLnNxcnQoTWF0aC5wb3coTWF0aC5hYnMoYy54LXN0YXJ0WzBdKSwyKStNYXRoLnBvdyhNYXRoLmFicyhjLnktc3RhcnRbMV0pLDIpKTtcblxuXG5cdHRoaXMuY292ZXIgPSB0aGlzLnFjYW52YXMucWFyYy5hcmMoe1xuXHRcdFx0XHRzdGFydDpbYy54LGMueV0sXG5cdFx0XHRcdHNBbmdsZTowLFxuXHRcdFx0XHRlQW5nbGU6MzYwLFxuXHRcdFx0XHRmaWxsQ29sb3I6JycsXG5cdFx0XHRcdC8vIG9wYWNpdHk6MC4yLFxuXHRcdFx0XHRib3JkZXJDb2xvcjonYmx1ZScsXG5cdFx0XHRcdHBvaW50ZXJFdmVudDonbm9uZScsXG5cdFx0XHRcdGxpa2U6Jy0tJyxcblx0XHRcdFx0dGl0bGU6J3Jlc2l6ZeimhuebluWFg+e0oCcsXG5cdFx0XHRcdHI6clxuXHRcdFx0fSlcblxuXHR2YXIgcG9seVBvaW50cyA9IHRoaXMucmVzaXplT2JqLnBvbHlQb2ludHMoKTsgXG5cdHZhciBwb3NpdGlvbiA9IHRoaXMuY292ZXIucG9seVBvaW50cygpO1xuXG5cdHRoaXMuaGFuZGxlciA9IHRoaXMucWNhbnZhcy5xYXJjLmFyYyh7XG5cdFx0XHRcdHN0YXJ0Oltwb3NpdGlvbls3XS54LHBvc2l0aW9uWzddLnldLFxuXHRcdFx0XG5cdFx0XHRcdHNBbmdsZTowLFxuXHRcdFx0XHRlQW5nbGU6MzYwLFxuXHRcdFx0XHRmaWxsQ29sb3I6J3JlZCcsXG5cdFx0XHRcdG9wYWNpdHk6MC4yLCBcblx0XHRcdFx0dGl0bGU6J3Jlc2l6ZeaTjeS9nOWPpeafhCcsXG5cdFx0XHRcdHI6MTAsXG5cdFx0XHRcdG1vdXNlZG93bjpmdW5jdGlvbigpeyBcblxuXHRcdFx0XHRcdG9sZEhlaWdodCA9IF90aGlzLnJlc2l6ZU9iai5oZWlnaHQ7XG5cdFx0XHRcdFx0b2xkV2lkdGggPSBfdGhpcy5yZXNpemVPYmoud2lkdGg7XG5cblxuXHRcdFx0XHRcdHJhdGUgPSBfdGhpcy5yZXNpemVPYmoud2lkdGgvX3RoaXMucmVzaXplT2JqLmhlaWdodDtcblxuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG1vdXNlbW92ZTpmdW5jdGlvbigpeyBcblxuXHRcdFx0XHRcdGlmKHJhdGUgIT09IG51bGwpeyBcblx0XHRcdFx0XHRcdHZhciBjID0gX3RoaXMucmVzaXplT2JqLmNlbnRlclBvaW50cygpO1xuXG5cblx0XHRcdFx0XHRcdC8v6YeN572udGhpcy5wb2ludOeahOWNiuW+hFxuXHRcdFx0XHRcdFx0dmFyIFIgPSBNYXRoLnNxcnQoTWF0aC5wb3coTWF0aC5hYnMoYy54LXRoaXMuc3RhcnRbMF0pLDIpK01hdGgucG93KE1hdGguYWJzKGMueS10aGlzLnN0YXJ0WzFdKSwyKSk7XG5cdFx0XHRcdFx0XHRfdGhpcy5jb3Zlci5zZXRSKFIpO1xuXG5cblx0XHRcdFx0XHRcdHZhciBuZXdIID0gTWF0aC5zcXJ0KDQqUipSLyhyYXRlKnJhdGUrMSkpO1xuXHRcdFx0XHRcdFx0dmFyIG5ld1cgPSByYXRlKm5ld0g7XG5cdFx0XHRcdFx0XHR2YXIgc3RhcnQgPSBbYy54LW5ld1cqMC41LGMueS1uZXdIKjAuNV07XG5cblx0XHRcdFx0XHRcdF90aGlzLnJlc2l6ZU9iai5zZXRTdGFydChzdGFydCk7XG5cdFx0XHRcdFx0XHRfdGhpcy5yZXNpemVPYmouc2V0SGVpZ2h0KG5ld0gpO1xuXHRcdFx0XHRcdFx0X3RoaXMucmVzaXplT2JqLnNldFdpZHRoKG5ld1cpO1xuXG5cblx0XHRcdFx0XHRcdC8vIGlmKF90aGlzLnFjYW52YXMucXJvdGF0ZSAhPT0gbnVsbFxuXHRcdFx0XHRcdFx0Ly8gXHQmJiBfdGhpcy5xY2FudmFzLnFyb3RhdGUucm90YXRlT2JqLnJvdGF0ZSl7XG5cdFx0XHRcdFx0XHRpZihfdGhpcy5yZXNpemVPYmoucm90YXRlKXtcdFxuIFxuXHRcdFx0XHRcdFx0XHRfdGhpcy5xY2FudmFzLnFyb3RhdGUucm90YXRlTGF5ZXIuZWxlbWVudHNbMF0uc2V0U3RhcnQoW2MueCtSKzEwLGMueS0xOF0pO1xuXHRcdFx0XHRcdFx0XHRfdGhpcy5xY2FudmFzLnFyb3RhdGUuc2hvd0hhbmRsZXIoX3RoaXMucmVzaXplT2JqKTtcblxuXHRcdFx0XHRcdFx0fWVsc2UgaWYoX3RoaXMucWNhbnZhcy5xcm90YXRlICE9PW51bGwpeyBcblx0XHRcdFx0XHRcdFx0X3RoaXMucWNhbnZhcy5xcm90YXRlLnJvdGF0ZUxheWVyLnNldERpc3BsYXkoJ25vbmUnKTtcblx0XHRcdFx0XHRcdH1cdFxuXG5cblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHR9LFxuXHRcdFx0XHRtb3VzZXVwOmZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0b2xkSGVpZ2h0ID0gbnVsbDtcblx0XHRcdFx0XHRvbGRXaWR0aCA9IG51bGw7XG5cblx0XHRcdFx0XHRyYXRlID0gbnVsbDtcblx0XHRcdFx0fVxuXHR9KVxuXG5cbiBcblx0XG5cdHRoaXMucmVzaXplTGF5ZXIucHVzaCh0aGlzLmNvdmVyLHRoaXMuaGFuZGxlcik7XG59XG5cblFyZXNpemUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihpZCkge1xuXHR0aGlzLnJlc2l6ZUxheWVyID0gdGhpcy5xY2FudmFzLnFsYXllci5sYXllcigpO1xuXHR0aGlzLnJlc2l6ZU9iaiA9IHRoaXMucWNhbnZhcy5nZXRFbGVCeUlkKGlkKTtcblx0Ly8gY29uc29sZS5sb2cob2JqKTtcblxuXG5cdHN3aXRjaCh0aGlzLnJlc2l6ZU9iai5UWVBFKXtcblx0XHRjYXNlICdyZWN0Jzpcblx0XHRcdHRoaXMucmVjdFJlc2l6ZSgpO1xuXHRcdGJyZWFrO1xuXHR9XG5cblxuXG5cdHRoaXMucmVzaXplTGF5ZXIuc2V0RGlzcGxheSgnYmxvY2snKTtcblxuXHR0aGlzLnFjYW52YXMucmFpc2VUb1RvcCh0aGlzLnJlc2l6ZUxheWVyKTtcbn07XG5cblFyZXNpemUucHJvdG90eXBlLnVwZGF0ZUVsZVBvc2l0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG5cdC8vIHZhciBvYmogPSB0aGlzLnFjYW52YXMuZHJhZ0FpbTtcblx0dmFyIG9iaiA9IHRoaXMucmVzaXplT2JqO1xuXHR2YXIgYyA9ICBvYmouY2VudGVyUG9pbnRzKCk7XG5cdHZhciBzdGFydCA9IHRoaXMucWNhbnZhcy5pc0Z1bihvYmouc3RhcnQpP29iai5zdGFydCgpOm9iai5zdGFydDtcblxuXHR2YXIgciA9IE1hdGguc3FydChNYXRoLnBvdyhNYXRoLmFicyhjLngtc3RhcnRbMF0pLDIpK01hdGgucG93KE1hdGguYWJzKGMueS1zdGFydFsxXSksMikpO1xuXHQgXG5cdHRoaXMuY292ZXIuc2V0U3RhcnQoW2MueCxjLnldKTtcblx0dGhpcy5jb3Zlci5zZXRSKHIpO1xuXG5cblx0dmFyIHBvc2l0aW9uID0gdGhpcy5jb3Zlci5wb2x5UG9pbnRzKCk7XG5cdHRoaXMuaGFuZGxlci5zZXRTdGFydChbcG9zaXRpb25bN10ueCxwb3NpdGlvbls3XS55XSk7XG5cbn1cblxuUXJlc2l6ZS5wcm90b3R5cGUuc2hvd0hhbmRsZXIgPSBmdW5jdGlvbihvYmopIHtcblxuXHRpZihvYmouaWQgIT0gdGhpcy5yZXNpemVPYmouaWQpeyAvL+WIh+aNouS4jeWQjOeahOWFg+e0oOaXtiDnvKnmlL7lkozop5Lluqbmjqfku7bpg73pmpDol49cblx0XHR0aGlzLnJlc2l6ZU9iai5yb3RhdGUgJiYgIHRoaXMucWNhbnZhcy5xcm90YXRlLnJvdGF0ZUxheWVyLnNldERpc3BsYXkoJ25vbmUnKTtcblx0XHR0aGlzLnJlc2l6ZU9iai5yZXNpemUgJiYgIHRoaXMucWNhbnZhcy5xcmVzaXplLnJlc2l6ZUxheWVyLnNldERpc3BsYXkoJ25vbmUnKTtcblx0fVx0XG5cblx0dGhpcy5yZXNpemVPYmogPSBvYmo7XG5cblxuXHR0aGlzLnVwZGF0ZUVsZVBvc2l0aW9uKCk7XG5cdHRoaXMucmVzaXplTGF5ZXIuc2V0RGlzcGxheSgnYmxvY2snKTtcblx0dGhpcy5xY2FudmFzLnJhaXNlVG9Ub3AodGhpcy5yZXNpemVMYXllcik7XG5cblxuIFxuXHRcbn07XG5cblFyZXNpemUucHJvdG90eXBlLmhpZGVIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMucmVzaXplTGF5ZXIuc2V0RGlzcGxheSgnbm9uZScpO1xufVxuXHRcblxuLypcbueUu+W4g+ahhuaetlFjYW52YXPnu5PmnoQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiovXG4vKuS4u+exuyovXG4vKlxuY19wOuWIneWni+WMlmNhbnZhc+WPguaVsOaVsOe7hFxuKi9cdFxuZnVuY3Rpb24gUWNhbnZhcyhvcHRpb25zKXtcblx0XG5cdHZhciBkb2MgPSBkb2N1bWVudDtcblx0dGhpcy5kcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbzsgLy8g5YGH6K6+dGhpcy5kcHLkuLoyXG5cdHRoaXMuZGVsYXlSZW5kZXIgPSBmYWxzZTsgIC8v5piv5ZCm5bu25pe25omn6KGMICjlpoLmnpzlhYPntKDku6XpnZnmgIHkuLrkuLsg5bu66K6u5byA5ZCvIOWinuWKoOa4suafk+aViOeOhylcblxuXHRpZih0aGlzLmlzQXJyKG9wdGlvbnMpKXtcblx0XHRpZihvcHRpb25zLmxlbmd0aDwzICl7XG5cdFx0XHRjb25zb2xlLmxvZygn5Yid5aeL5YyW5Y+C5pWw5LiN5q2j56GuJyk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHRcdHZhciBjX29iaiA9IGRvYy5nZXRFbGVtZW50QnlJZChvcHRpb25zWzBdKTtcblx0XHRjX29iai53aWR0aCA9IG9wdGlvbnNbMV0qdGhpcy5kcHI7XG5cdFx0Y19vYmouaGVpZ2h0ID0gb3B0aW9uc1syXSp0aGlzLmRwcjtcblx0XHRjX29iai5zdHlsZS53aWR0aCA9IG9wdGlvbnNbMV0rJ3B4Jztcblx0XHRjX29iai5zdHlsZS5oZWlnaHQgPSBvcHRpb25zWzJdKydweCc7XG5cblx0XHRcblx0XHQvL+iInuWPsOWvueixoVxuXHRcdHRoaXMuc3RhZ2UgPSB7XG5cdFx0XHRcImNhbnZhc1wiOmNfb2JqLFxuXHRcdFx0XCJpZFwiOm9wdGlvbnNbMF0sXG5cdFx0XHRcIndpZHRoXCI6b3B0aW9uc1sxXSxcblx0XHRcdFwiaGVpZ2h0XCI6b3B0aW9uc1syXVxuXHRcdH07XG5cdH1cblxuXG5cdGlmKHRoaXMuaXNPYmoob3B0aW9ucykpe1xuXG5cdFx0aWYoKHR5cGVvZiBvcHRpb25zLmlkID09J3VuZGVmaW5lZCcpIFxuXHRcdFx0fHwgKHR5cGVvZiBvcHRpb25zLmhlaWdodCA9PSd1bmRlZmluZWQnKVxuXHRcdFx0fHwgKHR5cGVvZiBvcHRpb25zLndpZHRoID09J3VuZGVmaW5lZCcpKXtcblx0XHRcdGNvbnNvbGUubG9nKCfliJ3lp4vljJblj4LmlbDkuI3mraPnoa4nKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG4gXG5cdFx0dmFyIGNfb2JqID0gZG9jLmdldEVsZW1lbnRCeUlkKG9wdGlvbnMuaWQpO1xuXHRcdGNfb2JqLndpZHRoID0gb3B0aW9ucy53aWR0aCp0aGlzLmRwcjtcblx0XHRjX29iai5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCp0aGlzLmRwcjtcblx0XHRjX29iai5zdHlsZS53aWR0aCA9IG9wdGlvbnMud2lkdGgrJ3B4Jztcblx0XHRjX29iai5zdHlsZS5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCsncHgnO1xuXHRcdFxuXHRcdC8v6Iie5Y+w5a+56LGhXG5cdFx0dGhpcy5zdGFnZSA9IHtcblx0XHRcdFwiY2FudmFzXCI6Y19vYmosXG5cdFx0XHRcImlkXCI6b3B0aW9ucy5pZCxcblx0XHRcdFwid2lkdGhcIjpvcHRpb25zLndpZHRoLFxuXHRcdFx0XCJoZWlnaHRcIjpvcHRpb25zLmhlaWdodFxuXHRcdH07XG5cblx0XHR0aGlzLm1vdXNlZG93biA9IG9wdGlvbnMubW91c2Vkb3duIHx8IGZ1bmN0aW9uKCl7fTtcblx0XHR0aGlzLm1vdXNlbW92ZSA9IG9wdGlvbnMubW91c2Vtb3ZlIHx8IGZ1bmN0aW9uKCl7fTtcblx0XHR0aGlzLm1vdXNldXAgPSBvcHRpb25zLm1vdXNldXAgfHwgZnVuY3Rpb24oKXt9O1xuXHRcdHRoaXMubW91c2VvdXQgPSBvcHRpb25zLm1vdXNlb3V0IHx8IGZ1bmN0aW9uKCl7fTtcblx0XHR0aGlzLm1vdXNlZW50ZXIgPSBvcHRpb25zLm1vdXNlZW50ZXIgfHwgZnVuY3Rpb24oKXt9O1xuXHRcdHRoaXMuZGJsY2xpY2sgPSBvcHRpb25zLmRibGNsaWNrIHx8IGZ1bmN0aW9uKCl7fTtcblxuXG5cdFx0dGhpcy5kZWxheVJlbmRlciA9IHR5cGVvZiBvcHRpb25zLmRlbGF5UmVuZGVyICE9J3VuZGVmaW5lZCc/b3B0aW9ucy5kZWxheVJlbmRlciA6ZmFsc2U7XG5cdH1cblxuXHR0aGlzLmNyZWF0ZVNoYWRvd0NhbnZhcygpO1x0XG5cblx0Ly8gaWYob3B0aW9ucy5sZW5ndGg8MyApe1xuXHQvLyBcdC8vIGNvbnNvbGUubG9nKCdRY2FudmFzIOWIneWni+WMluWPguaVsOS4jeato+ehricpO1xuXHQvLyBcdHJldHVybiBmYWxzZTtcblx0Ly8gfVxuXHRcblx0Ly8gdmFyIGNfb2JqID0gZG9jLmdldEVsZW1lbnRCeUlkKG9wdGlvbnNbMF0pO1xuXHQvLyBjX29iai53aWR0aCA9IG9wdGlvbnNbMV07XG5cdC8vIGNfb2JqLmhlaWdodCA9IG9wdGlvbnNbMl07XG5cdFxuXHQvLyAvL+iInuWPsOWvueixoVxuXHQvLyB0aGlzLnN0YWdlID0ge1xuXHQvLyBcdFwiaWRcIjpvcHRpb25zWzBdLFxuXHQvLyBcdFwid2lkdGhcIjpvcHRpb25zWzFdLFxuXHQvLyBcdFwiaGVpZ2h0XCI6b3B0aW9uc1syXVxuXHQvLyB9O1xuXHRcblx0dGhpcy5xY2FudmFzVmVyc2lvbiA9ICcxLjAnO1xuXHR0aGlzLlRZUEUgPSAnY2FudmFzJztcblx0dGhpcy5pZCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkrJycrcGFyc2VJbnQoTWF0aC5yYW5kb20oKSoxMDAwMDAwMDApO1xuXHR0aGlzLmNvbnRleHQgPSBjX29iai5nZXRDb250ZXh0KCcyZCcpO1xuXHQvLyDpnIDopoHlsIbnu5jliLbmr5TkvovmlL7lpKdcbiAgICB0aGlzLmNvbnRleHQuc2NhbGUodGhpcy5kcHIsdGhpcy5kcHIpO1xuXG5cdHRoaXMuY2FudmFzID0gY19vYmo7XG5cdHRoaXMuZnBzID0gNjA7XG5cdHRoaXMuZHJhZ0FpbSA9IG51bGw7ICAvL+W9k+WJjeaLluWKqOeahOWvueixoVxuXHR0aGlzLm1vdmVBaW0gPSBudWxsOyAgLy/lvZPliY3pvKDmoIfliJLov4fnmoTlr7nosaFcblxuXHQvL+W9k+acieWFg+e0oOaciemFjee9ruS6hnJlc2l6ZeaXtiDmiY3kvJrliJvlu7pxcmVzaXpl5a6e5L6LXG5cdC8vcXJlc2l6ZSA9IHtcblx0Ly9cdHJlc2l6ZUxheWVyOnt9IC8v5piv5LiA5LiqbGF5ZXLlr7nosaEg5L+d5a2Y5pyJ5LiA57uE57yp5pS+5aSn5bCP55qE5pON5L2c54K5XG5cdC8vfVxuXHR0aGlzLnFyZXNpemUgPSBudWxsOyAgXG5cblxuXHQvL+W9k+WFg+e0oOmFjee9ruS6hnJvdGF0ZeaXtiDmiY3kvJrliJvlu7pxcm90YXRl5a6e5L6LXG5cdC8vcXJvdGF0ZSA9IHtcblx0Ly9cdHJvdGF0ZUxheWVyOnt9IC8v5piv5LiA5LiqbGF5ZXLlr7nosaEg5L+d5a2Y5pyJ5LiA57uE6KeS5bqm55qE5pON5L2c54K5XG5cdC8vfVxuXHR0aGlzLnFyb3RhdGUgPSBudWxsOyAgXG5cblx0XG5cdFxuXHRcblx0XG5cdC8v5YWD57Sg5pWw57uEIO+8iOaMiXotaW5kZXjnlLHlsI/liLDlpKfmjpLluo/vvIlcblx0dGhpcy5lbGVtZW50cyA9IFtdO1xuXHQgXG5cdFxuXHRcblx0dGhpcy5xbGluZSA9IG5ldyBRbGluZSh0aGlzKTtcblx0dGhpcy5xdGV4dCA9IG5ldyBRdGV4dCh0aGlzKTtcblx0dGhpcy5xcmVjdCA9IG5ldyBRcmVjdCh0aGlzKTtcblx0dGhpcy5xYXJjID0gbmV3IFFhcmModGhpcyk7XG5cdHRoaXMucXBvbHlnb24gPSBuZXcgUXBvbHlnb24odGhpcyk7XG5cdHRoaXMucWFuaW1hdGlvbiA9IG5ldyBRYW5pbWF0aW9uKHRoaXMpO1xuXHR0aGlzLnFpbWcgPSBuZXcgUWltZyh0aGlzKTtcblx0dGhpcy5xc3Bpcml0ID0gbmV3IFFzcGlyaXQodGhpcyk7XG5cdHRoaXMucXNoYXBlID0gbmV3IFFzaGFwZSh0aGlzKTtcblxuXHRRbGF5ZXIucHJvdG90eXBlID0gdGhpcztcblx0dGhpcy5xbGF5ZXIgPSBuZXcgUWxheWVyKHRoaXMpO1xuXHR0aGlzLnFncm91cCA9IG5ldyBRZ3JvdXAodGhpcyk7XG5cblxuXHR0aGlzLnFxdWFkcmF0aWNDdXJ2ZSA9IG5ldyBRcXVhZHJhdGljQ3VydmUodGhpcyk7XG5cdHRoaXMucWJlemllckN1cnZlID0gbmV3IFFiZXppZXJDdXJ2ZSh0aGlzKTtcblx0XG5cdFxuXHR0aGlzLmV2ZW50ID0gbmV3IFFldmVudCh0aGlzKTtcblx0XG5cdC8vIHRoaXMuYW5pbWF0aW9uRnJhbWUgPSB0aGlzLnJlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUoKTtcblx0Ly8gY29uc29sZS5sb2coJ2FuaW1hdGlvbkZyYW1lJyk7XG5cdC8vIGNvbnNvbGUubG9nKHRoaXMuYW5pbWF0aW9uRnJhbWUudG9TdHJpbmcoKSk7XG5cdFxuXHQvL+iuoeeul2Zwc1xuXHR0aGlzLmxhc3RMb29wID0gKG5ldyBEYXRlKCkpLmdldE1pbGxpc2Vjb25kcygpO1xuXHR0aGlzLmNvdW50ID0gMTtcbiAgXHR0aGlzLmN1cnJGcHMgPSAwO1xuXG4gIFx0dGhpcy5UeXBlR3JvdXAgPSB7XG4gIFx0XHQnbGluZSc6dGhpcy5xbGluZS5wYWludExpbmUsXG4gIFx0XHQndGV4dCc6dGhpcy5xdGV4dC5wYWludFRleHQsXG4gIFx0XHQncmVjdCc6dGhpcy5xcmVjdC5wYWludFJlY3QsXG4gIFx0XHQnYXJjJzp0aGlzLnFhcmMucGFpbnRBcmMsXG4gIFx0XHQncG9seWdvbic6dGhpcy5xcG9seWdvbi5wYWludFBvbHlnb24sXG4gIFx0XHQnaW1nJzp0aGlzLnFpbWcucGFpbnRJbWcsXG4gIFx0XHQnc3Bpcml0Jzp0aGlzLnFzcGlyaXQucGFpbnRTcGlyaXQsXG4gIFx0XHQnc2hhcGUnOnRoaXMucXNoYXBlLnBhaW50U2hhcGUsXG4gIFx0XHQnbGF5ZXInOnRoaXMucWxheWVyLnBhaW50TGF5ZXIsIFxuICBcdFx0J2dyb3VwJzp0aGlzLnFncm91cC5wYWludEdyb3VwLFxuICBcdFx0J3F1YWRyYXRpY0N1cnZlJzp0aGlzLnFxdWFkcmF0aWNDdXJ2ZS5wYWludFF1YWRyYXRpY0N1cnZlLFxuICBcdFx0J2JlemllckN1cnZlJzp0aGlzLnFiZXppZXJDdXJ2ZS5wYWludEJlemllckN1cnZlXG4gIFx0fSBcblxuXG4gIFx0Ly8xcHjljaDkvY3lm74gXG4gIFx0dGhpcy5wbGFjZUhvbGRlckltZyA9IG5ldyBJbWFnZSgpO1xuICBcdHRoaXMucGxhY2VIb2xkZXJJbWcuc3JjID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQUVBQUFBQkNBWUFBQUFmRmNTSkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeWhwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRRd0lEYzVMakUyTURRMU1Td2dNakF4Tnk4d05TOHdOaTB3TVRvd09Eb3lNU0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UZ2dLRTFoWTJsdWRHOXphQ2tpSUhodGNFMU5Pa2x1YzNSaGJtTmxTVVE5SW5odGNDNXBhV1E2TkRsRU16YzROemxGTURKRE1URkZRVUUxUWtSRVF6VkRSakEyTkRnek5FUWlJSGh0Y0UxTk9rUnZZM1Z0Wlc1MFNVUTlJbmh0Y0M1a2FXUTZORGxFTXpjNE4wRkZNREpETVRGRlFVRTFRa1JFUXpWRFJqQTJORGd6TkVRaVBpQThlRzF3VFUwNlJHVnlhWFpsWkVaeWIyMGdjM1JTWldZNmFXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzBPVVF6TnpnM04wVXdNa014TVVWQlFUVkNSRVJETlVOR01EWTBPRE0wUkNJZ2MzUlNaV1k2Wkc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvME9VUXpOemczT0VVd01rTXhNVVZCUVRWQ1JFUkROVU5HTURZME9ETTBSQ0l2UGlBOEwzSmtaanBFWlhOamNtbHdkR2x2Ymo0Z1BDOXlaR1k2VWtSR1BpQThMM2c2ZUcxd2JXVjBZVDRnUEQ5NGNHRmphMlYwSUdWdVpEMGljaUkvUGgvMEhEc0FBQUFRU1VSQlZIamFZdmovL3o4RFFJQUJBQWo4QXY3Ym9rMFdBQUFBQUVsRlRrU3VRbUNDJ1xuXG5cdC8v5ZCv5YqoXG5cdHRoaXMuc3RhcnQoKTtcblx0Ly8gdGhpcy5yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lMS5jYWxsKHRoaXMsdGhpcy5zdGFydCk7XG5cdC8vIFxuXHQvLyBcbi8vIHdpbmRvdy5yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lKHRoaXMuc3RhcnQuYmluZCh0aGlzKSlcblxuXG4vLyB0aGlzLmFuaW1hdGlvbkZyYW1lKHRoaXMuc3RhcnQuYmluZCh0aGlzKSk7XG5cblxufVxuXG5RY2FudmFzLnByb3RvdHlwZS5jcmVhdGVTaGFkb3dDYW52YXMgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5zaGFkb3dDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0dGhpcy5zaGFkb3dDYW52YXMuaWQgPShuZXcgRGF0ZSgpKS5nZXRUaW1lKCkrJycrcGFyc2VJbnQoTWF0aC5yYW5kb20oKSoxMDAwMDAwMDApO1xuXHQvLyB0aGlzLnNoYWRvd0NhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdxY2FudmFzMScpO1xuXG5cblx0dGhpcy5zaGFkb3dDYW52YXMud2lkdGggPSB0aGlzLnN0YWdlLndpZHRoO1xuXHR0aGlzLnNoYWRvd0NhbnZhcy5oZWlnaHQgPSB0aGlzLnN0YWdlLmhlaWdodDsgIFxuXHR0aGlzLnNoYWRvd0NvbnRleHQgPSB0aGlzLnNoYWRvd0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG59O1xuUWNhbnZhcy5wcm90b3R5cGUuZ2V0U2hhZG93UGl4ZWxDb2xvciA9IGZ1bmN0aW9uKHBvcykge1xuXHQgIHZhciBpbWFnZURhdGEgPSB0aGlzLnNoYWRvd0NvbnRleHQuZ2V0SW1hZ2VEYXRhKHBvcy54LHBvcy55LCAxLCAxKTtcblx0ICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcblx0ICB2YXIgciA9IHBpeGVsWzBdO1xuXHQgIHZhciBnID0gcGl4ZWxbMV07XG5cdCAgdmFyIGIgPSBwaXhlbFsyXTtcblx0ICB2YXIgYSA9IHBpeGVsWzNdIC8gMjU1O1xuXHQgIGEgPSBNYXRoLnJvdW5kKGEgKiAxMDApIC8gMTAwO1xuXHQgIHZhciBySGV4ID0gci50b1N0cmluZygxNik7XG5cdCAgciA8IDE2ICYmIChySGV4ID0gXCIwXCIgKyBySGV4KTtcblx0ICB2YXIgZ0hleCA9IGcudG9TdHJpbmcoMTYpO1xuXHQgIGcgPCAxNiAmJiAoZ0hleCA9IFwiMFwiICsgZ0hleCk7XG5cdCAgdmFyIGJIZXggPSBiLnRvU3RyaW5nKDE2KTtcblx0ICBiIDwgMTYgJiYgKGJIZXggPSBcIjBcIiArIGJIZXgpO1xuXHQgIHZhciByZ2JhQ29sb3IgPSBcInJnYmEoXCIgKyByICsgXCIsXCIgKyBnICsgXCIsXCIgKyBiICsgXCIsXCIgKyBhICsgXCIpXCI7XG5cdCAgdmFyIHJnYkNvbG9yID0gXCJyZ2IoXCIgKyByICsgXCIsXCIgKyBnICsgXCIsXCIgKyBiICsgXCIpXCI7XG5cdCAgdmFyIGhleENvbG9yID0gXCIjXCIgKyBySGV4ICsgZ0hleCArIGJIZXg7XG5cdCAgcmV0dXJuIHtcblx0ICAgIHJnYmE6IHJnYmFDb2xvcixcblx0ICAgIHJnYjogcmdiQ29sb3IsXG5cdCAgICBoZXg6IGhleENvbG9yLFxuXHQgICAgcjogcixcblx0ICAgIGc6IGcsXG5cdCAgICBiOiBiLFxuXHQgICAgYTogYVxuXHQgIH07XG59O1xuLy/plIDmr4HmiYDmnInlr7nosaEg6YeK5pS+6LWE5rqQXG5RY2FudmFzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcblx0dGhpcy5lbGVtZW50cyA9IFtdOyBcblxufVxuUWNhbnZhcy5wcm90b3R5cGUuVHdlZW4gPSB7XG4gICAgTGluZWFyOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7IHJldHVybiBjKnQvZCArIGI7IH0sXG4gICAgUXVhZDoge1xuICAgICAgICBlYXNlSW46IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgZWFzZU91dDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgcmV0dXJuIC1jICoodCAvPSBkKSoodC0yKSArIGI7XG4gICAgICAgIH0sXG4gICAgICAgIGVhc2VJbk91dDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgaWYgKCh0IC89IGQgLyAyKSA8IDEpIHJldHVybiBjIC8gMiAqIHQgKiB0ICsgYjtcbiAgICAgICAgICAgIHJldHVybiAtYyAvIDIgKiAoKC0tdCkgKiAodC0yKSAtIDEpICsgYjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgQ3ViaWM6IHtcbiAgICAgICAgZWFzZUluOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKyBiO1xuICAgICAgICB9LFxuICAgICAgICBlYXNlT3V0OiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICByZXR1cm4gYyAqICgodCA9IHQvZCAtIDEpICogdCAqIHQgKyAxKSArIGI7XG4gICAgICAgIH0sXG4gICAgICAgIGVhc2VJbk91dDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgaWYgKCh0IC89IGQgLyAyKSA8IDEpIHJldHVybiBjIC8gMiAqIHQgKiB0KnQgKyBiO1xuICAgICAgICAgICAgcmV0dXJuIGMgLyAyKigodCAtPSAyKSAqIHQgKiB0ICsgMikgKyBiO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBRdWFydDoge1xuICAgICAgICBlYXNlSW46IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCp0ICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgZWFzZU91dDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgcmV0dXJuIC1jICogKCh0ID0gdC9kIC0gMSkgKiB0ICogdCp0IC0gMSkgKyBiO1xuICAgICAgICB9LFxuICAgICAgICBlYXNlSW5PdXQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIGlmICgodCAvPSBkIC8gMikgPCAxKSByZXR1cm4gYyAvIDIgKiB0ICogdCAqIHQgKiB0ICsgYjtcbiAgICAgICAgICAgIHJldHVybiAtYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCp0IC0gMikgKyBiO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBRdWludDoge1xuICAgICAgICBlYXNlSW46IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCAqIHQgKiB0ICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgZWFzZU91dDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgcmV0dXJuIGMgKiAoKHQgPSB0L2QgLSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxKSArIGI7XG4gICAgICAgIH0sXG4gICAgICAgIGVhc2VJbk91dDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgaWYgKCh0IC89IGQgLyAyKSA8IDEpIHJldHVybiBjIC8gMiAqIHQgKiB0ICogdCAqIHQgKiB0ICsgYjtcbiAgICAgICAgICAgIHJldHVybiBjIC8gMiooKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMikgKyBiO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBTaW5lOiB7XG4gICAgICAgIGVhc2VJbjogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgcmV0dXJuIC1jICogTWF0aC5jb3ModC9kICogKE1hdGguUEkvMikpICsgYyArIGI7XG4gICAgICAgIH0sXG4gICAgICAgIGVhc2VPdXQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjICogTWF0aC5zaW4odC9kICogKE1hdGguUEkvMikpICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgZWFzZUluT3V0OiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICByZXR1cm4gLWMgLyAyICogKE1hdGguY29zKE1hdGguUEkgKiB0L2QpIC0gMSkgKyBiO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBFeHBvOiB7XG4gICAgICAgIGVhc2VJbjogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgcmV0dXJuICh0PT0wKSA/IGIgOiBjICogTWF0aC5wb3coMiwgMTAgKiAodC9kIC0gMSkpICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgZWFzZU91dDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgcmV0dXJuICh0PT1kKSA/IGIgKyBjIDogYyAqICgtTWF0aC5wb3coMiwgLTEwICogdC9kKSArIDEpICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgZWFzZUluT3V0OiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICBpZiAodD09MCkgcmV0dXJuIGI7XG4gICAgICAgICAgICBpZiAodD09ZCkgcmV0dXJuIGIrYztcbiAgICAgICAgICAgIGlmICgodCAvPSBkIC8gMikgPCAxKSByZXR1cm4gYyAvIDIgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpICsgYjtcbiAgICAgICAgICAgIHJldHVybiBjIC8gMiAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpICsgYjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgQ2lyYzoge1xuICAgICAgICBlYXNlSW46IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIHJldHVybiAtYyAqIChNYXRoLnNxcnQoMSAtICh0IC89IGQpICogdCkgLSAxKSArIGI7XG4gICAgICAgIH0sXG4gICAgICAgIGVhc2VPdXQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjICogTWF0aC5zcXJ0KDEgLSAodCA9IHQvZCAtIDEpICogdCkgKyBiO1xuICAgICAgICB9LFxuICAgICAgICBlYXNlSW5PdXQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIGlmICgodCAvPSBkIC8gMikgPCAxKSByZXR1cm4gLWMgLyAyICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSkgKyBiO1xuICAgICAgICAgICAgcmV0dXJuIGMgLyAyICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpICsgYjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgRWxhc3RpYzoge1xuICAgICAgICBlYXNlSW46IGZ1bmN0aW9uKHQsIGIsIGMsIGQsIGEsIHApIHtcbiAgICAgICAgICAgIHZhciBzO1xuICAgICAgICAgICAgaWYgKHQ9PTApIHJldHVybiBiO1xuICAgICAgICAgICAgaWYgKCh0IC89IGQpID09IDEpIHJldHVybiBiICsgYztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcCA9PSBcInVuZGVmaW5lZFwiKSBwID0gZCAqIC4zO1xuICAgICAgICAgICAgaWYgKCFhIHx8IGEgPCBNYXRoLmFicyhjKSkge1xuICAgICAgICAgICAgICAgIHMgPSBwIC8gNDtcbiAgICAgICAgICAgICAgICBhID0gYztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKGMgLyBhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0ICogZCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKSArIGI7XG4gICAgICAgIH0sXG4gICAgICAgIGVhc2VPdXQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQsIGEsIHApIHtcbiAgICAgICAgICAgIHZhciBzO1xuICAgICAgICAgICAgaWYgKHQ9PTApIHJldHVybiBiO1xuICAgICAgICAgICAgaWYgKCh0IC89IGQpID09IDEpIHJldHVybiBiICsgYztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcCA9PSBcInVuZGVmaW5lZFwiKSBwID0gZCAqIC4zO1xuICAgICAgICAgICAgaWYgKCFhIHx8IGEgPCBNYXRoLmFicyhjKSkge1xuICAgICAgICAgICAgICAgIGEgPSBjOyBcbiAgICAgICAgICAgICAgICBzID0gcCAvIDQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBwLygyKk1hdGguUEkpICogTWF0aC5hc2luKGMvYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGEgKiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0ICogZCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgYyArIGIpO1xuICAgICAgICB9LFxuICAgICAgICBlYXNlSW5PdXQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQsIGEsIHApIHtcbiAgICAgICAgICAgIHZhciBzO1xuICAgICAgICAgICAgaWYgKHQ9PTApIHJldHVybiBiO1xuICAgICAgICAgICAgaWYgKCh0IC89IGQgLyAyKSA9PSAyKSByZXR1cm4gYitjO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwID09IFwidW5kZWZpbmVkXCIpIHAgPSBkICogKC4zICogMS41KTtcbiAgICAgICAgICAgIGlmICghYSB8fCBhIDwgTWF0aC5hYnMoYykpIHtcbiAgICAgICAgICAgICAgICBhID0gYzsgXG4gICAgICAgICAgICAgICAgcyA9IHAgLyA0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzID0gcCAvICgyICAqTWF0aC5QSSkgKiBNYXRoLmFzaW4oYyAvIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHQgPCAxKSByZXR1cm4gLS41ICogKGEgKiBNYXRoLnBvdygyLCAxMCogKHQgLT0xICkpICogTWF0aC5zaW4oKHQgKiBkIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpICsgYjtcbiAgICAgICAgICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgKiBkIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCApICogLjUgKyBjICsgYjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgQmFjazoge1xuICAgICAgICBlYXNlSW46IGZ1bmN0aW9uKHQsIGIsIGMsIGQsIHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcyA9PSBcInVuZGVmaW5lZFwiKSBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogKChzICsgMSkgKiB0IC0gcykgKyBiO1xuICAgICAgICB9LFxuICAgICAgICBlYXNlT3V0OiBmdW5jdGlvbih0LCBiLCBjLCBkLCBzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHMgPT0gXCJ1bmRlZmluZWRcIikgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICByZXR1cm4gYyAqICgodCA9IHQvZCAtIDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMSkgKyBiO1xuICAgICAgICB9LFxuICAgICAgICBlYXNlSW5PdXQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQsIHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcyA9PSBcInVuZGVmaW5lZFwiKSBzID0gMS43MDE1ODsgXG4gICAgICAgICAgICBpZiAoKHQgLz0gZCAvIDIpIDwgMSkgcmV0dXJuIGMgLyAyICogKHQgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCAtIHMpKSArIGI7XG4gICAgICAgICAgICByZXR1cm4gYyAvIDIqKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpICsgYjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgQm91bmNlOiB7XG4gICAgICAgIGVhc2VJbjogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgLy9yZXR1cm4gYyAtIFR3ZWVuLkJvdW5jZS5lYXNlT3V0KGQtdCwgMCwgYywgZCkgKyBiO1xuXHRcdFx0XHRcdHJldHVybiBjIC0gdGhpcy5lYXNlT3V0KGQtdCwgMCwgYywgZCkgKyBiO1xuICAgICAgICB9LFxuICAgICAgICBlYXNlT3V0OiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICBpZiAoKHQgLz0gZCkgPCAoMSAvIDIuNzUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogdCAqIHQpICsgYjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodCA8ICgyIC8gMi43NSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMS41IC8gMi43NSkpICogdCArIC43NSkgKyBiO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0IDwgKDIuNSAvIDIuNzUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDIuMjUgLyAyLjc1KSkgKiB0ICsgLjkzNzUpICsgYjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDIuNjI1IC8gMi43NSkpICogdCArIC45ODQzNzUpICsgYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZWFzZUluT3V0OiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICBpZiAodCA8IGQgLyAyKSB7XG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gVHdlZW4uQm91bmNlLmVhc2VJbih0ICogMiwgMCwgYywgZCkgKiAuNSArIGI7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmVhc2VJbih0ICogMiwgMCwgYywgZCkgKiAuNSArIGI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vcmV0dXJuIFR3ZWVuLkJvdW5jZS5lYXNlT3V0KHQgKiAyIC0gZCwgMCwgYywgZCkgKiAuNSArIGMgKiAuNSArIGI7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmVhc2VPdXQodCAqIDIgLSBkLCAwLCBjLCBkKSAqIC41ICsgYyAqIC41ICsgYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cdFxuXG5RY2FudmFzLnByb3RvdHlwZS5kZWxheVJlbmRlckZ1biA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnJlbmRlclRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHR0aGlzLmNsZWFyKCk7XG5cdHRoaXMucGFpbnQoKTtcblxuXHRpZigoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHRoaXMucmVuZGVyVGltZSk+IDE2KXtcblx0XHQvLyBjb25zb2xlLmxvZygn5riy5p+T6LaF6L+HMTZtc+S6hu+8jOmHjeaWsOabtOaWsOaXtumXtCcpO1xuXHRcdHRoaXMucmVuZGVyVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cdH1cblxufTtcbi8v5ZCv5YqoXG5RY2FudmFzLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCl7XG5cdCBcblx0aWYodGhpcy5kZWxheVJlbmRlcil7IFxuXHRcdGlmKHR5cGVvZiB0aGlzLnJlbmRlclRpbWUgPT0gJ3VuZGVmaW5lZCcpe1xuXHRcdFx0dGhpcy5kZWxheVJlbmRlckZ1bigpO1xuXG5cdFx0fWVsc2UgaWYoKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSB0aGlzLnJlbmRlclRpbWUpPiAxNil7XG5cdFx0XHR0aGlzLmRlbGF5UmVuZGVyRnVuKCk7XG5cdFx0fS8qZWxzZXtcblx0XHRcdGNvbnNvbGUubG9nKCfkuI3pnIDopoHph43mlrAg562J5LiL5LiA5LiqMTZtcycpO1xuXHRcdH0qL1xuXG5cdH1lbHNle1xuXHRcdHRoaXMuY2xlYXIoKTtcblx0XHR0aGlzLnBhaW50KCk7XG5cdH1cblx0XG5cdFxuXHQvL3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUuY2FsbCh0aGlzLFthcmd1bWVudHMuY2FsbGVlXSk7XG5cdFxuXHR2YXIgY3VycmVudExvb3AgPSAobmV3IERhdGUoKSkuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgaWYgKHRoaXMubGFzdExvb3AgPiBjdXJyZW50TG9vcCkge1xuXHRcdFx0dGhpcy5jdXJyRnBzID0gdGhpcy5jb3VudDtcbiAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgIH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNvdW50ICArPSAxO1x0XG4gICAgfVxuXHRcdFx0XHRcblx0XHR0aGlzLmxhc3RMb29wID0gY3VycmVudExvb3A7XHRcdFxuXHRcblx0Ly8gdGhpcy5hbmltYXRpb25GcmFtZSh0aGlzLmNhbGxiYWNrID0gYXJndW1lbnRzLmNhbGxlZSk7XG5cdC8vIHRoaXMuYW5pbWF0aW9uRnJhbWUodGhpcy5zdGFydC5iaW5kKHRoaXMpKTtcblxuXHQvLyB0aGlzLnJlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUxLmNhbGwodGhpcyx0aGlzLnN0YXJ0KTtcblxuXG53aW5kb3cucmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSh0aGlzLnN0YXJ0LmJpbmQodGhpcykpXG5cdFxufVx0XHRcdFx0XG5cdFxuXG4vL+agueaNrmVsZW1lbnRz5pWw57uEIOeUu+aJgOacieWFg+e0oFxuUWNhbnZhcy5wcm90b3R5cGUucGFpbnQgPSBmdW5jdGlvbihcdCl7XG5cdHZhciBsID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG5cdGZvcih2YXIgaSA9IDA7IGk8bDsgaSsrKXtcblx0XHR2YXIgbyA9IHRoaXMuZWxlbWVudHNbaV07XG5cblx0XHRpZihvLmRpc3BsYXk9PSdub25lJyl7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHR0aGlzLlR5cGVHcm91cFtvLlRZUEVdLmNhbGwodGhpc1sncScrby5UWVBFXSxvKTtcblx0XHRcblx0XHQvLyBzd2l0Y2ggKG8uVFlQRSl7XG5cdFx0Ly8gXHRjYXNlICdsaW5lJzpcblx0XHQvLyBcdFx0dGhpcy5xbGluZS5wYWludExpbmUobyk7XG5cdFx0Ly8gXHRcdGJyZWFrO1xuXHRcdC8vIFx0Y2FzZSAndGV4dCc6XG5cdFx0Ly8gXHRcdHRoaXMucXRleHQucGFpbnRUZXh0KG8pO1xuXHRcdC8vIFx0XHRicmVhaztcblx0XHQvLyBcdGNhc2UgJ3JlY3QnOlxuXHRcdC8vIFx0XHR0aGlzLnFyZWN0LnBhaW50UmVjdChvKTtcblx0XHQvLyBcdFx0YnJlYWs7XG5cdFx0Ly8gXHRjYXNlICdhcmMnOlxuXHRcdC8vIFx0XHR0aGlzLnFhcmMucGFpbnRBcmMobyk7XG5cdFx0Ly8gXHRcdGJyZWFrO1x0XG5cdFx0Ly8gXHRjYXNlICdwb2x5Z29uJzpcblx0XHQvLyBcdFx0dGhpcy5xcG9seWdvbi5wYWludFBvbHlnb24obyk7XG5cdFx0Ly8gXHRcdGJyZWFrO1x0XG5cdFx0Ly8gXHRjYXNlICdpbWcnOlxuXHRcdC8vIFx0XHR0aGlzLnFpbWcucGFpbnRJbWcobyk7XG5cdFx0Ly8gXHRcdGJyZWFrO1xuXHRcdC8vIFx0Y2FzZSAnc3Bpcml0Jzpcblx0XHQvLyBcdFx0dGhpcy5xc3Bpcml0LnBhaW50U3Bpcml0KG8pO1xuXHRcdC8vIFx0XHRicmVhaztcdFxuXHRcdC8vIFx0Y2FzZSAnc2hhcGUnOlxuXHRcdC8vIFx0XHR0aGlzLnFzaGFwZS5wYWludFNoYXBlKG8pO1xuXHRcdC8vIFx0XHRicmVhaztcdFx0XG5cdFx0Ly8gfVxuXHRcdFx0XHRcblx0fVxufVxuXG5cblxuXG5cblx0XG5RY2FudmFzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCl7XG5cdFx0dGhpcy5jYW52YXMud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aDtcblx0XHR0aGlzLmNvbnRleHQuc2NhbGUodGhpcy5kcHIsdGhpcy5kcHIpO1xuXHRcdHRoaXMuc2hhZG93Q2FudmFzLndpZHRoID0gdGhpcy5zaGFkb3dDYW52YXMud2lkdGg7XG5cblx0XHQvLyB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsMCx0aGlzLnN0YWdlLndpZHRoLHRoaXMuc3RhZ2UuaGVpZ2h0KTtcblx0XHQvLyB0aGlzLnNoYWRvd0NvbnRleHQuY2xlYXJSZWN0KDAsMCx0aGlzLnN0YWdlLndpZHRoLHRoaXMuc3RhZ2UuaGVpZ2h0KTtcbn1cdFxuXG5cdFx0XG5cbi8v5qC55o2u5a+56LGh5bGe5oCn5ZCN56ew6Ieq5Yqo55Sf5oiQW3NldCvlsZ7mgKflkI3np7Bd5pa55rOVXG5RY2FudmFzLnByb3RvdHlwZS5hcHBlbmRTZXRGdW4gPSBmdW5jdGlvbihvKXtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciBmaXJzdFRvVXBwZXJDYXNlID0gZnVuY3Rpb24ocyl7XG5cdFx0XHRcdHZhciBwID0gcy5zcGxpdCgnJyk7XG5cdFx0XHRcdHBbMF0gPSBwWzBdLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gcC5qb2luKCcnKTtcblx0XHR9XHRcdFxuXG5cdFx0Ly/miYDmnInlhYPntKDpg73pmYTliqBkaXNwbGF55bGe5oCnXG5cdFx0aWYodHlwZW9mIG8uZGlzcGxheSA9PSd1bmRlZmluZWQnKXtcblx0XHRcdG8uZGlzcGxheSA9ICdibG9jayc7XG5cdFx0fVxuXHRcdFxuXG5cdFx0XG5cdFx0XHRcdFxuXHRcdGZvcih2YXIgaSBpbiBvKXtcblx0XHRcdFxuXHRcdFx0XHQoaSAhPSAnVFlQRScpICYmIFxuXHRcdFx0XHQoaSAhPSAnaWQnKSAmJiBcblx0XHRcdFx0KGkgIT0gJ3dpdGhUZXh0JykgJiYgXG5cdFx0XHRcdChpICE9ICd3aXRoVGV4dEFsaWduJykgJiYgXG5cdFx0XHRcdCF0aGlzLmlzRnVuKG9baV0pICYmXG5cdFx0XHRcdChvWydzZXQnK2ZpcnN0VG9VcHBlckNhc2UoaSldID0gKGZ1bmN0aW9uKGluZGV4LG9iail7XG5cdFx0XHRcdFx0dmFyIHAgPSBpbmRleDtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24odCl7XG5cdFx0XHRcdFx0XHRvYmpbcF0gPSB0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0XHR9XG5cdFx0XHR9KShpLG8pKTtcblxuXHRcdFx0XHRcblx0XHR9XHRcdFxufVxuXG5RY2FudmFzLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbihvLG4pe1xuXHQgXG5cdGZvcih2YXIgaSBpbiBuKXsgXG5cdFx0KGkgIT0gJ1RZUEUnKSAmJiAob1tpXSA9IG5baV0pOyBcblx0fVxuXHRcdFx0XHQgXG5cdHRoaXMucHVzaEVsZW1lbnRzKG8pO1xufVxuUWNhbnZhcy5wcm90b3R5cGUuUmFuZG9tTnVtQm90aCA9IGZ1bmN0aW9uKE1pbixNYXgpe1xuICAgICAgdmFyIFJhbmdlID0gTWF4IC0gTWluO1xuICAgICAgdmFyIFJhbmQgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgdmFyIG51bSA9IE1pbiArIE1hdGgucm91bmQoUmFuZCAqIFJhbmdlKTsgLy/lm5voiI3kupTlhaVcbiAgICAgIHJldHVybiBudW07XG59XHRcblFjYW52YXMucHJvdG90eXBlLnB1c2hFbGVtZW50cyA9IGZ1bmN0aW9uKGVsZW1lbnQpe1xuXHRcblx0aWYodHlwZW9mIGVsZW1lbnQuaWQgPT0gJ3VuZGVmaW5lZCcpe1xuXHRcdC8v6Ieq5Yqo55Sf5oiQ5LiA5Liq5ZSv5LiAaWRcblx0XHRlbGVtZW50LmlkID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSsnJytwYXJzZUludChNYXRoLnJhbmRvbSgpKjEwMDAwMDAwMCk7XG5cdFx0ZWxlbWVudC5zaGFkb3dGaWxsQ29sb3IgPSAncmdiYSgnK3RoaXMuUmFuZG9tTnVtQm90aCgwLDI1NSkrJywnK3RoaXMuUmFuZG9tTnVtQm90aCgwLDI1NSkrJywnK3RoaXMuUmFuZG9tTnVtQm90aCgwLDI1NSkrJywxKSc7XG5cdFx0dGhpcy5lbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXHR9XG5cdFxufVxuXG5RY2FudmFzLnByb3RvdHlwZS5nZXRFbGVCeUlkID0gZnVuY3Rpb24oaWQpe1xuXHR2YXIgbCA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXHRmb3IodmFyIGk9MDtpPGw7aSsrKXtcblx0XHRpZih0aGlzLmVsZW1lbnRzW2ldLmlkID09IGlkKXtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudHNbaV07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cdFxuXHR9XG5cdFxufVxuXG4vL+S7jmVsZW1lbnRz5pWw57uE5Lit5Yig6ZmkIFxuLy/or6Xmlrnms5Xkvb/nlKjml7bopoHms6jmhI8g5aaC5p6c5YW25a6D5YWD57Sg55qE5p+Q5LiA5bGe5oCn5LiO6K+l5YWD57Sg5pyJ5YWz6IGUIOS4uuS6huS4jeiuqeWug+WHuueOsOWcqOeUu+W4g+S4reacgOWlveeUqHNldERpc3BsYXkoKeaWueazlVxuUWNhbnZhcy5wcm90b3R5cGUucmVtb3ZlRWxlID0gZnVuY3Rpb24ob2JqKXtcblx0dmFyIGwgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblx0XHRmb3IodmFyIGk9MDtpPGw7aSsrKXtcblx0XHRcdGlmKHRoaXMuZWxlbWVudHNbaV0uaWQgPT0gb2JqLmlkKXsgXG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50cy5zcGxpY2UoaSwxKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cdFxuXHRcdH1cbiBcblx0XG59XG4vL+S7jmVsZW1lbnRz5pWw57uE5Lit5Yig6ZmkIFxuLy/or6Xmlrnms5Xkvb/nlKjml7bopoHms6jmhI8g5aaC5p6c5YW25a6D5YWD57Sg55qE5p+Q5LiA5bGe5oCn5LiO6K+l5YWD57Sg5pyJ5YWz6IGUIOS4uuS6huS4jeiuqeWug+WHuueOsOWcqOeUu+W4g+S4reacgOWlveeUqHNldERpc3BsYXkoKeaWueazlVxuUWNhbnZhcy5wcm90b3R5cGUucmVtb3ZlRWxlQnlJZCA9IGZ1bmN0aW9uKGlkKXtcblx0dmFyIGwgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblx0XHRmb3IodmFyIGk9MDtpPGw7aSsrKXtcblx0XHRcdGlmKHRoaXMuZWxlbWVudHNbaV0uaWQgPT0gaWQpeyBcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnRzLnNwbGljZShpLDEpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVx0XG5cdFx0fVxuIFxuXHRcbn1cblxuXG5cblxuUWNhbnZhcy5wcm90b3R5cGUuZ2V0SW5kZXhCeUlkID0gZnVuY3Rpb24oaWQpe1xuXHR2YXIgbCA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXHRmb3IodmFyIGk9MDtpPGw7aSsrKXtcblx0XHRpZih0aGlzLmVsZW1lbnRzW2ldLmlkID09IGlkKXtcblx0XHRcdFx0cmV0dXJuIGk7IFxuXHRcdFx0XHRicmVhaztcblx0XHR9XHRcblx0fVxuIFxufVxuXG5cblFjYW52YXMucHJvdG90eXBlLmxvd2VyID0gZnVuY3Rpb24oZWwpe1xuXG5cdHZhciBjdXJySW5kZXggPSB0aGlzLmdldEluZGV4QnlJZChlbC5pZCk7IFxuXHRpZigoY3VyckluZGV4LTEgPCAwKSB8fCAodHlwZW9mIHRoaXMuZWxlbWVudHNbY3VyckluZGV4LTFdID09ICd1bmRlZmluZWQnKSl7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dGhpcy5lbGVtZW50c1tjdXJySW5kZXhdID0gdGhpcy5lbGVtZW50cy5zcGxpY2UoY3VyckluZGV4LTEsMSx0aGlzLmVsZW1lbnRzW2N1cnJJbmRleF0pWzBdO1xuXG5cbn1cblxuUWNhbnZhcy5wcm90b3R5cGUubG93ZXJUb0JvdHRvbSA9IGZ1bmN0aW9uKGVsKXsgXG5cblx0aWYodGhpcy5nZXRJbmRleEJ5SWQoZWwuaWQpID09IDApeyAgLy/lt7Lnu4/mmK/mnIDlupXlsYJcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR0aGlzLnJlbW92ZUVsZShlbCk7XG5cdHRoaXMuZWxlbWVudHMudW5zaGlmdChlbCk7XG5cbn1cblxuUWNhbnZhcy5wcm90b3R5cGUucmFpc2UgPSBmdW5jdGlvbihlbCl7IFxuXG5cdHZhciBjdXJySW5kZXggPSB0aGlzLmdldEluZGV4QnlJZChlbC5pZCk7ICBcblx0aWYodHlwZW9mIHRoaXMuZWxlbWVudHNbY3VyckluZGV4KzFdID09ICd1bmRlZmluZWQnKXtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR0aGlzLmVsZW1lbnRzW2N1cnJJbmRleF0gPSB0aGlzLmVsZW1lbnRzLnNwbGljZShjdXJySW5kZXgrMSwxLHRoaXMuZWxlbWVudHNbY3VyckluZGV4XSlbMF07XG5cblxufVxuXG5RY2FudmFzLnByb3RvdHlwZS5yYWlzZVRvVG9wID0gZnVuY3Rpb24oZWwpe1xuIFxuXHRpZih0aGlzLmdldEluZGV4QnlJZChlbC5pZCkgPT0gKHRoaXMuZWxlbWVudHMubGVuZ3RoLTEpKXsgIC8v5bey57uP5piv5pyA6aG25bGCXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dGhpcy5yZW1vdmVFbGUoZWwpO1xuXHR0aGlzLmVsZW1lbnRzLnB1c2goZWwpO1xufVxuXG4vL3Byb21pc2XnsbtcblFjYW52YXMucHJvdG90eXBlLmxvYWRQcm9taXNlID0gZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgdmFsdWUgPSBudWxsLCBzdWNjYWxsYmFja3MgPSBbXSwgZmFpbGNhbGxiYWNrcyA9IFtdO1xuICAgIHRoaXMudGhlbiA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgICAgIHN1Y2NhbGxiYWNrcy5wdXNoKGZ1bGZpbGxlZCk7XG4gICAgICAgIGZhaWxjYWxsYmFja3MucHVzaChyZWplY3RlZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IFxuICAgICAgICAgICAgc3VjY2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodmFsdWUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwwKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBmYWlsY2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodmFsdWUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwwKVxuICAgICAgIFxuICAgIH1cblxuICAgIGZuKHJlc29sdmUsIHJlamVjdCk7XG59XG5RY2FudmFzLnByb3RvdHlwZS5sb2FkSW1nU291cmNlID0gZnVuY3Rpb24oc291cmNlT2JqKXtcblx0aWYodGhpcy5pc0Fycihzb3VyY2VPYmopKXtcblx0XHR2YXIgdXJsQXJyID0gc291cmNlT2JqO1xuXHR9ZWxzZXtcblx0XHRpZihhcmd1bWVudHMubGVuZ3RoPjApe1xuXHRcdFx0dmFyIHVybEFyciAgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcblx0XHR9XG5cdH1cblx0XG5cdHZhciBfdGhpcyA9IHRoaXM7IFxuXHRyZXR1cm4gbmV3IHRoaXMubG9hZFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3Qpe1xuXHRcdC8v5YWI5a6e546w5Yqg6L295Zu+54mH6LWE5rqQXG5cdFx0dmFyIGltZ0FyciA9IFtdO1xuXHRcdHZhciBudW0gPSAwO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHVybEFyci5sZW5ndGg7IGkrKykgeyBcblx0XHRcdFx0aW1nID0gbmV3IEltYWdlKCk7XG5cdFx0XHRcdGltZ0Fyci5wdXNoKGltZyk7XG5cdFx0XHRcdGltZy5vbmxvYWQgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdG51bSsrO1xuXHRcdFx0XHRcdGlmKG51bT09aW1nQXJyLmxlbmd0aCl7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKGltZ0Fycik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9OyBcblx0XHRcdFx0aW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdlcnInKTtcblx0XHRcdFx0XHRudW0rKztcblx0XHRcdFx0XHRpZihudW09PWltZ0Fyci5sZW5ndGgpe1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShpbWdBcnIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zb2xlLmxvZygn57Si5byV5Li6Jyt0aGlzLnNvcnQrJ+eahOi1hOa6kOWKoOi9veWksei0pScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGltZy5zb3J0ID0gaTtcblx0XHRcdFx0aW1nLnNyYyA9IHVybEFycltpXTtcblx0XHRcdH1cblx0XHRcblx0XHRcblxuXHR9KSBcblxuXG59XG4vL+WKoOi9veWbvueJh+i1hOa6kFx0XHRcdFx0XG5RY2FudmFzLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24oc291cmNlT2JqLGNhbGxiYWNrKXtcblx0XG5cdGlmKHR5cGVvZiB0aGlzLnNvdXJjZT09J3VuZGVmaW5lZCcpe1xuXHRcdFx0dGhpcy5zb3VyY2UgPSB7fTtcblx0fVxuXHRcblx0dmFyIF90aGlzID0gdGhpcztcblx0XG5cdC8v5YWI5a6e546w5Yqg6L295Zu+54mH6LWE5rqQXG5cdHZhciBpbWdBcnIgPSBbXTtcblx0dmFyIG51bSA9IDA7XG5cdGZvcih2YXIgaSBpbiBzb3VyY2VPYmope1xuXHRcdFxuXHRcdFxuXHRcdGltZyA9IG5ldyBJbWFnZSgpO1xuXHRcdGltZ0Fyci5wdXNoKGltZyk7XG5cdFx0aW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRfdGhpcy5zb3VyY2VbdGhpcy5hbGlhc10gPSB0aGlzO1xuXHRcdFx0XG5cdFx0XHRudW0rKztcblx0XHRcdFxuXHRcdFx0aWYobnVtPT1pbWdBcnIubGVuZ3RoKXtcblx0XHRcdFx0Y2FsbGJhY2soX3RoaXMuc291cmNlKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGltZy5hbGlhcyA9IGk7XG5cdFx0aW1nLnNyYz1zb3VyY2VPYmpbaV07XG5cdH1cblx0XG59XG5cblFjYW52YXMucHJvdG90eXBlLmdldFNvdXJjZUJ5TmFtZSA9IGZ1bmN0aW9uKG5hbWUpe1xuXHRcdFxuXHRcdHJldHVybiB0aGlzLnNvdXJjZVtuYW1lXTtcdFx0XG59XHRcdFx0XHRcblxuUWNhbnZhcy5wcm90b3R5cGUuaXNPYmogPSBmdW5jdGlvbihvKXtcblx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKT09PSdbb2JqZWN0IE9iamVjdF0nO1xufVx0XHRcdFxuXG5cdFxuUWNhbnZhcy5wcm90b3R5cGUuaXNGdW4gPSBmdW5jdGlvbihvKXtcblx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKT09PSdbb2JqZWN0IEZ1bmN0aW9uXSc7IFxufVxuXHRcdFx0XHRcblFjYW52YXMucHJvdG90eXBlLmlzQXJyID0gZnVuY3Rpb24obyl7XG5cdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk9PT0nW29iamVjdCBBcnJheV0nO1xufVx0XG5cdFx0XHRcdFxuUWNhbnZhcy5wcm90b3R5cGUuaXNOdW0gPSBmdW5jdGlvbihvKXtcblx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKT09PSdbb2JqZWN0IE51bWJlcl0nO1xufVx0XG5cblFjYW52YXMucHJvdG90eXBlLmlzQm9vbCA9IGZ1bmN0aW9uKG8pe1xuXHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pPT09J1tvYmplY3QgQm9vbGVhbl0nO1xufVx0XHRcblxuUWNhbnZhcy5wcm90b3R5cGUuaXNTdHIgPSBmdW5jdGlvbihvKXtcblx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKT09PSdbb2JqZWN0IFN0cmluZ10nO1xufVx0XHRcdFx0XG5cblx0XHRcdFx0XG5RY2FudmFzLnByb3RvdHlwZS5jb2xvclJnYiA9IGZ1bmN0aW9uKGNvbG9yKXtcblxuXHRpZihjb2xvciA9PSAnJyl7XG5cdFx0cmV0dXJuICcwLDAsMCc7XG5cdH1cblxuXHQvLzE356eN5Z+65pys6ImyXG5cdHZhciBiYXNpY0NvbG9yID0ge1xuXHRcdFwiYXF1YVwiOlwiIzAwRkZGRlwiLFxuXHRcdFwiYmxhY2tcIjpcIiMwMDAwMDBcIixcblx0XHRcImJsdWVcIjpcIiMwMDAwRkZcIixcblx0XHRcImZ1Y2hzaWFcIjpcIiNGRjAwRkZcIixcblx0XHRcImdyYXlcIjpcIiM4MDgwODBcIixcblx0XHRcImdyZWVuXCI6XCIjMDA4MDAwXCIsXG5cdFx0XCJsaW1lXCI6XCIjMDBGRjAwXCIsXG5cdFx0XCJtYXJvb25cIjpcIiM4MDAwMDBcIixcblx0XHRcIm5hdnlcIjpcIiMwMDAwODBcIixcblx0XHRcIm9saXZlXCI6XCIjODA4MDAwXCIsXG5cdFx0XCJvcmFuZ2VcIjpcIiNGRkE1MDBcIixcblx0XHRcInB1cnBsZVwiOlwiIzgwMDA4MFwiLFxuXHRcdFwicmVkXCI6XCIjRkYwMDAwXCIsXG5cdFx0XCJzaWx2ZXJcIjpcIiNDMEMwQzBcIixcblx0XHRcInRlYWxcIjpcIiMwMDgwODBcIixcblx0XHRcIndoaXRlXCI6XCIjRkZGRkZGXCIsXG5cdFx0XCJ5ZWxsb3dcIjpcIiNGRkZGMDBcIlxuXHR9XG5cblx0aWYoY29sb3IuaW5kZXhPZignIycpPDApeyBcblx0XHRjb2xvciA9IGJhc2ljQ29sb3JbY29sb3IudG9Mb3dlckNhc2UoKV07XG5cdH1cblxuXHRcblx0dmFyIHJlZyA9IC9eIyhbMC05YS1mQS1mXXszfXxbMC05YS1mQS1mXXs2fSkkLztcbiAgICB2YXIgc0NvbG9yID0gY29sb3IudG9Mb3dlckNhc2UoKTtcbiAgICBpZihzQ29sb3IgJiYgcmVnLnRlc3Qoc0NvbG9yKSl7XG4gICAgICAgIGlmKHNDb2xvci5sZW5ndGggPT09IDQpe1xuICAgICAgICAgICAgdmFyIHNDb2xvck5ldyA9IFwiI1wiO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaT0xOyBpPDQ7IGkrPTEpe1xuICAgICAgICAgICAgICAgICAgICBzQ29sb3JOZXcgKz0gc0NvbG9yLnNsaWNlKGksaSsxKS5jb25jYXQoc0NvbG9yLnNsaWNlKGksaSsxKSk7ICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc0NvbG9yID0gc0NvbG9yTmV3O1xuICAgICAgICB9XG4gICAgICAgIC8v5aSE55CG5YWt5L2N55qE6aKc6Imy5YC8XG4gICAgICAgIHZhciBzQ29sb3JDaGFuZ2UgPSBbXTtcbiAgICAgICAgZm9yKHZhciBpPTE7IGk8NzsgaSs9Mil7XG4gICAgICAgICAgICBzQ29sb3JDaGFuZ2UucHVzaChwYXJzZUludChcIjB4XCIrc0NvbG9yLnNsaWNlKGksaSsyKSkpOyAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiUkdCKFwiICsgc0NvbG9yQ2hhbmdlLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgfWVsc2V7XG4gICAgICAgIHJldHVybiBzQ29sb3I7ICAgICAgICBcbiAgICB9fTtcdFxuXHRcblxuUWNhbnZhcy5wcm90b3R5cGUucmVxdWVzdE5leHRBbmltYXRpb25GcmFtZTEgPSBmdW5jdGlvbihjYWxsYmFjayl7XG4gICAgICAgICBcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cblxuICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNhbGxiYWNrKXsgXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrICwgc2VsZi50aW1lb3V0KTtcbiAgICAgICAgICAgICAgIH07XG59XG5cdFx0XHRcdFxuUWNhbnZhcy5wcm90b3R5cGUucmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBvcmlnaW5hbFdlYmtpdE1ldGhvZCxcbiAgICAgICAgICAgIHdyYXBwZXIgPSB1bmRlZmluZWQsXG4gICAgICAgICAgICBjYWxsYmFjayA9IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGdlY2tvVmVyc2lvbiA9IDAsXG4gICAgICAgICAgICB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmKHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpe1xuICAgICAgICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uKHRpbWUpe1xuICAgICAgICAgICAgICAgIGlmKHRpbWUgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgICAgIHRpbWUgKz0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxsYmFjayh0aW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvcmlnaW5hbFdlYmtpdE1ldGhvZCA9IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2ssZWxlbWVudCl7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsV2Via2l0TWV0aG9kKHdyYXBwZXIgLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZih3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lKXtcbiAgICAgICAgICAgIGluZGV4ID0gdXNlckFnZW50LmluZGV4T2YoJ3J2OicpO1xuICAgICAgICAgICAgaWYodXNlckFnZW50LmluZGV4T2YoJ0dlY2tvJykgIT0gLTEpe1xuICAgICAgICAgICAgICAgIGdlY2tvVmVyc2lvbiA9IHVzZXJBZ2VudC5zdWJzdHIoaW5kZXgrMyAsIDMpO1xuICAgICAgICAgICAgICAgIGlmKGdlY2tvVmVyc2lvbiA9PT0gJzIuMCcpe1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cblxuICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNhbGxiYWNrICwgZWxlbWVudCl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaDtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gK25ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNlbGYsc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoID0gK25ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnRpbWVvdXQgPSAxMDAwL3NlbGYuZnBzIC0gKGZpbmlzaCAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfSAsIHNlbGYudGltZW91dCk7XG4gICAgICAgICAgICAgICB9O1xufVxuXG5RY2FudmFzLnByb3RvdHlwZS5zZXREZWdyZWUgPSBmdW5jdGlvbihvYmope1xuXHRcdHZhciBjZW50ZXJQb3MgPSB7fTtcblx0XHRcblx0XHRpZihvYmouZGVncmVlICE9IDApe1xuXHRcdFx0Y2VudGVyUG9zID0gb2JqLmNlbnRlclBvaW50cygpO1xuXG5cdFx0XHR0aGlzLmNvbnRleHQudHJhbnNsYXRlKGNlbnRlclBvcy54LGNlbnRlclBvcy55KTtcblx0XHRcdHRoaXMuY29udGV4dC5yb3RhdGUob2JqLmRlZ3JlZSpNYXRoLlBJLzE4MCk7XG5cdFx0XHR0aGlzLmNvbnRleHQudHJhbnNsYXRlKC1jZW50ZXJQb3MueCwtY2VudGVyUG9zLnkpO1xuXG5cdFx0fVx0XG5cblx0XHRyZXR1cm4gY2VudGVyUG9zO1xufVxuXG5RY2FudmFzLnByb3RvdHlwZS5yZXNldERlZ3JlZSA9IGZ1bmN0aW9uKG9iaixjZW50ZXJQb3Mpe1xuXHRpZihvYmouZGVncmVlICE9IDApe1xuXHRcdHRoaXMuY29udGV4dC50cmFuc2xhdGUoY2VudGVyUG9zLngsY2VudGVyUG9zLnkpO1xuXHRcdHRoaXMuY29udGV4dC5yb3RhdGUoLW9iai5kZWdyZWUqTWF0aC5QSS8xODApO1xuXHRcdHRoaXMuY29udGV4dC50cmFuc2xhdGUoLWNlbnRlclBvcy54LC1jZW50ZXJQb3MueSk7XG5cdH1cbn1cblxudHlwZW9mIHdpbmRvdy5yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lID09J3VuZGVmaW5lZCdcbiYmIChmdW5jdGlvbigpe1xuXG5cdHdpbmRvdy5yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lID1cbiAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3JpZ2luYWxXZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB1bmRlZmluZWQsXG4gICAgICAgICAgd3JhcHBlciA9IHVuZGVmaW5lZCxcbiAgICAgICAgICBjYWxsYmFjayA9IHVuZGVmaW5lZCxcbiAgICAgICAgICBnZWNrb1ZlcnNpb24gPSAwLFxuICAgICAgICAgIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBXb3JrYXJvdW5kIGZvciBDaHJvbWUgMTAgYnVnIHdoZXJlIENocm9tZVxuICAgICAgLy8gZG9lcyBub3QgcGFzcyB0aGUgdGltZSB0byB0aGUgYW5pbWF0aW9uIGZ1bmN0aW9uXG4gICAgICBcbiAgICAgIGlmICh3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAvLyBEZWZpbmUgdGhlIHdyYXBwZXJcblxuICAgICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgIGlmICh0aW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHNlbGYuY2FsbGJhY2sodGltZSk7XG4gICAgICAgICB9O1xuXG4gICAgICAgICAvLyBNYWtlIHRoZSBzd2l0Y2hcbiAgICAgICAgICBcbiAgICAgICAgIG9yaWdpbmFsV2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZTsgICAgXG5cbiAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHNlbGYuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgICAgICAgICAgLy8gQnJvd3NlciBjYWxscyB0aGUgd3JhcHBlciBhbmQgd3JhcHBlciBjYWxscyB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgb3JpZ2luYWxXZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUod3JhcHBlciwgZWxlbWVudCk7XG4gICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFdvcmthcm91bmQgZm9yIEdlY2tvIDIuMCwgd2hpY2ggaGFzIGEgYnVnIGluXG4gICAgICAvLyBtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSB0aGF0IHJlc3RyaWN0cyBhbmltYXRpb25zXG4gICAgICAvLyB0byAzMC00MCBmcHMuXG5cbiAgICAgIGlmICh3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAvLyBDaGVjayB0aGUgR2Vja28gdmVyc2lvbi4gR2Vja28gaXMgdXNlZCBieSBicm93c2Vyc1xuICAgICAgICAgLy8gb3RoZXIgdGhhbiBGaXJlZm94LiBHZWNrbyAyLjAgY29ycmVzcG9uZHMgdG9cbiAgICAgICAgIC8vIEZpcmVmb3ggNC4wLlxuICAgICAgICAgXG4gICAgICAgICBpbmRleCA9IHVzZXJBZ2VudC5pbmRleE9mKCdydjonKTtcblxuICAgICAgICAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdHZWNrbycpICE9IC0xKSB7XG4gICAgICAgICAgICBnZWNrb1ZlcnNpb24gPSB1c2VyQWdlbnQuc3Vic3RyKGluZGV4ICsgMywgMyk7XG5cbiAgICAgICAgICAgIGlmIChnZWNrb1ZlcnNpb24gPT09ICcyLjAnKSB7XG4gICAgICAgICAgICAgICAvLyBGb3JjZXMgdGhlIHJldHVybiBzdGF0ZW1lbnQgdG8gZmFsbCB0aHJvdWdoXG4gICAgICAgICAgICAgICAvLyB0byB0aGUgc2V0VGltZW91dCgpIGZ1bmN0aW9uLlxuXG4gICAgICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAgIHx8XG4gICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgIHx8XG4gICAgICAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgIHx8XG4gICAgICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgIHx8XG5cbiAgICAgICAgIGZ1bmN0aW9uIChjYWxsYmFjaywgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGZpbmlzaDtcblxuXG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgc3RhcnQgPSArbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgIGNhbGxiYWNrKHN0YXJ0KTtcbiAgICAgICAgICAgICAgIGZpbmlzaCA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgICAgICAgICAgICBzZWxmLnRpbWVvdXQgPSAxMDAwIC8gc2VsZi5mcHMgLSAoZmluaXNoIC0gc3RhcnQpO1xuXG4gICAgICAgICAgICB9LCBzZWxmLnRpbWVvdXQpO1xuICAgICAgICAgfTtcbiAgICAgIH1cbiAgIClcbigpO1xuXG5cblxufSkoKVxuXHRcbm1vZHVsZS5leHBvcnRzLlFjYW52YXMgPSBRY2FudmFzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3FjYW52YXMvbGliL1FjYW52YXMuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_qrelation_vue__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_qrelation_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_qrelation_vue__);\n/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_qrelation_vue__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_qrelation_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_7e00ef64_hasScoped_true_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_qrelation_vue__ = __webpack_require__(35);\nvar disposed = false\nfunction injectStyle (ssrContext) {\n  if (disposed) return\n  __webpack_require__(11)\n}\nvar normalizeComponent = __webpack_require__(14)\n/* script */\n\n\n/* template */\n\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-7e00ef64\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_qrelation_vue___default.a,\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_7e00ef64_hasScoped_true_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_qrelation_vue__[\"a\" /* default */],\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\nComponent.options.__file = \"src/qrelation.vue\"\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-7e00ef64\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-7e00ef64\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Component.exports);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcXJlbGF0aW9uLnZ1ZT8zZWIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLG1CQUFPLENBQUMsRUFBNlA7QUFDdlE7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyxFQUFzRDtBQUN2RjtBQUMwRztBQUNhO0FBQ3ZIO0FBQ21QO0FBQ25QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNEhBQWM7QUFDaEIsRUFBRSxpT0FBZ0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFVLEdBQUc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRWMsZ0ZBQWlCIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi03ZTAwZWY2NFxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9xcmVsYXRpb24udnVlXCIpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIilcbi8qIHNjcmlwdCAqL1xuZXhwb3J0ICogZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vcXJlbGF0aW9uLnZ1ZVwiXG5pbXBvcnQgX192dWVfc2NyaXB0X18gZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vcXJlbGF0aW9uLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSAqL1xuaW1wb3J0IF9fdnVlX3RlbXBsYXRlX18gZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtN2UwMGVmNjRcXFwiLFxcXCJoYXNTY29wZWRcXFwiOnRydWUsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3FyZWxhdGlvbi52dWVcIlxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gXCJkYXRhLXYtN2UwMGVmNjRcIlxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fdnVlX3NjcmlwdF9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL3FyZWxhdGlvbi52dWVcIlxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtN2UwMGVmNjRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi03ZTAwZWY2NFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9xcmVsYXRpb24udnVlXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(12);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(2)(\"1ca29bad\", content, false, {});\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../node_modules/css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-7e00ef64\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./qrelation.vue\", function() {\n     var newContent = require(\"!!../node_modules/css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-7e00ef64\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./qrelation.vue\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcXJlbGF0aW9uLnZ1ZT9hYTEyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLEVBQTJRO0FBQ2pTLDRDQUE0QyxRQUFTO0FBQ3JEO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsQ0FBMEQsZ0NBQWdDO0FBQy9HO0FBQ0EsR0FBRyxLQUFVO0FBQ2I7QUFDQTtBQUNBLDhIQUE4SCxrRkFBa0Y7QUFDaE4sdUlBQXVJLGtGQUFrRjtBQUN6TjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTdlMDBlZjY0XFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3FyZWxhdGlvbi52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjFjYTI5YmFkXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi03ZTAwZWY2NFxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9xcmVsYXRpb24udnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTdlMDBlZjY0XFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3FyZWxhdGlvbi52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtN2UwMGVmNjRcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3NyYy9xcmVsYXRpb24udnVlXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(1)(true);\n// imports\n\n\n// module\nexports.push([module.i, \"\\n.json_lay[data-v-7e00ef64]{\\n\\t    padding: 10px;\\n    height: 200px;\\n    overflow: scroll;\\n}\\n#qflow_lay[data-v-7e00ef64]{ \\n\\t\\t\\tposition: relative;\\n}\\n.clear[data-v-7e00ef64]:after{\\n\\t\\t\\tcontent: \\\"\\\";\\n\\t\\t\\tdisplay: block;\\n\\t\\t\\tclear: both;\\n\\t\\t\\tfont-size: 0;\\n\\t\\t\\tline-height: 0;\\n}\\ncanvas[data-v-7e00ef64]{ \\n\\t\\t\\theight: 100%;\\n\\t\\t\\twidth: 100%;\\n\\t\\t\\tbackground-image: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PHBhdHRlcm4gaWQ9ImdyaWQiIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgcGF0dGVyblVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGggZD0iTSAwIDEwIEwgNDAgMTAgTSAxMCAwIEwgMTAgNDAgTSAwIDIwIEwgNDAgMjAgTSAyMCAwIEwgMjAgNDAgTSAwIDMwIEwgNDAgMzAgTSAzMCAwIEwgMzAgNDAiIGZpbGw9Im5vbmUiIHN0cm9rZT0iI2QwZDBkMCIgb3BhY2l0eT0iMC4yIiBzdHJva2Utd2lkdGg9IjEiLz48cGF0aCBkPSJNIDQwIDAgTCAwIDAgMCA0MCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZDBkMGQwIiBzdHJva2Utd2lkdGg9IjEiLz48L3BhdHRlcm4+PC9kZWZzPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9InVybCgjZ3JpZCkiLz48L3N2Zz4=\\\");\\n}\\n.tool[data-v-7e00ef64]{\\n\\t\\t\\theight: 40px;\\n\\t\\t\\tposition: relative;\\n\\t\\t\\tz-index: 1;\\n\\t\\t\\tline-height: 40px;\\n\\t\\t\\tbackground-color: #fff;\\n}\\n.tool span[data-v-7e00ef64]{\\n\\t\\t\\tdisplay: inline-block;\\n\\t\\t\\twidth: 30px;\\n\\t\\t\\theight: 30px;\\n\\t\\t\\ttext-align: center;\\n\\t\\t\\tmargin-top:5px;\\n\\t\\t\\tmargin-left:10px;\\n}\\n.tool span img[data-v-7e00ef64]{\\n\\t\\t\\tpointer-events: none;\\n}\\n#qcanvas_lay[data-v-7e00ef64]{\\n\\t\\t\\tposition: absolute;\\n\\t\\t\\ttop:0;\\n\\t\\t\\tleft:0;\\n\\t\\t\\twidth: 100%;\\n\\t\\t\\tbottom: 0;\\n\\t\\t\\toverflow:scroll;\\n}\\n.sheetLay[data-v-7e00ef64]{\\n\\t\\t\\tfont-size: 12px;\\n\\t\\t\\tposition: absolute;\\n\\t\\t\\tbottom: 0;\\n\\t\\t\\tleft:0;\\n\\t\\t\\tbackground: #fff;\\n}\\n.json[data-v-7e00ef64],\\n\\t\\t.save[data-v-7e00ef64],\\n\\t\\t.download[data-v-7e00ef64]{\\n\\t\\t\\tfloat: right;\\n\\t\\t\\tfont-size: 12px;\\n}\\n#titleInput[data-v-7e00ef64]{\\n\\t\\t\\tposition: absolute;\\n\\t\\t\\tleft:0;\\n\\t\\t\\ttop:0;\\n\\t\\t\\tpadding: 0;\\n\\t\\t\\tmargin:0;\\n\\t\\t\\tborder:none; \\n\\t\\t\\tfont-size: 12px;\\n\\t\\t\\tfont-family:'Microsoft YaHei';\\n\\t\\t\\toutline: none;\\n\\t\\t\\tbackground: #FDF8E1;\\n}\\n#lineTitleInput[data-v-7e00ef64],\\n\\t\\t#containerGridColumn[data-v-7e00ef64],\\n\\t\\t#lineLike[data-v-7e00ef64],\\n\\t\\t#lineType[data-v-7e00ef64]{\\n\\t\\t\\tposition: absolute;\\n\\t\\t\\tleft:0;\\n\\t\\t\\ttop:0;\\n\\t\\t\\tpadding: 0;\\n\\t\\t\\tmargin:0;\\n\\t\\t\\tborder:none;\\n\\t\\t\\ttext-indent: 5px;\\n\\t\\t\\tfont-size: 12px;\\n}\\n#tip[data-v-7e00ef64]{\\n\\t\\t\\tposition: absolute;\\n\\t\\t    z-index: 1;\\n\\t\\t    padding:0;\\n\\t\\t    margin:0;\\n\\t\\t    outline: none;\\n\\t\\t    display: none;\\n\\t\\t    font-family:'Microsoft YaHei';\\n\\t\\t    /* font-family: 'Arial'; */\\n\\t\\t\\tword-break: break-all;\\n\\t\\t    border:transparent;\\n\\t\\t    overflow: hidden; \\n\\t\\t    background: rgba(0,0,0,0);\\n\\t\\t    resize:none;\\n\\t\\t    /*pointer-events: none;*/\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"/Users/zhicheng/Documents/npm/qrelation/src/src/qrelation.vue\"],\"names\":[],\"mappings\":\";AA2QA;KACA,cAAA;IACA,cAAA;IACA,iBAAA;CACA;AACA;GACA,mBAAA;CACA;AACA;GACA,YAAA;GACA,eAAA;GACA,YAAA;GACA,aAAA;GACA,eAAA;CACA;AACA;GACA,aAAA;GACA,YAAA;GACA,gpBAAA;CAEA;AACA;GACA,aAAA;GACA,mBAAA;GACA,WAAA;GACA,kBAAA;GACA,uBAAA;CAEA;AACA;GACA,sBAAA;GACA,YAAA;GACA,aAAA;GACA,mBAAA;GACA,eAAA;GACA,iBAAA;CACA;AACA;GACA,qBAAA;CACA;AAGA;GACA,mBAAA;GACA,MAAA;GACA,OAAA;GACA,YAAA;GACA,UAAA;GACA,gBAAA;CACA;AACA;GACA,gBAAA;GACA,mBAAA;GACA,UAAA;GACA,OAAA;GACA,iBAAA;CAEA;AACA;;;GAGA,aAAA;GACA,gBAAA;CACA;AACA;GACA,mBAAA;GACA,OAAA;GACA,MAAA;GACA,WAAA;GACA,SAAA;GACA,YAAA;GACA,gBAAA;GACA,8BAAA;GACA,cAAA;GACA,oBAAA;CACA;AACA;;;;GAIA,mBAAA;GACA,OAAA;GACA,MAAA;GACA,WAAA;GACA,SAAA;GACA,YAAA;GACA,iBAAA;GACA,gBAAA;CACA;AACA;GACA,mBAAA;MACA,WAAA;MACA,UAAA;MACA,SAAA;MACA,cAAA;MACA,cAAA;MACA,8BAAA;MACA,2BAAA;GACA,sBAAA;MACA,mBAAA;MACA,iBAAA;MACA,0BAAA;MACA,YAAA;MACA,yBAAA;CACA\",\"file\":\"qrelation.vue\",\"sourcesContent\":[\"<template>\\n\\t<div id=\\\"qflow_lay\\\">\\n\\t\\t<div class=\\\"tool\\\">\\n\\t\\t\\t<span class=\\\"drag_ele\\\" data-id=\\\"-1\\\">\\n\\t\\t\\t\\t<img src=\\\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjAyMjk3NTk0ODc5IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjIxNDciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PGRlZnM+PHN0eWxlIHR5cGU9InRleHQvY3NzIj48L3N0eWxlPjwvZGVmcz48cGF0aCBkPSJNMjU2IDI4OGg2NHY2NGgtNjR6IG0xMjggMzg0aDM4NHY2NEgzODR6TTI1NiA0ODBoNjR2NjRoLTY0eiBtMCAxOTJoNjR2NjRoLTY0eiIgZmlsbD0iIzMzMzMzMyIgcC1pZD0iMjE0OCI+PC9wYXRoPjxwYXRoIGQ9Ik04MzIgNjRIMTkyYy0zNS4yIDAtNjQgMjguOC02NCA2NHY3NjhjMCAzNS4yIDI4LjggNjQgNjQgNjRoNjQwYzM1LjIgMCA2NC0yOC44IDY0LTY0VjEyOGMwLTM1LjItMjguOC02NC02NC02NHogbTAgODAwYzAgMTkuMi0xNiAzMi0zMiAzMkgyMjRjLTE2IDAtMzItMTIuOC0zMi0zMlYxNjBjMC0xOS4yIDE2LTMyIDMyLTMyaDU3NmMxNiAwIDMyIDEyLjggMzIgMzJ2NzA0eiIgZmlsbD0iIzMzMzMzMyIgcC1pZD0iMjE0OSI+PC9wYXRoPjxwYXRoIGQ9Ik0zODQgNDgwaDM4NHY2NEgzODR6IG0wLTE5MmgzODR2NjRIMzg0eiIgZmlsbD0iIzMzMzMzMyIgcC1pZD0iMjE1MCI+PC9wYXRoPjwvc3ZnPg==\\\" height=\\\"20\\\" alt=\\\"\\\" draggable=\\\"false\\\">\\n\\t\\t\\t</span>\\n\\t\\t\\t<span class=\\\"drag_ele\\\" data-id=\\\"1\\\">\\n\\t\\t\\t\\t<img src=\\\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjAyMjk3ODY3NDcwIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM1MjYiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PGRlZnM+PHN0eWxlIHR5cGU9InRleHQvY3NzIj48L3N0eWxlPjwvZGVmcz48cGF0aCBkPSJNNDU4LjIgMzcxSDExMi42Qzg2LjkgMzcxIDY2IDM1MC4xIDY2IDMyNC41VjE2NC45YzAtMjUuNyAyMC45LTQ2LjUgNDYuNS00Ni41aDM0NS42YzI1LjcgMCA0Ni41IDIwLjkgNDYuNSA0Ni41djE1OS41YzAuMSAyNS43LTIwLjggNDYuNi00Ni40IDQ2LjZ6TTExMi42IDE1OC4zYy0zLjYgMC02LjYgMy02LjYgNi42djE1OS41YzAgMy42IDMgNi42IDYuNiA2LjZoMzQ1LjZjMy42IDAgNi42LTMgNi42LTYuNlYxNjQuOWMwLTMuNi0zLTYuNi02LjYtNi42SDExMi42ek05MTAuMSA5MDhIMjU4LjhjLTI1LjcgMC00Ni41LTIwLjktNDYuNS00Ni41VjUxNS45YzAtMjUuNyAyMC45LTQ2LjUgNDYuNS00Ni41aDY1MS4zYzI1LjcgMCA0Ni41IDIwLjkgNDYuNSA0Ni41djM0NS42YzAgMjUuNy0yMC44IDQ2LjUtNDYuNSA0Ni41ek0yNTguOCA1MDkuMmMtMy42IDAtNi42IDMtNi42IDYuNnYzNDUuNmMwIDMuNiAzIDYuNiA2LjYgNi42aDY1MS4zYzMuNiAwIDYuNi0zIDYuNi02LjZWNTE1LjljMC0zLjYtMy02LjYtNi42LTYuNkgyNTguOHoiIGZpbGw9IiM0RjRGNEYiIHAtaWQ9IjM1MjciPjwvcGF0aD48cGF0aCBkPSJNMjI1LjUgNjk1LjNoLTU5LjNjLTE4LjMgMC0zMy4yLTE0LjktMzMuMi0zMy4xbC0wLjUtMzA1LjhjMC0xMSA4LjktMjAgMTkuOS0yMCAxMSAwIDE5LjkgOC45IDE5LjkgMTkuOWwwLjUgMjk5LjFoNTIuN2MxMSAwIDE5LjkgOC45IDE5LjkgMTkuOXMtOC44IDIwLTE5LjkgMjB6IiBmaWxsPSIjNEY0RjRGIiBwLWlkPSIzNTI4Ij48L3BhdGg+PC9zdmc+\\\" height=\\\"20\\\" alt=\\\"\\\" draggable=\\\"false\\\">\\n\\t\\t\\t</span>\\n\\t\\t\\t<span class=\\\"drag_ele\\\" data-id=\\\"2\\\">\\n\\t\\t\\t\\t<img src=\\\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjAzMDgxOTIxMDg0IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjMxMjEiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PGRlZnM+PHN0eWxlIHR5cGU9InRleHQvY3NzIj48L3N0eWxlPjwvZGVmcz48cGF0aCBkPSJNNjQuNzEzODg0IDY1MC40MDQyMWw4OTIuNjg0MjMyIDAgMCA1NS4wNTM4NzMtODkyLjY4NDIzMiAwIDAtNTUuMDUzODczWiIgcC1pZD0iMzEyMiI+PC9wYXRoPjxwYXRoIGQ9Ik01MTEuMDU3NTM1IDIzNy40ODc4NzlsNDQ2LjM0MDU4MSAwIDAgNTUuMDU2OTQzLTQ0Ni4zNDA1ODEgMCAwLTU1LjA1Njk0M1oiIHAtaWQ9IjMxMjMiPjwvcGF0aD48cGF0aCBkPSJNMTg5LjIyNTY4OSA0ODQuMzY3NjYzbDE4OC45NTM0OSAwIDQ2LjI4ODIzMyAxMTQuNzQ4NDQxIDY0Ljc0MTUxMyAwTDMxNi4zNjk0MzggMTc5LjkwNDM5M2wtNjIuNjk0OTAxIDBMODAuODMzMDAzIDU5OS4xMTYxMDNsNjQuNzQzNTYgMEwxODkuMjI1Njg5IDQ4NC4zNjc2NjN6TTI3NS42NDkwMTQgMjYyLjcxOTU0YzIuNzMxMjA0LTYuODU2MTUyIDUuMTcyODEzLTE2LjU5NzAwMyA3LjMxOTcwOS0yOS4yMjk3MThsMS40Njc0MjEgMGMyLjUzNTc1MyAxMy44OTU0NzUgNC44ODAxNDcgMjMuNjM2MzI3IDcuMDMwMTE0IDI5LjIyOTcxOGw2OC41NDkyMzYgMTc0LjI4ODQ4OEwyMDcuNjgyMDQgNDM3LjAwODAyOSAyNzUuNjQ5MDE0IDI2Mi43MTk1NHoiIHAtaWQ9IjMxMjQiPjwvcGF0aD48cGF0aCBkPSJNNTExLjA1NzUzNSAzNzUuMTI4NzAzbDQ0Ni4zNDA1ODEgMCAwIDU1LjA1Mzg3My00NDYuMzQwNTgxIDAgMC01NS4wNTM4NzNaIiBwLWlkPSIzMTI1Ij48L3BhdGg+PHBhdGggZD0iTTY0LjcxMzg4NCA3ODguMDQwOTRsODkyLjY4NDIzMiAwIDAgNTUuMDU0ODk3LTg5Mi42ODQyMzIgMCAwLTU1LjA1NDg5N1oiIHAtaWQ9IjMxMjYiPjwvcGF0aD48cGF0aCBkPSJNNTExLjA1NzUzNSA1MTIuNzY2NDU2bDQ0Ni4zNDA1ODEgMCAwIDU1LjA1NDg5Ny00NDYuMzQwNTgxIDAgMC01NS4wNTQ4OTdaIiBwLWlkPSIzMTI3Ij48L3BhdGg+PC9zdmc+\\\" height=\\\"20\\\" alt=\\\"\\\" draggable=\\\"false\\\">\\n\\t\\t\\t</span>\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t<span class=\\\"save\\\" @click=\\\"save\\\">\\n\\t\\t\\t\\t<img src=\\\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjAyMjk4MDA1NzAyIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjQ0MTQiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PGRlZnM+PHN0eWxlIHR5cGU9InRleHQvY3NzIj48L3N0eWxlPjwvZGVmcz48cGF0aCBkPSJNODk1LjgzIDYyLjEwMmMzMS43NjEgNS4yOTQgNTIuOTM1IDI2LjQ2OCA2MC44NzYgNTIuOTM1IDcuOTQgMTguNTI3IDUuMjk0IDgyLjA0OSA1LjI5NCAxMDguNTE3djYxNi42OTVjMCAxOC41MjcgMCA0Mi4zNDktMi42NDcgNTUuNTgyLTIuNjQ3IDMxLjc2MS0yMy44MjEgNTIuOTM1LTUwLjI4OCA2MC44NzYtMTguNTI3IDcuOTQtODQuNjk3IDUuMjk0LTEwOC41MTcgNS4yOTQtMjA2LjQ0NyAwLTQxMi44OTUgMC02MTkuMzQyIDAtMTUuODgxIDAtMzkuNzAxIDAtNTUuNTgyLTIuNjQ3LTI5LjExNS0yLjY0Ny01Mi45MzUtMjMuODIxLTYwLjg3Ni01MC4yODgtNS4yOTQtMTguNTI3LTIuNjQ3LTg0LjY5Ny0yLjY0Ny0xMDguNTE3di02MTkuMzQyYzAtMTUuODgxIDAtMzcuMDU1IDAtNTIuOTM1IDUuMjk0LTMxLjc2MSAyNi40NjctNTIuOTM1IDUyLjkzNS02My41MjIgMTguNTI3LTUuMjk0IDgyLjA0OS0yLjY0NyAxMDguNTE3LTIuNjQ3IDIwNi40NDcgMCA0MTAuMjQ4IDAgNjE2LjY5NSAwIDE1Ljg4MSAwIDM5LjcwMSAwIDU1LjU4MiAwek0zMzQuNzE5IDM2MS4xODZoMzU0LjY2NmMxMC41ODcgMCAxMy4yMzQtNS4yOTQgMTMuMjM0LTEzLjIzNHYtMjMwLjI2OGgtMzgxLjEzM3YyMjIuMzI4YzAgMTUuODgxLTIuNjQ3IDIxLjE3MyAxMy4yMzQgMjEuMTczek03NTguMiAxMTcuNjg0djI0OC43OTZjMCAzNy4wNTUtNy45NCA1MC4yODgtNDQuOTk0IDUwLjI4OC05Ny45MyAwLTM3MC41NDYgMC00MTguMTg4IDAtMjEuMTczIDAtMjkuMTE1LTEwLjU4Ny0yOS4xMTUtMzcuMDU1di0yNjIuMDI5Yy0zMS43NjEgMC04NC42OTcgMC0xMTYuNDU4IDAtMTUuODgxIDAtMjYuNDY3IDAtMjkuMTE1IDEwLjU4Ny0yLjY0NyA3Ljk0LTIuNjQ3IDEzNy42MzItMi42NDcgMTU2LjE1OHY1OTIuODc0YzAgMTMuMjM0IDAgMjMuODIxIDEzLjIzNCAyNi40NjcgNS4yOTQgMi42NDcgMTM3LjYzMiAyLjY0NyAxNTYuMTU4IDIuNjQ3IDUyLjkzNSAwIDU4LjIyOCAwIDExMS4xNjQgMHYtMTc5Ljk3OWgyMjcuNjIxdjE3OS45NzljNzQuMTA5IDAgMTExLjE2NCAwIDE4Ny45MiAwIDEwLjU4NyAwIDc0LjEwOSAwIDc5LjQwMy0yLjY0NyAxMC41ODctMi42NDcgMTMuMjM0LTEwLjU4NyAxMy4yMzQtMjYuNDY3di02NjkuNjNjMC0xMy4yMzQgMC02OC44MTUtMi42NDctNzYuNzU2LTIuNjQ3LTEzLjIzNC0xOC41MjctMTMuMjM0LTI2LjQ2Ny0xMy4yMzQtMzQuNDA4IDAtODQuNjk3IDIuNjQ3LTExOS4xMDQgMHpNNDUzLjgyMyA5MDMuNzcybDExNi40NTggMi42NDd2LTEyNC4zOThoLTExNi40NTh2MTIxLjc1MXoiIHAtaWQ9IjQ0MTUiPjwvcGF0aD48L3N2Zz4=\\\"\\n\\t\\t\\t\\theight=\\\"20\\\" alt=\\\"\\\" draggable=\\\"false\\\">\\n\\n\\t\\t\\t</span>\\n\\t\\t\\t<span class=\\\"download\\\" @click=\\\"download\\\">\\n\\t\\t\\t\\t<img src=\\\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjAyMzk1NTUzNjQwIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjI0MDkiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PGRlZnM+PHN0eWxlIHR5cGU9InRleHQvY3NzIj48L3N0eWxlPjwvZGVmcz48cGF0aCBkPSJNODMyLjEgNTkyLjdjLTExIDAtMjAgOS0yMCAyMHYxNTEuMmMwIDExLTkgMjAtMjAgMjBIMjMxLjljLTExIDAtMjAtOS0yMC0yMFY2MTIuN2MwLTExLTktMjAtMjAtMjBzLTIwIDktMjAgMjB2MTUxLjJjMCAzMy4xIDI2LjkgNjAgNjAgNjBINzkyYzMzLjEgMCA2MC0yNi45IDYwLTYwVjYxMi43YzAuMS0xMS04LjktMjAtMTkuOS0yMHoiIHAtaWQ9IjI0MTAiPjwvcGF0aD48cGF0aCBkPSJNNDY4LjMgNjU4LjZjMTEuMyAxMS45IDI3LjIgMTguNyA0My42IDE4LjcgMTYuNCAwIDMyLjMtNi44IDQzLjYtMTguOGw5OS4xLTEwNC43YzcuNi04IDcuMi0yMC43LTAuOC0yOC4zLTgtNy42LTIwLjctNy4yLTI4LjMgMC44bC05My42IDk4LjlWMjIwYzAtMTEtOS0yMC0yMC0yMHMtMjAgOS0yMCAyMHY0MDUuMmwtOTMuNC05OC42Yy03LjYtOC0yMC4zLTguNC0yOC4zLTAuOC04IDcuNi04LjQgMjAuMy0wLjggMjguM2w5OC45IDEwNC41eiIgcC1pZD0iMjQxMSI+PC9wYXRoPjwvc3ZnPg==\\\" height=\\\"20\\\" alt=\\\"\\\" draggable=\\\"false\\\">\\n\\t\\t\\t</span>\\n\\t\\t\\t<span class=\\\"json\\\" @click=\\\"jsShow\\\">\\n\\t\\t\\t\\t<img src=\\\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjAzMzgyNzgzMzY1IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjI3MjgiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PGRlZnM+PHN0eWxlIHR5cGU9InRleHQvY3NzIj48L3N0eWxlPjwvZGVmcz48cGF0aCBkPSJNMjE2LjQgMTA3LjFoNTAuMmM1LjcgMCAxMC40IDQuNyAxMC40IDEwLjRWMTU2YzAgNS43LTQuNyAxMC40LTEwLjQgMTAuNGgtNDUuOGMtNS43IDAtMTMuNCA0LjYtMTMuNCAxMC40bC0xIDI0Ni42Yy0xLjMgMzUuMi0yNS4xIDkwLTU4LjYgOTEuNCAyMy4yLTEgNTkuNiAzOS41IDU5LjYgODkuNGwtMSAyNDIuNGMwIDUuOCA0LjcgMTkuNiAxMC42IDE5LjZoNDkuM2M1LjkgMCAxMC44IDYuOCAxMC44IDEyLjh2MzAuOWMwIDUuOS00LjggMTAuOC0xMC44IDEwLjhoLTQ5LjhjLTMyLjQtMTIuMi02MC42LTQwLjctNjAuNi05MC40di0xODFjMC00OS45LTI3LjEtOTAuNC02MC42LTkwLjRINzcuMWMtNi44IDAtMTIuMi01LjUtMTIuMi0xMi4ydi02NS45YzAtNi44IDUuNS0xMi4yIDEyLjItMTIuMmgxOC4xYzMzLjUgMCA2MC42LTQwLjUgNjAuNi05MC40VjE5Ny40YzAtNDkuOSAyNy4xLTkwLjMgNjAuNi05MC4zTTgwOC42IDEwNy4xYzMzLjUgMCA2MC42IDQwLjQgNjAuNiA5MC4zdjE4MC44YzAgNDkuOSAyNy4xIDkwLjQgNjAuNiA5MC40aDE4LjFjNi43IDAgMTIuMiA1LjQgMTIuMiAxMi4ydjY1LjljMCA2LjctNS40IDEyLjItMTIuMiAxMi4yaC0xOC4yYy0zMy41IDAtNjAuNiA0MC41LTYwLjYgOTAuNHYxODFjMCA0OS43LTI4LjIgNzguMi02MC42IDkwLjRoLTQ5LjhjLTYgMC0xMC44LTQuOS0xMC44LTEwLjhWODc5YzAtNiA0LjktMTIuOCAxMC44LTEyLjhIODA4YzUuOSAwIDEwLjYtMTMuOCAxMC42LTE5LjZsLTEtMjQyLjRjMC00OS45IDM2LjQtOTAuNCA1OS42LTg5LjQtMzMuNS0xLjQtNTcuMy01Ni4yLTU4LjYtOTEuNGwtMS0yNDYuNmMwLTUuOC03LjctMTAuNC0xMy40LTEwLjRoLTQ1LjhjLTUuNyAwLTEwLjQtNC43LTEwLjQtMTAuNHYtMzguNWMwLTUuNyA0LjctMTAuNCAxMC40LTEwLjRoNTAuMk01MDguNCA2NjcuOGMxNi44IDAgMzAuNCAxMy42IDMwLjQgMzAuNCAwIDE2LjgtMTMuNiAzMC40LTMwLjQgMzAuNC0xNi44IDAtMzAuNC0xMy42LTMwLjQtMzAuNCAwLTE2LjggMTMuNi0zMC40IDMwLjQtMzAuNE0zODYuOCA2NjcuOGMxNi44IDAgMzAuNCAxMy42IDMwLjQgMzAuNCAwIDE2LjgtMTMuNiAzMC40LTMwLjQgMzAuNC0xNi44IDAtMzAuNC0xMy42LTMwLjQtMzAuNCAwLTE2LjggMTMuNi0zMC40IDMwLjQtMzAuNE02MzAgNjY3LjhjMTYuOCAwIDMwLjQgMTMuNiAzMC40IDMwLjQgMCAxNi44LTEzLjYgMzAuNC0zMC40IDMwLjQtMTYuOCAwLTMwLjQtMTMuNi0zMC40LTMwLjQgMC0xNi44IDEzLjYtMzAuNCAzMC40LTMwLjR6IiBwLWlkPSIyNzI5Ij48L3BhdGg+PC9zdmc+\\\"\\n\\t\\t\\t\\theight=\\\"20\\\" alt=\\\"\\\" draggable=\\\"false\\\">\\n\\n\\t\\t\\t</span>\\n\\n\\n\\t\\t</div>\\n\\t\\t<div id=\\\"qcanvas_lay\\\" v-bind:style=\\\"{'height':initHeight+'px'}\\\">\\n\\t\\t\\t<canvas id=\\\"qcanvas\\\"></canvas>\\n\\t\\t\\t<input type=\\\"text\\\" id=\\\"titleInput\\\" v-model=\\\"nodeTitle\\\" @input=\\\"modiTitle\\\" autocomplete=\\\"off\\\" @keyup.enter=\\\"onSubmit\\\">\\n\\t\\t\\t<input type=\\\"text\\\" id=\\\"containerGridColumn\\\" v-model.number=\\\"containerGridColumn\\\" @input=\\\"modiContainerGridColumn\\\" autocomplete=\\\"off\\\">\\n\\t\\t\\t<textarea name=\\\"\\\" id=\\\"tip\\\" v-model=\\\"tipText\\\" @input=\\\"modTip($event)\\\"></textarea>\\n\\n\\t\\t\\t<input type=\\\"text\\\" id=\\\"lineTitleInput\\\" v-model=\\\"lineNodeTitle\\\" @input=\\\"modiLineTitle\\\" autocomplete=\\\"off\\\">\\n\\t\\t\\t<select id=\\\"lineLike\\\" v-model=\\\"lineLike\\\" @change=\\\"modiLineLike\\\" autocomplete=\\\"off\\\">\\n\\t\\t\\t\\t<option v-for=\\\"item in lineStyleList\\\" :value=\\\"item.value\\\">{{item.name}}</option> \\n\\t\\t\\t</select>\\n\\t\\t\\t<select id=\\\"lineType\\\" v-model=\\\"lineType\\\" @change=\\\"modiLineType\\\" autocomplete=\\\"off\\\">\\n\\t\\t\\t\\t<option v-for=\\\"item in lineTypeList\\\" :value=\\\"item.value\\\">{{item.name}}</option> \\n\\t\\t\\t</select>\\n\\n\\t\\t\\t<!-- <div class=\\\"sheetLay\\\">\\n\\t\\t\\t\\t<span v-for=\\\"item in sheets\\\">{{item.name}}</span>\\n\\t\\t\\t</div> -->\\n\\t\\t</div>\\n\\n\\t\\t<el-dialog\\n\\t\\t    title=\\\"json数据\\\"\\n\\t\\t    :visible.sync=\\\"show\\\"\\n\\t\\t    width=\\\"30%\\\"\\n\\t\\t    @close=\\\"close\\\">\\n\\t\\t    <div class=\\\"json_lay\\\">\\n\\t\\t    \\t{{json}}\\n\\t\\t    </div>\\n\\t\\t    \\n\\t\\t</el-dialog>\\n\\t</div>\\n</template>\\n<script> \\nimport Vue from 'vue';\\n\\n\\timport {Dialog} from 'element-ui'\\n\\tVue.use(Dialog);\\n\\timport {Drag} from './lib/Drag.js'; \\n\\timport {Qflow} from './lib/Qflow.js';\\n\\n\\n\\tvar qflow;\\n\\n\\texport default{\\n\\t\\tname:\\\"qrelation\\\",\\n\\t\\tcomponents:{},\\n\\t\\tprops:['initWidth','initHeight','jsonData','saveFun'],\\n\\t\\tdata(){\\n\\t\\t\\treturn {\\n\\t\\t\\t  \\tcurr:0,\\n\\t\\t\\t  \\tsheets:[\\n\\t\\t\\t  \\t\\t{\\n\\t\\t\\t  \\t\\t\\tname:'sheet1',\\n\\t\\t\\t  \\t\\t}\\n\\t\\t\\t  \\t],\\n\\t  \\t\\t\\tnodeTitle:'',\\n\\t  \\t\\t\\tlineNodeTitle:'标题',\\n\\t  \\t\\t\\tlineType:'',\\n\\t  \\t\\t\\tlineTypeList:[\\n\\t  \\t\\t\\t\\t{\\n\\t\\t  \\t\\t\\t\\tname:'直线',\\n\\t\\t  \\t\\t\\t\\tvalue:'line'\\n\\t  \\t\\t\\t\\t},\\n\\t  \\t\\t\\t\\t{\\n\\t\\t  \\t\\t\\t\\tname:'二次曲线',\\n\\t\\t  \\t\\t\\t\\tvalue:'quadraticCurve'\\n\\t  \\t\\t\\t\\t},\\n\\t  \\t\\t\\t\\t{\\n\\t\\t  \\t\\t\\t\\tname:'三次曲线',\\n\\t\\t  \\t\\t\\t\\tvalue:'bezierCurve'\\n\\t  \\t\\t\\t\\t},\\n\\t  \\t\\t\\t\\t{\\n\\t\\t  \\t\\t\\t\\tname:'折线(横向)',\\n\\t\\t  \\t\\t\\t\\tvalue:'foldLine1'\\n\\t  \\t\\t\\t\\t},\\n\\t  \\t\\t\\t\\t{\\n\\t\\t  \\t\\t\\t\\tname:'折线(竖向)',\\n\\t\\t  \\t\\t\\t\\tvalue:'foldLine2'\\n\\t  \\t\\t\\t\\t}\\n\\t  \\t\\t\\t],\\n\\t  \\t\\t\\tlineLike:'',\\n\\t  \\t\\t\\tlineStyleList:[\\n\\t  \\t\\t\\t\\t{\\n\\t  \\t\\t\\t\\t\\tname:'-',\\n\\t  \\t\\t\\t\\t\\tvalue:'-'\\n\\t  \\t\\t\\t\\t},\\n\\t  \\t\\t\\t\\t{\\n\\t  \\t\\t\\t\\t\\tname:'->',\\n\\t  \\t\\t\\t\\t\\tvalue:'->'\\n\\t  \\t\\t\\t\\t},\\n\\t  \\t\\t\\t\\t{\\n\\t  \\t\\t\\t\\t\\tname:'<-',\\n\\t  \\t\\t\\t\\t\\tvalue:'<-'\\n\\t  \\t\\t\\t\\t},\\n\\t  \\t\\t\\t\\t{\\n\\t  \\t\\t\\t\\t\\tname:'<->',\\n\\t  \\t\\t\\t\\t\\tvalue:'<->'\\n\\t  \\t\\t\\t\\t},\\n\\t  \\t\\t\\t\\t{\\n\\t  \\t\\t\\t\\t\\tname:'--',\\n\\t  \\t\\t\\t\\t\\tvalue:'--'\\n\\t  \\t\\t\\t\\t},\\n\\t  \\t\\t\\t\\t{\\n\\t  \\t\\t\\t\\t\\tname:'<--',\\n\\t  \\t\\t\\t\\t\\tvalue:'<--'\\n\\t  \\t\\t\\t\\t},\\n\\t  \\t\\t\\t\\t{\\n\\t  \\t\\t\\t\\t\\tname:'-->',\\n\\t  \\t\\t\\t\\t\\tvalue:'-->'\\n\\t  \\t\\t\\t\\t},\\n\\t  \\t\\t\\t\\t{\\n\\t  \\t\\t\\t\\t\\tname:'<-->',\\n\\t  \\t\\t\\t\\t\\tvalue:'<-->'\\n\\t  \\t\\t\\t\\t},\\n\\t  \\t\\t\\t],\\n\\t  \\t\\t\\tcontainerGridColumn:1,\\n\\t  \\t\\t\\tshow:false,\\n\\t  \\t\\t\\tjson:'',\\n\\t  \\t\\t\\ttipText:''\\n\\n\\t\\t  }\\n\\t\\t},\\n\\t\\tmethods:{\\n\\t\\t\\tonSubmit:function(){\\n\\t\\t  \\t\\tqflow.contextSettingHide();\\n\\t\\t  \\t},\\n\\t\\t\\tjsShow:function(){\\n\\t\\t\\t\\tthis.json = JSON.stringify(qflow.returnSaveData());\\n\\t\\t\\t\\tthis.show = true;\\n\\t\\t\\t},\\n\\t\\t\\tclose:function(){\\n\\t\\t\\t\\tthis.show = false\\n\\t\\t\\t},\\n\\t\\t\\tdownload:function(){\\n\\t\\t  \\t\\tqflow.download();\\n\\t\\t  \\t},\\n\\t\\t\\tsave:function(){ \\n\\n\\t\\t  \\t\\tthis.saveFun && this.saveFun(qflow.returnSaveData());\\n\\t\\t  \\t},\\t\\n\\t\\t  \\tmodiTitle:function(){\\n\\t\\t  \\t\\tqflow.modiTitle(this.nodeTitle);\\n\\t\\t  \\t},\\n\\t\\t  \\tmodiLineTitle:function(){\\n\\t\\t  \\t\\tqflow.modiLineTitle(this.lineNodeTitle);\\n\\t\\t  \\t},\\n\\t\\t  \\tmodiLineLike:function(){\\n\\t\\t  \\t\\tqflow.modiLineLike(this.lineLike);\\n\\t\\t  \\t},\\n\\t\\t  \\tmodiLineType:function(){\\n\\n\\t\\t  \\t\\tqflow.modiLineType(this.lineType);\\n\\t\\t  \\t},\\n\\t\\t  \\tmodTip:function(e){\\n\\t\\t  \\t\\tvar elem = e.target;\\n\\t\\t  \\t\\telem.style.height = 'auto';\\n\\t            elem.scrollTop = 0; //防抖动\\n\\t            elem.style.height = elem.scrollHeight + 'px'; \\n\\n\\t            qflow.updateTipText(elem.value,parseInt(elem.style.height));\\n\\n\\t\\t  \\t\\t// console.log(this.tipText);\\n\\t\\t  \\t\\t// var tip = document.getElementById('tip');\\n\\t\\t  \\t\\t// tip.style.height = tip.scrollTop + tip.scrollHeight + \\\"px\\\";\\n\\n\\t\\t  \\t\\t// this.tipText = this.tipText.replace(/ /g, '');\\n\\n\\t\\t  \\t\\t// // qflow.updateTipText(this.tipText.replace(/\\\\r\\\\n/g, '\\\\n'),parseInt(tip.style.height));\\n\\t\\t  \\t\\t// qflow.updateTipText(this.tipText.replace(/\\\\r\\\\n/g, ''),parseInt(tip.style.height));\\n\\n\\n\\t\\t  \\t},\\n\\t\\t  \\tmodiContainerGridColumn:function(){\\n\\n\\t\\t  \\t\\tif(this.containerGridColumn =='' || \\n\\t\\t  \\t\\t\\tthis.containerGridColumn ==0){\\n\\n\\t\\t  \\t\\t\\treturn false;\\n\\t\\t  \\t\\t} \\n\\t\\t\\t  \\tqflow.modiContainerGridColumn(this.containerGridColumn);\\n\\t\\t  \\t\\t\\n\\n\\t\\t  \\t},\\n\\t\\t  \\tinit:function(){\\n\\t\\t  \\t\\tvar _this = this;\\n\\t\\t  \\t\\tqflow = new Qflow({\\n\\t\\t\\t\\t\\tid:'qcanvas',\\n\\t\\t\\t\\t\\twidth:_this.initWidth,\\n\\t\\t\\t\\t\\theight:_this.initHeight,\\n\\t\\t\\t\\t\\tinitData:_this.jsonData[_this.curr],\\n\\t\\t\\t\\t\\t// Qcanvas:Qcanvas\\n\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tnew Drag({ \\n\\t\\t\\t          dragAimClass:\\\"drag_ele\\\",\\n\\t\\t\\t          moveFun:(x,y)=>{ \\n\\t\\t\\t          \\t// console.log(x,y);\\n\\t\\t\\t          },\\n\\t\\t\\t          upFun:(obj)=>{ \\n\\t\\t\\t          \\tif(obj.y > 40 && obj.x>0){\\n\\n\\t\\t\\t          \\t\\t//转换到画布的坐标\\n\\t\\t\\t          \\t\\t// obj.y +=document.getElementById('qcanvas_lay').scrollTop;\\n\\t\\t\\t          \\t\\t// obj.x +=document.getElementById('qcanvas_lay').scrollLeft;\\n\\n\\t\\t\\t\\t \\t\\t\\tqflow.addEle(obj);\\n\\t\\t\\t          \\t}\\n\\n\\t\\t\\t          }\\n\\t\\t\\t      })\\n\\t\\t  \\t}\\n\\n\\t\\t},\\n\\t\\tmounted(){\\n\\t\\t\\t// console.log(Drag);\\n\\t\\t\\t// console.log(Qcanvas);\\n\\n\\t\\t\\tthis.init();\\n\\t\\t},\\n\\t\\tcreated(){\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\tcomputed:{\\n\\n\\t\\t},\\n\\t\\twatch:{\\n\\n\\t\\t},\\n\\t\\t// 销毁监听事件\\n\\t\\tdestroyed() {\\n\\t\\t  qflow !== null & qflow.destroy();\\n\\n\\t\\t  qflow = null;\\n\\t\\t}\\n\\t}\\n\\n</script>\\n<style scoped>\\n.json_lay{\\n\\t    padding: 10px;\\n    height: 200px;\\n    overflow: scroll;\\n}\\n#qflow_lay{ \\n\\t\\t\\tposition: relative;\\n\\t\\t}\\n.clear:after{\\n\\t\\t\\tcontent: \\\"\\\";\\n\\t\\t\\tdisplay: block;\\n\\t\\t\\tclear: both;\\n\\t\\t\\tfont-size: 0;\\n\\t\\t\\tline-height: 0;\\n\\t\\t}\\n\\t\\tcanvas{ \\n\\t\\t\\theight: 100%;\\n\\t\\t\\twidth: 100%;\\n\\t\\t\\tbackground-image: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PHBhdHRlcm4gaWQ9ImdyaWQiIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgcGF0dGVyblVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGggZD0iTSAwIDEwIEwgNDAgMTAgTSAxMCAwIEwgMTAgNDAgTSAwIDIwIEwgNDAgMjAgTSAyMCAwIEwgMjAgNDAgTSAwIDMwIEwgNDAgMzAgTSAzMCAwIEwgMzAgNDAiIGZpbGw9Im5vbmUiIHN0cm9rZT0iI2QwZDBkMCIgb3BhY2l0eT0iMC4yIiBzdHJva2Utd2lkdGg9IjEiLz48cGF0aCBkPSJNIDQwIDAgTCAwIDAgMCA0MCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZDBkMGQwIiBzdHJva2Utd2lkdGg9IjEiLz48L3BhdHRlcm4+PC9kZWZzPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9InVybCgjZ3JpZCkiLz48L3N2Zz4=\\\");\\n\\n\\t\\t}\\n\\t\\t.tool{\\n\\t\\t\\theight: 40px;\\n\\t\\t\\tposition: relative;\\n\\t\\t\\tz-index: 1;\\n\\t\\t\\tline-height: 40px;\\n\\t\\t\\tbackground-color: #fff;\\n\\n\\t\\t}\\n\\t\\t.tool span{\\n\\t\\t\\tdisplay: inline-block;\\n\\t\\t\\twidth: 30px;\\n\\t\\t\\theight: 30px;\\n\\t\\t\\ttext-align: center;\\n\\t\\t\\tmargin-top:5px;\\n\\t\\t\\tmargin-left:10px;\\n\\t\\t} \\n\\t\\t.tool span img{\\n\\t\\t\\tpointer-events: none;\\n\\t\\t}\\n\\n\\n\\t\\t#qcanvas_lay{\\n\\t\\t\\tposition: absolute;\\n\\t\\t\\ttop:0;\\n\\t\\t\\tleft:0;\\n\\t\\t\\twidth: 100%;\\n\\t\\t\\tbottom: 0;\\n\\t\\t\\toverflow:scroll;\\n\\t\\t}\\n\\t\\t.sheetLay{\\n\\t\\t\\tfont-size: 12px;\\n\\t\\t\\tposition: absolute;\\n\\t\\t\\tbottom: 0;\\n\\t\\t\\tleft:0;\\n\\t\\t\\tbackground: #fff;\\n\\n\\t\\t}\\n\\t\\t.json,\\n\\t\\t.save,\\n\\t\\t.download{\\n\\t\\t\\tfloat: right;\\n\\t\\t\\tfont-size: 12px;\\n\\t\\t}\\n\\t\\t#titleInput{\\n\\t\\t\\tposition: absolute;\\n\\t\\t\\tleft:0;\\n\\t\\t\\ttop:0;\\n\\t\\t\\tpadding: 0;\\n\\t\\t\\tmargin:0;\\n\\t\\t\\tborder:none; \\n\\t\\t\\tfont-size: 12px;\\n\\t\\t\\tfont-family:'Microsoft YaHei';\\n\\t\\t\\toutline: none;\\n\\t\\t\\tbackground: #FDF8E1;\\n\\t\\t}\\n\\t\\t#lineTitleInput,\\n\\t\\t#containerGridColumn,\\n\\t\\t#lineLike,\\n\\t\\t#lineType{\\n\\t\\t\\tposition: absolute;\\n\\t\\t\\tleft:0;\\n\\t\\t\\ttop:0;\\n\\t\\t\\tpadding: 0;\\n\\t\\t\\tmargin:0;\\n\\t\\t\\tborder:none;\\n\\t\\t\\ttext-indent: 5px;\\n\\t\\t\\tfont-size: 12px;\\n\\t\\t}\\n#tip{\\n\\t\\t\\tposition: absolute;\\n\\t\\t    z-index: 1;\\n\\t\\t    padding:0;\\n\\t\\t    margin:0;\\n\\t\\t    outline: none;\\n\\t\\t    display: none;\\n\\t\\t    font-family:'Microsoft YaHei';\\n\\t\\t    /* font-family: 'Arial'; */\\n\\t\\t\\tword-break: break-all;\\n\\t\\t    border:transparent;\\n\\t\\t    overflow: hidden; \\n\\t\\t    background: rgba(0,0,0,0);\\n\\t\\t    resize:none;\\n\\t\\t    /*pointer-events: none;*/\\n\\t\\t}\\n</style>\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcXJlbGF0aW9uLnZ1ZT8xMjc0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJCQUEyQixtQkFBTyxDQUFDLENBQTRDO0FBQy9FOzs7QUFHQTtBQUNBLGNBQWMsUUFBUyxnQ0FBZ0Msc0JBQXNCLG9CQUFvQix1QkFBdUIsR0FBRyw4QkFBOEIsNEJBQTRCLEdBQUcsZ0NBQWdDLHNCQUFzQix1QkFBdUIsb0JBQW9CLHFCQUFxQix1QkFBdUIsR0FBRywwQkFBMEIsc0JBQXNCLG9CQUFvQixtREFBbUQsdW1CQUF1bUIsR0FBRyx5QkFBeUIscUJBQXFCLDJCQUEyQixtQkFBbUIsMEJBQTBCLCtCQUErQixHQUFHLDhCQUE4Qiw4QkFBOEIsb0JBQW9CLHFCQUFxQiwyQkFBMkIsdUJBQXVCLHlCQUF5QixHQUFHLGtDQUFrQyw2QkFBNkIsR0FBRyxnQ0FBZ0MsMkJBQTJCLGNBQWMsZUFBZSxvQkFBb0Isa0JBQWtCLHdCQUF3QixHQUFHLDZCQUE2Qix3QkFBd0IsMkJBQTJCLGtCQUFrQixlQUFlLHlCQUF5QixHQUFHLHVGQUF1RixxQkFBcUIsd0JBQXdCLEdBQUcsK0JBQStCLDJCQUEyQixlQUFlLGNBQWMsbUJBQW1CLGlCQUFpQixvQkFBb0IseUJBQXlCLHNDQUFzQyxzQkFBc0IsNEJBQTRCLEdBQUcsaUpBQWlKLDJCQUEyQixlQUFlLGNBQWMsbUJBQW1CLGlCQUFpQixvQkFBb0IseUJBQXlCLHdCQUF3QixHQUFHLHdCQUF3QiwyQkFBMkIscUJBQXFCLG9CQUFvQixtQkFBbUIsd0JBQXdCLHdCQUF3Qix3Q0FBd0Msa0NBQWtDLGlDQUFpQyw2QkFBNkIsMkJBQTJCLHFDQUFxQyxzQkFBc0IsaUNBQWlDLEtBQUssVUFBVSxnSEFBZ0gsTUFBTSxVQUFVLFVBQVUsV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsWUFBWSxLQUFLLEtBQUssVUFBVSxX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b0JBQW9CLHlCQUF5Qix3QkFBd0IsT0FBTyxPQUFPLDJCQUEyQixxQkFBcUIsb0JBQW9CLG1CQUFtQix3QkFBd0Isd0JBQXdCLHdDQUF3QyxrQ0FBa0MsaUNBQWlDLDZCQUE2QiwyQkFBMkIscUNBQXFDLHNCQUFzQixpQ0FBaUMsU0FBUyw2QkFBNkI7O0FBRXY0dUIiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLmpzb25fbGF5W2RhdGEtdi03ZTAwZWY2NF17XFxuXFx0ICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgIGhlaWdodDogMjAwcHg7XFxuICAgIG92ZXJmbG93OiBzY3JvbGw7XFxufVxcbiNxZmxvd19sYXlbZGF0YS12LTdlMDBlZjY0XXsgXFxuXFx0XFx0XFx0cG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4uY2xlYXJbZGF0YS12LTdlMDBlZjY0XTphZnRlcntcXG5cXHRcXHRcXHRjb250ZW50OiBcXFwiXFxcIjtcXG5cXHRcXHRcXHRkaXNwbGF5OiBibG9jaztcXG5cXHRcXHRcXHRjbGVhcjogYm90aDtcXG5cXHRcXHRcXHRmb250LXNpemU6IDA7XFxuXFx0XFx0XFx0bGluZS1oZWlnaHQ6IDA7XFxufVxcbmNhbnZhc1tkYXRhLXYtN2UwMGVmNjRdeyBcXG5cXHRcXHRcXHRoZWlnaHQ6IDEwMCU7XFxuXFx0XFx0XFx0d2lkdGg6IDEwMCU7XFxuXFx0XFx0XFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlOREFpSUdobGFXZG9kRDBpTkRBaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BHUmxabk0rUEhCaGRIUmxjbTRnYVdROUltZHlhV1FpSUhkcFpIUm9QU0kwTUNJZ2FHVnBaMmgwUFNJME1DSWdjR0YwZEdWeWJsVnVhWFJ6UFNKMWMyVnlVM0JoWTJWUGJsVnpaU0krUEhCaGRHZ2daRDBpVFNBd0lERXdJRXdnTkRBZ01UQWdUU0F4TUNBd0lFd2dNVEFnTkRBZ1RTQXdJREl3SUV3Z05EQWdNakFnVFNBeU1DQXdJRXdnTWpBZ05EQWdUU0F3SURNd0lFd2dOREFnTXpBZ1RTQXpNQ0F3SUV3Z016QWdOREFpSUdacGJHdzlJbTV2Ym1VaUlITjBjbTlyWlQwaUkyUXdaREJrTUNJZ2IzQmhZMmwwZVQwaU1DNHlJaUJ6ZEhKdmEyVXRkMmxrZEdnOUlqRWlMejQ4Y0dGMGFDQmtQU0pOSURRd0lEQWdUQ0F3SURBZ01DQTBNQ0lnWm1sc2JEMGlibTl1WlNJZ2MzUnliMnRsUFNJalpEQmtNR1F3SWlCemRISnZhMlV0ZDJsa2RHZzlJakVpTHo0OEwzQmhkSFJsY200K1BDOWtaV1p6UGp4eVpXTjBJSGRwWkhSb1BTSXhNREFsSWlCb1pXbG5hSFE5SWpFd01DVWlJR1pwYkd3OUluVnliQ2dqWjNKcFpDa2lMejQ4TDNOMlp6ND1cXFwiKTtcXG59XFxuLnRvb2xbZGF0YS12LTdlMDBlZjY0XXtcXG5cXHRcXHRcXHRoZWlnaHQ6IDQwcHg7XFxuXFx0XFx0XFx0cG9zaXRpb246IHJlbGF0aXZlO1xcblxcdFxcdFxcdHotaW5kZXg6IDE7XFxuXFx0XFx0XFx0bGluZS1oZWlnaHQ6IDQwcHg7XFxuXFx0XFx0XFx0YmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG59XFxuLnRvb2wgc3BhbltkYXRhLXYtN2UwMGVmNjRde1xcblxcdFxcdFxcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG5cXHRcXHRcXHR3aWR0aDogMzBweDtcXG5cXHRcXHRcXHRoZWlnaHQ6IDMwcHg7XFxuXFx0XFx0XFx0dGV4dC1hbGlnbjogY2VudGVyO1xcblxcdFxcdFxcdG1hcmdpbi10b3A6NXB4O1xcblxcdFxcdFxcdG1hcmdpbi1sZWZ0OjEwcHg7XFxufVxcbi50b29sIHNwYW4gaW1nW2RhdGEtdi03ZTAwZWY2NF17XFxuXFx0XFx0XFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcbiNxY2FudmFzX2xheVtkYXRhLXYtN2UwMGVmNjRde1xcblxcdFxcdFxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5cXHRcXHRcXHR0b3A6MDtcXG5cXHRcXHRcXHRsZWZ0OjA7XFxuXFx0XFx0XFx0d2lkdGg6IDEwMCU7XFxuXFx0XFx0XFx0Ym90dG9tOiAwO1xcblxcdFxcdFxcdG92ZXJmbG93OnNjcm9sbDtcXG59XFxuLnNoZWV0TGF5W2RhdGEtdi03ZTAwZWY2NF17XFxuXFx0XFx0XFx0Zm9udC1zaXplOiAxMnB4O1xcblxcdFxcdFxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5cXHRcXHRcXHRib3R0b206IDA7XFxuXFx0XFx0XFx0bGVmdDowO1xcblxcdFxcdFxcdGJhY2tncm91bmQ6ICNmZmY7XFxufVxcbi5qc29uW2RhdGEtdi03ZTAwZWY2NF0sXFxuXFx0XFx0LnNhdmVbZGF0YS12LTdlMDBlZjY0XSxcXG5cXHRcXHQuZG93bmxvYWRbZGF0YS12LTdlMDBlZjY0XXtcXG5cXHRcXHRcXHRmbG9hdDogcmlnaHQ7XFxuXFx0XFx0XFx0Zm9udC1zaXplOiAxMnB4O1xcbn1cXG4jdGl0bGVJbnB1dFtkYXRhLXYtN2UwMGVmNjRde1xcblxcdFxcdFxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5cXHRcXHRcXHRsZWZ0OjA7XFxuXFx0XFx0XFx0dG9wOjA7XFxuXFx0XFx0XFx0cGFkZGluZzogMDtcXG5cXHRcXHRcXHRtYXJnaW46MDtcXG5cXHRcXHRcXHRib3JkZXI6bm9uZTsgXFxuXFx0XFx0XFx0Zm9udC1zaXplOiAxMnB4O1xcblxcdFxcdFxcdGZvbnQtZmFtaWx5OidNaWNyb3NvZnQgWWFIZWknO1xcblxcdFxcdFxcdG91dGxpbmU6IG5vbmU7XFxuXFx0XFx0XFx0YmFja2dyb3VuZDogI0ZERjhFMTtcXG59XFxuI2xpbmVUaXRsZUlucHV0W2RhdGEtdi03ZTAwZWY2NF0sXFxuXFx0XFx0I2NvbnRhaW5lckdyaWRDb2x1bW5bZGF0YS12LTdlMDBlZjY0XSxcXG5cXHRcXHQjbGluZUxpa2VbZGF0YS12LTdlMDBlZjY0XSxcXG5cXHRcXHQjbGluZVR5cGVbZGF0YS12LTdlMDBlZjY0XXtcXG5cXHRcXHRcXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0XFx0XFx0bGVmdDowO1xcblxcdFxcdFxcdHRvcDowO1xcblxcdFxcdFxcdHBhZGRpbmc6IDA7XFxuXFx0XFx0XFx0bWFyZ2luOjA7XFxuXFx0XFx0XFx0Ym9yZGVyOm5vbmU7XFxuXFx0XFx0XFx0dGV4dC1pbmRlbnQ6IDVweDtcXG5cXHRcXHRcXHRmb250LXNpemU6IDEycHg7XFxufVxcbiN0aXBbZGF0YS12LTdlMDBlZjY0XXtcXG5cXHRcXHRcXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0XFx0ICAgIHotaW5kZXg6IDE7XFxuXFx0XFx0ICAgIHBhZGRpbmc6MDtcXG5cXHRcXHQgICAgbWFyZ2luOjA7XFxuXFx0XFx0ICAgIG91dGxpbmU6IG5vbmU7XFxuXFx0XFx0ICAgIGRpc3BsYXk6IG5vbmU7XFxuXFx0XFx0ICAgIGZvbnQtZmFtaWx5OidNaWNyb3NvZnQgWWFIZWknO1xcblxcdFxcdCAgICAvKiBmb250LWZhbWlseTogJ0FyaWFsJzsgKi9cXG5cXHRcXHRcXHR3b3JkLWJyZWFrOiBicmVhay1hbGw7XFxuXFx0XFx0ICAgIGJvcmRlcjp0cmFuc3BhcmVudDtcXG5cXHRcXHQgICAgb3ZlcmZsb3c6IGhpZGRlbjsgXFxuXFx0XFx0ICAgIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsMCk7XFxuXFx0XFx0ICAgIHJlc2l6ZTpub25lO1xcblxcdFxcdCAgICAvKnBvaW50ZXItZXZlbnRzOiBub25lOyovXFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvVXNlcnMvemhpY2hlbmcvRG9jdW1lbnRzL25wbS9xcmVsYXRpb24vc3JjL3NyYy9xcmVsYXRpb24udnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUEyUUE7S0FDQSxjQUFBO0lBQ0EsY0FBQTtJQUNBLGlCQUFBO0NBQ0E7QUFDQTtHQUNBLG1CQUFBO0NBQ0E7QUFDQTtHQUNBLFlBQUE7R0FDQSxlQUFBO0dBQ0EsWUFBQTtHQUNBLGFBQUE7R0FDQSxlQUFBO0NBQ0E7QUFDQTtHQUNBLGFBQUE7R0FDQSxZQUFBO0dBQ0EsZ3BCQUFBO0NBRUE7QUFDQTtHQUNBLGFBQUE7R0FDQSxtQkFBQTtHQUNBLFdBQUE7R0FDQSxrQkFBQTtHQUNBLHVCQUFBO0NBRUE7QUFDQTtHQUNBLHNCQUFBO0dBQ0EsWUFBQTtHQUNBLGFBQUE7R0FDQSxtQkFBQTtHQUNBLGVBQUE7R0FDQSxpQkFBQTtDQUNBO0FBQ0E7R0FDQSxxQkFBQTtDQUNBO0FBR0E7R0FDQSxtQkFBQTtHQUNBLE1BQUE7R0FDQSxPQUFBO0dBQ0EsWUFBQTtHQUNBLFVBQUE7R0FDQSxnQkFBQTtDQUNBO0FBQ0E7R0FDQSxnQkFBQTtHQUNBLG1CQUFBO0dBQ0EsVUFBQTtHQUNBLE9BQUE7R0FDQSxpQkFBQTtDQUVBO0FBQ0E7OztHQUdBLGFBQUE7R0FDQSxnQkFBQTtDQUNBO0FBQ0E7R0FDQSxtQkFBQTtHQUNBLE9BQUE7R0FDQSxNQUFBO0dBQ0EsV0FBQTtHQUNBLFNBQUE7R0FDQSxZQUFBO0dBQ0EsZ0JBQUE7R0FDQSw4QkFBQTtHQUNBLGNBQUE7R0FDQSxvQkFBQTtDQUNBO0FBQ0E7Ozs7R0FJQSxtQkFBQTtHQUNBLE9BQUE7R0FDQSxNQUFBO0dBQ0EsV0FBQTtHQUNBLFNBQUE7R0FDQSxZQUFBO0dBQ0EsaUJBQUE7R0FDQSxnQkFBQTtDQUNBO0FBQ0E7R0FDQSxtQkFBQTtNQUNBLFdBQUE7TUFDQSxVQUFBO01BQ0EsU0FBQTtNQUNBLGNBQUE7TUFDQSxjQUFBO01BQ0EsOEJBQUE7TUFDQSwyQkFBQTtHQUNBLHNCQUFBO01BQ0EsbUJBQUE7TUFDQSxpQkFBQTtNQUNBLDBCQUFBO01BQ0EsWUFBQTtNQUNBLHlCQUFBO0NBQ0FcIixcImZpbGVcIjpcInFyZWxhdGlvbi52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcblxcdDxkaXYgaWQ9XFxcInFmbG93X2xheVxcXCI+XFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwidG9vbFxcXCI+XFxuXFx0XFx0XFx0PHNwYW4gY2xhc3M9XFxcImRyYWdfZWxlXFxcIiBkYXRhLWlkPVxcXCItMVxcXCI+XFxuXFx0XFx0XFx0XFx0PGltZyBzcmM9XFxcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCemRHRnVaR0ZzYjI1bFBTSnVieUkvUGp3aFJFOURWRmxRUlNCemRtY2dVRlZDVEVsRElDSXRMeTlYTTBNdkwwUlVSQ0JUVmtjZ01TNHhMeTlGVGlJZ0ltaDBkSEE2THk5M2QzY3Vkek11YjNKbkwwZHlZWEJvYVdOekwxTldSeTh4TGpFdlJGUkVMM04yWnpFeExtUjBaQ0krUEhOMlp5QjBQU0l4TmpBeU1qazNOVGswT0RjNUlpQmpiR0Z6Y3owaWFXTnZiaUlnZG1sbGQwSnZlRDBpTUNBd0lERXdNalFnTVRBeU5DSWdkbVZ5YzJsdmJqMGlNUzR4SWlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhBdGFXUTlJakl4TkRjaUlIaHRiRzV6T25oc2FXNXJQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUwzaHNhVzVySWlCM2FXUjBhRDBpTWpBd0lpQm9aV2xuYUhROUlqSXdNQ0krUEdSbFpuTStQSE4wZVd4bElIUjVjR1U5SW5SbGVIUXZZM056SWo0OEwzTjBlV3hsUGp3dlpHVm1jejQ4Y0dGMGFDQmtQU0pOTWpVMklESTRPR2cyTkhZMk5HZ3ROalI2SUcweE1qZ2dNemcwYURNNE5IWTJORWd6T0RSNlRUSTFOaUEwT0RCb05qUjJOalJvTFRZMGVpQnRNQ0F4T1RKb05qUjJOalJvTFRZMGVpSWdabWxzYkQwaUl6TXpNek16TXlJZ2NDMXBaRDBpTWpFME9DSStQQzl3WVhSb1BqeHdZWFJvSUdROUlrMDRNeklnTmpSSU1Ua3lZeTB6TlM0eUlEQXROalFnTWpndU9DMDJOQ0EyTkhZM05qaGpNQ0F6TlM0eUlESTRMamdnTmpRZ05qUWdOalJvTmpRd1l6TTFMaklnTUNBMk5DMHlPQzQ0SURZMExUWTBWakV5T0dNd0xUTTFMakl0TWpndU9DMDJOQzAyTkMwMk5Ib2diVEFnT0RBd1l6QWdNVGt1TWkweE5pQXpNaTB6TWlBek1rZ3lNalJqTFRFMklEQXRNekl0TVRJdU9DMHpNaTB6TWxZeE5qQmpNQzB4T1M0eUlERTJMVE15SURNeUxUTXlhRFUzTm1NeE5pQXdJRE15SURFeUxqZ2dNeklnTXpKMk56QTBlaUlnWm1sc2JEMGlJek16TXpNek15SWdjQzFwWkQwaU1qRTBPU0krUEM5d1lYUm9Qanh3WVhSb0lHUTlJazB6T0RRZ05EZ3dhRE00TkhZMk5FZ3pPRFI2SUcwd0xURTVNbWd6T0RSMk5qUklNemcwZWlJZ1ptbHNiRDBpSXpNek16TXpNeUlnY0MxcFpEMGlNakUxTUNJK1BDOXdZWFJvUGp3dmMzWm5QZz09XFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiBhbHQ9XFxcIlxcXCIgZHJhZ2dhYmxlPVxcXCJmYWxzZVxcXCI+XFxuXFx0XFx0XFx0PC9zcGFuPlxcblxcdFxcdFxcdDxzcGFuIGNsYXNzPVxcXCJkcmFnX2VsZVxcXCIgZGF0YS1pZD1cXFwiMVxcXCI+XFxuXFx0XFx0XFx0XFx0PGltZyBzcmM9XFxcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCemRHRnVaR0ZzYjI1bFBTSnVieUkvUGp3aFJFOURWRmxRUlNCemRtY2dVRlZDVEVsRElDSXRMeTlYTTBNdkwwUlVSQ0JUVmtjZ01TNHhMeTlGVGlJZ0ltaDBkSEE2THk5M2QzY3Vkek11YjNKbkwwZHlZWEJvYVdOekwxTldSeTh4TGpFdlJGUkVMM04yWnpFeExtUjBaQ0krUEhOMlp5QjBQU0l4TmpBeU1qazNPRFkzTkRjd0lpQmpiR0Z6Y3owaWFXTnZiaUlnZG1sbGQwSnZlRDBpTUNBd0lERXdNalFnTVRBeU5DSWdkbVZ5YzJsdmJqMGlNUzR4SWlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhBdGFXUTlJak0xTWpZaUlIaHRiRzV6T25oc2FXNXJQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUwzaHNhVzVySWlCM2FXUjBhRDBpTWpBd0lpQm9aV2xuYUhROUlqSXdNQ0krUEdSbFpuTStQSE4wZVd4bElIUjVjR1U5SW5SbGVIUXZZM056SWo0OEwzTjBlV3hsUGp3dlpHVm1jejQ4Y0dGMGFDQmtQU0pOTkRVNExqSWdNemN4U0RFeE1pNDJRemcyTGprZ016Y3hJRFkySURNMU1DNHhJRFkySURNeU5DNDFWakUyTkM0NVl6QXRNalV1TnlBeU1DNDVMVFEyTGpVZ05EWXVOUzAwTmk0MWFETTBOUzQyWXpJMUxqY2dNQ0EwTmk0MUlESXdMamtnTkRZdU5TQTBOaTQxZGpFMU9TNDFZekF1TVNBeU5TNDNMVEl3TGpnZ05EWXVOaTAwTmk0MElEUTJMalo2VFRFeE1pNDJJREUxT0M0ell5MHpMallnTUMwMkxqWWdNeTAyTGpZZ05pNDJkakUxT1M0MVl6QWdNeTQySURNZ05pNDJJRFl1TmlBMkxqWm9NelExTGpaak15NDJJREFnTmk0MkxUTWdOaTQyTFRZdU5sWXhOalF1T1dNd0xUTXVOaTB6TFRZdU5pMDJMall0Tmk0MlNERXhNaTQyZWswNU1UQXVNU0E1TURoSU1qVTRMamhqTFRJMUxqY2dNQzAwTmk0MUxUSXdMamt0TkRZdU5TMDBOaTQxVmpVeE5TNDVZekF0TWpVdU55QXlNQzQ1TFRRMkxqVWdORFl1TlMwME5pNDFhRFkxTVM0ell6STFMamNnTUNBME5pNDFJREl3TGprZ05EWXVOU0EwTmk0MWRqTTBOUzQyWXpBZ01qVXVOeTB5TUM0NElEUTJMalV0TkRZdU5TQTBOaTQxZWsweU5UZ3VPQ0ExTURrdU1tTXRNeTQySURBdE5pNDJJRE10Tmk0MklEWXVObll6TkRVdU5tTXdJRE11TmlBeklEWXVOaUEyTGpZZ05pNDJhRFkxTVM0ell6TXVOaUF3SURZdU5pMHpJRFl1TmkwMkxqWldOVEUxTGpsak1DMHpMall0TXkwMkxqWXROaTQyTFRZdU5rZ3lOVGd1T0hvaUlHWnBiR3c5SWlNMFJqUkdORVlpSUhBdGFXUTlJak0xTWpjaVBqd3ZjR0YwYUQ0OGNHRjBhQ0JrUFNKTk1qSTFMalVnTmprMUxqTm9MVFU1TGpOakxURTRMak1nTUMwek15NHlMVEUwTGprdE16TXVNaTB6TXk0eGJDMHdMalV0TXpBMUxqaGpNQzB4TVNBNExqa3RNakFnTVRrdU9TMHlNQ0F4TVNBd0lERTVMamtnT0M0NUlERTVMamtnTVRrdU9Xd3dMalVnTWprNUxqRm9OVEl1TjJNeE1TQXdJREU1TGprZ09DNDVJREU1TGprZ01Ua3VPWE10T0M0NElESXdMVEU1TGprZ01qQjZJaUJtYVd4c1BTSWpORVkwUmpSR0lpQndMV2xrUFNJek5USTRJajQ4TDNCaGRHZytQQzl6ZG1jK1xcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgYWx0PVxcXCJcXFwiIGRyYWdnYWJsZT1cXFwiZmFsc2VcXFwiPlxcblxcdFxcdFxcdDwvc3Bhbj5cXG5cXHRcXHRcXHQ8c3BhbiBjbGFzcz1cXFwiZHJhZ19lbGVcXFwiIGRhdGEtaWQ9XFxcIjJcXFwiPlxcblxcdFxcdFxcdFxcdDxpbWcgc3JjPVxcXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQnpkR0Z1WkdGc2IyNWxQU0p1YnlJL1Bqd2hSRTlEVkZsUVJTQnpkbWNnVUZWQ1RFbERJQ0l0THk5WE0wTXZMMFJVUkNCVFZrY2dNUzR4THk5RlRpSWdJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MMGR5WVhCb2FXTnpMMU5XUnk4eExqRXZSRlJFTDNOMlp6RXhMbVIwWkNJK1BITjJaeUIwUFNJeE5qQXpNRGd4T1RJeE1EZzBJaUJqYkdGemN6MGlhV052YmlJZ2RtbGxkMEp2ZUQwaU1DQXdJREV3TWpRZ01UQXlOQ0lnZG1WeWMybHZiajBpTVM0eElpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIQXRhV1E5SWpNeE1qRWlJSGh0Ykc1ek9uaHNhVzVyUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMM2hzYVc1cklpQjNhV1IwYUQwaU1qQXdJaUJvWldsbmFIUTlJakl3TUNJK1BHUmxabk0rUEhOMGVXeGxJSFI1Y0dVOUluUmxlSFF2WTNOeklqNDhMM04wZVd4bFBqd3ZaR1ZtY3o0OGNHRjBhQ0JrUFNKTk5qUXVOekV6T0RnMElEWTFNQzQwTURReU1XdzRPVEl1TmpnME1qTXlJREFnTUNBMU5TNHdOVE00TnpNdE9Ea3lMalk0TkRJek1pQXdJREF0TlRVdU1EVXpPRGN6V2lJZ2NDMXBaRDBpTXpFeU1pSStQQzl3WVhSb1BqeHdZWFJvSUdROUlrMDFNVEV1TURVM05UTTFJREl6Tnk0ME9EYzROemxzTkRRMkxqTTBNRFU0TVNBd0lEQWdOVFV1TURVMk9UUXpMVFEwTmk0ek5EQTFPREVnTUNBd0xUVTFMakExTmprME0xb2lJSEF0YVdROUlqTXhNak1pUGp3dmNHRjBhRDQ4Y0dGMGFDQmtQU0pOTVRnNUxqSXlOVFk0T1NBME9EUXVNelkzTmpZemJERTRPQzQ1TlRNME9TQXdJRFEyTGpJNE9ESXpNeUF4TVRRdU56UTRORFF4SURZMExqYzBNVFV4TXlBd1RETXhOaTR6TmprME16Z2dNVGM1TGprd05ETTVNMnd0TmpJdU5qazBPVEF4SURCTU9EQXVPRE16TURBeklEVTVPUzR4TVRZeE1ETnNOalF1TnpRek5UWWdNRXd4T0RrdU1qSTFOamc1SURRNE5DNHpOamMyTmpONlRUSTNOUzQyTkRrd01UUWdNall5TGpjeE9UVTBZekl1TnpNeE1qQTBMVFl1T0RVMk1UVXlJRFV1TVRjeU9ERXpMVEUyTGpVNU56QXdNeUEzTGpNeE9UY3dPUzB5T1M0eU1qazNNVGhzTVM0ME5qYzBNakVnTUdNeUxqVXpOVGMxTXlBeE15NDRPVFUwTnpVZ05DNDRPREF4TkRjZ01qTXVOak0yTXpJM0lEY3VNRE13TVRFMElESTVMakl5T1RjeE9HdzJPQzQxTkRreU16WWdNVGMwTGpJNE9EUTRPRXd5TURjdU5qZ3lNRFFnTkRNM0xqQXdPREF5T1NBeU56VXVOalE1TURFMElESTJNaTQzTVRrMU5Ib2lJSEF0YVdROUlqTXhNalFpUGp3dmNHRjBhRDQ4Y0dGMGFDQmtQU0pOTlRFeExqQTFOelV6TlNBek56VXVNVEk0TnpBemJEUTBOaTR6TkRBMU9ERWdNQ0F3SURVMUxqQTFNemczTXkwME5EWXVNelF3TlRneElEQWdNQzAxTlM0d05UTTROek5hSWlCd0xXbGtQU0l6TVRJMUlqNDhMM0JoZEdnK1BIQmhkR2dnWkQwaVRUWTBMamN4TXpnNE5DQTNPRGd1TURRd09UUnNPRGt5TGpZNE5ESXpNaUF3SURBZ05UVXVNRFUwT0RrM0xUZzVNaTQyT0RReU16SWdNQ0F3TFRVMUxqQTFORGc1TjFvaUlIQXRhV1E5SWpNeE1qWWlQand2Y0dGMGFENDhjR0YwYUNCa1BTSk5OVEV4TGpBMU56VXpOU0ExTVRJdU56WTJORFUyYkRRME5pNHpOREExT0RFZ01DQXdJRFUxTGpBMU5EZzVOeTAwTkRZdU16UXdOVGd4SURBZ01DMDFOUzR3TlRRNE9UZGFJaUJ3TFdsa1BTSXpNVEkzSWo0OEwzQmhkR2crUEM5emRtYytcXFwiIGhlaWdodD1cXFwiMjBcXFwiIGFsdD1cXFwiXFxcIiBkcmFnZ2FibGU9XFxcImZhbHNlXFxcIj5cXG5cXHRcXHRcXHQ8L3NwYW4+XFxuXFx0XFx0XFx0XFxuXFx0XFx0XFx0XFxuXFx0XFx0XFx0PHNwYW4gY2xhc3M9XFxcInNhdmVcXFwiIEBjbGljaz1cXFwic2F2ZVxcXCI+XFxuXFx0XFx0XFx0XFx0PGltZyBzcmM9XFxcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCemRHRnVaR0ZzYjI1bFBTSnVieUkvUGp3aFJFOURWRmxRUlNCemRtY2dVRlZDVEVsRElDSXRMeTlYTTBNdkwwUlVSQ0JUVmtjZ01TNHhMeTlGVGlJZ0ltaDBkSEE2THk5M2QzY3Vkek11YjNKbkwwZHlZWEJvYVdOekwxTldSeTh4TGpFdlJGUkVMM04yWnpFeExtUjBaQ0krUEhOMlp5QjBQU0l4TmpBeU1qazRNREExTnpBeUlpQmpiR0Z6Y3owaWFXTnZiaUlnZG1sbGQwSnZlRDBpTUNBd0lERXdNalFnTVRBeU5DSWdkbVZ5YzJsdmJqMGlNUzR4SWlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhBdGFXUTlJalEwTVRRaUlIaHRiRzV6T25oc2FXNXJQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUwzaHNhVzVySWlCM2FXUjBhRDBpTWpBd0lpQm9aV2xuYUhROUlqSXdNQ0krUEdSbFpuTStQSE4wZVd4bElIUjVjR1U5SW5SbGVIUXZZM056SWo0OEwzTjBlV3hsUGp3dlpHVm1jejQ4Y0dGMGFDQmtQU0pOT0RrMUxqZ3pJRFl5TGpFd01tTXpNUzQzTmpFZ05TNHlPVFFnTlRJdU9UTTFJREkyTGpRMk9DQTJNQzQ0TnpZZ05USXVPVE0xSURjdU9UUWdNVGd1TlRJM0lEVXVNamswSURneUxqQTBPU0ExTGpJNU5DQXhNRGd1TlRFM2RqWXhOaTQyT1RWak1DQXhPQzQxTWpjZ01DQTBNaTR6TkRrdE1pNDJORGNnTlRVdU5UZ3lMVEl1TmpRM0lETXhMamMyTVMweU15NDRNakVnTlRJdU9UTTFMVFV3TGpJNE9DQTJNQzQ0TnpZdE1UZ3VOVEkzSURjdU9UUXRPRFF1TmprM0lEVXVNamswTFRFd09DNDFNVGNnTlM0eU9UUXRNakEyTGpRME55QXdMVFF4TWk0NE9UVWdNQzAyTVRrdU16UXlJREF0TVRVdU9EZ3hJREF0TXprdU56QXhJREF0TlRVdU5UZ3lMVEl1TmpRM0xUSTVMakV4TlMweUxqWTBOeTAxTWk0NU16VXRNak11T0RJeExUWXdMamczTmkwMU1DNHlPRGd0TlM0eU9UUXRNVGd1TlRJM0xUSXVOalEzTFRnMExqWTVOeTB5TGpZME55MHhNRGd1TlRFM2RpMDJNVGt1TXpReVl6QXRNVFV1T0RneElEQXRNemN1TURVMUlEQXROVEl1T1RNMUlEVXVNamswTFRNeExqYzJNU0F5Tmk0ME5qY3ROVEl1T1RNMUlEVXlMamt6TlMwMk15NDFNaklnTVRndU5USTNMVFV1TWprMElEZ3lMakEwT1MweUxqWTBOeUF4TURndU5URTNMVEl1TmpRM0lESXdOaTQwTkRjZ01DQTBNVEF1TWpRNElEQWdOakUyTGpZNU5TQXdJREUxTGpnNE1TQXdJRE01TGpjd01TQXdJRFUxTGpVNE1pQXdlazB6TXpRdU56RTVJRE0yTVM0eE9EWm9NelUwTGpZMk5tTXhNQzQxT0RjZ01DQXhNeTR5TXpRdE5TNHlPVFFnTVRNdU1qTTBMVEV6TGpJek5IWXRNak13TGpJMk9HZ3RNemd4TGpFek0zWXlNakl1TXpJNFl6QWdNVFV1T0RneExUSXVOalEzSURJeExqRTNNeUF4TXk0eU16UWdNakV1TVRjemVrMDNOVGd1TWlBeE1UY3VOamcwZGpJME9DNDNPVFpqTUNBek55NHdOVFV0Tnk0NU5DQTFNQzR5T0RndE5EUXVPVGswSURVd0xqSTRPQzA1Tnk0NU15QXdMVE0zTUM0MU5EWWdNQzAwTVRndU1UZzRJREF0TWpFdU1UY3pJREF0TWprdU1URTFMVEV3TGpVNE55MHlPUzR4TVRVdE16Y3VNRFUxZGkweU5qSXVNREk1WXkwek1TNDNOakVnTUMwNE5DNDJPVGNnTUMweE1UWXVORFU0SURBdE1UVXVPRGd4SURBdE1qWXVORFkzSURBdE1qa3VNVEUxSURFd0xqVTROeTB5TGpZME55QTNMamswTFRJdU5qUTNJREV6Tnk0Mk16SXRNaTQyTkRjZ01UVTJMakUxT0hZMU9USXVPRGMwWXpBZ01UTXVNak0wSURBZ01qTXVPREl4SURFekxqSXpOQ0F5Tmk0ME5qY2dOUzR5T1RRZ01pNDJORGNnTVRNM0xqWXpNaUF5TGpZME55QXhOVFl1TVRVNElESXVOalEzSURVeUxqa3pOU0F3SURVNExqSXlPQ0F3SURFeE1TNHhOalFnTUhZdE1UYzVMamszT1dneU1qY3VOakl4ZGpFM09TNDVOemxqTnpRdU1UQTVJREFnTVRFeExqRTJOQ0F3SURFNE55NDVNaUF3SURFd0xqVTROeUF3SURjMExqRXdPU0F3SURjNUxqUXdNeTB5TGpZME55QXhNQzQxT0RjdE1pNDJORGNnTVRNdU1qTTBMVEV3TGpVNE55QXhNeTR5TXpRdE1qWXVORFkzZGkwMk5qa3VOak5qTUMweE15NHlNelFnTUMwMk9DNDRNVFV0TWk0Mk5EY3ROell1TnpVMkxUSXVOalEzTFRFekxqSXpOQzB4T0M0MU1qY3RNVE11TWpNMExUSTJMalEyTnkweE15NHlNelF0TXpRdU5EQTRJREF0T0RRdU5qazNJREl1TmpRM0xURXhPUzR4TURRZ01IcE5ORFV6TGpneU15QTVNRE11TnpjeWJERXhOaTQwTlRnZ01pNDJORGQyTFRFeU5DNHpPVGhvTFRFeE5pNDBOVGgyTVRJeExqYzFNWG9pSUhBdGFXUTlJalEwTVRVaVBqd3ZjR0YwYUQ0OEwzTjJaejQ9XFxcIlxcblxcdFxcdFxcdFxcdGhlaWdodD1cXFwiMjBcXFwiIGFsdD1cXFwiXFxcIiBkcmFnZ2FibGU9XFxcImZhbHNlXFxcIj5cXG5cXG5cXHRcXHRcXHQ8L3NwYW4+XFxuXFx0XFx0XFx0PHNwYW4gY2xhc3M9XFxcImRvd25sb2FkXFxcIiBAY2xpY2s9XFxcImRvd25sb2FkXFxcIj5cXG5cXHRcXHRcXHRcXHQ8aW1nIHNyYz1cXFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJ6ZEdGdVpHRnNiMjVsUFNKdWJ5SS9QandoUkU5RFZGbFFSU0J6ZG1jZ1VGVkNURWxESUNJdEx5OVhNME12TDBSVVJDQlRWa2NnTVM0eEx5OUZUaUlnSW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTDBkeVlYQm9hV056TDFOV1J5OHhMakV2UkZSRUwzTjJaekV4TG1SMFpDSStQSE4yWnlCMFBTSXhOakF5TXprMU5UVXpOalF3SWlCamJHRnpjejBpYVdOdmJpSWdkbWxsZDBKdmVEMGlNQ0F3SURFd01qUWdNVEF5TkNJZ2RtVnljMmx2YmowaU1TNHhJaUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSEF0YVdROUlqSTBNRGtpSUhodGJHNXpPbmhzYVc1clBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1TDNoc2FXNXJJaUIzYVdSMGFEMGlNakF3SWlCb1pXbG5hSFE5SWpJd01DSStQR1JsWm5NK1BITjBlV3hsSUhSNWNHVTlJblJsZUhRdlkzTnpJajQ4TDNOMGVXeGxQand2WkdWbWN6NDhjR0YwYUNCa1BTSk5PRE15TGpFZ05Ua3lMamRqTFRFeElEQXRNakFnT1MweU1DQXlNSFl4TlRFdU1tTXdJREV4TFRrZ01qQXRNakFnTWpCSU1qTXhMamxqTFRFeElEQXRNakF0T1MweU1DMHlNRlkyTVRJdU4yTXdMVEV4TFRrdE1qQXRNakF0TWpCekxUSXdJRGt0TWpBZ01qQjJNVFV4TGpKak1DQXpNeTR4SURJMkxqa2dOakFnTmpBZ05qQklOemt5WXpNekxqRWdNQ0EyTUMweU5pNDVJRFl3TFRZd1ZqWXhNaTQzWXpBdU1TMHhNUzA0TGprdE1qQXRNVGt1T1MweU1Ib2lJSEF0YVdROUlqSTBNVEFpUGp3dmNHRjBhRDQ4Y0dGMGFDQmtQU0pOTkRZNExqTWdOalU0TGpaak1URXVNeUF4TVM0NUlESTNMaklnTVRndU55QTBNeTQySURFNExqY2dNVFl1TkNBd0lETXlMak10Tmk0NElEUXpMall0TVRndU9HdzVPUzR4TFRFd05DNDNZemN1TmkwNElEY3VNaTB5TUM0M0xUQXVPQzB5T0M0ekxUZ3ROeTQyTFRJd0xqY3ROeTR5TFRJNExqTWdNQzQ0YkMwNU15NDJJRGs0TGpsV01qSXdZekF0TVRFdE9TMHlNQzB5TUMweU1ITXRNakFnT1MweU1DQXlNSFkwTURVdU1td3RPVE11TkMwNU9DNDJZeTAzTGpZdE9DMHlNQzR6TFRndU5DMHlPQzR6TFRBdU9DMDRJRGN1TmkwNExqUWdNakF1TXkwd0xqZ2dNamd1TTJ3NU9DNDVJREV3TkM0MWVpSWdjQzFwWkQwaU1qUXhNU0krUEM5d1lYUm9Qand2YzNablBnPT1cXFwiIGhlaWdodD1cXFwiMjBcXFwiIGFsdD1cXFwiXFxcIiBkcmFnZ2FibGU9XFxcImZhbHNlXFxcIj5cXG5cXHRcXHRcXHQ8L3NwYW4+XFxuXFx0XFx0XFx0PHNwYW4gY2xhc3M9XFxcImpzb25cXFwiIEBjbGljaz1cXFwianNTaG93XFxcIj5cXG5cXHRcXHRcXHRcXHQ8aW1nIHNyYz1cXFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJ6ZEdGdVpHRnNiMjVsUFNKdWJ5SS9QandoUkU5RFZGbFFSU0J6ZG1jZ1VGVkNURWxESUNJdEx5OVhNME12TDBSVVJDQlRWa2NnTVM0eEx5OUZUaUlnSW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTDBkeVlYQm9hV056TDFOV1J5OHhMakV2UkZSRUwzTjJaekV4TG1SMFpDSStQSE4yWnlCMFBTSXhOakF6TXpneU56Z3pNelkxSWlCamJHRnpjejBpYVdOdmJpSWdkbWxsZDBKdmVEMGlNQ0F3SURFd01qUWdNVEF5TkNJZ2RtVnljMmx2YmowaU1TNHhJaUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSEF0YVdROUlqSTNNamdpSUhodGJHNXpPbmhzYVc1clBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1TDNoc2FXNXJJaUIzYVdSMGFEMGlNakF3SWlCb1pXbG5hSFE5SWpJd01DSStQR1JsWm5NK1BITjBlV3hsSUhSNWNHVTlJblJsZUhRdlkzTnpJajQ4TDNOMGVXeGxQand2WkdWbWN6NDhjR0YwYUNCa1BTSk5NakUyTGpRZ01UQTNMakZvTlRBdU1tTTFMamNnTUNBeE1DNDBJRFF1TnlBeE1DNDBJREV3TGpSV01UVTJZekFnTlM0M0xUUXVOeUF4TUM0MExURXdMalFnTVRBdU5HZ3RORFV1T0dNdE5TNDNJREF0TVRNdU5DQTBMall0TVRNdU5DQXhNQzQwYkMweElESTBOaTQyWXkweExqTWdNelV1TWkweU5TNHhJRGt3TFRVNExqWWdPVEV1TkNBeU15NHlMVEVnTlRrdU5pQXpPUzQxSURVNUxqWWdPRGt1Tkd3dE1TQXlOREl1TkdNd0lEVXVPQ0EwTGpjZ01Ua3VOaUF4TUM0MklERTVMalpvTkRrdU0yTTFMamtnTUNBeE1DNDRJRFl1T0NBeE1DNDRJREV5TGpoMk16QXVPV013SURVdU9TMDBMamdnTVRBdU9DMHhNQzQ0SURFd0xqaG9MVFE1TGpoakxUTXlMalF0TVRJdU1pMDJNQzQyTFRRd0xqY3ROakF1TmkwNU1DNDBkaTB4T0RGak1DMDBPUzQ1TFRJM0xqRXRPVEF1TkMwMk1DNDJMVGt3TGpSSU56Y3VNV010Tmk0NElEQXRNVEl1TWkwMUxqVXRNVEl1TWkweE1pNHlkaTAyTlM0NVl6QXROaTQ0SURVdU5TMHhNaTR5SURFeUxqSXRNVEl1TW1neE9DNHhZek16TGpVZ01DQTJNQzQyTFRRd0xqVWdOakF1TmkwNU1DNDBWakU1Tnk0MFl6QXRORGt1T1NBeU55NHhMVGt3TGpNZ05qQXVOaTA1TUM0elRUZ3dPQzQySURFd055NHhZek16TGpVZ01DQTJNQzQySURRd0xqUWdOakF1TmlBNU1DNHpkakU0TUM0NFl6QWdORGt1T1NBeU55NHhJRGt3TGpRZ05qQXVOaUE1TUM0MGFERTRMakZqTmk0M0lEQWdNVEl1TWlBMUxqUWdNVEl1TWlBeE1pNHlkalkxTGpsak1DQTJMamN0TlM0MElERXlMakl0TVRJdU1pQXhNaTR5YUMweE9DNHlZeTB6TXk0MUlEQXROakF1TmlBME1DNDFMVFl3TGpZZ09UQXVOSFl4T0RGak1DQTBPUzQzTFRJNExqSWdOemd1TWkwMk1DNDJJRGt3TGpSb0xUUTVMamhqTFRZZ01DMHhNQzQ0TFRRdU9TMHhNQzQ0TFRFd0xqaFdPRGM1WXpBdE5pQTBMamt0TVRJdU9DQXhNQzQ0TFRFeUxqaElPREE0WXpVdU9TQXdJREV3TGpZdE1UTXVPQ0F4TUM0MkxURTVMalpzTFRFdE1qUXlMalJqTUMwME9TNDVJRE0yTGpRdE9UQXVOQ0ExT1M0MkxUZzVMalF0TXpNdU5TMHhMalF0TlRjdU15MDFOaTR5TFRVNExqWXRPVEV1Tkd3dE1TMHlORFl1Tm1Nd0xUVXVPQzAzTGpjdE1UQXVOQzB4TXk0MExURXdMalJvTFRRMUxqaGpMVFV1TnlBd0xURXdMalF0TkM0M0xURXdMalF0TVRBdU5IWXRNemd1TldNd0xUVXVOeUEwTGpjdE1UQXVOQ0F4TUM0MExURXdMalJvTlRBdU1rMDFNRGd1TkNBMk5qY3VPR014Tmk0NElEQWdNekF1TkNBeE15NDJJRE13TGpRZ016QXVOQ0F3SURFMkxqZ3RNVE11TmlBek1DNDBMVE13TGpRZ016QXVOQzB4Tmk0NElEQXRNekF1TkMweE15NDJMVE13TGpRdE16QXVOQ0F3TFRFMkxqZ2dNVE11Tmkwek1DNDBJRE13TGpRdE16QXVORTB6T0RZdU9DQTJOamN1T0dNeE5pNDRJREFnTXpBdU5DQXhNeTQySURNd0xqUWdNekF1TkNBd0lERTJMamd0TVRNdU5pQXpNQzQwTFRNd0xqUWdNekF1TkMweE5pNDRJREF0TXpBdU5DMHhNeTQyTFRNd0xqUXRNekF1TkNBd0xURTJMamdnTVRNdU5pMHpNQzQwSURNd0xqUXRNekF1TkUwMk16QWdOalkzTGpoak1UWXVPQ0F3SURNd0xqUWdNVE11TmlBek1DNDBJRE13TGpRZ01DQXhOaTQ0TFRFekxqWWdNekF1TkMwek1DNDBJRE13TGpRdE1UWXVPQ0F3TFRNd0xqUXRNVE11Tmkwek1DNDBMVE13TGpRZ01DMHhOaTQ0SURFekxqWXRNekF1TkNBek1DNDBMVE13TGpSNklpQndMV2xrUFNJeU56STVJajQ4TDNCaGRHZytQQzl6ZG1jK1xcXCJcXG5cXHRcXHRcXHRcXHRoZWlnaHQ9XFxcIjIwXFxcIiBhbHQ9XFxcIlxcXCIgZHJhZ2dhYmxlPVxcXCJmYWxzZVxcXCI+XFxuXFxuXFx0XFx0XFx0PC9zcGFuPlxcblxcblxcblxcdFxcdDwvZGl2PlxcblxcdFxcdDxkaXYgaWQ9XFxcInFjYW52YXNfbGF5XFxcIiB2LWJpbmQ6c3R5bGU9XFxcInsnaGVpZ2h0Jzppbml0SGVpZ2h0KydweCd9XFxcIj5cXG5cXHRcXHRcXHQ8Y2FudmFzIGlkPVxcXCJxY2FudmFzXFxcIj48L2NhbnZhcz5cXG5cXHRcXHRcXHQ8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgaWQ9XFxcInRpdGxlSW5wdXRcXFwiIHYtbW9kZWw9XFxcIm5vZGVUaXRsZVxcXCIgQGlucHV0PVxcXCJtb2RpVGl0bGVcXFwiIGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIiBAa2V5dXAuZW50ZXI9XFxcIm9uU3VibWl0XFxcIj5cXG5cXHRcXHRcXHQ8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgaWQ9XFxcImNvbnRhaW5lckdyaWRDb2x1bW5cXFwiIHYtbW9kZWwubnVtYmVyPVxcXCJjb250YWluZXJHcmlkQ29sdW1uXFxcIiBAaW5wdXQ9XFxcIm1vZGlDb250YWluZXJHcmlkQ29sdW1uXFxcIiBhdXRvY29tcGxldGU9XFxcIm9mZlxcXCI+XFxuXFx0XFx0XFx0PHRleHRhcmVhIG5hbWU9XFxcIlxcXCIgaWQ9XFxcInRpcFxcXCIgdi1tb2RlbD1cXFwidGlwVGV4dFxcXCIgQGlucHV0PVxcXCJtb2RUaXAoJGV2ZW50KVxcXCI+PC90ZXh0YXJlYT5cXG5cXG5cXHRcXHRcXHQ8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgaWQ9XFxcImxpbmVUaXRsZUlucHV0XFxcIiB2LW1vZGVsPVxcXCJsaW5lTm9kZVRpdGxlXFxcIiBAaW5wdXQ9XFxcIm1vZGlMaW5lVGl0bGVcXFwiIGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIj5cXG5cXHRcXHRcXHQ8c2VsZWN0IGlkPVxcXCJsaW5lTGlrZVxcXCIgdi1tb2RlbD1cXFwibGluZUxpa2VcXFwiIEBjaGFuZ2U9XFxcIm1vZGlMaW5lTGlrZVxcXCIgYXV0b2NvbXBsZXRlPVxcXCJvZmZcXFwiPlxcblxcdFxcdFxcdFxcdDxvcHRpb24gdi1mb3I9XFxcIml0ZW0gaW4gbGluZVN0eWxlTGlzdFxcXCIgOnZhbHVlPVxcXCJpdGVtLnZhbHVlXFxcIj57e2l0ZW0ubmFtZX19PC9vcHRpb24+IFxcblxcdFxcdFxcdDwvc2VsZWN0PlxcblxcdFxcdFxcdDxzZWxlY3QgaWQ9XFxcImxpbmVUeXBlXFxcIiB2LW1vZGVsPVxcXCJsaW5lVHlwZVxcXCIgQGNoYW5nZT1cXFwibW9kaUxpbmVUeXBlXFxcIiBhdXRvY29tcGxldGU9XFxcIm9mZlxcXCI+XFxuXFx0XFx0XFx0XFx0PG9wdGlvbiB2LWZvcj1cXFwiaXRlbSBpbiBsaW5lVHlwZUxpc3RcXFwiIDp2YWx1ZT1cXFwiaXRlbS52YWx1ZVxcXCI+e3tpdGVtLm5hbWV9fTwvb3B0aW9uPiBcXG5cXHRcXHRcXHQ8L3NlbGVjdD5cXG5cXG5cXHRcXHRcXHQ8IS0tIDxkaXYgY2xhc3M9XFxcInNoZWV0TGF5XFxcIj5cXG5cXHRcXHRcXHRcXHQ8c3BhbiB2LWZvcj1cXFwiaXRlbSBpbiBzaGVldHNcXFwiPnt7aXRlbS5uYW1lfX08L3NwYW4+XFxuXFx0XFx0XFx0PC9kaXY+IC0tPlxcblxcdFxcdDwvZGl2PlxcblxcblxcdFxcdDxlbC1kaWFsb2dcXG5cXHRcXHQgICAgdGl0bGU9XFxcImpzb27mlbDmja5cXFwiXFxuXFx0XFx0ICAgIDp2aXNpYmxlLnN5bmM9XFxcInNob3dcXFwiXFxuXFx0XFx0ICAgIHdpZHRoPVxcXCIzMCVcXFwiXFxuXFx0XFx0ICAgIEBjbG9zZT1cXFwiY2xvc2VcXFwiPlxcblxcdFxcdCAgICA8ZGl2IGNsYXNzPVxcXCJqc29uX2xheVxcXCI+XFxuXFx0XFx0ICAgIFxcdHt7anNvbn19XFxuXFx0XFx0ICAgIDwvZGl2PlxcblxcdFxcdCAgICBcXG5cXHRcXHQ8L2VsLWRpYWxvZz5cXG5cXHQ8L2Rpdj5cXG48L3RlbXBsYXRlPlxcbjxzY3JpcHQ+IFxcbmltcG9ydCBWdWUgZnJvbSAndnVlJztcXG5cXG5cXHRpbXBvcnQge0RpYWxvZ30gZnJvbSAnZWxlbWVudC11aSdcXG5cXHRWdWUudXNlKERpYWxvZyk7XFxuXFx0aW1wb3J0IHtEcmFnfSBmcm9tICcuL2xpYi9EcmFnLmpzJzsgXFxuXFx0aW1wb3J0IHtRZmxvd30gZnJvbSAnLi9saWIvUWZsb3cuanMnO1xcblxcblxcblxcdHZhciBxZmxvdztcXG5cXG5cXHRleHBvcnQgZGVmYXVsdHtcXG5cXHRcXHRuYW1lOlxcXCJxcmVsYXRpb25cXFwiLFxcblxcdFxcdGNvbXBvbmVudHM6e30sXFxuXFx0XFx0cHJvcHM6Wydpbml0V2lkdGgnLCdpbml0SGVpZ2h0JywnanNvbkRhdGEnLCdzYXZlRnVuJ10sXFxuXFx0XFx0ZGF0YSgpe1xcblxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0ICBcXHRjdXJyOjAsXFxuXFx0XFx0XFx0ICBcXHRzaGVldHM6W1xcblxcdFxcdFxcdCAgXFx0XFx0e1xcblxcdFxcdFxcdCAgXFx0XFx0XFx0bmFtZTonc2hlZXQxJyxcXG5cXHRcXHRcXHQgIFxcdFxcdH1cXG5cXHRcXHRcXHQgIFxcdF0sXFxuXFx0ICBcXHRcXHRcXHRub2RlVGl0bGU6JycsXFxuXFx0ICBcXHRcXHRcXHRsaW5lTm9kZVRpdGxlOifmoIfpopgnLFxcblxcdCAgXFx0XFx0XFx0bGluZVR5cGU6JycsXFxuXFx0ICBcXHRcXHRcXHRsaW5lVHlwZUxpc3Q6W1xcblxcdCAgXFx0XFx0XFx0XFx0e1xcblxcdFxcdCAgXFx0XFx0XFx0XFx0bmFtZTon55u057q/JyxcXG5cXHRcXHQgIFxcdFxcdFxcdFxcdHZhbHVlOidsaW5lJ1xcblxcdCAgXFx0XFx0XFx0XFx0fSxcXG5cXHQgIFxcdFxcdFxcdFxcdHtcXG5cXHRcXHQgIFxcdFxcdFxcdFxcdG5hbWU6J+S6jOasoeabsue6vycsXFxuXFx0XFx0ICBcXHRcXHRcXHRcXHR2YWx1ZToncXVhZHJhdGljQ3VydmUnXFxuXFx0ICBcXHRcXHRcXHRcXHR9LFxcblxcdCAgXFx0XFx0XFx0XFx0e1xcblxcdFxcdCAgXFx0XFx0XFx0XFx0bmFtZTon5LiJ5qyh5puy57q/JyxcXG5cXHRcXHQgIFxcdFxcdFxcdFxcdHZhbHVlOidiZXppZXJDdXJ2ZSdcXG5cXHQgIFxcdFxcdFxcdFxcdH0sXFxuXFx0ICBcXHRcXHRcXHRcXHR7XFxuXFx0XFx0ICBcXHRcXHRcXHRcXHRuYW1lOifmipjnur8o5qiq5ZCRKScsXFxuXFx0XFx0ICBcXHRcXHRcXHRcXHR2YWx1ZTonZm9sZExpbmUxJ1xcblxcdCAgXFx0XFx0XFx0XFx0fSxcXG5cXHQgIFxcdFxcdFxcdFxcdHtcXG5cXHRcXHQgIFxcdFxcdFxcdFxcdG5hbWU6J+aKmOe6vyjnq5blkJEpJyxcXG5cXHRcXHQgIFxcdFxcdFxcdFxcdHZhbHVlOidmb2xkTGluZTInXFxuXFx0ICBcXHRcXHRcXHRcXHR9XFxuXFx0ICBcXHRcXHRcXHRdLFxcblxcdCAgXFx0XFx0XFx0bGluZUxpa2U6JycsXFxuXFx0ICBcXHRcXHRcXHRsaW5lU3R5bGVMaXN0OltcXG5cXHQgIFxcdFxcdFxcdFxcdHtcXG5cXHQgIFxcdFxcdFxcdFxcdFxcdG5hbWU6Jy0nLFxcblxcdCAgXFx0XFx0XFx0XFx0XFx0dmFsdWU6Jy0nXFxuXFx0ICBcXHRcXHRcXHRcXHR9LFxcblxcdCAgXFx0XFx0XFx0XFx0e1xcblxcdCAgXFx0XFx0XFx0XFx0XFx0bmFtZTonLT4nLFxcblxcdCAgXFx0XFx0XFx0XFx0XFx0dmFsdWU6Jy0+J1xcblxcdCAgXFx0XFx0XFx0XFx0fSxcXG5cXHQgIFxcdFxcdFxcdFxcdHtcXG5cXHQgIFxcdFxcdFxcdFxcdFxcdG5hbWU6JzwtJyxcXG5cXHQgIFxcdFxcdFxcdFxcdFxcdHZhbHVlOic8LSdcXG5cXHQgIFxcdFxcdFxcdFxcdH0sXFxuXFx0ICBcXHRcXHRcXHRcXHR7XFxuXFx0ICBcXHRcXHRcXHRcXHRcXHRuYW1lOic8LT4nLFxcblxcdCAgXFx0XFx0XFx0XFx0XFx0dmFsdWU6JzwtPidcXG5cXHQgIFxcdFxcdFxcdFxcdH0sXFxuXFx0ICBcXHRcXHRcXHRcXHR7XFxuXFx0ICBcXHRcXHRcXHRcXHRcXHRuYW1lOictLScsXFxuXFx0ICBcXHRcXHRcXHRcXHRcXHR2YWx1ZTonLS0nXFxuXFx0ICBcXHRcXHRcXHRcXHR9LFxcblxcdCAgXFx0XFx0XFx0XFx0e1xcblxcdCAgXFx0XFx0XFx0XFx0XFx0bmFtZTonPC0tJyxcXG5cXHQgIFxcdFxcdFxcdFxcdFxcdHZhbHVlOic8LS0nXFxuXFx0ICBcXHRcXHRcXHRcXHR9LFxcblxcdCAgXFx0XFx0XFx0XFx0e1xcblxcdCAgXFx0XFx0XFx0XFx0XFx0bmFtZTonLS0+JyxcXG5cXHQgIFxcdFxcdFxcdFxcdFxcdHZhbHVlOictLT4nXFxuXFx0ICBcXHRcXHRcXHRcXHR9LFxcblxcdCAgXFx0XFx0XFx0XFx0e1xcblxcdCAgXFx0XFx0XFx0XFx0XFx0bmFtZTonPC0tPicsXFxuXFx0ICBcXHRcXHRcXHRcXHRcXHR2YWx1ZTonPC0tPidcXG5cXHQgIFxcdFxcdFxcdFxcdH0sXFxuXFx0ICBcXHRcXHRcXHRdLFxcblxcdCAgXFx0XFx0XFx0Y29udGFpbmVyR3JpZENvbHVtbjoxLFxcblxcdCAgXFx0XFx0XFx0c2hvdzpmYWxzZSxcXG5cXHQgIFxcdFxcdFxcdGpzb246JycsXFxuXFx0ICBcXHRcXHRcXHR0aXBUZXh0OicnXFxuXFxuXFx0XFx0ICB9XFxuXFx0XFx0fSxcXG5cXHRcXHRtZXRob2RzOntcXG5cXHRcXHRcXHRvblN1Ym1pdDpmdW5jdGlvbigpe1xcblxcdFxcdCAgXFx0XFx0cWZsb3cuY29udGV4dFNldHRpbmdIaWRlKCk7XFxuXFx0XFx0ICBcXHR9LFxcblxcdFxcdFxcdGpzU2hvdzpmdW5jdGlvbigpe1xcblxcdFxcdFxcdFxcdHRoaXMuanNvbiA9IEpTT04uc3RyaW5naWZ5KHFmbG93LnJldHVyblNhdmVEYXRhKCkpO1xcblxcdFxcdFxcdFxcdHRoaXMuc2hvdyA9IHRydWU7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRjbG9zZTpmdW5jdGlvbigpe1xcblxcdFxcdFxcdFxcdHRoaXMuc2hvdyA9IGZhbHNlXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRkb3dubG9hZDpmdW5jdGlvbigpe1xcblxcdFxcdCAgXFx0XFx0cWZsb3cuZG93bmxvYWQoKTtcXG5cXHRcXHQgIFxcdH0sXFxuXFx0XFx0XFx0c2F2ZTpmdW5jdGlvbigpeyBcXG5cXG5cXHRcXHQgIFxcdFxcdHRoaXMuc2F2ZUZ1biAmJiB0aGlzLnNhdmVGdW4ocWZsb3cucmV0dXJuU2F2ZURhdGEoKSk7XFxuXFx0XFx0ICBcXHR9LFxcdFxcblxcdFxcdCAgXFx0bW9kaVRpdGxlOmZ1bmN0aW9uKCl7XFxuXFx0XFx0ICBcXHRcXHRxZmxvdy5tb2RpVGl0bGUodGhpcy5ub2RlVGl0bGUpO1xcblxcdFxcdCAgXFx0fSxcXG5cXHRcXHQgIFxcdG1vZGlMaW5lVGl0bGU6ZnVuY3Rpb24oKXtcXG5cXHRcXHQgIFxcdFxcdHFmbG93Lm1vZGlMaW5lVGl0bGUodGhpcy5saW5lTm9kZVRpdGxlKTtcXG5cXHRcXHQgIFxcdH0sXFxuXFx0XFx0ICBcXHRtb2RpTGluZUxpa2U6ZnVuY3Rpb24oKXtcXG5cXHRcXHQgIFxcdFxcdHFmbG93Lm1vZGlMaW5lTGlrZSh0aGlzLmxpbmVMaWtlKTtcXG5cXHRcXHQgIFxcdH0sXFxuXFx0XFx0ICBcXHRtb2RpTGluZVR5cGU6ZnVuY3Rpb24oKXtcXG5cXG5cXHRcXHQgIFxcdFxcdHFmbG93Lm1vZGlMaW5lVHlwZSh0aGlzLmxpbmVUeXBlKTtcXG5cXHRcXHQgIFxcdH0sXFxuXFx0XFx0ICBcXHRtb2RUaXA6ZnVuY3Rpb24oZSl7XFxuXFx0XFx0ICBcXHRcXHR2YXIgZWxlbSA9IGUudGFyZ2V0O1xcblxcdFxcdCAgXFx0XFx0ZWxlbS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XFxuXFx0ICAgICAgICAgICAgZWxlbS5zY3JvbGxUb3AgPSAwOyAvL+mYsuaKluWKqFxcblxcdCAgICAgICAgICAgIGVsZW0uc3R5bGUuaGVpZ2h0ID0gZWxlbS5zY3JvbGxIZWlnaHQgKyAncHgnOyBcXG5cXG5cXHQgICAgICAgICAgICBxZmxvdy51cGRhdGVUaXBUZXh0KGVsZW0udmFsdWUscGFyc2VJbnQoZWxlbS5zdHlsZS5oZWlnaHQpKTtcXG5cXG5cXHRcXHQgIFxcdFxcdC8vIGNvbnNvbGUubG9nKHRoaXMudGlwVGV4dCk7XFxuXFx0XFx0ICBcXHRcXHQvLyB2YXIgdGlwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RpcCcpO1xcblxcdFxcdCAgXFx0XFx0Ly8gdGlwLnN0eWxlLmhlaWdodCA9IHRpcC5zY3JvbGxUb3AgKyB0aXAuc2Nyb2xsSGVpZ2h0ICsgXFxcInB4XFxcIjtcXG5cXG5cXHRcXHQgIFxcdFxcdC8vIHRoaXMudGlwVGV4dCA9IHRoaXMudGlwVGV4dC5yZXBsYWNlKC8gL2csICcnKTtcXG5cXG5cXHRcXHQgIFxcdFxcdC8vIC8vIHFmbG93LnVwZGF0ZVRpcFRleHQodGhpcy50aXBUZXh0LnJlcGxhY2UoL1xcXFxyXFxcXG4vZywgJ1xcXFxuJykscGFyc2VJbnQodGlwLnN0eWxlLmhlaWdodCkpO1xcblxcdFxcdCAgXFx0XFx0Ly8gcWZsb3cudXBkYXRlVGlwVGV4dCh0aGlzLnRpcFRleHQucmVwbGFjZSgvXFxcXHJcXFxcbi9nLCAnJykscGFyc2VJbnQodGlwLnN0eWxlLmhlaWdodCkpO1xcblxcblxcblxcdFxcdCAgXFx0fSxcXG5cXHRcXHQgIFxcdG1vZGlDb250YWluZXJHcmlkQ29sdW1uOmZ1bmN0aW9uKCl7XFxuXFxuXFx0XFx0ICBcXHRcXHRpZih0aGlzLmNvbnRhaW5lckdyaWRDb2x1bW4gPT0nJyB8fCBcXG5cXHRcXHQgIFxcdFxcdFxcdHRoaXMuY29udGFpbmVyR3JpZENvbHVtbiA9PTApe1xcblxcblxcdFxcdCAgXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdCAgXFx0XFx0fSBcXG5cXHRcXHRcXHQgIFxcdHFmbG93Lm1vZGlDb250YWluZXJHcmlkQ29sdW1uKHRoaXMuY29udGFpbmVyR3JpZENvbHVtbik7XFxuXFx0XFx0ICBcXHRcXHRcXG5cXG5cXHRcXHQgIFxcdH0sXFxuXFx0XFx0ICBcXHRpbml0OmZ1bmN0aW9uKCl7XFxuXFx0XFx0ICBcXHRcXHR2YXIgX3RoaXMgPSB0aGlzO1xcblxcdFxcdCAgXFx0XFx0cWZsb3cgPSBuZXcgUWZsb3coe1xcblxcdFxcdFxcdFxcdFxcdGlkOidxY2FudmFzJyxcXG5cXHRcXHRcXHRcXHRcXHR3aWR0aDpfdGhpcy5pbml0V2lkdGgsXFxuXFx0XFx0XFx0XFx0XFx0aGVpZ2h0Ol90aGlzLmluaXRIZWlnaHQsXFxuXFx0XFx0XFx0XFx0XFx0aW5pdERhdGE6X3RoaXMuanNvbkRhdGFbX3RoaXMuY3Vycl0sXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUWNhbnZhczpRY2FudmFzXFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0XFx0bmV3IERyYWcoeyBcXG5cXHRcXHRcXHQgICAgICAgICAgZHJhZ0FpbUNsYXNzOlxcXCJkcmFnX2VsZVxcXCIsXFxuXFx0XFx0XFx0ICAgICAgICAgIG1vdmVGdW46KHgseSk9PnsgXFxuXFx0XFx0XFx0ICAgICAgICAgIFxcdC8vIGNvbnNvbGUubG9nKHgseSk7XFxuXFx0XFx0XFx0ICAgICAgICAgIH0sXFxuXFx0XFx0XFx0ICAgICAgICAgIHVwRnVuOihvYmopPT57IFxcblxcdFxcdFxcdCAgICAgICAgICBcXHRpZihvYmoueSA+IDQwICYmIG9iai54PjApe1xcblxcblxcdFxcdFxcdCAgICAgICAgICBcXHRcXHQvL+i9rOaNouWIsOeUu+W4g+eahOWdkOagh1xcblxcdFxcdFxcdCAgICAgICAgICBcXHRcXHQvLyBvYmoueSArPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdxY2FudmFzX2xheScpLnNjcm9sbFRvcDtcXG5cXHRcXHRcXHQgICAgICAgICAgXFx0XFx0Ly8gb2JqLnggKz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncWNhbnZhc19sYXknKS5zY3JvbGxMZWZ0O1xcblxcblxcdFxcdFxcdFxcdCBcXHRcXHRcXHRxZmxvdy5hZGRFbGUob2JqKTtcXG5cXHRcXHRcXHQgICAgICAgICAgXFx0fVxcblxcblxcdFxcdFxcdCAgICAgICAgICB9XFxuXFx0XFx0XFx0ICAgICAgfSlcXG5cXHRcXHQgIFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcdFxcdG1vdW50ZWQoKXtcXG5cXHRcXHRcXHQvLyBjb25zb2xlLmxvZyhEcmFnKTtcXG5cXHRcXHRcXHQvLyBjb25zb2xlLmxvZyhRY2FudmFzKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmluaXQoKTtcXG5cXHRcXHR9LFxcblxcdFxcdGNyZWF0ZWQoKXtcXG5cXHRcXHRcXHRcXG5cXHRcXHR9LFxcblxcdFxcdGNvbXB1dGVkOntcXG5cXG5cXHRcXHR9LFxcblxcdFxcdHdhdGNoOntcXG5cXG5cXHRcXHR9LFxcblxcdFxcdC8vIOmUgOavgeebkeWQrOS6i+S7tlxcblxcdFxcdGRlc3Ryb3llZCgpIHtcXG5cXHRcXHQgIHFmbG93ICE9PSBudWxsICYgcWZsb3cuZGVzdHJveSgpO1xcblxcblxcdFxcdCAgcWZsb3cgPSBudWxsO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuPC9zY3JpcHQ+XFxuPHN0eWxlIHNjb3BlZD5cXG4uanNvbl9sYXl7XFxuXFx0ICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgIGhlaWdodDogMjAwcHg7XFxuICAgIG92ZXJmbG93OiBzY3JvbGw7XFxufVxcbiNxZmxvd19sYXl7IFxcblxcdFxcdFxcdHBvc2l0aW9uOiByZWxhdGl2ZTtcXG5cXHRcXHR9XFxuLmNsZWFyOmFmdGVye1xcblxcdFxcdFxcdGNvbnRlbnQ6IFxcXCJcXFwiO1xcblxcdFxcdFxcdGRpc3BsYXk6IGJsb2NrO1xcblxcdFxcdFxcdGNsZWFyOiBib3RoO1xcblxcdFxcdFxcdGZvbnQtc2l6ZTogMDtcXG5cXHRcXHRcXHRsaW5lLWhlaWdodDogMDtcXG5cXHRcXHR9XFxuXFx0XFx0Y2FudmFzeyBcXG5cXHRcXHRcXHRoZWlnaHQ6IDEwMCU7XFxuXFx0XFx0XFx0d2lkdGg6IDEwMCU7XFxuXFx0XFx0XFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlOREFpSUdobGFXZG9kRDBpTkRBaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BHUmxabk0rUEhCaGRIUmxjbTRnYVdROUltZHlhV1FpSUhkcFpIUm9QU0kwTUNJZ2FHVnBaMmgwUFNJME1DSWdjR0YwZEdWeWJsVnVhWFJ6UFNKMWMyVnlVM0JoWTJWUGJsVnpaU0krUEhCaGRHZ2daRDBpVFNBd0lERXdJRXdnTkRBZ01UQWdUU0F4TUNBd0lFd2dNVEFnTkRBZ1RTQXdJREl3SUV3Z05EQWdNakFnVFNBeU1DQXdJRXdnTWpBZ05EQWdUU0F3SURNd0lFd2dOREFnTXpBZ1RTQXpNQ0F3SUV3Z016QWdOREFpSUdacGJHdzlJbTV2Ym1VaUlITjBjbTlyWlQwaUkyUXdaREJrTUNJZ2IzQmhZMmwwZVQwaU1DNHlJaUJ6ZEhKdmEyVXRkMmxrZEdnOUlqRWlMejQ4Y0dGMGFDQmtQU0pOSURRd0lEQWdUQ0F3SURBZ01DQTBNQ0lnWm1sc2JEMGlibTl1WlNJZ2MzUnliMnRsUFNJalpEQmtNR1F3SWlCemRISnZhMlV0ZDJsa2RHZzlJakVpTHo0OEwzQmhkSFJsY200K1BDOWtaV1p6UGp4eVpXTjBJSGRwWkhSb1BTSXhNREFsSWlCb1pXbG5hSFE5SWpFd01DVWlJR1pwYkd3OUluVnliQ2dqWjNKcFpDa2lMejQ4TDNOMlp6ND1cXFwiKTtcXG5cXG5cXHRcXHR9XFxuXFx0XFx0LnRvb2x7XFxuXFx0XFx0XFx0aGVpZ2h0OiA0MHB4O1xcblxcdFxcdFxcdHBvc2l0aW9uOiByZWxhdGl2ZTtcXG5cXHRcXHRcXHR6LWluZGV4OiAxO1xcblxcdFxcdFxcdGxpbmUtaGVpZ2h0OiA0MHB4O1xcblxcdFxcdFxcdGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuXFxuXFx0XFx0fVxcblxcdFxcdC50b29sIHNwYW57XFxuXFx0XFx0XFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xcblxcdFxcdFxcdHdpZHRoOiAzMHB4O1xcblxcdFxcdFxcdGhlaWdodDogMzBweDtcXG5cXHRcXHRcXHR0ZXh0LWFsaWduOiBjZW50ZXI7XFxuXFx0XFx0XFx0bWFyZ2luLXRvcDo1cHg7XFxuXFx0XFx0XFx0bWFyZ2luLWxlZnQ6MTBweDtcXG5cXHRcXHR9IFxcblxcdFxcdC50b29sIHNwYW4gaW1ne1xcblxcdFxcdFxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcblxcdFxcdH1cXG5cXG5cXG5cXHRcXHQjcWNhbnZhc19sYXl7XFxuXFx0XFx0XFx0cG9zaXRpb246IGFic29sdXRlO1xcblxcdFxcdFxcdHRvcDowO1xcblxcdFxcdFxcdGxlZnQ6MDtcXG5cXHRcXHRcXHR3aWR0aDogMTAwJTtcXG5cXHRcXHRcXHRib3R0b206IDA7XFxuXFx0XFx0XFx0b3ZlcmZsb3c6c2Nyb2xsO1xcblxcdFxcdH1cXG5cXHRcXHQuc2hlZXRMYXl7XFxuXFx0XFx0XFx0Zm9udC1zaXplOiAxMnB4O1xcblxcdFxcdFxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5cXHRcXHRcXHRib3R0b206IDA7XFxuXFx0XFx0XFx0bGVmdDowO1xcblxcdFxcdFxcdGJhY2tncm91bmQ6ICNmZmY7XFxuXFxuXFx0XFx0fVxcblxcdFxcdC5qc29uLFxcblxcdFxcdC5zYXZlLFxcblxcdFxcdC5kb3dubG9hZHtcXG5cXHRcXHRcXHRmbG9hdDogcmlnaHQ7XFxuXFx0XFx0XFx0Zm9udC1zaXplOiAxMnB4O1xcblxcdFxcdH1cXG5cXHRcXHQjdGl0bGVJbnB1dHtcXG5cXHRcXHRcXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0XFx0XFx0bGVmdDowO1xcblxcdFxcdFxcdHRvcDowO1xcblxcdFxcdFxcdHBhZGRpbmc6IDA7XFxuXFx0XFx0XFx0bWFyZ2luOjA7XFxuXFx0XFx0XFx0Ym9yZGVyOm5vbmU7IFxcblxcdFxcdFxcdGZvbnQtc2l6ZTogMTJweDtcXG5cXHRcXHRcXHRmb250LWZhbWlseTonTWljcm9zb2Z0IFlhSGVpJztcXG5cXHRcXHRcXHRvdXRsaW5lOiBub25lO1xcblxcdFxcdFxcdGJhY2tncm91bmQ6ICNGREY4RTE7XFxuXFx0XFx0fVxcblxcdFxcdCNsaW5lVGl0bGVJbnB1dCxcXG5cXHRcXHQjY29udGFpbmVyR3JpZENvbHVtbixcXG5cXHRcXHQjbGluZUxpa2UsXFxuXFx0XFx0I2xpbmVUeXBle1xcblxcdFxcdFxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5cXHRcXHRcXHRsZWZ0OjA7XFxuXFx0XFx0XFx0dG9wOjA7XFxuXFx0XFx0XFx0cGFkZGluZzogMDtcXG5cXHRcXHRcXHRtYXJnaW46MDtcXG5cXHRcXHRcXHRib3JkZXI6bm9uZTtcXG5cXHRcXHRcXHR0ZXh0LWluZGVudDogNXB4O1xcblxcdFxcdFxcdGZvbnQtc2l6ZTogMTJweDtcXG5cXHRcXHR9XFxuI3RpcHtcXG5cXHRcXHRcXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0XFx0ICAgIHotaW5kZXg6IDE7XFxuXFx0XFx0ICAgIHBhZGRpbmc6MDtcXG5cXHRcXHQgICAgbWFyZ2luOjA7XFxuXFx0XFx0ICAgIG91dGxpbmU6IG5vbmU7XFxuXFx0XFx0ICAgIGRpc3BsYXk6IG5vbmU7XFxuXFx0XFx0ICAgIGZvbnQtZmFtaWx5OidNaWNyb3NvZnQgWWFIZWknO1xcblxcdFxcdCAgICAvKiBmb250LWZhbWlseTogJ0FyaWFsJzsgKi9cXG5cXHRcXHRcXHR3b3JkLWJyZWFrOiBicmVhay1hbGw7XFxuXFx0XFx0ICAgIGJvcmRlcjp0cmFuc3BhcmVudDtcXG5cXHRcXHQgICAgb3ZlcmZsb3c6IGhpZGRlbjsgXFxuXFx0XFx0ICAgIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsMCk7XFxuXFx0XFx0ICAgIHJlc2l6ZTpub25lO1xcblxcdFxcdCAgICAvKnBvaW50ZXItZXZlbnRzOiBub25lOyovXFxuXFx0XFx0fVxcbjwvc3R5bGU+XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTdlMDBlZjY0XCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvcXJlbGF0aW9uLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

eval("/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzP2I1MzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3QkFBd0I7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAocGFyZW50SWQsIGxpc3QpIHtcbiAgdmFyIHN0eWxlcyA9IFtdXG4gIHZhciBuZXdTdHlsZXMgPSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICB2YXIgaWQgPSBpdGVtWzBdXG4gICAgdmFyIGNzcyA9IGl0ZW1bMV1cbiAgICB2YXIgbWVkaWEgPSBpdGVtWzJdXG4gICAgdmFyIHNvdXJjZU1hcCA9IGl0ZW1bM11cbiAgICB2YXIgcGFydCA9IHtcbiAgICAgIGlkOiBwYXJlbnRJZCArICc6JyArIGksXG4gICAgICBjc3M6IGNzcyxcbiAgICAgIG1lZGlhOiBtZWRpYSxcbiAgICAgIHNvdXJjZU1hcDogc291cmNlTWFwXG4gICAgfVxuICAgIGlmICghbmV3U3R5bGVzW2lkXSkge1xuICAgICAgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHsgaWQ6IGlkLCBwYXJ0czogW3BhcnRdIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVzXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

eval("/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file.\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanM/NTU0ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgcmF3U2NyaXB0RXhwb3J0cyxcbiAgY29tcGlsZWRUZW1wbGF0ZSxcbiAgZnVuY3Rpb25hbFRlbXBsYXRlLFxuICBpbmplY3RTdHlsZXMsXG4gIHNjb3BlSWQsXG4gIG1vZHVsZUlkZW50aWZpZXIgLyogc2VydmVyIG9ubHkgKi9cbikge1xuICB2YXIgZXNNb2R1bGVcbiAgdmFyIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyB8fCB7fVxuXG4gIC8vIEVTNiBtb2R1bGVzIGludGVyb3BcbiAgdmFyIHR5cGUgPSB0eXBlb2YgcmF3U2NyaXB0RXhwb3J0cy5kZWZhdWx0XG4gIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXNNb2R1bGUgPSByYXdTY3JpcHRFeHBvcnRzXG4gICAgc2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICB9XG5cbiAgLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcFxuICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nXG4gICAgPyBzY3JpcHRFeHBvcnRzLm9wdGlvbnNcbiAgICA6IHNjcmlwdEV4cG9ydHNcblxuICAvLyByZW5kZXIgZnVuY3Rpb25zXG4gIGlmIChjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBjb21waWxlZFRlbXBsYXRlLnJlbmRlclxuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWRUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9IHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIHZhciBmdW5jdGlvbmFsID0gb3B0aW9ucy5mdW5jdGlvbmFsXG4gICAgdmFyIGV4aXN0aW5nID0gZnVuY3Rpb25hbFxuICAgICAgPyBvcHRpb25zLnJlbmRlclxuICAgICAgOiBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuXG4gICAgaWYgKCFmdW5jdGlvbmFsKSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yIHRlbXBsYXRlLW9ubHkgaG90LXJlbG9hZCBiZWNhdXNlIGluIHRoYXQgY2FzZSB0aGUgcmVuZGVyIGZuIGRvZXNuJ3RcbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIG5vcm1hbGl6ZXJcbiAgICAgIG9wdGlvbnMuX2luamVjdFN0eWxlcyA9IGhvb2tcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlc01vZHVsZTogZXNNb2R1bGUsXG4gICAgZXhwb3J0czogc2NyaXB0RXhwb3J0cyxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(16);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(2)(\"71f13851\", content, false, {});\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../../../css-loader/index.js!./dialog.css\", function() {\n     var newContent = require(\"!!../../../css-loader/index.js!./dialog.css\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdGhlbWUtY2hhbGsvZGlhbG9nLmNzcz8yM2QwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLEVBQTZDO0FBQ25FLDRDQUE0QyxRQUFTO0FBQ3JEO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsQ0FBbUQsZ0NBQWdDO0FBQ3hHO0FBQ0EsR0FBRyxLQUFVO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9kaWFsb2cuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjcxZjEzODUxXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vZGlhbG9nLmNzc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vZGlhbG9nLmNzc1wiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdGhlbWUtY2hhbGsvZGlhbG9nLmNzc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(1)(false);\n// imports\n\n\n// module\nexports.push([module.i, \".v-modal-enter{-webkit-animation:v-modal-in .2s ease;animation:v-modal-in .2s ease}.v-modal-leave{-webkit-animation:v-modal-out .2s ease forwards;animation:v-modal-out .2s ease forwards}@-webkit-keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-in{0%{opacity:0}}@-webkit-keyframes v-modal-out{100%{opacity:0}}@keyframes v-modal-out{100%{opacity:0}}.v-modal{position:fixed;left:0;top:0;width:100%;height:100%;opacity:.5;background:#000}.el-popup-parent--hidden{overflow:hidden}.el-dialog{position:relative;margin:0 auto 50px;background:#FFF;border-radius:2px;-webkit-box-shadow:0 1px 3px rgba(0,0,0,.3);box-shadow:0 1px 3px rgba(0,0,0,.3);-webkit-box-sizing:border-box;box-sizing:border-box;width:50%}.el-dialog.is-fullscreen{width:100%;margin-top:0;margin-bottom:0;height:100%;overflow:auto}.el-dialog__wrapper{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto;margin:0}.el-dialog__header{padding:20px 20px 10px}.el-dialog__headerbtn{position:absolute;top:20px;right:20px;padding:0;background:0 0;border:none;outline:0;cursor:pointer;font-size:16px}.el-dialog__headerbtn .el-dialog__close{color:#909399}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:#409EFF}.el-dialog__title{line-height:24px;font-size:18px;color:#303133}.el-dialog__body{padding:30px 20px;color:#606266;font-size:14px;word-break:break-all}.el-dialog__footer{padding:10px 20px 20px;text-align:right;-webkit-box-sizing:border-box;box-sizing:border-box}.el-dialog--center{text-align:center}.el-dialog--center .el-dialog__body{text-align:initial;padding:25px 25px 30px}.el-dialog--center .el-dialog__footer{text-align:inherit}.dialog-fade-enter-active{-webkit-animation:dialog-fade-in .3s;animation:dialog-fade-in .3s}.dialog-fade-leave-active{-webkit-animation:dialog-fade-out .3s;animation:dialog-fade-out .3s}@-webkit-keyframes dialog-fade-in{0%{-webkit-transform:translate3d(0,-20px,0);transform:translate3d(0,-20px,0);opacity:0}100%{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);opacity:1}}@keyframes dialog-fade-in{0%{-webkit-transform:translate3d(0,-20px,0);transform:translate3d(0,-20px,0);opacity:0}100%{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);opacity:1}}@-webkit-keyframes dialog-fade-out{0%{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);opacity:1}100%{-webkit-transform:translate3d(0,-20px,0);transform:translate3d(0,-20px,0);opacity:0}}@keyframes dialog-fade-out{0%{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);opacity:1}100%{-webkit-transform:translate3d(0,-20px,0);transform:translate3d(0,-20px,0);opacity:0}}\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdGhlbWUtY2hhbGsvZGlhbG9nLmNzcz9lZDJkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJCQUEyQixtQkFBTyxDQUFDLENBQXFDO0FBQ3hFOzs7QUFHQTtBQUNBLGNBQWMsUUFBUyxrQkFBa0Isc0NBQXNDLDhCQUE4QixlQUFlLGdEQUFnRCx3Q0FBd0MsOEJBQThCLEdBQUcsV0FBVyxzQkFBc0IsR0FBRyxXQUFXLCtCQUErQixLQUFLLFdBQVcsdUJBQXVCLEtBQUssV0FBVyxTQUFTLGVBQWUsT0FBTyxNQUFNLFdBQVcsWUFBWSxXQUFXLGdCQUFnQix5QkFBeUIsZ0JBQWdCLFdBQVcsa0JBQWtCLG1CQUFtQixnQkFBZ0Isa0JBQWtCLDRDQUE0QyxvQ0FBb0MsOEJBQThCLHNCQUFzQixVQUFVLHlCQUF5QixXQUFXLGFBQWEsZ0JBQWdCLFlBQVksY0FBYyxvQkFBb0IsZUFBZSxNQUFNLFFBQVEsU0FBUyxPQUFPLGNBQWMsU0FBUyxtQkFBbUIsdUJBQXVCLHNCQUFzQixrQkFBa0IsU0FBUyxXQUFXLFVBQVUsZUFBZSxZQUFZLFVBQVUsZUFBZSxlQUFlLHdDQUF3QyxjQUFjLDRGQUE0RixjQUFjLGtCQUFrQixpQkFBaUIsZUFBZSxjQUFjLGlCQUFpQixrQkFBa0IsY0FBYyxlQUFlLHFCQUFxQixtQkFBbUIsdUJBQXVCLGlCQUFpQiw4QkFBOEIsc0JBQXNCLG1CQUFtQixrQkFBa0Isb0NBQW9DLG1CQUFtQix1QkFBdUIsc0NBQXNDLG1CQUFtQiwwQkFBMEIscUNBQXFDLDZCQUE2QiwwQkFBMEIsc0NBQXNDLDhCQUE4QixrQ0FBa0MsR0FBRyx5Q0FBeUMsaUNBQWlDLFVBQVUsS0FBSyxxQ0FBcUMsNkJBQTZCLFdBQVcsMEJBQTBCLEdBQUcseUNBQXlDLGlDQUFpQyxVQUFVLEtBQUsscUNBQXFDLDZCQUE2QixXQUFXLG1DQUFtQyxHQUFHLHFDQUFxQyw2QkFBNkIsVUFBVSxLQUFLLHlDQUF5QyxpQ0FBaUMsV0FBVywyQkFBMkIsR0FBRyxxQ0FBcUMsNkJBQTZCLFVBQVUsS0FBSyx5Q0FBeUMsaUNBQWlDLFdBQVc7O0FBRXhtRiIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIudi1tb2RhbC1lbnRlcnstd2Via2l0LWFuaW1hdGlvbjp2LW1vZGFsLWluIC4ycyBlYXNlO2FuaW1hdGlvbjp2LW1vZGFsLWluIC4ycyBlYXNlfS52LW1vZGFsLWxlYXZley13ZWJraXQtYW5pbWF0aW9uOnYtbW9kYWwtb3V0IC4ycyBlYXNlIGZvcndhcmRzO2FuaW1hdGlvbjp2LW1vZGFsLW91dCAuMnMgZWFzZSBmb3J3YXJkc31ALXdlYmtpdC1rZXlmcmFtZXMgdi1tb2RhbC1pbnswJXtvcGFjaXR5OjB9fUBrZXlmcmFtZXMgdi1tb2RhbC1pbnswJXtvcGFjaXR5OjB9fUAtd2Via2l0LWtleWZyYW1lcyB2LW1vZGFsLW91dHsxMDAle29wYWNpdHk6MH19QGtleWZyYW1lcyB2LW1vZGFsLW91dHsxMDAle29wYWNpdHk6MH19LnYtbW9kYWx7cG9zaXRpb246Zml4ZWQ7bGVmdDowO3RvcDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7b3BhY2l0eTouNTtiYWNrZ3JvdW5kOiMwMDB9LmVsLXBvcHVwLXBhcmVudC0taGlkZGVue292ZXJmbG93OmhpZGRlbn0uZWwtZGlhbG9ne3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbjowIGF1dG8gNTBweDtiYWNrZ3JvdW5kOiNGRkY7Ym9yZGVyLXJhZGl1czoycHg7LXdlYmtpdC1ib3gtc2hhZG93OjAgMXB4IDNweCByZ2JhKDAsMCwwLC4zKTtib3gtc2hhZG93OjAgMXB4IDNweCByZ2JhKDAsMCwwLC4zKTstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7d2lkdGg6NTAlfS5lbC1kaWFsb2cuaXMtZnVsbHNjcmVlbnt3aWR0aDoxMDAlO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjA7aGVpZ2h0OjEwMCU7b3ZlcmZsb3c6YXV0b30uZWwtZGlhbG9nX193cmFwcGVye3Bvc2l0aW9uOmZpeGVkO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO292ZXJmbG93OmF1dG87bWFyZ2luOjB9LmVsLWRpYWxvZ19faGVhZGVye3BhZGRpbmc6MjBweCAyMHB4IDEwcHh9LmVsLWRpYWxvZ19faGVhZGVyYnRue3Bvc2l0aW9uOmFic29sdXRlO3RvcDoyMHB4O3JpZ2h0OjIwcHg7cGFkZGluZzowO2JhY2tncm91bmQ6MCAwO2JvcmRlcjpub25lO291dGxpbmU6MDtjdXJzb3I6cG9pbnRlcjtmb250LXNpemU6MTZweH0uZWwtZGlhbG9nX19oZWFkZXJidG4gLmVsLWRpYWxvZ19fY2xvc2V7Y29sb3I6IzkwOTM5OX0uZWwtZGlhbG9nX19oZWFkZXJidG46Zm9jdXMgLmVsLWRpYWxvZ19fY2xvc2UsLmVsLWRpYWxvZ19faGVhZGVyYnRuOmhvdmVyIC5lbC1kaWFsb2dfX2Nsb3Nle2NvbG9yOiM0MDlFRkZ9LmVsLWRpYWxvZ19fdGl0bGV7bGluZS1oZWlnaHQ6MjRweDtmb250LXNpemU6MThweDtjb2xvcjojMzAzMTMzfS5lbC1kaWFsb2dfX2JvZHl7cGFkZGluZzozMHB4IDIwcHg7Y29sb3I6IzYwNjI2Njtmb250LXNpemU6MTRweDt3b3JkLWJyZWFrOmJyZWFrLWFsbH0uZWwtZGlhbG9nX19mb290ZXJ7cGFkZGluZzoxMHB4IDIwcHggMjBweDt0ZXh0LWFsaWduOnJpZ2h0Oy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveH0uZWwtZGlhbG9nLS1jZW50ZXJ7dGV4dC1hbGlnbjpjZW50ZXJ9LmVsLWRpYWxvZy0tY2VudGVyIC5lbC1kaWFsb2dfX2JvZHl7dGV4dC1hbGlnbjppbml0aWFsO3BhZGRpbmc6MjVweCAyNXB4IDMwcHh9LmVsLWRpYWxvZy0tY2VudGVyIC5lbC1kaWFsb2dfX2Zvb3Rlcnt0ZXh0LWFsaWduOmluaGVyaXR9LmRpYWxvZy1mYWRlLWVudGVyLWFjdGl2ZXstd2Via2l0LWFuaW1hdGlvbjpkaWFsb2ctZmFkZS1pbiAuM3M7YW5pbWF0aW9uOmRpYWxvZy1mYWRlLWluIC4zc30uZGlhbG9nLWZhZGUtbGVhdmUtYWN0aXZley13ZWJraXQtYW5pbWF0aW9uOmRpYWxvZy1mYWRlLW91dCAuM3M7YW5pbWF0aW9uOmRpYWxvZy1mYWRlLW91dCAuM3N9QC13ZWJraXQta2V5ZnJhbWVzIGRpYWxvZy1mYWRlLWluezAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsLTIwcHgsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsLTIwcHgsMCk7b3BhY2l0eTowfTEwMCV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7b3BhY2l0eToxfX1Aa2V5ZnJhbWVzIGRpYWxvZy1mYWRlLWluezAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsLTIwcHgsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsLTIwcHgsMCk7b3BhY2l0eTowfTEwMCV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7b3BhY2l0eToxfX1ALXdlYmtpdC1rZXlmcmFtZXMgZGlhbG9nLWZhZGUtb3V0ezAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO29wYWNpdHk6MX0xMDAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsLTIwcHgsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsLTIwcHgsMCk7b3BhY2l0eTowfX1Aa2V5ZnJhbWVzIGRpYWxvZy1mYWRlLW91dHswJXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTtvcGFjaXR5OjF9MTAwJXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLC0yMHB4LDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLC0yMHB4LDApO29wYWNpdHk6MH19XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL25vZGVfbW9kdWxlcy9lbGVtZW50LXVpL2xpYi90aGVtZS1jaGFsay9kaWFsb2cuY3NzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 89);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return normalizeComponent; });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n\n/***/ 11:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(18);\n\n/***/ }),\n\n/***/ 15:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(23);\n\n/***/ }),\n\n/***/ 4:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(27);\n\n/***/ }),\n\n/***/ 89:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/dialog/src/component.vue?vue&type=template&id=60140e62&\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    \"transition\",\n    {\n      attrs: { name: \"dialog-fade\" },\n      on: { \"after-enter\": _vm.afterEnter, \"after-leave\": _vm.afterLeave }\n    },\n    [\n      _c(\n        \"div\",\n        {\n          directives: [\n            {\n              name: \"show\",\n              rawName: \"v-show\",\n              value: _vm.visible,\n              expression: \"visible\"\n            }\n          ],\n          staticClass: \"el-dialog__wrapper\",\n          on: {\n            click: function($event) {\n              if ($event.target !== $event.currentTarget) {\n                return null\n              }\n              return _vm.handleWrapperClick($event)\n            }\n          }\n        },\n        [\n          _c(\n            \"div\",\n            {\n              key: _vm.key,\n              ref: \"dialog\",\n              class: [\n                \"el-dialog\",\n                {\n                  \"is-fullscreen\": _vm.fullscreen,\n                  \"el-dialog--center\": _vm.center\n                },\n                _vm.customClass\n              ],\n              style: _vm.style,\n              attrs: {\n                role: \"dialog\",\n                \"aria-modal\": \"true\",\n                \"aria-label\": _vm.title || \"dialog\"\n              }\n            },\n            [\n              _c(\n                \"div\",\n                { staticClass: \"el-dialog__header\" },\n                [\n                  _vm._t(\"title\", [\n                    _c(\"span\", { staticClass: \"el-dialog__title\" }, [\n                      _vm._v(_vm._s(_vm.title))\n                    ])\n                  ]),\n                  _vm.showClose\n                    ? _c(\n                        \"button\",\n                        {\n                          staticClass: \"el-dialog__headerbtn\",\n                          attrs: { type: \"button\", \"aria-label\": \"Close\" },\n                          on: { click: _vm.handleClose }\n                        },\n                        [\n                          _c(\"i\", {\n                            staticClass:\n                              \"el-dialog__close el-icon el-icon-close\"\n                          })\n                        ]\n                      )\n                    : _vm._e()\n                ],\n                2\n              ),\n              _vm.rendered\n                ? _c(\n                    \"div\",\n                    { staticClass: \"el-dialog__body\" },\n                    [_vm._t(\"default\")],\n                    2\n                  )\n                : _vm._e(),\n              _vm.$slots.footer\n                ? _c(\n                    \"div\",\n                    { staticClass: \"el-dialog__footer\" },\n                    [_vm._t(\"footer\")],\n                    2\n                  )\n                : _vm._e()\n            ]\n          )\n        ]\n      )\n    ]\n  )\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n// CONCATENATED MODULE: ./packages/dialog/src/component.vue?vue&type=template&id=60140e62&\n\n// EXTERNAL MODULE: external \"element-ui/lib/utils/popup\"\nvar popup_ = __webpack_require__(15);\nvar popup_default = /*#__PURE__*/__webpack_require__.n(popup_);\n\n// EXTERNAL MODULE: external \"element-ui/lib/mixins/migrating\"\nvar migrating_ = __webpack_require__(11);\nvar migrating_default = /*#__PURE__*/__webpack_require__.n(migrating_);\n\n// EXTERNAL MODULE: external \"element-ui/lib/mixins/emitter\"\nvar emitter_ = __webpack_require__(4);\nvar emitter_default = /*#__PURE__*/__webpack_require__.n(emitter_);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/dialog/src/component.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n/* harmony default export */ var componentvue_type_script_lang_js_ = ({\n  name: 'ElDialog',\n\n  mixins: [popup_default.a, emitter_default.a, migrating_default.a],\n\n  props: {\n    title: {\n      type: String,\n      default: ''\n    },\n\n    modal: {\n      type: Boolean,\n      default: true\n    },\n\n    modalAppendToBody: {\n      type: Boolean,\n      default: true\n    },\n\n    appendToBody: {\n      type: Boolean,\n      default: false\n    },\n\n    lockScroll: {\n      type: Boolean,\n      default: true\n    },\n\n    closeOnClickModal: {\n      type: Boolean,\n      default: true\n    },\n\n    closeOnPressEscape: {\n      type: Boolean,\n      default: true\n    },\n\n    showClose: {\n      type: Boolean,\n      default: true\n    },\n\n    width: String,\n\n    fullscreen: Boolean,\n\n    customClass: {\n      type: String,\n      default: ''\n    },\n\n    top: {\n      type: String,\n      default: '15vh'\n    },\n    beforeClose: Function,\n    center: {\n      type: Boolean,\n      default: false\n    },\n\n    destroyOnClose: Boolean\n  },\n\n  data: function data() {\n    return {\n      closed: false,\n      key: 0\n    };\n  },\n\n\n  watch: {\n    visible: function visible(val) {\n      var _this = this;\n\n      if (val) {\n        this.closed = false;\n        this.$emit('open');\n        this.$el.addEventListener('scroll', this.updatePopper);\n        this.$nextTick(function () {\n          _this.$refs.dialog.scrollTop = 0;\n        });\n        if (this.appendToBody) {\n          document.body.appendChild(this.$el);\n        }\n      } else {\n        this.$el.removeEventListener('scroll', this.updatePopper);\n        if (!this.closed) this.$emit('close');\n        if (this.destroyOnClose) {\n          this.$nextTick(function () {\n            _this.key++;\n          });\n        }\n      }\n    }\n  },\n\n  computed: {\n    style: function style() {\n      var style = {};\n      if (!this.fullscreen) {\n        style.marginTop = this.top;\n        if (this.width) {\n          style.width = this.width;\n        }\n      }\n      return style;\n    }\n  },\n\n  methods: {\n    getMigratingConfig: function getMigratingConfig() {\n      return {\n        props: {\n          'size': 'size is removed.'\n        }\n      };\n    },\n    handleWrapperClick: function handleWrapperClick() {\n      if (!this.closeOnClickModal) return;\n      this.handleClose();\n    },\n    handleClose: function handleClose() {\n      if (typeof this.beforeClose === 'function') {\n        this.beforeClose(this.hide);\n      } else {\n        this.hide();\n      }\n    },\n    hide: function hide(cancel) {\n      if (cancel !== false) {\n        this.$emit('update:visible', false);\n        this.$emit('close');\n        this.closed = true;\n      }\n    },\n    updatePopper: function updatePopper() {\n      this.broadcast('ElSelectDropdown', 'updatePopper');\n      this.broadcast('ElDropdownMenu', 'updatePopper');\n    },\n    afterEnter: function afterEnter() {\n      this.$emit('opened');\n    },\n    afterLeave: function afterLeave() {\n      this.$emit('closed');\n    }\n  },\n\n  mounted: function mounted() {\n    if (this.visible) {\n      this.rendered = true;\n      this.open();\n      if (this.appendToBody) {\n        document.body.appendChild(this.$el);\n      }\n    }\n  },\n  destroyed: function destroyed() {\n    // if appendToBody is true, remove DOM node after destroy\n    if (this.appendToBody && this.$el && this.$el.parentNode) {\n      this.$el.parentNode.removeChild(this.$el);\n    }\n  }\n});\n// CONCATENATED MODULE: ./packages/dialog/src/component.vue?vue&type=script&lang=js&\n /* harmony default export */ var src_componentvue_type_script_lang_js_ = (componentvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./packages/dialog/src/component.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer[\"a\" /* default */])(\n  src_componentvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"packages/dialog/src/component.vue\"\n/* harmony default export */ var src_component = (component.exports);\n// CONCATENATED MODULE: ./packages/dialog/index.js\n\n\n/* istanbul ignore next */\nsrc_component.install = function (Vue) {\n  Vue.component(src_component.name, src_component);\n};\n\n/* harmony default export */ var dialog = __webpack_exports__[\"default\"] = (src_component);\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvZGlhbG9nLmpzP2FhZTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0NBQWdDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxrQkFBa0I7QUFDbEY7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpQ0FBaUM7QUFDbEYsd0hBQXdILG1CQUFtQixFQUFFO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEIsRUFBRTtBQUMvRCx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELCtEQUErRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyRkFBMkYsMkJBQTJCLEVBQUU7QUFDeEg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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R0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDhHO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVAsVUFBVSIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID1cbi8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvZGlzdC9cIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gODkpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyAwOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbm9ybWFsaXplQ29tcG9uZW50OyB9KTtcbi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZSAoZXhjZXB0IGZvciBtb2R1bGVzKS5cbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZS5cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgc2NyaXB0RXhwb3J0cyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyLCAvKiBzZXJ2ZXIgb25seSAqL1xuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xuKSB7XG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gJ2RhdGEtdi0nICsgc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHsgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgdGhpcy4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290KSB9XG4gICAgICA6IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyBmb3IgdGVtcGxhdGUtb25seSBob3QtcmVsb2FkIGJlY2F1c2UgaW4gdGhhdCBjYXNlIHRoZSByZW5kZXIgZm4gZG9lc24ndFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxuICAgICAgb3B0aW9ucy5faW5qZWN0U3R5bGVzID0gaG9va1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDExOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlbGVtZW50LXVpL2xpYi9taXhpbnMvbWlncmF0aW5nXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMTU6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImVsZW1lbnQtdWkvbGliL3V0aWxzL3BvcHVwXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZWxlbWVudC11aS9saWIvbWl4aW5zL2VtaXR0ZXJcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA4OTpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vcGFja2FnZXMvZGlhbG9nL3NyYy9jb21wb25lbnQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTYwMTQwZTYyJlxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcInRyYW5zaXRpb25cIixcbiAgICB7XG4gICAgICBhdHRyczogeyBuYW1lOiBcImRpYWxvZy1mYWRlXCIgfSxcbiAgICAgIG9uOiB7IFwiYWZ0ZXItZW50ZXJcIjogX3ZtLmFmdGVyRW50ZXIsIFwiYWZ0ZXItbGVhdmVcIjogX3ZtLmFmdGVyTGVhdmUgfVxuICAgIH0sXG4gICAgW1xuICAgICAgX2MoXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6IFwic2hvd1wiLFxuICAgICAgICAgICAgICByYXdOYW1lOiBcInYtc2hvd1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogX3ZtLnZpc2libGUsXG4gICAgICAgICAgICAgIGV4cHJlc3Npb246IFwidmlzaWJsZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC1kaWFsb2dfX3dyYXBwZXJcIixcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfdm0uaGFuZGxlV3JhcHBlckNsaWNrKCRldmVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGtleTogX3ZtLmtleSxcbiAgICAgICAgICAgICAgcmVmOiBcImRpYWxvZ1wiLFxuICAgICAgICAgICAgICBjbGFzczogW1xuICAgICAgICAgICAgICAgIFwiZWwtZGlhbG9nXCIsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgXCJpcy1mdWxsc2NyZWVuXCI6IF92bS5mdWxsc2NyZWVuLFxuICAgICAgICAgICAgICAgICAgXCJlbC1kaWFsb2ctLWNlbnRlclwiOiBfdm0uY2VudGVyXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfdm0uY3VzdG9tQ2xhc3NcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgc3R5bGU6IF92bS5zdHlsZSxcbiAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICByb2xlOiBcImRpYWxvZ1wiLFxuICAgICAgICAgICAgICAgIFwiYXJpYS1tb2RhbFwiOiBcInRydWVcIixcbiAgICAgICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogX3ZtLnRpdGxlIHx8IFwiZGlhbG9nXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcImVsLWRpYWxvZ19faGVhZGVyXCIgfSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBfdm0uX3QoXCJ0aXRsZVwiLCBbXG4gICAgICAgICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImVsLWRpYWxvZ19fdGl0bGVcIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0udGl0bGUpKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICBfdm0uc2hvd0Nsb3NlXG4gICAgICAgICAgICAgICAgICAgID8gX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC1kaWFsb2dfX2hlYWRlcmJ0blwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyB0eXBlOiBcImJ1dHRvblwiLCBcImFyaWEtbGFiZWxcIjogXCJDbG9zZVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0uaGFuZGxlQ2xvc2UgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJpXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZWwtZGlhbG9nX19jbG9zZSBlbC1pY29uIGVsLWljb24tY2xvc2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBfdm0ucmVuZGVyZWRcbiAgICAgICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcImVsLWRpYWxvZ19fYm9keVwiIH0sXG4gICAgICAgICAgICAgICAgICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICAgIF92bS4kc2xvdHMuZm9vdGVyXG4gICAgICAgICAgICAgICAgPyBfYyhcbiAgICAgICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJlbC1kaWFsb2dfX2Zvb3RlclwiIH0sXG4gICAgICAgICAgICAgICAgICAgIFtfdm0uX3QoXCJmb290ZXJcIildLFxuICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIClcbiAgICAgICAgXVxuICAgICAgKVxuICAgIF1cbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2RpYWxvZy9zcmMvY29tcG9uZW50LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02MDE0MGU2MiZcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcImVsZW1lbnQtdWkvbGliL3V0aWxzL3BvcHVwXCJcbnZhciBwb3B1cF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcbnZhciBwb3B1cF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihwb3B1cF8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIFwiZWxlbWVudC11aS9saWIvbWl4aW5zL21pZ3JhdGluZ1wiXG52YXIgbWlncmF0aW5nXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xudmFyIG1pZ3JhdGluZ19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihtaWdyYXRpbmdfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcImVsZW1lbnQtdWkvbGliL21peGlucy9lbWl0dGVyXCJcbnZhciBlbWl0dGVyXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgZW1pdHRlcl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihlbWl0dGVyXyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3BhY2thZ2VzL2RpYWxvZy9zcmMvY29tcG9uZW50LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnRWxEaWFsb2cnLFxuXG4gIG1peGluczogW3BvcHVwX2RlZmF1bHQuYSwgZW1pdHRlcl9kZWZhdWx0LmEsIG1pZ3JhdGluZ19kZWZhdWx0LmFdLFxuXG4gIHByb3BzOiB7XG4gICAgdGl0bGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICcnXG4gICAgfSxcblxuICAgIG1vZGFsOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG5cbiAgICBtb2RhbEFwcGVuZFRvQm9keToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuXG4gICAgYXBwZW5kVG9Cb2R5OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuXG4gICAgbG9ja1Njcm9sbDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuXG4gICAgY2xvc2VPbkNsaWNrTW9kYWw6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcblxuICAgIGNsb3NlT25QcmVzc0VzY2FwZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuXG4gICAgc2hvd0Nsb3NlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG5cbiAgICB3aWR0aDogU3RyaW5nLFxuXG4gICAgZnVsbHNjcmVlbjogQm9vbGVhbixcblxuICAgIGN1c3RvbUNsYXNzOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnJ1xuICAgIH0sXG5cbiAgICB0b3A6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICcxNXZoJ1xuICAgIH0sXG4gICAgYmVmb3JlQ2xvc2U6IEZ1bmN0aW9uLFxuICAgIGNlbnRlcjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcblxuICAgIGRlc3Ryb3lPbkNsb3NlOiBCb29sZWFuXG4gIH0sXG5cbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xvc2VkOiBmYWxzZSxcbiAgICAgIGtleTogMFxuICAgIH07XG4gIH0sXG5cblxuICB3YXRjaDoge1xuICAgIHZpc2libGU6IGZ1bmN0aW9uIHZpc2libGUodmFsKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJGVtaXQoJ29wZW4nKTtcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy51cGRhdGVQb3BwZXIpO1xuICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuJHJlZnMuZGlhbG9nLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5hcHBlbmRUb0JvZHkpIHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuJGVsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy51cGRhdGVQb3BwZXIpO1xuICAgICAgICBpZiAoIXRoaXMuY2xvc2VkKSB0aGlzLiRlbWl0KCdjbG9zZScpO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95T25DbG9zZSkge1xuICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmtleSsrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgc3R5bGU6IGZ1bmN0aW9uIHN0eWxlKCkge1xuICAgICAgdmFyIHN0eWxlID0ge307XG4gICAgICBpZiAoIXRoaXMuZnVsbHNjcmVlbikge1xuICAgICAgICBzdHlsZS5tYXJnaW5Ub3AgPSB0aGlzLnRvcDtcbiAgICAgICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgICAgICBzdHlsZS53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGdldE1pZ3JhdGluZ0NvbmZpZzogZnVuY3Rpb24gZ2V0TWlncmF0aW5nQ29uZmlnKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAnc2l6ZSc6ICdzaXplIGlzIHJlbW92ZWQuJ1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgaGFuZGxlV3JhcHBlckNsaWNrOiBmdW5jdGlvbiBoYW5kbGVXcmFwcGVyQ2xpY2soKSB7XG4gICAgICBpZiAoIXRoaXMuY2xvc2VPbkNsaWNrTW9kYWwpIHJldHVybjtcbiAgICAgIHRoaXMuaGFuZGxlQ2xvc2UoKTtcbiAgICB9LFxuICAgIGhhbmRsZUNsb3NlOiBmdW5jdGlvbiBoYW5kbGVDbG9zZSgpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5iZWZvcmVDbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmJlZm9yZUNsb3NlKHRoaXMuaGlkZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhpZGU6IGZ1bmN0aW9uIGhpZGUoY2FuY2VsKSB7XG4gICAgICBpZiAoY2FuY2VsICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6dmlzaWJsZScsIGZhbHNlKTtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2xvc2UnKTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXBkYXRlUG9wcGVyOiBmdW5jdGlvbiB1cGRhdGVQb3BwZXIoKSB7XG4gICAgICB0aGlzLmJyb2FkY2FzdCgnRWxTZWxlY3REcm9wZG93bicsICd1cGRhdGVQb3BwZXInKTtcbiAgICAgIHRoaXMuYnJvYWRjYXN0KCdFbERyb3Bkb3duTWVudScsICd1cGRhdGVQb3BwZXInKTtcbiAgICB9LFxuICAgIGFmdGVyRW50ZXI6IGZ1bmN0aW9uIGFmdGVyRW50ZXIoKSB7XG4gICAgICB0aGlzLiRlbWl0KCdvcGVuZWQnKTtcbiAgICB9LFxuICAgIGFmdGVyTGVhdmU6IGZ1bmN0aW9uIGFmdGVyTGVhdmUoKSB7XG4gICAgICB0aGlzLiRlbWl0KCdjbG9zZWQnKTtcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICB0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMub3BlbigpO1xuICAgICAgaWYgKHRoaXMuYXBwZW5kVG9Cb2R5KSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy4kZWwpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQoKSB7XG4gICAgLy8gaWYgYXBwZW5kVG9Cb2R5IGlzIHRydWUsIHJlbW92ZSBET00gbm9kZSBhZnRlciBkZXN0cm95XG4gICAgaWYgKHRoaXMuYXBwZW5kVG9Cb2R5ICYmIHRoaXMuJGVsICYmIHRoaXMuJGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuJGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy4kZWwpO1xuICAgIH1cbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2RpYWxvZy9zcmMvY29tcG9uZW50LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfY29tcG9uZW50dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKGNvbXBvbmVudHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcbnZhciBjb21wb25lbnROb3JtYWxpemVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9kaWFsb2cvc3JjL2NvbXBvbmVudC52dWVcblxuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBjb21wb25lbnQgPSBPYmplY3QoY29tcG9uZW50Tm9ybWFsaXplcltcImFcIiAvKiBkZWZhdWx0ICovXSkoXG4gIHNyY19jb21wb25lbnR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBhcGk7IH1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwicGFja2FnZXMvZGlhbG9nL3NyYy9jb21wb25lbnQudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY19jb21wb25lbnQgPSAoY29tcG9uZW50LmV4cG9ydHMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9kaWFsb2cvaW5kZXguanNcblxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuc3JjX2NvbXBvbmVudC5pbnN0YWxsID0gZnVuY3Rpb24gKFZ1ZSkge1xuICBWdWUuY29tcG9uZW50KHNyY19jb21wb25lbnQubmFtZSwgc3JjX2NvbXBvbmVudCk7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkaWFsb2cgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChzcmNfY29tcG9uZW50KTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvZGlhbG9nLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nexports.__esModule = true;\n\nvar _util = __webpack_require__(19);\n\n/**\n * Show migrating guide in browser console.\n *\n * Usage:\n * import Migrating from 'element-ui/src/mixins/migrating';\n *\n * mixins: [Migrating]\n *\n * add getMigratingConfig method for your component.\n *  getMigratingConfig() {\n *    return {\n *      props: {\n *        'allow-no-selection': 'allow-no-selection is removed.',\n *        'selection-mode': 'selection-mode is removed.'\n *      },\n *      events: {\n *        selectionchange: 'selectionchange is renamed to selection-change.'\n *      }\n *    };\n *  },\n */\nexports.default = {\n  mounted: function mounted() {\n    if (process.env.NODE_ENV === 'production') return;\n    if (!this.$vnode) return;\n\n    var _getMigratingConfig = this.getMigratingConfig(),\n        _getMigratingConfig$p = _getMigratingConfig.props,\n        props = _getMigratingConfig$p === undefined ? {} : _getMigratingConfig$p,\n        _getMigratingConfig$e = _getMigratingConfig.events,\n        events = _getMigratingConfig$e === undefined ? {} : _getMigratingConfig$e;\n\n    var _$vnode = this.$vnode,\n        data = _$vnode.data,\n        componentOptions = _$vnode.componentOptions;\n\n    var definedProps = data.attrs || {};\n    var definedEvents = componentOptions.listeners || {};\n\n    for (var propName in definedProps) {\n      propName = (0, _util.kebabCase)(propName); // compatible with camel case\n      if (props[propName]) {\n        console.warn('[Element Migrating][' + this.$options.name + '][Attribute]: ' + props[propName]);\n      }\n    }\n\n    for (var eventName in definedEvents) {\n      eventName = (0, _util.kebabCase)(eventName); // compatible with camel case\n      if (events[eventName]) {\n        console.warn('[Element Migrating][' + this.$options.name + '][Event]: ' + events[eventName]);\n      }\n    }\n  },\n\n  methods: {\n    getMigratingConfig: function getMigratingConfig() {\n      return {\n        props: {},\n        events: {}\n      };\n    }\n  }\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvbWl4aW5zL21pZ3JhdGluZy5qcz82OTZlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLCtDQUFhOztBQUViOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxFQUEyQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFIiwiZmlsZSI6IjE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKCdlbGVtZW50LXVpL2xpYi91dGlscy91dGlsJyk7XG5cbi8qKlxuICogU2hvdyBtaWdyYXRpbmcgZ3VpZGUgaW4gYnJvd3NlciBjb25zb2xlLlxuICpcbiAqIFVzYWdlOlxuICogaW1wb3J0IE1pZ3JhdGluZyBmcm9tICdlbGVtZW50LXVpL3NyYy9taXhpbnMvbWlncmF0aW5nJztcbiAqXG4gKiBtaXhpbnM6IFtNaWdyYXRpbmddXG4gKlxuICogYWRkIGdldE1pZ3JhdGluZ0NvbmZpZyBtZXRob2QgZm9yIHlvdXIgY29tcG9uZW50LlxuICogIGdldE1pZ3JhdGluZ0NvbmZpZygpIHtcbiAqICAgIHJldHVybiB7XG4gKiAgICAgIHByb3BzOiB7XG4gKiAgICAgICAgJ2FsbG93LW5vLXNlbGVjdGlvbic6ICdhbGxvdy1uby1zZWxlY3Rpb24gaXMgcmVtb3ZlZC4nLFxuICogICAgICAgICdzZWxlY3Rpb24tbW9kZSc6ICdzZWxlY3Rpb24tbW9kZSBpcyByZW1vdmVkLidcbiAqICAgICAgfSxcbiAqICAgICAgZXZlbnRzOiB7XG4gKiAgICAgICAgc2VsZWN0aW9uY2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlIGlzIHJlbmFtZWQgdG8gc2VsZWN0aW9uLWNoYW5nZS4nXG4gKiAgICAgIH1cbiAqICAgIH07XG4gKiAgfSxcbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSByZXR1cm47XG4gICAgaWYgKCF0aGlzLiR2bm9kZSkgcmV0dXJuO1xuXG4gICAgdmFyIF9nZXRNaWdyYXRpbmdDb25maWcgPSB0aGlzLmdldE1pZ3JhdGluZ0NvbmZpZygpLFxuICAgICAgICBfZ2V0TWlncmF0aW5nQ29uZmlnJHAgPSBfZ2V0TWlncmF0aW5nQ29uZmlnLnByb3BzLFxuICAgICAgICBwcm9wcyA9IF9nZXRNaWdyYXRpbmdDb25maWckcCA9PT0gdW5kZWZpbmVkID8ge30gOiBfZ2V0TWlncmF0aW5nQ29uZmlnJHAsXG4gICAgICAgIF9nZXRNaWdyYXRpbmdDb25maWckZSA9IF9nZXRNaWdyYXRpbmdDb25maWcuZXZlbnRzLFxuICAgICAgICBldmVudHMgPSBfZ2V0TWlncmF0aW5nQ29uZmlnJGUgPT09IHVuZGVmaW5lZCA/IHt9IDogX2dldE1pZ3JhdGluZ0NvbmZpZyRlO1xuXG4gICAgdmFyIF8kdm5vZGUgPSB0aGlzLiR2bm9kZSxcbiAgICAgICAgZGF0YSA9IF8kdm5vZGUuZGF0YSxcbiAgICAgICAgY29tcG9uZW50T3B0aW9ucyA9IF8kdm5vZGUuY29tcG9uZW50T3B0aW9ucztcblxuICAgIHZhciBkZWZpbmVkUHJvcHMgPSBkYXRhLmF0dHJzIHx8IHt9O1xuICAgIHZhciBkZWZpbmVkRXZlbnRzID0gY29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMgfHwge307XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkZWZpbmVkUHJvcHMpIHtcbiAgICAgIHByb3BOYW1lID0gKDAsIF91dGlsLmtlYmFiQ2FzZSkocHJvcE5hbWUpOyAvLyBjb21wYXRpYmxlIHdpdGggY2FtZWwgY2FzZVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tFbGVtZW50IE1pZ3JhdGluZ11bJyArIHRoaXMuJG9wdGlvbnMubmFtZSArICddW0F0dHJpYnV0ZV06ICcgKyBwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBkZWZpbmVkRXZlbnRzKSB7XG4gICAgICBldmVudE5hbWUgPSAoMCwgX3V0aWwua2ViYWJDYXNlKShldmVudE5hbWUpOyAvLyBjb21wYXRpYmxlIHdpdGggY2FtZWwgY2FzZVxuICAgICAgaWYgKGV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW0VsZW1lbnQgTWlncmF0aW5nXVsnICsgdGhpcy4kb3B0aW9ucy5uYW1lICsgJ11bRXZlbnRdOiAnICsgZXZlbnRzW2V2ZW50TmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgZ2V0TWlncmF0aW5nQ29uZmlnOiBmdW5jdGlvbiBnZXRNaWdyYXRpbmdDb25maWcoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge30sXG4gICAgICAgIGV2ZW50czoge31cbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvbGliL21peGlucy9taWdyYXRpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.isEmpty = exports.isEqual = exports.arrayEquals = exports.looseEqual = exports.capitalize = exports.kebabCase = exports.autoprefixer = exports.isFirefox = exports.isEdge = exports.isIE = exports.coerceTruthyValueToArray = exports.arrayFind = exports.arrayFindIndex = exports.escapeRegexpString = exports.valueEquals = exports.generateId = exports.getValueByPath = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.noop = noop;\nexports.hasOwn = hasOwn;\nexports.toObject = toObject;\nexports.getPropByPath = getPropByPath;\nexports.rafThrottle = rafThrottle;\nexports.objToArray = objToArray;\n\nvar _vue = __webpack_require__(0);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _types = __webpack_require__(22);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction noop() {};\n\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n};\n\nfunction extend(to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to;\n};\n\nfunction toObject(arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res;\n};\n\nvar getValueByPath = exports.getValueByPath = function getValueByPath(object, prop) {\n  prop = prop || '';\n  var paths = prop.split('.');\n  var current = object;\n  var result = null;\n  for (var i = 0, j = paths.length; i < j; i++) {\n    var path = paths[i];\n    if (!current) break;\n\n    if (i === j - 1) {\n      result = current[path];\n      break;\n    }\n    current = current[path];\n  }\n  return result;\n};\n\nfunction getPropByPath(obj, path, strict) {\n  var tempObj = obj;\n  path = path.replace(/\\[(\\w+)\\]/g, '.$1');\n  path = path.replace(/^\\./, '');\n\n  var keyArr = path.split('.');\n  var i = 0;\n  for (var len = keyArr.length; i < len - 1; ++i) {\n    if (!tempObj && !strict) break;\n    var key = keyArr[i];\n    if (key in tempObj) {\n      tempObj = tempObj[key];\n    } else {\n      if (strict) {\n        throw new Error('please transfer a valid prop path to form item!');\n      }\n      break;\n    }\n  }\n  return {\n    o: tempObj,\n    k: keyArr[i],\n    v: tempObj ? tempObj[keyArr[i]] : null\n  };\n};\n\nvar generateId = exports.generateId = function generateId() {\n  return Math.floor(Math.random() * 10000);\n};\n\nvar valueEquals = exports.valueEquals = function valueEquals(a, b) {\n  // see: https://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript\n  if (a === b) return true;\n  if (!(a instanceof Array)) return false;\n  if (!(b instanceof Array)) return false;\n  if (a.length !== b.length) return false;\n  for (var i = 0; i !== a.length; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n};\n\nvar escapeRegexpString = exports.escapeRegexpString = function escapeRegexpString() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return String(value).replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&');\n};\n\n// TODO: use native Array.find, Array.findIndex when IE support is dropped\nvar arrayFindIndex = exports.arrayFindIndex = function arrayFindIndex(arr, pred) {\n  for (var i = 0; i !== arr.length; ++i) {\n    if (pred(arr[i])) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nvar arrayFind = exports.arrayFind = function arrayFind(arr, pred) {\n  var idx = arrayFindIndex(arr, pred);\n  return idx !== -1 ? arr[idx] : undefined;\n};\n\n// coerce truthy value to array\nvar coerceTruthyValueToArray = exports.coerceTruthyValueToArray = function coerceTruthyValueToArray(val) {\n  if (Array.isArray(val)) {\n    return val;\n  } else if (val) {\n    return [val];\n  } else {\n    return [];\n  }\n};\n\nvar isIE = exports.isIE = function isIE() {\n  return !_vue2.default.prototype.$isServer && !isNaN(Number(document.documentMode));\n};\n\nvar isEdge = exports.isEdge = function isEdge() {\n  return !_vue2.default.prototype.$isServer && navigator.userAgent.indexOf('Edge') > -1;\n};\n\nvar isFirefox = exports.isFirefox = function isFirefox() {\n  return !_vue2.default.prototype.$isServer && !!window.navigator.userAgent.match(/firefox/i);\n};\n\nvar autoprefixer = exports.autoprefixer = function autoprefixer(style) {\n  if ((typeof style === 'undefined' ? 'undefined' : _typeof(style)) !== 'object') return style;\n  var rules = ['transform', 'transition', 'animation'];\n  var prefixes = ['ms-', 'webkit-'];\n  rules.forEach(function (rule) {\n    var value = style[rule];\n    if (rule && value) {\n      prefixes.forEach(function (prefix) {\n        style[prefix + rule] = value;\n      });\n    }\n  });\n  return style;\n};\n\nvar kebabCase = exports.kebabCase = function kebabCase(str) {\n  var hyphenateRE = /([^-])([A-Z])/g;\n  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();\n};\n\nvar capitalize = exports.capitalize = function capitalize(str) {\n  if (!(0, _types.isString)(str)) return str;\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\nvar looseEqual = exports.looseEqual = function looseEqual(a, b) {\n  var isObjectA = (0, _types.isObject)(a);\n  var isObjectB = (0, _types.isObject)(b);\n  if (isObjectA && isObjectB) {\n    return JSON.stringify(a) === JSON.stringify(b);\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b);\n  } else {\n    return false;\n  }\n};\n\nvar arrayEquals = exports.arrayEquals = function arrayEquals(arrayA, arrayB) {\n  arrayA = arrayA || [];\n  arrayB = arrayB || [];\n\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n\n  for (var i = 0; i < arrayA.length; i++) {\n    if (!looseEqual(arrayA[i], arrayB[i])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar isEqual = exports.isEqual = function isEqual(value1, value2) {\n  if (Array.isArray(value1) && Array.isArray(value2)) {\n    return arrayEquals(value1, value2);\n  }\n  return looseEqual(value1, value2);\n};\n\nvar isEmpty = exports.isEmpty = function isEmpty(val) {\n  // null or undefined\n  if (val == null) return true;\n\n  if (typeof val === 'boolean') return false;\n\n  if (typeof val === 'number') return !val;\n\n  if (val instanceof Error) return val.message === '';\n\n  switch (Object.prototype.toString.call(val)) {\n    // String or Array\n    case '[object String]':\n    case '[object Array]':\n      return !val.length;\n\n    // Map or Set or File\n    case '[object File]':\n    case '[object Map]':\n    case '[object Set]':\n      {\n        return !val.size;\n      }\n    // Plain Object\n    case '[object Object]':\n      {\n        return !Object.keys(val).length;\n      }\n  }\n\n  return false;\n};\n\nfunction rafThrottle(fn) {\n  var locked = false;\n  return function () {\n    var _this = this;\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (locked) return;\n    locked = true;\n    window.requestAnimationFrame(function (_) {\n      fn.apply(_this, args);\n      locked = false;\n    });\n  };\n}\n\nfunction objToArray(obj) {\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return isEmpty(obj) ? [] : [obj];\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvdXRpbC5qcz9jYTUwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUEsb0dBQW9HLG1CQUFtQixFQUFFLG1CQUFtQiw4SEFBOEg7O0FBRTFRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsQ0FBSzs7QUFFeEI7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLEVBQTRCOztBQUVqRCxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmlzRW1wdHkgPSBleHBvcnRzLmlzRXF1YWwgPSBleHBvcnRzLmFycmF5RXF1YWxzID0gZXhwb3J0cy5sb29zZUVxdWFsID0gZXhwb3J0cy5jYXBpdGFsaXplID0gZXhwb3J0cy5rZWJhYkNhc2UgPSBleHBvcnRzLmF1dG9wcmVmaXhlciA9IGV4cG9ydHMuaXNGaXJlZm94ID0gZXhwb3J0cy5pc0VkZ2UgPSBleHBvcnRzLmlzSUUgPSBleHBvcnRzLmNvZXJjZVRydXRoeVZhbHVlVG9BcnJheSA9IGV4cG9ydHMuYXJyYXlGaW5kID0gZXhwb3J0cy5hcnJheUZpbmRJbmRleCA9IGV4cG9ydHMuZXNjYXBlUmVnZXhwU3RyaW5nID0gZXhwb3J0cy52YWx1ZUVxdWFscyA9IGV4cG9ydHMuZ2VuZXJhdGVJZCA9IGV4cG9ydHMuZ2V0VmFsdWVCeVBhdGggPSB1bmRlZmluZWQ7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5ub29wID0gbm9vcDtcbmV4cG9ydHMuaGFzT3duID0gaGFzT3duO1xuZXhwb3J0cy50b09iamVjdCA9IHRvT2JqZWN0O1xuZXhwb3J0cy5nZXRQcm9wQnlQYXRoID0gZ2V0UHJvcEJ5UGF0aDtcbmV4cG9ydHMucmFmVGhyb3R0bGUgPSByYWZUaHJvdHRsZTtcbmV4cG9ydHMub2JqVG9BcnJheSA9IG9ialRvQXJyYXk7XG5cbnZhciBfdnVlID0gcmVxdWlyZSgndnVlJyk7XG5cbnZhciBfdnVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Z1ZSk7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKCdlbGVtZW50LXVpL2xpYi91dGlscy90eXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBub29wKCkge307XG5cbmZ1bmN0aW9uIGhhc093bihvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59O1xuXG5mdW5jdGlvbiBleHRlbmQodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0bztcbn07XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBnZXRWYWx1ZUJ5UGF0aCA9IGV4cG9ydHMuZ2V0VmFsdWVCeVBhdGggPSBmdW5jdGlvbiBnZXRWYWx1ZUJ5UGF0aChvYmplY3QsIHByb3ApIHtcbiAgcHJvcCA9IHByb3AgfHwgJyc7XG4gIHZhciBwYXRocyA9IHByb3Auc3BsaXQoJy4nKTtcbiAgdmFyIGN1cnJlbnQgPSBvYmplY3Q7XG4gIHZhciByZXN1bHQgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IHBhdGhzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgIHZhciBwYXRoID0gcGF0aHNbaV07XG4gICAgaWYgKCFjdXJyZW50KSBicmVhaztcblxuICAgIGlmIChpID09PSBqIC0gMSkge1xuICAgICAgcmVzdWx0ID0gY3VycmVudFtwYXRoXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjdXJyZW50ID0gY3VycmVudFtwYXRoXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gZ2V0UHJvcEJ5UGF0aChvYmosIHBhdGgsIHN0cmljdCkge1xuICB2YXIgdGVtcE9iaiA9IG9iajtcbiAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFxbKFxcdyspXFxdL2csICcuJDEnKTtcbiAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLi8sICcnKTtcblxuICB2YXIga2V5QXJyID0gcGF0aC5zcGxpdCgnLicpO1xuICB2YXIgaSA9IDA7XG4gIGZvciAodmFyIGxlbiA9IGtleUFyci5sZW5ndGg7IGkgPCBsZW4gLSAxOyArK2kpIHtcbiAgICBpZiAoIXRlbXBPYmogJiYgIXN0cmljdCkgYnJlYWs7XG4gICAgdmFyIGtleSA9IGtleUFycltpXTtcbiAgICBpZiAoa2V5IGluIHRlbXBPYmopIHtcbiAgICAgIHRlbXBPYmogPSB0ZW1wT2JqW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwbGVhc2UgdHJhbnNmZXIgYSB2YWxpZCBwcm9wIHBhdGggdG8gZm9ybSBpdGVtIScpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbzogdGVtcE9iaixcbiAgICBrOiBrZXlBcnJbaV0sXG4gICAgdjogdGVtcE9iaiA/IHRlbXBPYmpba2V5QXJyW2ldXSA6IG51bGxcbiAgfTtcbn07XG5cbnZhciBnZW5lcmF0ZUlkID0gZXhwb3J0cy5nZW5lcmF0ZUlkID0gZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcbn07XG5cbnZhciB2YWx1ZUVxdWFscyA9IGV4cG9ydHMudmFsdWVFcXVhbHMgPSBmdW5jdGlvbiB2YWx1ZUVxdWFscyhhLCBiKSB7XG4gIC8vIHNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzExNTk4Mi9ob3ctdG8tY2hlY2staWYtdHdvLWFycmF5cy1hcmUtZXF1YWwtd2l0aC1qYXZhc2NyaXB0XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKCEoYSBpbnN0YW5jZW9mIEFycmF5KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIShiIGluc3RhbmNlb2YgQXJyYXkpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgIT09IGEubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGVzY2FwZVJlZ2V4cFN0cmluZyA9IGV4cG9ydHMuZXNjYXBlUmVnZXhwU3RyaW5nID0gZnVuY3Rpb24gZXNjYXBlUmVnZXhwU3RyaW5nKCkge1xuICB2YXIgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICByZXR1cm4gU3RyaW5nKHZhbHVlKS5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKyo/Ll0vZywgJ1xcXFwkJicpO1xufTtcblxuLy8gVE9ETzogdXNlIG5hdGl2ZSBBcnJheS5maW5kLCBBcnJheS5maW5kSW5kZXggd2hlbiBJRSBzdXBwb3J0IGlzIGRyb3BwZWRcbnZhciBhcnJheUZpbmRJbmRleCA9IGV4cG9ydHMuYXJyYXlGaW5kSW5kZXggPSBmdW5jdGlvbiBhcnJheUZpbmRJbmRleChhcnIsIHByZWQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgIT09IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChwcmVkKGFycltpXSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG52YXIgYXJyYXlGaW5kID0gZXhwb3J0cy5hcnJheUZpbmQgPSBmdW5jdGlvbiBhcnJheUZpbmQoYXJyLCBwcmVkKSB7XG4gIHZhciBpZHggPSBhcnJheUZpbmRJbmRleChhcnIsIHByZWQpO1xuICByZXR1cm4gaWR4ICE9PSAtMSA/IGFycltpZHhdIDogdW5kZWZpbmVkO1xufTtcblxuLy8gY29lcmNlIHRydXRoeSB2YWx1ZSB0byBhcnJheVxudmFyIGNvZXJjZVRydXRoeVZhbHVlVG9BcnJheSA9IGV4cG9ydHMuY29lcmNlVHJ1dGh5VmFsdWVUb0FycmF5ID0gZnVuY3Rpb24gY29lcmNlVHJ1dGh5VmFsdWVUb0FycmF5KHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfSBlbHNlIGlmICh2YWwpIHtcbiAgICByZXR1cm4gW3ZhbF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuXG52YXIgaXNJRSA9IGV4cG9ydHMuaXNJRSA9IGZ1bmN0aW9uIGlzSUUoKSB7XG4gIHJldHVybiAhX3Z1ZTIuZGVmYXVsdC5wcm90b3R5cGUuJGlzU2VydmVyICYmICFpc05hTihOdW1iZXIoZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSk7XG59O1xuXG52YXIgaXNFZGdlID0gZXhwb3J0cy5pc0VkZ2UgPSBmdW5jdGlvbiBpc0VkZ2UoKSB7XG4gIHJldHVybiAhX3Z1ZTIuZGVmYXVsdC5wcm90b3R5cGUuJGlzU2VydmVyICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID4gLTE7XG59O1xuXG52YXIgaXNGaXJlZm94ID0gZXhwb3J0cy5pc0ZpcmVmb3ggPSBmdW5jdGlvbiBpc0ZpcmVmb3goKSB7XG4gIHJldHVybiAhX3Z1ZTIuZGVmYXVsdC5wcm90b3R5cGUuJGlzU2VydmVyICYmICEhd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2ZpcmVmb3gvaSk7XG59O1xuXG52YXIgYXV0b3ByZWZpeGVyID0gZXhwb3J0cy5hdXRvcHJlZml4ZXIgPSBmdW5jdGlvbiBhdXRvcHJlZml4ZXIoc3R5bGUpIHtcbiAgaWYgKCh0eXBlb2Ygc3R5bGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHN0eWxlKSkgIT09ICdvYmplY3QnKSByZXR1cm4gc3R5bGU7XG4gIHZhciBydWxlcyA9IFsndHJhbnNmb3JtJywgJ3RyYW5zaXRpb24nLCAnYW5pbWF0aW9uJ107XG4gIHZhciBwcmVmaXhlcyA9IFsnbXMtJywgJ3dlYmtpdC0nXTtcbiAgcnVsZXMuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgIHZhciB2YWx1ZSA9IHN0eWxlW3J1bGVdO1xuICAgIGlmIChydWxlICYmIHZhbHVlKSB7XG4gICAgICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgc3R5bGVbcHJlZml4ICsgcnVsZV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzdHlsZTtcbn07XG5cbnZhciBrZWJhYkNhc2UgPSBleHBvcnRzLmtlYmFiQ2FzZSA9IGZ1bmN0aW9uIGtlYmFiQ2FzZShzdHIpIHtcbiAgdmFyIGh5cGhlbmF0ZVJFID0gLyhbXi1dKShbQS1aXSkvZztcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKS5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGNhcGl0YWxpemUgPSBleHBvcnRzLmNhcGl0YWxpemUgPSBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xuICBpZiAoISgwLCBfdHlwZXMuaXNTdHJpbmcpKHN0cikpIHJldHVybiBzdHI7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59O1xuXG52YXIgbG9vc2VFcXVhbCA9IGV4cG9ydHMubG9vc2VFcXVhbCA9IGZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICB2YXIgaXNPYmplY3RBID0gKDAsIF90eXBlcy5pc09iamVjdCkoYSk7XG4gIHZhciBpc09iamVjdEIgPSAoMCwgX3R5cGVzLmlzT2JqZWN0KShiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpO1xuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBhcnJheUVxdWFscyA9IGV4cG9ydHMuYXJyYXlFcXVhbHMgPSBmdW5jdGlvbiBhcnJheUVxdWFscyhhcnJheUEsIGFycmF5Qikge1xuICBhcnJheUEgPSBhcnJheUEgfHwgW107XG4gIGFycmF5QiA9IGFycmF5QiB8fCBbXTtcblxuICBpZiAoYXJyYXlBLmxlbmd0aCAhPT0gYXJyYXlCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFsb29zZUVxdWFsKGFycmF5QVtpXSwgYXJyYXlCW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGlzRXF1YWwgPSBleHBvcnRzLmlzRXF1YWwgPSBmdW5jdGlvbiBpc0VxdWFsKHZhbHVlMSwgdmFsdWUyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlMSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZTIpKSB7XG4gICAgcmV0dXJuIGFycmF5RXF1YWxzKHZhbHVlMSwgdmFsdWUyKTtcbiAgfVxuICByZXR1cm4gbG9vc2VFcXVhbCh2YWx1ZTEsIHZhbHVlMik7XG59O1xuXG52YXIgaXNFbXB0eSA9IGV4cG9ydHMuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkodmFsKSB7XG4gIC8vIG51bGwgb3IgdW5kZWZpbmVkXG4gIGlmICh2YWwgPT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykgcmV0dXJuICF2YWw7XG5cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLm1lc3NhZ2UgPT09ICcnO1xuXG4gIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkpIHtcbiAgICAvLyBTdHJpbmcgb3IgQXJyYXlcbiAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgIGNhc2UgJ1tvYmplY3QgQXJyYXldJzpcbiAgICAgIHJldHVybiAhdmFsLmxlbmd0aDtcblxuICAgIC8vIE1hcCBvciBTZXQgb3IgRmlsZVxuICAgIGNhc2UgJ1tvYmplY3QgRmlsZV0nOlxuICAgIGNhc2UgJ1tvYmplY3QgTWFwXSc6XG4gICAgY2FzZSAnW29iamVjdCBTZXRdJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICF2YWwuc2l6ZTtcbiAgICAgIH1cbiAgICAvLyBQbGFpbiBPYmplY3RcbiAgICBjYXNlICdbb2JqZWN0IE9iamVjdF0nOlxuICAgICAge1xuICAgICAgICByZXR1cm4gIU9iamVjdC5rZXlzKHZhbCkubGVuZ3RoO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gcmFmVGhyb3R0bGUoZm4pIHtcbiAgdmFyIGxvY2tlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAobG9ja2VkKSByZXR1cm47XG4gICAgbG9ja2VkID0gdHJ1ZTtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIChfKSB7XG4gICAgICBmbi5hcHBseShfdGhpcywgYXJncyk7XG4gICAgICBsb2NrZWQgPSBmYWxzZTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb2JqVG9BcnJheShvYmopIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgcmV0dXJuIGlzRW1wdHkob2JqKSA/IFtdIDogW29ial07XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(21);\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz9kN2FkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxtQkFBTyxDQUFDLEVBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(5)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz85YjJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///21\n");

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.isString = isString;\nexports.isObject = isObject;\nexports.isHtmlElement = isHtmlElement;\nfunction isString(obj) {\n  return Object.prototype.toString.call(obj) === '[object String]';\n}\n\nfunction isObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n\nfunction isHtmlElement(node) {\n  return node && node.nodeType === Node.ELEMENT_NODE;\n}\n\nvar isFunction = exports.isFunction = function isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n};\n\nvar isUndefined = exports.isUndefined = function isUndefined(val) {\n  return val === void 0;\n};\n\nvar isDefined = exports.isDefined = function isDefined(val) {\n  return val !== undefined && val !== null;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvdHlwZXMuanM/ZjM3ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5leHBvcnRzLmlzSHRtbEVsZW1lbnQgPSBpc0h0bWxFbGVtZW50O1xuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5mdW5jdGlvbiBpc0h0bWxFbGVtZW50KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG59XG5cbnZhciBpc0Z1bmN0aW9uID0gZXhwb3J0cy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgdmFyIGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBpc1VuZGVmaW5lZCA9IGV4cG9ydHMuaXNVbmRlZmluZWQgPSBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PT0gdm9pZCAwO1xufTtcblxudmFyIGlzRGVmaW5lZCA9IGV4cG9ydHMuaXNEZWZpbmVkID0gZnVuY3Rpb24gaXNEZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgJiYgdmFsICE9PSBudWxsO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVtZW50LXVpL2xpYi91dGlscy90eXBlcy5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22\n");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.PopupManager = undefined;\n\nvar _vue = __webpack_require__(0);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _merge = __webpack_require__(24);\n\nvar _merge2 = _interopRequireDefault(_merge);\n\nvar _popupManager = __webpack_require__(25);\n\nvar _popupManager2 = _interopRequireDefault(_popupManager);\n\nvar _scrollbarWidth = __webpack_require__(26);\n\nvar _scrollbarWidth2 = _interopRequireDefault(_scrollbarWidth);\n\nvar _dom = __webpack_require__(6);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar idSeed = 1;\n\nvar scrollBarWidth = void 0;\n\nexports.default = {\n  props: {\n    visible: {\n      type: Boolean,\n      default: false\n    },\n    openDelay: {},\n    closeDelay: {},\n    zIndex: {},\n    modal: {\n      type: Boolean,\n      default: false\n    },\n    modalFade: {\n      type: Boolean,\n      default: true\n    },\n    modalClass: {},\n    modalAppendToBody: {\n      type: Boolean,\n      default: false\n    },\n    lockScroll: {\n      type: Boolean,\n      default: true\n    },\n    closeOnPressEscape: {\n      type: Boolean,\n      default: false\n    },\n    closeOnClickModal: {\n      type: Boolean,\n      default: false\n    }\n  },\n\n  beforeMount: function beforeMount() {\n    this._popupId = 'popup-' + idSeed++;\n    _popupManager2.default.register(this._popupId, this);\n  },\n  beforeDestroy: function beforeDestroy() {\n    _popupManager2.default.deregister(this._popupId);\n    _popupManager2.default.closeModal(this._popupId);\n\n    this.restoreBodyStyle();\n  },\n  data: function data() {\n    return {\n      opened: false,\n      bodyPaddingRight: null,\n      computedBodyPaddingRight: 0,\n      withoutHiddenClass: true,\n      rendered: false\n    };\n  },\n\n\n  watch: {\n    visible: function visible(val) {\n      var _this = this;\n\n      if (val) {\n        if (this._opening) return;\n        if (!this.rendered) {\n          this.rendered = true;\n          _vue2.default.nextTick(function () {\n            _this.open();\n          });\n        } else {\n          this.open();\n        }\n      } else {\n        this.close();\n      }\n    }\n  },\n\n  methods: {\n    open: function open(options) {\n      var _this2 = this;\n\n      if (!this.rendered) {\n        this.rendered = true;\n      }\n\n      var props = (0, _merge2.default)({}, this.$props || this, options);\n\n      if (this._closeTimer) {\n        clearTimeout(this._closeTimer);\n        this._closeTimer = null;\n      }\n      clearTimeout(this._openTimer);\n\n      var openDelay = Number(props.openDelay);\n      if (openDelay > 0) {\n        this._openTimer = setTimeout(function () {\n          _this2._openTimer = null;\n          _this2.doOpen(props);\n        }, openDelay);\n      } else {\n        this.doOpen(props);\n      }\n    },\n    doOpen: function doOpen(props) {\n      if (this.$isServer) return;\n      if (this.willOpen && !this.willOpen()) return;\n      if (this.opened) return;\n\n      this._opening = true;\n\n      var dom = this.$el;\n\n      var modal = props.modal;\n\n      var zIndex = props.zIndex;\n      if (zIndex) {\n        _popupManager2.default.zIndex = zIndex;\n      }\n\n      if (modal) {\n        if (this._closing) {\n          _popupManager2.default.closeModal(this._popupId);\n          this._closing = false;\n        }\n        _popupManager2.default.openModal(this._popupId, _popupManager2.default.nextZIndex(), this.modalAppendToBody ? undefined : dom, props.modalClass, props.modalFade);\n        if (props.lockScroll) {\n          this.withoutHiddenClass = !(0, _dom.hasClass)(document.body, 'el-popup-parent--hidden');\n          if (this.withoutHiddenClass) {\n            this.bodyPaddingRight = document.body.style.paddingRight;\n            this.computedBodyPaddingRight = parseInt((0, _dom.getStyle)(document.body, 'paddingRight'), 10);\n          }\n          scrollBarWidth = (0, _scrollbarWidth2.default)();\n          var bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;\n          var bodyOverflowY = (0, _dom.getStyle)(document.body, 'overflowY');\n          if (scrollBarWidth > 0 && (bodyHasOverflow || bodyOverflowY === 'scroll') && this.withoutHiddenClass) {\n            document.body.style.paddingRight = this.computedBodyPaddingRight + scrollBarWidth + 'px';\n          }\n          (0, _dom.addClass)(document.body, 'el-popup-parent--hidden');\n        }\n      }\n\n      if (getComputedStyle(dom).position === 'static') {\n        dom.style.position = 'absolute';\n      }\n\n      dom.style.zIndex = _popupManager2.default.nextZIndex();\n      this.opened = true;\n\n      this.onOpen && this.onOpen();\n\n      this.doAfterOpen();\n    },\n    doAfterOpen: function doAfterOpen() {\n      this._opening = false;\n    },\n    close: function close() {\n      var _this3 = this;\n\n      if (this.willClose && !this.willClose()) return;\n\n      if (this._openTimer !== null) {\n        clearTimeout(this._openTimer);\n        this._openTimer = null;\n      }\n      clearTimeout(this._closeTimer);\n\n      var closeDelay = Number(this.closeDelay);\n\n      if (closeDelay > 0) {\n        this._closeTimer = setTimeout(function () {\n          _this3._closeTimer = null;\n          _this3.doClose();\n        }, closeDelay);\n      } else {\n        this.doClose();\n      }\n    },\n    doClose: function doClose() {\n      this._closing = true;\n\n      this.onClose && this.onClose();\n\n      if (this.lockScroll) {\n        setTimeout(this.restoreBodyStyle, 200);\n      }\n\n      this.opened = false;\n\n      this.doAfterClose();\n    },\n    doAfterClose: function doAfterClose() {\n      _popupManager2.default.closeModal(this._popupId);\n      this._closing = false;\n    },\n    restoreBodyStyle: function restoreBodyStyle() {\n      if (this.modal && this.withoutHiddenClass) {\n        document.body.style.paddingRight = this.bodyPaddingRight;\n        (0, _dom.removeClass)(document.body, 'el-popup-parent--hidden');\n      }\n      this.withoutHiddenClass = true;\n    }\n  }\n};\nexports.PopupManager = _popupManager2.default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvcG9wdXAvaW5kZXguanM/ZWM5ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxDQUFLOztBQUV4Qjs7QUFFQSxhQUFhLG1CQUFPLENBQUMsRUFBNEI7O0FBRWpEOztBQUVBLG9CQUFvQixtQkFBTyxDQUFDLEVBQTBDOztBQUV0RTs7QUFFQSxzQkFBc0IsbUJBQU8sQ0FBQyxFQUFvQjs7QUFFbEQ7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLENBQVE7O0FBRTNCLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3Rjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5Qb3B1cE1hbmFnZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfdnVlID0gcmVxdWlyZSgndnVlJyk7XG5cbnZhciBfdnVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Z1ZSk7XG5cbnZhciBfbWVyZ2UgPSByZXF1aXJlKCdlbGVtZW50LXVpL2xpYi91dGlscy9tZXJnZScpO1xuXG52YXIgX21lcmdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lcmdlKTtcblxudmFyIF9wb3B1cE1hbmFnZXIgPSByZXF1aXJlKCdlbGVtZW50LXVpL2xpYi91dGlscy9wb3B1cC9wb3B1cC1tYW5hZ2VyJyk7XG5cbnZhciBfcG9wdXBNYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BvcHVwTWFuYWdlcik7XG5cbnZhciBfc2Nyb2xsYmFyV2lkdGggPSByZXF1aXJlKCcuLi9zY3JvbGxiYXItd2lkdGgnKTtcblxudmFyIF9zY3JvbGxiYXJXaWR0aDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zY3JvbGxiYXJXaWR0aCk7XG5cbnZhciBfZG9tID0gcmVxdWlyZSgnLi4vZG9tJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBpZFNlZWQgPSAxO1xuXG52YXIgc2Nyb2xsQmFyV2lkdGggPSB2b2lkIDA7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgcHJvcHM6IHtcbiAgICB2aXNpYmxlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIG9wZW5EZWxheToge30sXG4gICAgY2xvc2VEZWxheToge30sXG4gICAgekluZGV4OiB7fSxcbiAgICBtb2RhbDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBtb2RhbEZhZGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBtb2RhbENsYXNzOiB7fSxcbiAgICBtb2RhbEFwcGVuZFRvQm9keToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBsb2NrU2Nyb2xsOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgY2xvc2VPblByZXNzRXNjYXBlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGNsb3NlT25DbGlja01vZGFsOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uIGJlZm9yZU1vdW50KCkge1xuICAgIHRoaXMuX3BvcHVwSWQgPSAncG9wdXAtJyArIGlkU2VlZCsrO1xuICAgIF9wb3B1cE1hbmFnZXIyLmRlZmF1bHQucmVnaXN0ZXIodGhpcy5fcG9wdXBJZCwgdGhpcyk7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgX3BvcHVwTWFuYWdlcjIuZGVmYXVsdC5kZXJlZ2lzdGVyKHRoaXMuX3BvcHVwSWQpO1xuICAgIF9wb3B1cE1hbmFnZXIyLmRlZmF1bHQuY2xvc2VNb2RhbCh0aGlzLl9wb3B1cElkKTtcblxuICAgIHRoaXMucmVzdG9yZUJvZHlTdHlsZSgpO1xuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcGVuZWQ6IGZhbHNlLFxuICAgICAgYm9keVBhZGRpbmdSaWdodDogbnVsbCxcbiAgICAgIGNvbXB1dGVkQm9keVBhZGRpbmdSaWdodDogMCxcbiAgICAgIHdpdGhvdXRIaWRkZW5DbGFzczogdHJ1ZSxcbiAgICAgIHJlbmRlcmVkOiBmYWxzZVxuICAgIH07XG4gIH0sXG5cblxuICB3YXRjaDoge1xuICAgIHZpc2libGU6IGZ1bmN0aW9uIHZpc2libGUodmFsKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcGVuaW5nKSByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJlZCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICAgICAgICAgIF92dWUyLmRlZmF1bHQubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMub3BlbigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMucmVuZGVyZWQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wcyA9ICgwLCBfbWVyZ2UyLmRlZmF1bHQpKHt9LCB0aGlzLiRwcm9wcyB8fCB0aGlzLCBvcHRpb25zKTtcblxuICAgICAgaWYgKHRoaXMuX2Nsb3NlVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Nsb3NlVGltZXIpO1xuICAgICAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9vcGVuVGltZXIpO1xuXG4gICAgICB2YXIgb3BlbkRlbGF5ID0gTnVtYmVyKHByb3BzLm9wZW5EZWxheSk7XG4gICAgICBpZiAob3BlbkRlbGF5ID4gMCkge1xuICAgICAgICB0aGlzLl9vcGVuVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIuX29wZW5UaW1lciA9IG51bGw7XG4gICAgICAgICAgX3RoaXMyLmRvT3Blbihwcm9wcyk7XG4gICAgICAgIH0sIG9wZW5EZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRvT3Blbihwcm9wcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkb09wZW46IGZ1bmN0aW9uIGRvT3Blbihwcm9wcykge1xuICAgICAgaWYgKHRoaXMuJGlzU2VydmVyKSByZXR1cm47XG4gICAgICBpZiAodGhpcy53aWxsT3BlbiAmJiAhdGhpcy53aWxsT3BlbigpKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5vcGVuZWQpIHJldHVybjtcblxuICAgICAgdGhpcy5fb3BlbmluZyA9IHRydWU7XG5cbiAgICAgIHZhciBkb20gPSB0aGlzLiRlbDtcblxuICAgICAgdmFyIG1vZGFsID0gcHJvcHMubW9kYWw7XG5cbiAgICAgIHZhciB6SW5kZXggPSBwcm9wcy56SW5kZXg7XG4gICAgICBpZiAoekluZGV4KSB7XG4gICAgICAgIF9wb3B1cE1hbmFnZXIyLmRlZmF1bHQuekluZGV4ID0gekluZGV4O1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kYWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NpbmcpIHtcbiAgICAgICAgICBfcG9wdXBNYW5hZ2VyMi5kZWZhdWx0LmNsb3NlTW9kYWwodGhpcy5fcG9wdXBJZCk7XG4gICAgICAgICAgdGhpcy5fY2xvc2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIF9wb3B1cE1hbmFnZXIyLmRlZmF1bHQub3Blbk1vZGFsKHRoaXMuX3BvcHVwSWQsIF9wb3B1cE1hbmFnZXIyLmRlZmF1bHQubmV4dFpJbmRleCgpLCB0aGlzLm1vZGFsQXBwZW5kVG9Cb2R5ID8gdW5kZWZpbmVkIDogZG9tLCBwcm9wcy5tb2RhbENsYXNzLCBwcm9wcy5tb2RhbEZhZGUpO1xuICAgICAgICBpZiAocHJvcHMubG9ja1Njcm9sbCkge1xuICAgICAgICAgIHRoaXMud2l0aG91dEhpZGRlbkNsYXNzID0gISgwLCBfZG9tLmhhc0NsYXNzKShkb2N1bWVudC5ib2R5LCAnZWwtcG9wdXAtcGFyZW50LS1oaWRkZW4nKTtcbiAgICAgICAgICBpZiAodGhpcy53aXRob3V0SGlkZGVuQ2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keVBhZGRpbmdSaWdodCA9IGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0O1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlZEJvZHlQYWRkaW5nUmlnaHQgPSBwYXJzZUludCgoMCwgX2RvbS5nZXRTdHlsZSkoZG9jdW1lbnQuYm9keSwgJ3BhZGRpbmdSaWdodCcpLCAxMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNjcm9sbEJhcldpZHRoID0gKDAsIF9zY3JvbGxiYXJXaWR0aDIuZGVmYXVsdCkoKTtcbiAgICAgICAgICB2YXIgYm9keUhhc092ZXJmbG93ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA8IGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgIHZhciBib2R5T3ZlcmZsb3dZID0gKDAsIF9kb20uZ2V0U3R5bGUpKGRvY3VtZW50LmJvZHksICdvdmVyZmxvd1knKTtcbiAgICAgICAgICBpZiAoc2Nyb2xsQmFyV2lkdGggPiAwICYmIChib2R5SGFzT3ZlcmZsb3cgfHwgYm9keU92ZXJmbG93WSA9PT0gJ3Njcm9sbCcpICYmIHRoaXMud2l0aG91dEhpZGRlbkNsYXNzKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IHRoaXMuY29tcHV0ZWRCb2R5UGFkZGluZ1JpZ2h0ICsgc2Nyb2xsQmFyV2lkdGggKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoMCwgX2RvbS5hZGRDbGFzcykoZG9jdW1lbnQuYm9keSwgJ2VsLXBvcHVwLXBhcmVudC0taGlkZGVuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUoZG9tKS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgZG9tLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIH1cblxuICAgICAgZG9tLnN0eWxlLnpJbmRleCA9IF9wb3B1cE1hbmFnZXIyLmRlZmF1bHQubmV4dFpJbmRleCgpO1xuICAgICAgdGhpcy5vcGVuZWQgPSB0cnVlO1xuXG4gICAgICB0aGlzLm9uT3BlbiAmJiB0aGlzLm9uT3BlbigpO1xuXG4gICAgICB0aGlzLmRvQWZ0ZXJPcGVuKCk7XG4gICAgfSxcbiAgICBkb0FmdGVyT3BlbjogZnVuY3Rpb24gZG9BZnRlck9wZW4oKSB7XG4gICAgICB0aGlzLl9vcGVuaW5nID0gZmFsc2U7XG4gICAgfSxcbiAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMud2lsbENsb3NlICYmICF0aGlzLndpbGxDbG9zZSgpKSByZXR1cm47XG5cbiAgICAgIGlmICh0aGlzLl9vcGVuVGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX29wZW5UaW1lcik7XG4gICAgICAgIHRoaXMuX29wZW5UaW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fY2xvc2VUaW1lcik7XG5cbiAgICAgIHZhciBjbG9zZURlbGF5ID0gTnVtYmVyKHRoaXMuY2xvc2VEZWxheSk7XG5cbiAgICAgIGlmIChjbG9zZURlbGF5ID4gMCkge1xuICAgICAgICB0aGlzLl9jbG9zZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMzLl9jbG9zZVRpbWVyID0gbnVsbDtcbiAgICAgICAgICBfdGhpczMuZG9DbG9zZSgpO1xuICAgICAgICB9LCBjbG9zZURlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZG9DbG9zZTogZnVuY3Rpb24gZG9DbG9zZSgpIHtcbiAgICAgIHRoaXMuX2Nsb3NpbmcgPSB0cnVlO1xuXG4gICAgICB0aGlzLm9uQ2xvc2UgJiYgdGhpcy5vbkNsb3NlKCk7XG5cbiAgICAgIGlmICh0aGlzLmxvY2tTY3JvbGwpIHtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnJlc3RvcmVCb2R5U3R5bGUsIDIwMCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3BlbmVkID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuZG9BZnRlckNsb3NlKCk7XG4gICAgfSxcbiAgICBkb0FmdGVyQ2xvc2U6IGZ1bmN0aW9uIGRvQWZ0ZXJDbG9zZSgpIHtcbiAgICAgIF9wb3B1cE1hbmFnZXIyLmRlZmF1bHQuY2xvc2VNb2RhbCh0aGlzLl9wb3B1cElkKTtcbiAgICAgIHRoaXMuX2Nsb3NpbmcgPSBmYWxzZTtcbiAgICB9LFxuICAgIHJlc3RvcmVCb2R5U3R5bGU6IGZ1bmN0aW9uIHJlc3RvcmVCb2R5U3R5bGUoKSB7XG4gICAgICBpZiAodGhpcy5tb2RhbCAmJiB0aGlzLndpdGhvdXRIaWRkZW5DbGFzcykge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IHRoaXMuYm9keVBhZGRpbmdSaWdodDtcbiAgICAgICAgKDAsIF9kb20ucmVtb3ZlQ2xhc3MpKGRvY3VtZW50LmJvZHksICdlbC1wb3B1cC1wYXJlbnQtLWhpZGRlbicpO1xuICAgICAgfVxuICAgICAgdGhpcy53aXRob3V0SGlkZGVuQ2xhc3MgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcbmV4cG9ydHMuUG9wdXBNYW5hZ2VyID0gX3BvcHVwTWFuYWdlcjIuZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVtZW50LXVpL2xpYi91dGlscy9wb3B1cC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///23\n");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nexports.default = function (target) {\n  for (var i = 1, j = arguments.length; i < j; i++) {\n    var source = arguments[i] || {};\n    for (var prop in source) {\n      if (source.hasOwnProperty(prop)) {\n        var value = source[prop];\n        if (value !== undefined) {\n          target[prop] = value;\n        }\n      }\n    }\n  }\n\n  return target;\n};\n\n;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvbWVyZ2UuanM/OGU2NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMSwgaiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldIHx8IHt9O1xuICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvbWVyZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///24\n");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _vue = __webpack_require__(0);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _dom = __webpack_require__(6);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar hasModal = false;\nvar hasInitZIndex = false;\nvar zIndex = void 0;\n\nvar getModal = function getModal() {\n  if (_vue2.default.prototype.$isServer) return;\n  var modalDom = PopupManager.modalDom;\n  if (modalDom) {\n    hasModal = true;\n  } else {\n    hasModal = false;\n    modalDom = document.createElement('div');\n    PopupManager.modalDom = modalDom;\n\n    modalDom.addEventListener('touchmove', function (event) {\n      event.preventDefault();\n      event.stopPropagation();\n    });\n\n    modalDom.addEventListener('click', function () {\n      PopupManager.doOnModalClick && PopupManager.doOnModalClick();\n    });\n  }\n\n  return modalDom;\n};\n\nvar instances = {};\n\nvar PopupManager = {\n  modalFade: true,\n\n  getInstance: function getInstance(id) {\n    return instances[id];\n  },\n\n  register: function register(id, instance) {\n    if (id && instance) {\n      instances[id] = instance;\n    }\n  },\n\n  deregister: function deregister(id) {\n    if (id) {\n      instances[id] = null;\n      delete instances[id];\n    }\n  },\n\n  nextZIndex: function nextZIndex() {\n    return PopupManager.zIndex++;\n  },\n\n  modalStack: [],\n\n  doOnModalClick: function doOnModalClick() {\n    var topItem = PopupManager.modalStack[PopupManager.modalStack.length - 1];\n    if (!topItem) return;\n\n    var instance = PopupManager.getInstance(topItem.id);\n    if (instance && instance.closeOnClickModal) {\n      instance.close();\n    }\n  },\n\n  openModal: function openModal(id, zIndex, dom, modalClass, modalFade) {\n    if (_vue2.default.prototype.$isServer) return;\n    if (!id || zIndex === undefined) return;\n    this.modalFade = modalFade;\n\n    var modalStack = this.modalStack;\n\n    for (var i = 0, j = modalStack.length; i < j; i++) {\n      var item = modalStack[i];\n      if (item.id === id) {\n        return;\n      }\n    }\n\n    var modalDom = getModal();\n\n    (0, _dom.addClass)(modalDom, 'v-modal');\n    if (this.modalFade && !hasModal) {\n      (0, _dom.addClass)(modalDom, 'v-modal-enter');\n    }\n    if (modalClass) {\n      var classArr = modalClass.trim().split(/\\s+/);\n      classArr.forEach(function (item) {\n        return (0, _dom.addClass)(modalDom, item);\n      });\n    }\n    setTimeout(function () {\n      (0, _dom.removeClass)(modalDom, 'v-modal-enter');\n    }, 200);\n\n    if (dom && dom.parentNode && dom.parentNode.nodeType !== 11) {\n      dom.parentNode.appendChild(modalDom);\n    } else {\n      document.body.appendChild(modalDom);\n    }\n\n    if (zIndex) {\n      modalDom.style.zIndex = zIndex;\n    }\n    modalDom.tabIndex = 0;\n    modalDom.style.display = '';\n\n    this.modalStack.push({ id: id, zIndex: zIndex, modalClass: modalClass });\n  },\n\n  closeModal: function closeModal(id) {\n    var modalStack = this.modalStack;\n    var modalDom = getModal();\n\n    if (modalStack.length > 0) {\n      var topItem = modalStack[modalStack.length - 1];\n      if (topItem.id === id) {\n        if (topItem.modalClass) {\n          var classArr = topItem.modalClass.trim().split(/\\s+/);\n          classArr.forEach(function (item) {\n            return (0, _dom.removeClass)(modalDom, item);\n          });\n        }\n\n        modalStack.pop();\n        if (modalStack.length > 0) {\n          modalDom.style.zIndex = modalStack[modalStack.length - 1].zIndex;\n        }\n      } else {\n        for (var i = modalStack.length - 1; i >= 0; i--) {\n          if (modalStack[i].id === id) {\n            modalStack.splice(i, 1);\n            break;\n          }\n        }\n      }\n    }\n\n    if (modalStack.length === 0) {\n      if (this.modalFade) {\n        (0, _dom.addClass)(modalDom, 'v-modal-leave');\n      }\n      setTimeout(function () {\n        if (modalStack.length === 0) {\n          if (modalDom.parentNode) modalDom.parentNode.removeChild(modalDom);\n          modalDom.style.display = 'none';\n          PopupManager.modalDom = undefined;\n        }\n        (0, _dom.removeClass)(modalDom, 'v-modal-leave');\n      }, 200);\n    }\n  }\n};\n\nObject.defineProperty(PopupManager, 'zIndex', {\n  configurable: true,\n  get: function get() {\n    if (!hasInitZIndex) {\n      zIndex = zIndex || (_vue2.default.prototype.$ELEMENT || {}).zIndex || 2000;\n      hasInitZIndex = true;\n    }\n    return zIndex;\n  },\n  set: function set(value) {\n    zIndex = value;\n  }\n});\n\nvar getTopPopup = function getTopPopup() {\n  if (_vue2.default.prototype.$isServer) return;\n  if (PopupManager.modalStack.length > 0) {\n    var topPopup = PopupManager.modalStack[PopupManager.modalStack.length - 1];\n    if (!topPopup) return;\n    var instance = PopupManager.getInstance(topPopup.id);\n\n    return instance;\n  }\n};\n\nif (!_vue2.default.prototype.$isServer) {\n  // handle `esc` key when the popup is shown\n  window.addEventListener('keydown', function (event) {\n    if (event.keyCode === 27) {\n      var topPopup = getTopPopup();\n\n      if (topPopup && topPopup.closeOnPressEscape) {\n        topPopup.handleClose ? topPopup.handleClose() : topPopup.handleAction ? topPopup.handleAction('cancel') : topPopup.close();\n      }\n    }\n  });\n}\n\nexports.default = PopupManager;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvcG9wdXAvcG9wdXAtbWFuYWdlci5qcz8zODBjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxDQUFLOztBQUV4Qjs7QUFFQSxXQUFXLG1CQUFPLENBQUMsQ0FBMEI7O0FBRTdDLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsaURBQWlEO0FBQzNFLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsImZpbGUiOiIyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF92dWUgPSByZXF1aXJlKCd2dWUnKTtcblxudmFyIF92dWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdnVlKTtcblxudmFyIF9kb20gPSByZXF1aXJlKCdlbGVtZW50LXVpL2xpYi91dGlscy9kb20nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGhhc01vZGFsID0gZmFsc2U7XG52YXIgaGFzSW5pdFpJbmRleCA9IGZhbHNlO1xudmFyIHpJbmRleCA9IHZvaWQgMDtcblxudmFyIGdldE1vZGFsID0gZnVuY3Rpb24gZ2V0TW9kYWwoKSB7XG4gIGlmIChfdnVlMi5kZWZhdWx0LnByb3RvdHlwZS4kaXNTZXJ2ZXIpIHJldHVybjtcbiAgdmFyIG1vZGFsRG9tID0gUG9wdXBNYW5hZ2VyLm1vZGFsRG9tO1xuICBpZiAobW9kYWxEb20pIHtcbiAgICBoYXNNb2RhbCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgaGFzTW9kYWwgPSBmYWxzZTtcbiAgICBtb2RhbERvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIFBvcHVwTWFuYWdlci5tb2RhbERvbSA9IG1vZGFsRG9tO1xuXG4gICAgbW9kYWxEb20uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG5cbiAgICBtb2RhbERvbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIFBvcHVwTWFuYWdlci5kb09uTW9kYWxDbGljayAmJiBQb3B1cE1hbmFnZXIuZG9Pbk1vZGFsQ2xpY2soKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBtb2RhbERvbTtcbn07XG5cbnZhciBpbnN0YW5jZXMgPSB7fTtcblxudmFyIFBvcHVwTWFuYWdlciA9IHtcbiAgbW9kYWxGYWRlOiB0cnVlLFxuXG4gIGdldEluc3RhbmNlOiBmdW5jdGlvbiBnZXRJbnN0YW5jZShpZCkge1xuICAgIHJldHVybiBpbnN0YW5jZXNbaWRdO1xuICB9LFxuXG4gIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihpZCwgaW5zdGFuY2UpIHtcbiAgICBpZiAoaWQgJiYgaW5zdGFuY2UpIHtcbiAgICAgIGluc3RhbmNlc1tpZF0gPSBpbnN0YW5jZTtcbiAgICB9XG4gIH0sXG5cbiAgZGVyZWdpc3RlcjogZnVuY3Rpb24gZGVyZWdpc3RlcihpZCkge1xuICAgIGlmIChpZCkge1xuICAgICAgaW5zdGFuY2VzW2lkXSA9IG51bGw7XG4gICAgICBkZWxldGUgaW5zdGFuY2VzW2lkXTtcbiAgICB9XG4gIH0sXG5cbiAgbmV4dFpJbmRleDogZnVuY3Rpb24gbmV4dFpJbmRleCgpIHtcbiAgICByZXR1cm4gUG9wdXBNYW5hZ2VyLnpJbmRleCsrO1xuICB9LFxuXG4gIG1vZGFsU3RhY2s6IFtdLFxuXG4gIGRvT25Nb2RhbENsaWNrOiBmdW5jdGlvbiBkb09uTW9kYWxDbGljaygpIHtcbiAgICB2YXIgdG9wSXRlbSA9IFBvcHVwTWFuYWdlci5tb2RhbFN0YWNrW1BvcHVwTWFuYWdlci5tb2RhbFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGlmICghdG9wSXRlbSkgcmV0dXJuO1xuXG4gICAgdmFyIGluc3RhbmNlID0gUG9wdXBNYW5hZ2VyLmdldEluc3RhbmNlKHRvcEl0ZW0uaWQpO1xuICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5jbG9zZU9uQ2xpY2tNb2RhbCkge1xuICAgICAgaW5zdGFuY2UuY2xvc2UoKTtcbiAgICB9XG4gIH0sXG5cbiAgb3Blbk1vZGFsOiBmdW5jdGlvbiBvcGVuTW9kYWwoaWQsIHpJbmRleCwgZG9tLCBtb2RhbENsYXNzLCBtb2RhbEZhZGUpIHtcbiAgICBpZiAoX3Z1ZTIuZGVmYXVsdC5wcm90b3R5cGUuJGlzU2VydmVyKSByZXR1cm47XG4gICAgaWYgKCFpZCB8fCB6SW5kZXggPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIHRoaXMubW9kYWxGYWRlID0gbW9kYWxGYWRlO1xuXG4gICAgdmFyIG1vZGFsU3RhY2sgPSB0aGlzLm1vZGFsU3RhY2s7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IG1vZGFsU3RhY2subGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IG1vZGFsU3RhY2tbaV07XG4gICAgICBpZiAoaXRlbS5pZCA9PT0gaWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtb2RhbERvbSA9IGdldE1vZGFsKCk7XG5cbiAgICAoMCwgX2RvbS5hZGRDbGFzcykobW9kYWxEb20sICd2LW1vZGFsJyk7XG4gICAgaWYgKHRoaXMubW9kYWxGYWRlICYmICFoYXNNb2RhbCkge1xuICAgICAgKDAsIF9kb20uYWRkQ2xhc3MpKG1vZGFsRG9tLCAndi1tb2RhbC1lbnRlcicpO1xuICAgIH1cbiAgICBpZiAobW9kYWxDbGFzcykge1xuICAgICAgdmFyIGNsYXNzQXJyID0gbW9kYWxDbGFzcy50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgICAgIGNsYXNzQXJyLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICgwLCBfZG9tLmFkZENsYXNzKShtb2RhbERvbSwgaXRlbSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAoMCwgX2RvbS5yZW1vdmVDbGFzcykobW9kYWxEb20sICd2LW1vZGFsLWVudGVyJyk7XG4gICAgfSwgMjAwKTtcblxuICAgIGlmIChkb20gJiYgZG9tLnBhcmVudE5vZGUgJiYgZG9tLnBhcmVudE5vZGUubm9kZVR5cGUgIT09IDExKSB7XG4gICAgICBkb20ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChtb2RhbERvbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobW9kYWxEb20pO1xuICAgIH1cblxuICAgIGlmICh6SW5kZXgpIHtcbiAgICAgIG1vZGFsRG9tLnN0eWxlLnpJbmRleCA9IHpJbmRleDtcbiAgICB9XG4gICAgbW9kYWxEb20udGFiSW5kZXggPSAwO1xuICAgIG1vZGFsRG9tLnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgIHRoaXMubW9kYWxTdGFjay5wdXNoKHsgaWQ6IGlkLCB6SW5kZXg6IHpJbmRleCwgbW9kYWxDbGFzczogbW9kYWxDbGFzcyB9KTtcbiAgfSxcblxuICBjbG9zZU1vZGFsOiBmdW5jdGlvbiBjbG9zZU1vZGFsKGlkKSB7XG4gICAgdmFyIG1vZGFsU3RhY2sgPSB0aGlzLm1vZGFsU3RhY2s7XG4gICAgdmFyIG1vZGFsRG9tID0gZ2V0TW9kYWwoKTtcblxuICAgIGlmIChtb2RhbFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciB0b3BJdGVtID0gbW9kYWxTdGFja1ttb2RhbFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHRvcEl0ZW0uaWQgPT09IGlkKSB7XG4gICAgICAgIGlmICh0b3BJdGVtLm1vZGFsQ2xhc3MpIHtcbiAgICAgICAgICB2YXIgY2xhc3NBcnIgPSB0b3BJdGVtLm1vZGFsQ2xhc3MudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgY2xhc3NBcnIuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfZG9tLnJlbW92ZUNsYXNzKShtb2RhbERvbSwgaXRlbSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBtb2RhbFN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAobW9kYWxTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbW9kYWxEb20uc3R5bGUuekluZGV4ID0gbW9kYWxTdGFja1ttb2RhbFN0YWNrLmxlbmd0aCAtIDFdLnpJbmRleDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IG1vZGFsU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobW9kYWxTdGFja1tpXS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIG1vZGFsU3RhY2suc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZGFsU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5tb2RhbEZhZGUpIHtcbiAgICAgICAgKDAsIF9kb20uYWRkQ2xhc3MpKG1vZGFsRG9tLCAndi1tb2RhbC1sZWF2ZScpO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtb2RhbFN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmIChtb2RhbERvbS5wYXJlbnROb2RlKSBtb2RhbERvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG1vZGFsRG9tKTtcbiAgICAgICAgICBtb2RhbERvbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIFBvcHVwTWFuYWdlci5tb2RhbERvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAoMCwgX2RvbS5yZW1vdmVDbGFzcykobW9kYWxEb20sICd2LW1vZGFsLWxlYXZlJyk7XG4gICAgICB9LCAyMDApO1xuICAgIH1cbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvcHVwTWFuYWdlciwgJ3pJbmRleCcsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAoIWhhc0luaXRaSW5kZXgpIHtcbiAgICAgIHpJbmRleCA9IHpJbmRleCB8fCAoX3Z1ZTIuZGVmYXVsdC5wcm90b3R5cGUuJEVMRU1FTlQgfHwge30pLnpJbmRleCB8fCAyMDAwO1xuICAgICAgaGFzSW5pdFpJbmRleCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB6SW5kZXg7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgekluZGV4ID0gdmFsdWU7XG4gIH1cbn0pO1xuXG52YXIgZ2V0VG9wUG9wdXAgPSBmdW5jdGlvbiBnZXRUb3BQb3B1cCgpIHtcbiAgaWYgKF92dWUyLmRlZmF1bHQucHJvdG90eXBlLiRpc1NlcnZlcikgcmV0dXJuO1xuICBpZiAoUG9wdXBNYW5hZ2VyLm1vZGFsU3RhY2subGVuZ3RoID4gMCkge1xuICAgIHZhciB0b3BQb3B1cCA9IFBvcHVwTWFuYWdlci5tb2RhbFN0YWNrW1BvcHVwTWFuYWdlci5tb2RhbFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGlmICghdG9wUG9wdXApIHJldHVybjtcbiAgICB2YXIgaW5zdGFuY2UgPSBQb3B1cE1hbmFnZXIuZ2V0SW5zdGFuY2UodG9wUG9wdXAuaWQpO1xuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG59O1xuXG5pZiAoIV92dWUyLmRlZmF1bHQucHJvdG90eXBlLiRpc1NlcnZlcikge1xuICAvLyBoYW5kbGUgYGVzY2Aga2V5IHdoZW4gdGhlIHBvcHVwIGlzIHNob3duXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICB2YXIgdG9wUG9wdXAgPSBnZXRUb3BQb3B1cCgpO1xuXG4gICAgICBpZiAodG9wUG9wdXAgJiYgdG9wUG9wdXAuY2xvc2VPblByZXNzRXNjYXBlKSB7XG4gICAgICAgIHRvcFBvcHVwLmhhbmRsZUNsb3NlID8gdG9wUG9wdXAuaGFuZGxlQ2xvc2UoKSA6IHRvcFBvcHVwLmhhbmRsZUFjdGlvbiA/IHRvcFBvcHVwLmhhbmRsZUFjdGlvbignY2FuY2VsJykgOiB0b3BQb3B1cC5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFBvcHVwTWFuYWdlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVtZW50LXVpL2xpYi91dGlscy9wb3B1cC9wb3B1cC1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///25\n");

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nexports.default = function () {\n  if (_vue2.default.prototype.$isServer) return 0;\n  if (scrollBarWidth !== undefined) return scrollBarWidth;\n\n  var outer = document.createElement('div');\n  outer.className = 'el-scrollbar__wrap';\n  outer.style.visibility = 'hidden';\n  outer.style.width = '100px';\n  outer.style.position = 'absolute';\n  outer.style.top = '-9999px';\n  document.body.appendChild(outer);\n\n  var widthNoScroll = outer.offsetWidth;\n  outer.style.overflow = 'scroll';\n\n  var inner = document.createElement('div');\n  inner.style.width = '100%';\n  outer.appendChild(inner);\n\n  var widthWithScroll = inner.offsetWidth;\n  outer.parentNode.removeChild(outer);\n  scrollBarWidth = widthNoScroll - widthWithScroll;\n\n  return scrollBarWidth;\n};\n\nvar _vue = __webpack_require__(0);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar scrollBarWidth = void 0;\n\n;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvc2Nyb2xsYmFyLXdpZHRoLmpzP2U5M2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxDQUFLOztBQUV4Qjs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7O0FBRUEiLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF92dWUyLmRlZmF1bHQucHJvdG90eXBlLiRpc1NlcnZlcikgcmV0dXJuIDA7XG4gIGlmIChzY3JvbGxCYXJXaWR0aCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gc2Nyb2xsQmFyV2lkdGg7XG5cbiAgdmFyIG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG91dGVyLmNsYXNzTmFtZSA9ICdlbC1zY3JvbGxiYXJfX3dyYXAnO1xuICBvdXRlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIG91dGVyLnN0eWxlLndpZHRoID0gJzEwMHB4JztcbiAgb3V0ZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBvdXRlci5zdHlsZS50b3AgPSAnLTk5OTlweCc7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXIpO1xuXG4gIHZhciB3aWR0aE5vU2Nyb2xsID0gb3V0ZXIub2Zmc2V0V2lkdGg7XG4gIG91dGVyLnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XG5cbiAgdmFyIGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGlubmVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICBvdXRlci5hcHBlbmRDaGlsZChpbm5lcik7XG5cbiAgdmFyIHdpZHRoV2l0aFNjcm9sbCA9IGlubmVyLm9mZnNldFdpZHRoO1xuICBvdXRlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG91dGVyKTtcbiAgc2Nyb2xsQmFyV2lkdGggPSB3aWR0aE5vU2Nyb2xsIC0gd2lkdGhXaXRoU2Nyb2xsO1xuXG4gIHJldHVybiBzY3JvbGxCYXJXaWR0aDtcbn07XG5cbnZhciBfdnVlID0gcmVxdWlyZSgndnVlJyk7XG5cbnZhciBfdnVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Z1ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBzY3JvbGxCYXJXaWR0aCA9IHZvaWQgMDtcblxuO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvbGliL3V0aWxzL3Njcm9sbGJhci13aWR0aC5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26\n");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nfunction _broadcast(componentName, eventName, params) {\n  this.$children.forEach(function (child) {\n    var name = child.$options.componentName;\n\n    if (name === componentName) {\n      child.$emit.apply(child, [eventName].concat(params));\n    } else {\n      _broadcast.apply(child, [componentName, eventName].concat([params]));\n    }\n  });\n}\nexports.default = {\n  methods: {\n    dispatch: function dispatch(componentName, eventName, params) {\n      var parent = this.$parent || this.$root;\n      var name = parent.$options.componentName;\n\n      while (parent && (!name || name !== componentName)) {\n        parent = parent.$parent;\n\n        if (parent) {\n          name = parent.$options.componentName;\n        }\n      }\n      if (parent) {\n        parent.$emit.apply(parent, [eventName].concat(params));\n      }\n    },\n    broadcast: function broadcast(componentName, eventName, params) {\n      _broadcast.call(this, componentName, eventName, params);\n    }\n  }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvbWl4aW5zL2VtaXR0ZXIuanM/N2NmOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZnVuY3Rpb24gX2Jyb2FkY2FzdChjb21wb25lbnROYW1lLCBldmVudE5hbWUsIHBhcmFtcykge1xuICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHZhciBuYW1lID0gY2hpbGQuJG9wdGlvbnMuY29tcG9uZW50TmFtZTtcblxuICAgIGlmIChuYW1lID09PSBjb21wb25lbnROYW1lKSB7XG4gICAgICBjaGlsZC4kZW1pdC5hcHBseShjaGlsZCwgW2V2ZW50TmFtZV0uY29uY2F0KHBhcmFtcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYnJvYWRjYXN0LmFwcGx5KGNoaWxkLCBbY29tcG9uZW50TmFtZSwgZXZlbnROYW1lXS5jb25jYXQoW3BhcmFtc10pKTtcbiAgICB9XG4gIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBtZXRob2RzOiB7XG4gICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIGRpc3BhdGNoKGNvbXBvbmVudE5hbWUsIGV2ZW50TmFtZSwgcGFyYW1zKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy4kcGFyZW50IHx8IHRoaXMuJHJvb3Q7XG4gICAgICB2YXIgbmFtZSA9IHBhcmVudC4kb3B0aW9ucy5jb21wb25lbnROYW1lO1xuXG4gICAgICB3aGlsZSAocGFyZW50ICYmICghbmFtZSB8fCBuYW1lICE9PSBjb21wb25lbnROYW1lKSkge1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgbmFtZSA9IHBhcmVudC4kb3B0aW9ucy5jb21wb25lbnROYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC4kZW1pdC5hcHBseShwYXJlbnQsIFtldmVudE5hbWVdLmNvbmNhdChwYXJhbXMpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGJyb2FkY2FzdDogZnVuY3Rpb24gYnJvYWRjYXN0KGNvbXBvbmVudE5hbWUsIGV2ZW50TmFtZSwgcGFyYW1zKSB7XG4gICAgICBfYnJvYWRjYXN0LmNhbGwodGhpcywgY29tcG9uZW50TmFtZSwgZXZlbnROYW1lLCBwYXJhbXMpO1xuICAgIH1cbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVtZW50LXVpL2xpYi9taXhpbnMvZW1pdHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///27\n");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(29);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(2)(\"1b794c9e\", content, false, {});\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../../../css-loader/index.js!./base.css\", function() {\n     var newContent = require(\"!!../../../css-loader/index.js!./base.css\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdGhlbWUtY2hhbGsvYmFzZS5jc3M/ZWZiOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxFQUEyQztBQUNqRSw0Q0FBNEMsUUFBUztBQUNyRDtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLENBQW1ELGdDQUFnQztBQUN4RztBQUNBLEdBQUcsS0FBVTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYmFzZS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiMWI3OTRjOWVcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9iYXNlLmNzc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYmFzZS5jc3NcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvbGliL3RoZW1lLWNoYWxrL2Jhc2UuY3NzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///28\n");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

eval("var escape = __webpack_require__(30);\nexports = module.exports = __webpack_require__(1)(false);\n// imports\n\n\n// module\nexports.push([module.i, \".el-fade-in-enter,.el-fade-in-leave-active,.el-fade-in-linear-enter,.el-fade-in-linear-leave,.el-fade-in-linear-leave-active,.fade-in-linear-enter,.fade-in-linear-leave,.fade-in-linear-leave-active{opacity:0}.fade-in-linear-enter-active,.fade-in-linear-leave-active{-webkit-transition:opacity .2s linear;transition:opacity .2s linear}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{-webkit-transition:opacity .2s linear;transition:opacity .2s linear}.el-fade-in-enter-active,.el-fade-in-leave-active{-webkit-transition:all .3s cubic-bezier(.55,0,.1,1);transition:all .3s cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{-webkit-transition:all .3s cubic-bezier(.55,0,.1,1);transition:all .3s cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter,.el-zoom-in-center-leave-active{opacity:0;-webkit-transform:scaleX(0);transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;-webkit-transform:scaleY(1);transform:scaleY(1);-webkit-transition:opacity .3s cubic-bezier(.23,1,.32,1),-webkit-transform .3s cubic-bezier(.23,1,.32,1);transition:opacity .3s cubic-bezier(.23,1,.32,1),-webkit-transform .3s cubic-bezier(.23,1,.32,1);transition:transform .3s cubic-bezier(.23,1,.32,1),opacity .3s cubic-bezier(.23,1,.32,1);transition:transform .3s cubic-bezier(.23,1,.32,1),opacity .3s cubic-bezier(.23,1,.32,1),-webkit-transform .3s cubic-bezier(.23,1,.32,1);-webkit-transform-origin:center top;transform-origin:center top}.el-zoom-in-top-enter,.el-zoom-in-top-leave-active{opacity:0;-webkit-transform:scaleY(0);transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;-webkit-transform:scaleY(1);transform:scaleY(1);-webkit-transition:opacity .3s cubic-bezier(.23,1,.32,1),-webkit-transform .3s cubic-bezier(.23,1,.32,1);transition:opacity .3s cubic-bezier(.23,1,.32,1),-webkit-transform .3s cubic-bezier(.23,1,.32,1);transition:transform .3s cubic-bezier(.23,1,.32,1),opacity .3s cubic-bezier(.23,1,.32,1);transition:transform .3s cubic-bezier(.23,1,.32,1),opacity .3s cubic-bezier(.23,1,.32,1),-webkit-transform .3s cubic-bezier(.23,1,.32,1);-webkit-transform-origin:center bottom;transform-origin:center bottom}.el-zoom-in-bottom-enter,.el-zoom-in-bottom-leave-active{opacity:0;-webkit-transform:scaleY(0);transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;-webkit-transform:scale(1,1);transform:scale(1,1);-webkit-transition:opacity .3s cubic-bezier(.23,1,.32,1),-webkit-transform .3s cubic-bezier(.23,1,.32,1);transition:opacity .3s cubic-bezier(.23,1,.32,1),-webkit-transform .3s cubic-bezier(.23,1,.32,1);transition:transform .3s cubic-bezier(.23,1,.32,1),opacity .3s cubic-bezier(.23,1,.32,1);transition:transform .3s cubic-bezier(.23,1,.32,1),opacity .3s cubic-bezier(.23,1,.32,1),-webkit-transform .3s cubic-bezier(.23,1,.32,1);-webkit-transform-origin:top left;transform-origin:top left}.el-zoom-in-left-enter,.el-zoom-in-left-leave-active{opacity:0;-webkit-transform:scale(.45,.45);transform:scale(.45,.45)}.collapse-transition{-webkit-transition:.3s height ease-in-out,.3s padding-top ease-in-out,.3s padding-bottom ease-in-out;transition:.3s height ease-in-out,.3s padding-top ease-in-out,.3s padding-bottom ease-in-out}.horizontal-collapse-transition{-webkit-transition:.3s width ease-in-out,.3s padding-left ease-in-out,.3s padding-right ease-in-out;transition:.3s width ease-in-out,.3s padding-left ease-in-out,.3s padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{-webkit-transition:all 1s;transition:all 1s}.el-list-enter,.el-list-leave-active{opacity:0;-webkit-transform:translateY(-30px);transform:translateY(-30px)}.el-opacity-transition{-webkit-transition:opacity .3s cubic-bezier(.55,0,.1,1);transition:opacity .3s cubic-bezier(.55,0,.1,1)}@font-face{font-family:element-icons;src:url(\" + escape(__webpack_require__(31)) + \") format(\\\"woff\\\"),url(\" + escape(__webpack_require__(32)) + \") format(\\\"truetype\\\");font-weight:400;font-display:\\\"auto\\\";font-style:normal}[class*=\\\" el-icon-\\\"],[class^=el-icon-]{font-family:element-icons!important;speak:none;font-style:normal;font-weight:400;font-variant:normal;text-transform:none;line-height:1;vertical-align:baseline;display:inline-block;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.el-icon-ice-cream-round:before{content:\\\"\\\\E6A0\\\"}.el-icon-ice-cream-square:before{content:\\\"\\\\E6A3\\\"}.el-icon-lollipop:before{content:\\\"\\\\E6A4\\\"}.el-icon-potato-strips:before{content:\\\"\\\\E6A5\\\"}.el-icon-milk-tea:before{content:\\\"\\\\E6A6\\\"}.el-icon-ice-drink:before{content:\\\"\\\\E6A7\\\"}.el-icon-ice-tea:before{content:\\\"\\\\E6A9\\\"}.el-icon-coffee:before{content:\\\"\\\\E6AA\\\"}.el-icon-orange:before{content:\\\"\\\\E6AB\\\"}.el-icon-pear:before{content:\\\"\\\\E6AC\\\"}.el-icon-apple:before{content:\\\"\\\\E6AD\\\"}.el-icon-cherry:before{content:\\\"\\\\E6AE\\\"}.el-icon-watermelon:before{content:\\\"\\\\E6AF\\\"}.el-icon-grape:before{content:\\\"\\\\E6B0\\\"}.el-icon-refrigerator:before{content:\\\"\\\\E6B1\\\"}.el-icon-goblet-square-full:before{content:\\\"\\\\E6B2\\\"}.el-icon-goblet-square:before{content:\\\"\\\\E6B3\\\"}.el-icon-goblet-full:before{content:\\\"\\\\E6B4\\\"}.el-icon-goblet:before{content:\\\"\\\\E6B5\\\"}.el-icon-cold-drink:before{content:\\\"\\\\E6B6\\\"}.el-icon-coffee-cup:before{content:\\\"\\\\E6B8\\\"}.el-icon-water-cup:before{content:\\\"\\\\E6B9\\\"}.el-icon-hot-water:before{content:\\\"\\\\E6BA\\\"}.el-icon-ice-cream:before{content:\\\"\\\\E6BB\\\"}.el-icon-dessert:before{content:\\\"\\\\E6BC\\\"}.el-icon-sugar:before{content:\\\"\\\\E6BD\\\"}.el-icon-tableware:before{content:\\\"\\\\E6BE\\\"}.el-icon-burger:before{content:\\\"\\\\E6BF\\\"}.el-icon-knife-fork:before{content:\\\"\\\\E6C1\\\"}.el-icon-fork-spoon:before{content:\\\"\\\\E6C2\\\"}.el-icon-chicken:before{content:\\\"\\\\E6C3\\\"}.el-icon-food:before{content:\\\"\\\\E6C4\\\"}.el-icon-dish-1:before{content:\\\"\\\\E6C5\\\"}.el-icon-dish:before{content:\\\"\\\\E6C6\\\"}.el-icon-moon-night:before{content:\\\"\\\\E6EE\\\"}.el-icon-moon:before{content:\\\"\\\\E6F0\\\"}.el-icon-cloudy-and-sunny:before{content:\\\"\\\\E6F1\\\"}.el-icon-partly-cloudy:before{content:\\\"\\\\E6F2\\\"}.el-icon-cloudy:before{content:\\\"\\\\E6F3\\\"}.el-icon-sunny:before{content:\\\"\\\\E6F6\\\"}.el-icon-sunset:before{content:\\\"\\\\E6F7\\\"}.el-icon-sunrise-1:before{content:\\\"\\\\E6F8\\\"}.el-icon-sunrise:before{content:\\\"\\\\E6F9\\\"}.el-icon-heavy-rain:before{content:\\\"\\\\E6FA\\\"}.el-icon-lightning:before{content:\\\"\\\\E6FB\\\"}.el-icon-light-rain:before{content:\\\"\\\\E6FC\\\"}.el-icon-wind-power:before{content:\\\"\\\\E6FD\\\"}.el-icon-baseball:before{content:\\\"\\\\E712\\\"}.el-icon-soccer:before{content:\\\"\\\\E713\\\"}.el-icon-football:before{content:\\\"\\\\E715\\\"}.el-icon-basketball:before{content:\\\"\\\\E716\\\"}.el-icon-ship:before{content:\\\"\\\\E73F\\\"}.el-icon-truck:before{content:\\\"\\\\E740\\\"}.el-icon-bicycle:before{content:\\\"\\\\E741\\\"}.el-icon-mobile-phone:before{content:\\\"\\\\E6D3\\\"}.el-icon-service:before{content:\\\"\\\\E6D4\\\"}.el-icon-key:before{content:\\\"\\\\E6E2\\\"}.el-icon-unlock:before{content:\\\"\\\\E6E4\\\"}.el-icon-lock:before{content:\\\"\\\\E6E5\\\"}.el-icon-watch:before{content:\\\"\\\\E6FE\\\"}.el-icon-watch-1:before{content:\\\"\\\\E6FF\\\"}.el-icon-timer:before{content:\\\"\\\\E702\\\"}.el-icon-alarm-clock:before{content:\\\"\\\\E703\\\"}.el-icon-map-location:before{content:\\\"\\\\E704\\\"}.el-icon-delete-location:before{content:\\\"\\\\E705\\\"}.el-icon-add-location:before{content:\\\"\\\\E706\\\"}.el-icon-location-information:before{content:\\\"\\\\E707\\\"}.el-icon-location-outline:before{content:\\\"\\\\E708\\\"}.el-icon-location:before{content:\\\"\\\\E79E\\\"}.el-icon-place:before{content:\\\"\\\\E709\\\"}.el-icon-discover:before{content:\\\"\\\\E70A\\\"}.el-icon-first-aid-kit:before{content:\\\"\\\\E70B\\\"}.el-icon-trophy-1:before{content:\\\"\\\\E70C\\\"}.el-icon-trophy:before{content:\\\"\\\\E70D\\\"}.el-icon-medal:before{content:\\\"\\\\E70E\\\"}.el-icon-medal-1:before{content:\\\"\\\\E70F\\\"}.el-icon-stopwatch:before{content:\\\"\\\\E710\\\"}.el-icon-mic:before{content:\\\"\\\\E711\\\"}.el-icon-copy-document:before{content:\\\"\\\\E718\\\"}.el-icon-full-screen:before{content:\\\"\\\\E719\\\"}.el-icon-switch-button:before{content:\\\"\\\\E71B\\\"}.el-icon-aim:before{content:\\\"\\\\E71C\\\"}.el-icon-crop:before{content:\\\"\\\\E71D\\\"}.el-icon-odometer:before{content:\\\"\\\\E71E\\\"}.el-icon-time:before{content:\\\"\\\\E71F\\\"}.el-icon-bangzhu:before{content:\\\"\\\\E724\\\"}.el-icon-close-notification:before{content:\\\"\\\\E726\\\"}.el-icon-microphone:before{content:\\\"\\\\E727\\\"}.el-icon-turn-off-microphone:before{content:\\\"\\\\E728\\\"}.el-icon-position:before{content:\\\"\\\\E729\\\"}.el-icon-postcard:before{content:\\\"\\\\E72A\\\"}.el-icon-message:before{content:\\\"\\\\E72B\\\"}.el-icon-chat-line-square:before{content:\\\"\\\\E72D\\\"}.el-icon-chat-dot-square:before{content:\\\"\\\\E72E\\\"}.el-icon-chat-dot-round:before{content:\\\"\\\\E72F\\\"}.el-icon-chat-square:before{content:\\\"\\\\E730\\\"}.el-icon-chat-line-round:before{content:\\\"\\\\E731\\\"}.el-icon-chat-round:before{content:\\\"\\\\E732\\\"}.el-icon-set-up:before{content:\\\"\\\\E733\\\"}.el-icon-turn-off:before{content:\\\"\\\\E734\\\"}.el-icon-open:before{content:\\\"\\\\E735\\\"}.el-icon-connection:before{content:\\\"\\\\E736\\\"}.el-icon-link:before{content:\\\"\\\\E737\\\"}.el-icon-cpu:before{content:\\\"\\\\E738\\\"}.el-icon-thumb:before{content:\\\"\\\\E739\\\"}.el-icon-female:before{content:\\\"\\\\E73A\\\"}.el-icon-male:before{content:\\\"\\\\E73B\\\"}.el-icon-guide:before{content:\\\"\\\\E73C\\\"}.el-icon-news:before{content:\\\"\\\\E73E\\\"}.el-icon-price-tag:before{content:\\\"\\\\E744\\\"}.el-icon-discount:before{content:\\\"\\\\E745\\\"}.el-icon-wallet:before{content:\\\"\\\\E747\\\"}.el-icon-coin:before{content:\\\"\\\\E748\\\"}.el-icon-money:before{content:\\\"\\\\E749\\\"}.el-icon-bank-card:before{content:\\\"\\\\E74A\\\"}.el-icon-box:before{content:\\\"\\\\E74B\\\"}.el-icon-present:before{content:\\\"\\\\E74C\\\"}.el-icon-sell:before{content:\\\"\\\\E6D5\\\"}.el-icon-sold-out:before{content:\\\"\\\\E6D6\\\"}.el-icon-shopping-bag-2:before{content:\\\"\\\\E74D\\\"}.el-icon-shopping-bag-1:before{content:\\\"\\\\E74E\\\"}.el-icon-shopping-cart-2:before{content:\\\"\\\\E74F\\\"}.el-icon-shopping-cart-1:before{content:\\\"\\\\E750\\\"}.el-icon-shopping-cart-full:before{content:\\\"\\\\E751\\\"}.el-icon-smoking:before{content:\\\"\\\\E752\\\"}.el-icon-no-smoking:before{content:\\\"\\\\E753\\\"}.el-icon-house:before{content:\\\"\\\\E754\\\"}.el-icon-table-lamp:before{content:\\\"\\\\E755\\\"}.el-icon-school:before{content:\\\"\\\\E756\\\"}.el-icon-office-building:before{content:\\\"\\\\E757\\\"}.el-icon-toilet-paper:before{content:\\\"\\\\E758\\\"}.el-icon-notebook-2:before{content:\\\"\\\\E759\\\"}.el-icon-notebook-1:before{content:\\\"\\\\E75A\\\"}.el-icon-files:before{content:\\\"\\\\E75B\\\"}.el-icon-collection:before{content:\\\"\\\\E75C\\\"}.el-icon-receiving:before{content:\\\"\\\\E75D\\\"}.el-icon-suitcase-1:before{content:\\\"\\\\E760\\\"}.el-icon-suitcase:before{content:\\\"\\\\E761\\\"}.el-icon-film:before{content:\\\"\\\\E763\\\"}.el-icon-collection-tag:before{content:\\\"\\\\E765\\\"}.el-icon-data-analysis:before{content:\\\"\\\\E766\\\"}.el-icon-pie-chart:before{content:\\\"\\\\E767\\\"}.el-icon-data-board:before{content:\\\"\\\\E768\\\"}.el-icon-data-line:before{content:\\\"\\\\E76D\\\"}.el-icon-reading:before{content:\\\"\\\\E769\\\"}.el-icon-magic-stick:before{content:\\\"\\\\E76A\\\"}.el-icon-coordinate:before{content:\\\"\\\\E76B\\\"}.el-icon-mouse:before{content:\\\"\\\\E76C\\\"}.el-icon-brush:before{content:\\\"\\\\E76E\\\"}.el-icon-headset:before{content:\\\"\\\\E76F\\\"}.el-icon-umbrella:before{content:\\\"\\\\E770\\\"}.el-icon-scissors:before{content:\\\"\\\\E771\\\"}.el-icon-mobile:before{content:\\\"\\\\E773\\\"}.el-icon-attract:before{content:\\\"\\\\E774\\\"}.el-icon-monitor:before{content:\\\"\\\\E775\\\"}.el-icon-search:before{content:\\\"\\\\E778\\\"}.el-icon-takeaway-box:before{content:\\\"\\\\E77A\\\"}.el-icon-paperclip:before{content:\\\"\\\\E77D\\\"}.el-icon-printer:before{content:\\\"\\\\E77E\\\"}.el-icon-document-add:before{content:\\\"\\\\E782\\\"}.el-icon-document:before{content:\\\"\\\\E785\\\"}.el-icon-document-checked:before{content:\\\"\\\\E786\\\"}.el-icon-document-copy:before{content:\\\"\\\\E787\\\"}.el-icon-document-delete:before{content:\\\"\\\\E788\\\"}.el-icon-document-remove:before{content:\\\"\\\\E789\\\"}.el-icon-tickets:before{content:\\\"\\\\E78B\\\"}.el-icon-folder-checked:before{content:\\\"\\\\E77F\\\"}.el-icon-folder-delete:before{content:\\\"\\\\E780\\\"}.el-icon-folder-remove:before{content:\\\"\\\\E781\\\"}.el-icon-folder-add:before{content:\\\"\\\\E783\\\"}.el-icon-folder-opened:before{content:\\\"\\\\E784\\\"}.el-icon-folder:before{content:\\\"\\\\E78A\\\"}.el-icon-edit-outline:before{content:\\\"\\\\E764\\\"}.el-icon-edit:before{content:\\\"\\\\E78C\\\"}.el-icon-date:before{content:\\\"\\\\E78E\\\"}.el-icon-c-scale-to-original:before{content:\\\"\\\\E7C6\\\"}.el-icon-view:before{content:\\\"\\\\E6CE\\\"}.el-icon-loading:before{content:\\\"\\\\E6CF\\\"}.el-icon-rank:before{content:\\\"\\\\E6D1\\\"}.el-icon-sort-down:before{content:\\\"\\\\E7C4\\\"}.el-icon-sort-up:before{content:\\\"\\\\E7C5\\\"}.el-icon-sort:before{content:\\\"\\\\E6D2\\\"}.el-icon-finished:before{content:\\\"\\\\E6CD\\\"}.el-icon-refresh-left:before{content:\\\"\\\\E6C7\\\"}.el-icon-refresh-right:before{content:\\\"\\\\E6C8\\\"}.el-icon-refresh:before{content:\\\"\\\\E6D0\\\"}.el-icon-video-play:before{content:\\\"\\\\E7C0\\\"}.el-icon-video-pause:before{content:\\\"\\\\E7C1\\\"}.el-icon-d-arrow-right:before{content:\\\"\\\\E6DC\\\"}.el-icon-d-arrow-left:before{content:\\\"\\\\E6DD\\\"}.el-icon-arrow-up:before{content:\\\"\\\\E6E1\\\"}.el-icon-arrow-down:before{content:\\\"\\\\E6DF\\\"}.el-icon-arrow-right:before{content:\\\"\\\\E6E0\\\"}.el-icon-arrow-left:before{content:\\\"\\\\E6DE\\\"}.el-icon-top-right:before{content:\\\"\\\\E6E7\\\"}.el-icon-top-left:before{content:\\\"\\\\E6E8\\\"}.el-icon-top:before{content:\\\"\\\\E6E6\\\"}.el-icon-bottom:before{content:\\\"\\\\E6EB\\\"}.el-icon-right:before{content:\\\"\\\\E6E9\\\"}.el-icon-back:before{content:\\\"\\\\E6EA\\\"}.el-icon-bottom-right:before{content:\\\"\\\\E6EC\\\"}.el-icon-bottom-left:before{content:\\\"\\\\E6ED\\\"}.el-icon-caret-top:before{content:\\\"\\\\E78F\\\"}.el-icon-caret-bottom:before{content:\\\"\\\\E790\\\"}.el-icon-caret-right:before{content:\\\"\\\\E791\\\"}.el-icon-caret-left:before{content:\\\"\\\\E792\\\"}.el-icon-d-caret:before{content:\\\"\\\\E79A\\\"}.el-icon-share:before{content:\\\"\\\\E793\\\"}.el-icon-menu:before{content:\\\"\\\\E798\\\"}.el-icon-s-grid:before{content:\\\"\\\\E7A6\\\"}.el-icon-s-check:before{content:\\\"\\\\E7A7\\\"}.el-icon-s-data:before{content:\\\"\\\\E7A8\\\"}.el-icon-s-opportunity:before{content:\\\"\\\\E7AA\\\"}.el-icon-s-custom:before{content:\\\"\\\\E7AB\\\"}.el-icon-s-claim:before{content:\\\"\\\\E7AD\\\"}.el-icon-s-finance:before{content:\\\"\\\\E7AE\\\"}.el-icon-s-comment:before{content:\\\"\\\\E7AF\\\"}.el-icon-s-flag:before{content:\\\"\\\\E7B0\\\"}.el-icon-s-marketing:before{content:\\\"\\\\E7B1\\\"}.el-icon-s-shop:before{content:\\\"\\\\E7B4\\\"}.el-icon-s-open:before{content:\\\"\\\\E7B5\\\"}.el-icon-s-management:before{content:\\\"\\\\E7B6\\\"}.el-icon-s-ticket:before{content:\\\"\\\\E7B7\\\"}.el-icon-s-release:before{content:\\\"\\\\E7B8\\\"}.el-icon-s-home:before{content:\\\"\\\\E7B9\\\"}.el-icon-s-promotion:before{content:\\\"\\\\E7BA\\\"}.el-icon-s-operation:before{content:\\\"\\\\E7BB\\\"}.el-icon-s-unfold:before{content:\\\"\\\\E7BC\\\"}.el-icon-s-fold:before{content:\\\"\\\\E7A9\\\"}.el-icon-s-platform:before{content:\\\"\\\\E7BD\\\"}.el-icon-s-order:before{content:\\\"\\\\E7BE\\\"}.el-icon-s-cooperation:before{content:\\\"\\\\E7BF\\\"}.el-icon-bell:before{content:\\\"\\\\E725\\\"}.el-icon-message-solid:before{content:\\\"\\\\E799\\\"}.el-icon-video-camera:before{content:\\\"\\\\E772\\\"}.el-icon-video-camera-solid:before{content:\\\"\\\\E796\\\"}.el-icon-camera:before{content:\\\"\\\\E779\\\"}.el-icon-camera-solid:before{content:\\\"\\\\E79B\\\"}.el-icon-download:before{content:\\\"\\\\E77C\\\"}.el-icon-upload2:before{content:\\\"\\\\E77B\\\"}.el-icon-upload:before{content:\\\"\\\\E7C3\\\"}.el-icon-picture-outline-round:before{content:\\\"\\\\E75F\\\"}.el-icon-picture-outline:before{content:\\\"\\\\E75E\\\"}.el-icon-picture:before{content:\\\"\\\\E79F\\\"}.el-icon-close:before{content:\\\"\\\\E6DB\\\"}.el-icon-check:before{content:\\\"\\\\E6DA\\\"}.el-icon-plus:before{content:\\\"\\\\E6D9\\\"}.el-icon-minus:before{content:\\\"\\\\E6D8\\\"}.el-icon-help:before{content:\\\"\\\\E73D\\\"}.el-icon-s-help:before{content:\\\"\\\\E7B3\\\"}.el-icon-circle-close:before{content:\\\"\\\\E78D\\\"}.el-icon-circle-check:before{content:\\\"\\\\E720\\\"}.el-icon-circle-plus-outline:before{content:\\\"\\\\E723\\\"}.el-icon-remove-outline:before{content:\\\"\\\\E722\\\"}.el-icon-zoom-out:before{content:\\\"\\\\E776\\\"}.el-icon-zoom-in:before{content:\\\"\\\\E777\\\"}.el-icon-error:before{content:\\\"\\\\E79D\\\"}.el-icon-success:before{content:\\\"\\\\E79C\\\"}.el-icon-circle-plus:before{content:\\\"\\\\E7A0\\\"}.el-icon-remove:before{content:\\\"\\\\E7A2\\\"}.el-icon-info:before{content:\\\"\\\\E7A1\\\"}.el-icon-question:before{content:\\\"\\\\E7A4\\\"}.el-icon-warning-outline:before{content:\\\"\\\\E6C9\\\"}.el-icon-warning:before{content:\\\"\\\\E7A3\\\"}.el-icon-goods:before{content:\\\"\\\\E7C2\\\"}.el-icon-s-goods:before{content:\\\"\\\\E7B2\\\"}.el-icon-star-off:before{content:\\\"\\\\E717\\\"}.el-icon-star-on:before{content:\\\"\\\\E797\\\"}.el-icon-more-outline:before{content:\\\"\\\\E6CC\\\"}.el-icon-more:before{content:\\\"\\\\E794\\\"}.el-icon-phone-outline:before{content:\\\"\\\\E6CB\\\"}.el-icon-phone:before{content:\\\"\\\\E795\\\"}.el-icon-user:before{content:\\\"\\\\E6E3\\\"}.el-icon-user-solid:before{content:\\\"\\\\E7A5\\\"}.el-icon-setting:before{content:\\\"\\\\E6CA\\\"}.el-icon-s-tools:before{content:\\\"\\\\E7AC\\\"}.el-icon-delete:before{content:\\\"\\\\E6D7\\\"}.el-icon-delete-solid:before{content:\\\"\\\\E7C9\\\"}.el-icon-eleme:before{content:\\\"\\\\E7C7\\\"}.el-icon-platform-eleme:before{content:\\\"\\\\E7CA\\\"}.el-icon-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@-webkit-keyframes rotating{0%{-webkit-transform:rotateZ(0);transform:rotateZ(0)}100%{-webkit-transform:rotateZ(360deg);transform:rotateZ(360deg)}}@keyframes rotating{0%{-webkit-transform:rotateZ(0);transform:rotateZ(0)}100%{-webkit-transform:rotateZ(360deg);transform:rotateZ(360deg)}}\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdGhlbWUtY2hhbGsvYmFzZS5jc3M/ODBiMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsRUFBdUM7QUFDNUQsMkJBQTJCLG1CQUFPLENBQUMsQ0FBcUM7QUFDeEU7OztBQUdBO0FBQ0EsY0FBYyxRQUFTLHlNQUF5TSxVQUFVLDBEQUEwRCxzQ0FBc0MsOEJBQThCLGdFQUFnRSxzQ0FBc0MsOEJBQThCLGtEQUFrRCxvREFBb0QsNENBQTRDLGdFQUFnRSxvREFBb0QsNENBQTRDLHlEQUF5RCxVQUFVLDRCQUE0QixvQkFBb0IsMERBQTBELFVBQVUsNEJBQTRCLG9CQUFvQix5R0FBeUcsaUdBQWlHLHlGQUF5Rix5SUFBeUksb0NBQW9DLDRCQUE0QixtREFBbUQsVUFBVSw0QkFBNEIsb0JBQW9CLGdFQUFnRSxVQUFVLDRCQUE0QixvQkFBb0IseUdBQXlHLGlHQUFpRyx5RkFBeUYseUlBQXlJLHVDQUF1QywrQkFBK0IseURBQXlELFVBQVUsNEJBQTRCLG9CQUFvQiw0REFBNEQsVUFBVSw2QkFBNkIscUJBQXFCLHlHQUF5RyxpR0FBaUcseUZBQXlGLHlJQUF5SSxrQ0FBa0MsMEJBQTBCLHFEQUFxRCxVQUFVLGlDQUFpQyx5QkFBeUIscUJBQXFCLHFHQUFxRyw2RkFBNkYsZ0NBQWdDLG9HQUFvRyw0RkFBNEYsNENBQTRDLDBCQUEwQixrQkFBa0IscUNBQXFDLFVBQVUsb0NBQW9DLDRCQUE0Qix1QkFBdUIsd0RBQXdELGdEQUFnRCxXQUFXLDBCQUEwQixtQkFBbUIsbUJBQU8sQ0FBQyxFQUE0Qix3Q0FBd0MsbUJBQU8sQ0FBQyxFQUEyQiw2QkFBNkIsZ0JBQWdCLHNCQUFzQixrQkFBa0IseUNBQXlDLG9DQUFvQyxXQUFXLGtCQUFrQixnQkFBZ0Isb0JBQW9CLG9CQUFvQixjQUFjLHdCQUF3QixxQkFBcUIsbUNBQW1DLGtDQUFrQyxnQ0FBZ0MsbUJBQW1CLGlD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NEIsbUJBQW1CLHVCQUF1QixtQkFBbUIscUJBQXFCLG1CQUFtQix5QkFBeUIsbUJBQW1CLGdDQUFnQyxtQkFBbUIsd0JBQXdCLG1CQUFtQixzQkFBc0IsbUJBQW1CLHdCQUF3QixtQkFBbUIseUJBQXlCLG1CQUFtQix3QkFBd0IsbUJBQW1CLDZCQUE2QixtQkFBbUIscUJBQXFCLG1CQUFtQiw4QkFBOEIsbUJBQW1CLHNCQUFzQixtQkFBbUIscUJBQXFCLG1CQUFtQiwyQkFBMkIsbUJBQW1CLHdCQUF3QixtQkFBbUIsd0JBQXdCLG1CQUFtQix1QkFBdUIsbUJBQW1CLDZCQUE2QixtQkFBbUIsc0JBQXNCLG1CQUFtQiwrQkFBK0IsbUJBQW1CLGlCQUFpQiw4Q0FBOEMsc0NBQXNDLGdCQUFnQixnQkFBZ0IsZUFBZSxpQkFBaUIsNEJBQTRCLEdBQUcsNkJBQTZCLHFCQUFxQixLQUFLLGtDQUFrQywyQkFBMkIsb0JBQW9CLEdBQUcsNkJBQTZCLHFCQUFxQixLQUFLLGtDQUFrQywyQkFBMkI7O0FBRWgvaEIiLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZXNjYXBlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Nzcy1sb2FkZXIvbGliL3VybC9lc2NhcGUuanNcIik7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmVsLWZhZGUtaW4tZW50ZXIsLmVsLWZhZGUtaW4tbGVhdmUtYWN0aXZlLC5lbC1mYWRlLWluLWxpbmVhci1lbnRlciwuZWwtZmFkZS1pbi1saW5lYXItbGVhdmUsLmVsLWZhZGUtaW4tbGluZWFyLWxlYXZlLWFjdGl2ZSwuZmFkZS1pbi1saW5lYXItZW50ZXIsLmZhZGUtaW4tbGluZWFyLWxlYXZlLC5mYWRlLWluLWxpbmVhci1sZWF2ZS1hY3RpdmV7b3BhY2l0eTowfS5mYWRlLWluLWxpbmVhci1lbnRlci1hY3RpdmUsLmZhZGUtaW4tbGluZWFyLWxlYXZlLWFjdGl2ZXstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuMnMgbGluZWFyO3RyYW5zaXRpb246b3BhY2l0eSAuMnMgbGluZWFyfS5lbC1mYWRlLWluLWxpbmVhci1lbnRlci1hY3RpdmUsLmVsLWZhZGUtaW4tbGluZWFyLWxlYXZlLWFjdGl2ZXstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuMnMgbGluZWFyO3RyYW5zaXRpb246b3BhY2l0eSAuMnMgbGluZWFyfS5lbC1mYWRlLWluLWVudGVyLWFjdGl2ZSwuZWwtZmFkZS1pbi1sZWF2ZS1hY3RpdmV7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuM3MgY3ViaWMtYmV6aWVyKC41NSwwLC4xLDEpO3RyYW5zaXRpb246YWxsIC4zcyBjdWJpYy1iZXppZXIoLjU1LDAsLjEsMSl9LmVsLXpvb20taW4tY2VudGVyLWVudGVyLWFjdGl2ZSwuZWwtem9vbS1pbi1jZW50ZXItbGVhdmUtYWN0aXZley13ZWJraXQtdHJhbnNpdGlvbjphbGwgLjNzIGN1YmljLWJlemllciguNTUsMCwuMSwxKTt0cmFuc2l0aW9uOmFsbCAuM3MgY3ViaWMtYmV6aWVyKC41NSwwLC4xLDEpfS5lbC16b29tLWluLWNlbnRlci1lbnRlciwuZWwtem9vbS1pbi1jZW50ZXItbGVhdmUtYWN0aXZle29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTpzY2FsZVgoMCk7dHJhbnNmb3JtOnNjYWxlWCgwKX0uZWwtem9vbS1pbi10b3AtZW50ZXItYWN0aXZlLC5lbC16b29tLWluLXRvcC1sZWF2ZS1hY3RpdmV7b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnNjYWxlWSgxKTt0cmFuc2Zvcm06c2NhbGVZKDEpOy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4zcyBjdWJpYy1iZXppZXIoLjIzLDEsLjMyLDEpLC13ZWJraXQtdHJhbnNmb3JtIC4zcyBjdWJpYy1iZXppZXIoLjIzLDEsLjMyLDEpO3RyYW5zaXRpb246b3BhY2l0eSAuM3MgY3ViaWMtYmV6aWVyKC4yMywxLC4zMiwxKSwtd2Via2l0LXRyYW5zZm9ybSAuM3MgY3ViaWMtYmV6aWVyKC4yMywxLC4zMiwxKTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuM3MgY3ViaWMtYmV6aWVyKC4yMywxLC4zMiwxKSxvcGFjaXR5IC4zcyBjdWJpYy1iZXppZXIoLjIzLDEsLjMyLDEpO3RyYW5zaXRpb246dHJhbnNmb3JtIC4zcyBjdWJpYy1iZXppZXIoLjIzLDEsLjMyLDEpLG9wYWNpdHkgLjNzIGN1YmljLWJlemllciguMjMsMSwuMzIsMSksLXdlYmtpdC10cmFuc2Zvcm0gLjNzIGN1YmljLWJlemllciguMjMsMSwuMzIsMSk7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOmNlbnRlciB0b3A7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXIgdG9wfS5lbC16b29tLWluLXRvcC1lbnRlciwuZWwtem9vbS1pbi10b3AtbGVhdmUtYWN0aXZle29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTpzY2FsZVkoMCk7dHJhbnNmb3JtOnNjYWxlWSgwKX0uZWwtem9vbS1pbi1ib3R0b20tZW50ZXItYWN0aXZlLC5lbC16b29tLWluLWJvdHRvbS1sZWF2ZS1hY3RpdmV7b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnNjYWxlWSgxKTt0cmFuc2Zvcm06c2NhbGVZKDEpOy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4zcyBjdWJpYy1iZXppZXIoLjIzLDEsLjMyLDEpLC13ZWJraXQtdHJhbnNmb3JtIC4zcyBjdWJpYy1iZXppZXIoLjIzLDEsLjMyLDEpO3RyYW5zaXRpb246b3BhY2l0eSAuM3MgY3ViaWMtYmV6aWVyKC4yMywxLC4zMiwxKSwtd2Via2l0LXRyYW5zZm9ybSAuM3MgY3ViaWMtYmV6aWVyKC4yMywxLC4zMiwxKTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuM3MgY3ViaWMtYmV6aWVyKC4yMywxLC4zMiwxKSxvcGFjaXR5IC4zcyBjdWJpYy1iZXppZXIoLjIzLDEsLjMyLDEpO3RyYW5zaXRpb246dHJhbnNmb3JtIC4zcyBjdWJpYy1iZXppZXIoLjIzLDEsLjMyLDEpLG9wYWNpdHkgLjNzIGN1YmljLWJlemllciguMjMsMSwuMzIsMSksLXdlYmtpdC10cmFuc2Zvcm0gLjNzIGN1YmljLWJlemllciguMjMsMSwuMzIsMSk7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOmNlbnRlciBib3R0b207dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXIgYm90dG9tfS5lbC16b29tLWluLWJvdHRvbS1lbnRlciwuZWwtem9vbS1pbi1ib3R0b20tbGVhdmUtYWN0aXZle29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTpzY2FsZVkoMCk7dHJhbnNmb3JtOnNjYWxlWSgwKX0uZWwtem9vbS1pbi1sZWZ0LWVudGVyLWFjdGl2ZSwuZWwtem9vbS1pbi1sZWZ0LWxlYXZlLWFjdGl2ZXtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMSwxKTt0cmFuc2Zvcm06c2NhbGUoMSwxKTstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuM3MgY3ViaWMtYmV6aWVyKC4yMywxLC4zMiwxKSwtd2Via2l0LXRyYW5zZm9ybSAuM3MgY3ViaWMtYmV6aWVyKC4yMywxLC4zMiwxKTt0cmFuc2l0aW9uOm9wYWNpdHkgLjNzIGN1YmljLWJlemllciguMjMsMSwuMzIsMSksLXdlYmtpdC10cmFuc2Zvcm0gLjNzIGN1YmljLWJlemllciguMjMsMSwuMzIsMSk7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjNzIGN1YmljLWJlemllciguMjMsMSwuMzIsMSksb3BhY2l0eSAuM3MgY3ViaWMtYmV6aWVyKC4yMywxLC4zMiwxKTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuM3MgY3ViaWMtYmV6aWVyKC4yMywxLC4zMiwxKSxvcGFjaXR5IC4zcyBjdWJpYy1iZXppZXIoLjIzLDEsLjMyLDEpLC13ZWJraXQtdHJhbnNmb3JtIC4zcyBjdWJpYy1iZXppZXIoLjIzLDEsLjMyLDEpOy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjp0b3AgbGVmdDt0cmFuc2Zvcm0tb3JpZ2luOnRvcCBsZWZ0fS5lbC16b29tLWluLWxlZnQtZW50ZXIsLmVsLXpvb20taW4tbGVmdC1sZWF2ZS1hY3RpdmV7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKC40NSwuNDUpO3RyYW5zZm9ybTpzY2FsZSguNDUsLjQ1KX0uY29sbGFwc2UtdHJhbnNpdGlvbnstd2Via2l0LXRyYW5zaXRpb246LjNzIGhlaWdodCBlYXNlLWluLW91dCwuM3MgcGFkZGluZy10b3AgZWFzZS1pbi1vdXQsLjNzIHBhZGRpbmctYm90dG9tIGVhc2UtaW4tb3V0O3RyYW5zaXRpb246LjNzIGhlaWdodCBlYXNlLWluLW91dCwuM3MgcGFkZGluZy10b3AgZWFzZS1pbi1vdXQsLjNzIHBhZGRpbmctYm90dG9tIGVhc2UtaW4tb3V0fS5ob3Jpem9udGFsLWNvbGxhcHNlLXRyYW5zaXRpb257LXdlYmtpdC10cmFuc2l0aW9uOi4zcyB3aWR0aCBlYXNlLWluLW91dCwuM3MgcGFkZGluZy1sZWZ0IGVhc2UtaW4tb3V0LC4zcyBwYWRkaW5nLXJpZ2h0IGVhc2UtaW4tb3V0O3RyYW5zaXRpb246LjNzIHdpZHRoIGVhc2UtaW4tb3V0LC4zcyBwYWRkaW5nLWxlZnQgZWFzZS1pbi1vdXQsLjNzIHBhZGRpbmctcmlnaHQgZWFzZS1pbi1vdXR9LmVsLWxpc3QtZW50ZXItYWN0aXZlLC5lbC1saXN0LWxlYXZlLWFjdGl2ZXstd2Via2l0LXRyYW5zaXRpb246YWxsIDFzO3RyYW5zaXRpb246YWxsIDFzfS5lbC1saXN0LWVudGVyLC5lbC1saXN0LWxlYXZlLWFjdGl2ZXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtMzBweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTMwcHgpfS5lbC1vcGFjaXR5LXRyYW5zaXRpb257LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjNzIGN1YmljLWJlemllciguNTUsMCwuMSwxKTt0cmFuc2l0aW9uOm9wYWNpdHkgLjNzIGN1YmljLWJlemllciguNTUsMCwuMSwxKX1AZm9udC1mYWNle2ZvbnQtZmFtaWx5OmVsZW1lbnQtaWNvbnM7c3JjOnVybChcIiArIGVzY2FwZShyZXF1aXJlKFwiLi9mb250cy9lbGVtZW50LWljb25zLndvZmZcIikpICsgXCIpIGZvcm1hdChcXFwid29mZlxcXCIpLHVybChcIiArIGVzY2FwZShyZXF1aXJlKFwiLi9mb250cy9lbGVtZW50LWljb25zLnR0ZlwiKSkgKyBcIikgZm9ybWF0KFxcXCJ0cnVldHlwZVxcXCIpO2ZvbnQtd2VpZ2h0OjQwMDtmb250LWRpc3BsYXk6XFxcImF1dG9cXFwiO2ZvbnQtc3R5bGU6bm9ybWFsfVtjbGFzcyo9XFxcIiBlbC1pY29uLVxcXCJdLFtjbGFzc149ZWwtaWNvbi1de2ZvbnQtZmFtaWx5OmVsZW1lbnQtaWNvbnMhaW1wb3J0YW50O3NwZWFrOm5vbmU7Zm9udC1zdHlsZTpub3JtYWw7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtdmFyaWFudDpub3JtYWw7dGV4dC10cmFuc2Zvcm06bm9uZTtsaW5lLWhlaWdodDoxO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lO2Rpc3BsYXk6aW5saW5lLWJsb2NrOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlfS5lbC1pY29uLWljZS1jcmVhbS1yb3VuZDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2QTBcXFwifS5lbC1pY29uLWljZS1jcmVhbS1zcXVhcmU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkEzXFxcIn0uZWwtaWNvbi1sb2xsaXBvcDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2QTRcXFwifS5lbC1pY29uLXBvdGF0by1zdHJpcHM6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkE1XFxcIn0uZWwtaWNvbi1taWxrLXRlYTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2QTZcXFwifS5lbC1pY29uLWljZS1kcmluazpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2QTdcXFwifS5lbC1pY29uLWljZS10ZWE6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkE5XFxcIn0uZWwtaWNvbi1jb2ZmZWU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkFBXFxcIn0uZWwtaWNvbi1vcmFuZ2U6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkFCXFxcIn0uZWwtaWNvbi1wZWFyOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZBQ1xcXCJ9LmVsLWljb24tYXBwbGU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkFEXFxcIn0uZWwtaWNvbi1jaGVycnk6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkFFXFxcIn0uZWwtaWNvbi13YXRlcm1lbG9uOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZBRlxcXCJ9LmVsLWljb24tZ3JhcGU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkIwXFxcIn0uZWwtaWNvbi1yZWZyaWdlcmF0b3I6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkIxXFxcIn0uZWwtaWNvbi1nb2JsZXQtc3F1YXJlLWZ1bGw6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkIyXFxcIn0uZWwtaWNvbi1nb2JsZXQtc3F1YXJlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZCM1xcXCJ9LmVsLWljb24tZ29ibGV0LWZ1bGw6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkI0XFxcIn0uZWwtaWNvbi1nb2JsZXQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkI1XFxcIn0uZWwtaWNvbi1jb2xkLWRyaW5rOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZCNlxcXCJ9LmVsLWljb24tY29mZmVlLWN1cDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2QjhcXFwifS5lbC1pY29uLXdhdGVyLWN1cDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2QjlcXFwifS5lbC1pY29uLWhvdC13YXRlcjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2QkFcXFwifS5lbC1pY29uLWljZS1jcmVhbTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2QkJcXFwifS5lbC1pY29uLWRlc3NlcnQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkJDXFxcIn0uZWwtaWNvbi1zdWdhcjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2QkRcXFwifS5lbC1pY29uLXRhYmxld2FyZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2QkVcXFwifS5lbC1pY29uLWJ1cmdlcjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2QkZcXFwifS5lbC1pY29uLWtuaWZlLWZvcms6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkMxXFxcIn0uZWwtaWNvbi1mb3JrLXNwb29uOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZDMlxcXCJ9LmVsLWljb24tY2hpY2tlbjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2QzNcXFwifS5lbC1pY29uLWZvb2Q6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkM0XFxcIn0uZWwtaWNvbi1kaXNoLTE6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkM1XFxcIn0uZWwtaWNvbi1kaXNoOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZDNlxcXCJ9LmVsLWljb24tbW9vbi1uaWdodDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2RUVcXFwifS5lbC1pY29uLW1vb246YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkYwXFxcIn0uZWwtaWNvbi1jbG91ZHktYW5kLXN1bm55OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZGMVxcXCJ9LmVsLWljb24tcGFydGx5LWNsb3VkeTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2RjJcXFwifS5lbC1pY29uLWNsb3VkeTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2RjNcXFwifS5lbC1pY29uLXN1bm55OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZGNlxcXCJ9LmVsLWljb24tc3Vuc2V0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZGN1xcXCJ9LmVsLWljb24tc3VucmlzZS0xOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZGOFxcXCJ9LmVsLWljb24tc3VucmlzZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2RjlcXFwifS5lbC1pY29uLWhlYXZ5LXJhaW46YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkZBXFxcIn0uZWwtaWNvbi1saWdodG5pbmc6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkZCXFxcIn0uZWwtaWNvbi1saWdodC1yYWluOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZGQ1xcXCJ9LmVsLWljb24td2luZC1wb3dlcjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2RkRcXFwifS5lbC1pY29uLWJhc2ViYWxsOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTcxMlxcXCJ9LmVsLWljb24tc29jY2VyOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTcxM1xcXCJ9LmVsLWljb24tZm9vdGJhbGw6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzE1XFxcIn0uZWwtaWNvbi1iYXNrZXRiYWxsOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTcxNlxcXCJ9LmVsLWljb24tc2hpcDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3M0ZcXFwifS5lbC1pY29uLXRydWNrOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc0MFxcXCJ9LmVsLWljb24tYmljeWNsZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NDFcXFwifS5lbC1pY29uLW1vYmlsZS1waG9uZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2RDNcXFwifS5lbC1pY29uLXNlcnZpY2U6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkQ0XFxcIn0uZWwtaWNvbi1rZXk6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkUyXFxcIn0uZWwtaWNvbi11bmxvY2s6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkU0XFxcIn0uZWwtaWNvbi1sb2NrOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZFNVxcXCJ9LmVsLWljb24td2F0Y2g6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkZFXFxcIn0uZWwtaWNvbi13YXRjaC0xOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZGRlxcXCJ9LmVsLWljb24tdGltZXI6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzAyXFxcIn0uZWwtaWNvbi1hbGFybS1jbG9jazpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MDNcXFwifS5lbC1pY29uLW1hcC1sb2NhdGlvbjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MDRcXFwifS5lbC1pY29uLWRlbGV0ZS1sb2NhdGlvbjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MDVcXFwifS5lbC1pY29uLWFkZC1sb2NhdGlvbjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MDZcXFwifS5lbC1pY29uLWxvY2F0aW9uLWluZm9ybWF0aW9uOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTcwN1xcXCJ9LmVsLWljb24tbG9jYXRpb24tb3V0bGluZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MDhcXFwifS5lbC1pY29uLWxvY2F0aW9uOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc5RVxcXCJ9LmVsLWljb24tcGxhY2U6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzA5XFxcIn0uZWwtaWNvbi1kaXNjb3ZlcjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MEFcXFwifS5lbC1pY29uLWZpcnN0LWFpZC1raXQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzBCXFxcIn0uZWwtaWNvbi10cm9waHktMTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MENcXFwifS5lbC1pY29uLXRyb3BoeTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MERcXFwifS5lbC1pY29uLW1lZGFsOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTcwRVxcXCJ9LmVsLWljb24tbWVkYWwtMTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MEZcXFwifS5lbC1pY29uLXN0b3B3YXRjaDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MTBcXFwifS5lbC1pY29uLW1pYzpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MTFcXFwifS5lbC1pY29uLWNvcHktZG9jdW1lbnQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzE4XFxcIn0uZWwtaWNvbi1mdWxsLXNjcmVlbjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MTlcXFwifS5lbC1pY29uLXN3aXRjaC1idXR0b246YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzFCXFxcIn0uZWwtaWNvbi1haW06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzFDXFxcIn0uZWwtaWNvbi1jcm9wOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTcxRFxcXCJ9LmVsLWljb24tb2RvbWV0ZXI6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzFFXFxcIn0uZWwtaWNvbi10aW1lOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTcxRlxcXCJ9LmVsLWljb24tYmFuZ3podTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MjRcXFwifS5lbC1pY29uLWNsb3NlLW5vdGlmaWNhdGlvbjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MjZcXFwifS5lbC1pY29uLW1pY3JvcGhvbmU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzI3XFxcIn0uZWwtaWNvbi10dXJuLW9mZi1taWNyb3Bob25lOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTcyOFxcXCJ9LmVsLWljb24tcG9zaXRpb246YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzI5XFxcIn0uZWwtaWNvbi1wb3N0Y2FyZDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MkFcXFwifS5lbC1pY29uLW1lc3NhZ2U6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzJCXFxcIn0uZWwtaWNvbi1jaGF0LWxpbmUtc3F1YXJlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTcyRFxcXCJ9LmVsLWljb24tY2hhdC1kb3Qtc3F1YXJlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTcyRVxcXCJ9LmVsLWljb24tY2hhdC1kb3Qtcm91bmQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzJGXFxcIn0uZWwtaWNvbi1jaGF0LXNxdWFyZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MzBcXFwifS5lbC1pY29uLWNoYXQtbGluZS1yb3VuZDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MzFcXFwifS5lbC1pY29uLWNoYXQtcm91bmQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzMyXFxcIn0uZWwtaWNvbi1zZXQtdXA6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzMzXFxcIn0uZWwtaWNvbi10dXJuLW9mZjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MzRcXFwifS5lbC1pY29uLW9wZW46YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzM1XFxcIn0uZWwtaWNvbi1jb25uZWN0aW9uOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTczNlxcXCJ9LmVsLWljb24tbGluazpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MzdcXFwifS5lbC1pY29uLWNwdTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MzhcXFwifS5lbC1pY29uLXRodW1iOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTczOVxcXCJ9LmVsLWljb24tZmVtYWxlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTczQVxcXCJ9LmVsLWljb24tbWFsZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3M0JcXFwifS5lbC1pY29uLWd1aWRlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTczQ1xcXCJ9LmVsLWljb24tbmV3czpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3M0VcXFwifS5lbC1pY29uLXByaWNlLXRhZzpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NDRcXFwifS5lbC1pY29uLWRpc2NvdW50OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc0NVxcXCJ9LmVsLWljb24td2FsbGV0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc0N1xcXCJ9LmVsLWljb24tY29pbjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NDhcXFwifS5lbC1pY29uLW1vbmV5OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc0OVxcXCJ9LmVsLWljb24tYmFuay1jYXJkOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc0QVxcXCJ9LmVsLWljb24tYm94OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc0QlxcXCJ9LmVsLWljb24tcHJlc2VudDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NENcXFwifS5lbC1pY29uLXNlbGw6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkQ1XFxcIn0uZWwtaWNvbi1zb2xkLW91dDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2RDZcXFwifS5lbC1pY29uLXNob3BwaW5nLWJhZy0yOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc0RFxcXCJ9LmVsLWljb24tc2hvcHBpbmctYmFnLTE6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzRFXFxcIn0uZWwtaWNvbi1zaG9wcGluZy1jYXJ0LTI6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzRGXFxcIn0uZWwtaWNvbi1zaG9wcGluZy1jYXJ0LTE6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzUwXFxcIn0uZWwtaWNvbi1zaG9wcGluZy1jYXJ0LWZ1bGw6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzUxXFxcIn0uZWwtaWNvbi1zbW9raW5nOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc1MlxcXCJ9LmVsLWljb24tbm8tc21va2luZzpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NTNcXFwifS5lbC1pY29uLWhvdXNlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc1NFxcXCJ9LmVsLWljb24tdGFibGUtbGFtcDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NTVcXFwifS5lbC1pY29uLXNjaG9vbDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NTZcXFwifS5lbC1pY29uLW9mZmljZS1idWlsZGluZzpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NTdcXFwifS5lbC1pY29uLXRvaWxldC1wYXBlcjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NThcXFwifS5lbC1pY29uLW5vdGVib29rLTI6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzU5XFxcIn0uZWwtaWNvbi1ub3RlYm9vay0xOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc1QVxcXCJ9LmVsLWljb24tZmlsZXM6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzVCXFxcIn0uZWwtaWNvbi1jb2xsZWN0aW9uOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc1Q1xcXCJ9LmVsLWljb24tcmVjZWl2aW5nOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc1RFxcXCJ9LmVsLWljb24tc3VpdGNhc2UtMTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NjBcXFwifS5lbC1pY29uLXN1aXRjYXNlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc2MVxcXCJ9LmVsLWljb24tZmlsbTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NjNcXFwifS5lbC1pY29uLWNvbGxlY3Rpb24tdGFnOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc2NVxcXCJ9LmVsLWljb24tZGF0YS1hbmFseXNpczpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NjZcXFwifS5lbC1pY29uLXBpZS1jaGFydDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NjdcXFwifS5lbC1pY29uLWRhdGEtYm9hcmQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzY4XFxcIn0uZWwtaWNvbi1kYXRhLWxpbmU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzZEXFxcIn0uZWwtaWNvbi1yZWFkaW5nOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc2OVxcXCJ9LmVsLWljb24tbWFnaWMtc3RpY2s6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzZBXFxcIn0uZWwtaWNvbi1jb29yZGluYXRlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc2QlxcXCJ9LmVsLWljb24tbW91c2U6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzZDXFxcIn0uZWwtaWNvbi1icnVzaDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NkVcXFwifS5lbC1pY29uLWhlYWRzZXQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzZGXFxcIn0uZWwtaWNvbi11bWJyZWxsYTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NzBcXFwifS5lbC1pY29uLXNjaXNzb3JzOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc3MVxcXCJ9LmVsLWljb24tbW9iaWxlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc3M1xcXCJ9LmVsLWljb24tYXR0cmFjdDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NzRcXFwifS5lbC1pY29uLW1vbml0b3I6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzc1XFxcIn0uZWwtaWNvbi1zZWFyY2g6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzc4XFxcIn0uZWwtaWNvbi10YWtlYXdheS1ib3g6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzdBXFxcIn0uZWwtaWNvbi1wYXBlcmNsaXA6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzdEXFxcIn0uZWwtaWNvbi1wcmludGVyOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc3RVxcXCJ9LmVsLWljb24tZG9jdW1lbnQtYWRkOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc4MlxcXCJ9LmVsLWljb24tZG9jdW1lbnQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzg1XFxcIn0uZWwtaWNvbi1kb2N1bWVudC1jaGVja2VkOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc4NlxcXCJ9LmVsLWljb24tZG9jdW1lbnQtY29weTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3ODdcXFwifS5lbC1pY29uLWRvY3VtZW50LWRlbGV0ZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3ODhcXFwifS5lbC1pY29uLWRvY3VtZW50LXJlbW92ZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3ODlcXFwifS5lbC1pY29uLXRpY2tldHM6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzhCXFxcIn0uZWwtaWNvbi1mb2xkZXItY2hlY2tlZDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3N0ZcXFwifS5lbC1pY29uLWZvbGRlci1kZWxldGU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzgwXFxcIn0uZWwtaWNvbi1mb2xkZXItcmVtb3ZlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc4MVxcXCJ9LmVsLWljb24tZm9sZGVyLWFkZDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3ODNcXFwifS5lbC1pY29uLWZvbGRlci1vcGVuZWQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzg0XFxcIn0uZWwtaWNvbi1mb2xkZXI6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzhBXFxcIn0uZWwtaWNvbi1lZGl0LW91dGxpbmU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzY0XFxcIn0uZWwtaWNvbi1lZGl0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc4Q1xcXCJ9LmVsLWljb24tZGF0ZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3OEVcXFwifS5lbC1pY29uLWMtc2NhbGUtdG8tb3JpZ2luYWw6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFN0M2XFxcIn0uZWwtaWNvbi12aWV3OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZDRVxcXCJ9LmVsLWljb24tbG9hZGluZzpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2Q0ZcXFwifS5lbC1pY29uLXJhbms6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkQxXFxcIn0uZWwtaWNvbi1zb3J0LWRvd246YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFN0M0XFxcIn0uZWwtaWNvbi1zb3J0LXVwOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTdDNVxcXCJ9LmVsLWljb24tc29ydDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2RDJcXFwifS5lbC1pY29uLWZpbmlzaGVkOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZDRFxcXCJ9LmVsLWljb24tcmVmcmVzaC1sZWZ0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZDN1xcXCJ9LmVsLWljb24tcmVmcmVzaC1yaWdodDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2QzhcXFwifS5lbC1pY29uLXJlZnJlc2g6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkQwXFxcIn0uZWwtaWNvbi12aWRlby1wbGF5OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTdDMFxcXCJ9LmVsLWljb24tdmlkZW8tcGF1c2U6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFN0MxXFxcIn0uZWwtaWNvbi1kLWFycm93LXJpZ2h0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZEQ1xcXCJ9LmVsLWljb24tZC1hcnJvdy1sZWZ0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZERFxcXCJ9LmVsLWljb24tYXJyb3ctdXA6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkUxXFxcIn0uZWwtaWNvbi1hcnJvdy1kb3duOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZERlxcXCJ9LmVsLWljb24tYXJyb3ctcmlnaHQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkUwXFxcIn0uZWwtaWNvbi1hcnJvdy1sZWZ0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZERVxcXCJ9LmVsLWljb24tdG9wLXJpZ2h0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZFN1xcXCJ9LmVsLWljb24tdG9wLWxlZnQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkU4XFxcIn0uZWwtaWNvbi10b3A6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkU2XFxcIn0uZWwtaWNvbi1ib3R0b206YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkVCXFxcIn0uZWwtaWNvbi1yaWdodDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2RTlcXFwifS5lbC1pY29uLWJhY2s6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkVBXFxcIn0uZWwtaWNvbi1ib3R0b20tcmlnaHQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkVDXFxcIn0uZWwtaWNvbi1ib3R0b20tbGVmdDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2RURcXFwifS5lbC1pY29uLWNhcmV0LXRvcDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3OEZcXFwifS5lbC1pY29uLWNhcmV0LWJvdHRvbTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3OTBcXFwifS5lbC1pY29uLWNhcmV0LXJpZ2h0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc5MVxcXCJ9LmVsLWljb24tY2FyZXQtbGVmdDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3OTJcXFwifS5lbC1pY29uLWQtY2FyZXQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzlBXFxcIn0uZWwtaWNvbi1zaGFyZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3OTNcXFwifS5lbC1pY29uLW1lbnU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzk4XFxcIn0uZWwtaWNvbi1zLWdyaWQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFN0E2XFxcIn0uZWwtaWNvbi1zLWNoZWNrOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTdBN1xcXCJ9LmVsLWljb24tcy1kYXRhOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTdBOFxcXCJ9LmVsLWljb24tcy1vcHBvcnR1bml0eTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3QUFcXFwifS5lbC1pY29uLXMtY3VzdG9tOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTdBQlxcXCJ9LmVsLWljb24tcy1jbGFpbTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3QURcXFwifS5lbC1pY29uLXMtZmluYW5jZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3QUVcXFwifS5lbC1pY29uLXMtY29tbWVudDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3QUZcXFwifS5lbC1pY29uLXMtZmxhZzpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3QjBcXFwifS5lbC1pY29uLXMtbWFya2V0aW5nOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTdCMVxcXCJ9LmVsLWljb24tcy1zaG9wOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTdCNFxcXCJ9LmVsLWljb24tcy1vcGVuOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTdCNVxcXCJ9LmVsLWljb24tcy1tYW5hZ2VtZW50OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTdCNlxcXCJ9LmVsLWljb24tcy10aWNrZXQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFN0I3XFxcIn0uZWwtaWNvbi1zLXJlbGVhc2U6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFN0I4XFxcIn0uZWwtaWNvbi1zLWhvbWU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFN0I5XFxcIn0uZWwtaWNvbi1zLXByb21vdGlvbjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3QkFcXFwifS5lbC1pY29uLXMtb3BlcmF0aW9uOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTdCQlxcXCJ9LmVsLWljb24tcy11bmZvbGQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFN0JDXFxcIn0uZWwtaWNvbi1zLWZvbGQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFN0E5XFxcIn0uZWwtaWNvbi1zLXBsYXRmb3JtOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTdCRFxcXCJ9LmVsLWljb24tcy1vcmRlcjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3QkVcXFwifS5lbC1pY29uLXMtY29vcGVyYXRpb246YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFN0JGXFxcIn0uZWwtaWNvbi1iZWxsOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTcyNVxcXCJ9LmVsLWljb24tbWVzc2FnZS1zb2xpZDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3OTlcXFwifS5lbC1pY29uLXZpZGVvLWNhbWVyYTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NzJcXFwifS5lbC1pY29uLXZpZGVvLWNhbWVyYS1zb2xpZDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3OTZcXFwifS5lbC1pY29uLWNhbWVyYTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NzlcXFwifS5lbC1pY29uLWNhbWVyYS1zb2xpZDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3OUJcXFwifS5lbC1pY29uLWRvd25sb2FkOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc3Q1xcXCJ9LmVsLWljb24tdXBsb2FkMjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3N0JcXFwifS5lbC1pY29uLXVwbG9hZDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3QzNcXFwifS5lbC1pY29uLXBpY3R1cmUtb3V0bGluZS1yb3VuZDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NUZcXFwifS5lbC1pY29uLXBpY3R1cmUtb3V0bGluZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NUVcXFwifS5lbC1pY29uLXBpY3R1cmU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzlGXFxcIn0uZWwtaWNvbi1jbG9zZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2REJcXFwifS5lbC1pY29uLWNoZWNrOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZEQVxcXCJ9LmVsLWljb24tcGx1czpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2RDlcXFwifS5lbC1pY29uLW1pbnVzOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZEOFxcXCJ9LmVsLWljb24taGVscDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3M0RcXFwifS5lbC1pY29uLXMtaGVscDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3QjNcXFwifS5lbC1pY29uLWNpcmNsZS1jbG9zZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3OERcXFwifS5lbC1pY29uLWNpcmNsZS1jaGVjazpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MjBcXFwifS5lbC1pY29uLWNpcmNsZS1wbHVzLW91dGxpbmU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzIzXFxcIn0uZWwtaWNvbi1yZW1vdmUtb3V0bGluZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3MjJcXFwifS5lbC1pY29uLXpvb20tb3V0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc3NlxcXCJ9LmVsLWljb24tem9vbS1pbjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3NzdcXFwifS5lbC1pY29uLWVycm9yOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTc5RFxcXCJ9LmVsLWljb24tc3VjY2VzczpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3OUNcXFwifS5lbC1pY29uLWNpcmNsZS1wbHVzOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTdBMFxcXCJ9LmVsLWljb24tcmVtb3ZlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTdBMlxcXCJ9LmVsLWljb24taW5mbzpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3QTFcXFwifS5lbC1pY29uLXF1ZXN0aW9uOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTdBNFxcXCJ9LmVsLWljb24td2FybmluZy1vdXRsaW5lOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZDOVxcXCJ9LmVsLWljb24td2FybmluZzpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3QTNcXFwifS5lbC1pY29uLWdvb2RzOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTdDMlxcXCJ9LmVsLWljb24tcy1nb29kczpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3QjJcXFwifS5lbC1pY29uLXN0YXItb2ZmOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTcxN1xcXCJ9LmVsLWljb24tc3Rhci1vbjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3OTdcXFwifS5lbC1pY29uLW1vcmUtb3V0bGluZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU2Q0NcXFwifS5lbC1pY29uLW1vcmU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzk0XFxcIn0uZWwtaWNvbi1waG9uZS1vdXRsaW5lOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZDQlxcXCJ9LmVsLWljb24tcGhvbmU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNzk1XFxcIn0uZWwtaWNvbi11c2VyOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZFM1xcXCJ9LmVsLWljb24tdXNlci1zb2xpZDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3QTVcXFwifS5lbC1pY29uLXNldHRpbmc6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFNkNBXFxcIn0uZWwtaWNvbi1zLXRvb2xzOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTdBQ1xcXCJ9LmVsLWljb24tZGVsZXRlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTZEN1xcXCJ9LmVsLWljb24tZGVsZXRlLXNvbGlkOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTdDOVxcXCJ9LmVsLWljb24tZWxlbWU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFN0M3XFxcIn0uZWwtaWNvbi1wbGF0Zm9ybS1lbGVtZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEU3Q0FcXFwifS5lbC1pY29uLWxvYWRpbmd7LXdlYmtpdC1hbmltYXRpb246cm90YXRpbmcgMnMgbGluZWFyIGluZmluaXRlO2FuaW1hdGlvbjpyb3RhdGluZyAycyBsaW5lYXIgaW5maW5pdGV9LmVsLWljb24tLXJpZ2h0e21hcmdpbi1sZWZ0OjVweH0uZWwtaWNvbi0tbGVmdHttYXJnaW4tcmlnaHQ6NXB4fUAtd2Via2l0LWtleWZyYW1lcyByb3RhdGluZ3swJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGVaKDApO3RyYW5zZm9ybTpyb3RhdGVaKDApfTEwMCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlWigzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGVaKDM2MGRlZyl9fUBrZXlmcmFtZXMgcm90YXRpbmd7MCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlWigwKTt0cmFuc2Zvcm06cm90YXRlWigwKX0xMDAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZVooMzYwZGVnKTt0cmFuc2Zvcm06cm90YXRlWigzNjBkZWcpfX1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvbGliL3RoZW1lLWNoYWxrL2Jhc2UuY3NzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///29\n");

/***/ }),
/* 30 */
/***/ (function(module, exports) {

eval("module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qcz85MzExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZSh1cmwpIHtcbiAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHVybFxuICAgIH1cbiAgICAvLyBJZiB1cmwgaXMgYWxyZWFkeSB3cmFwcGVkIGluIHF1b3RlcywgcmVtb3ZlIHRoZW1cbiAgICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICAgICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gICAgLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAgIC8vIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG4gICAgaWYgKC9bXCInKCkgXFx0XFxuXS8udGVzdCh1cmwpKSB7XG4gICAgICAgIHJldHVybiAnXCInICsgdXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJykgKyAnXCInXG4gICAgfVxuXG4gICAgcmV0dXJuIHVybFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///30\n");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"static/img/element-icons.woff?535877f50039c0cb49a6196a5b7517cd\";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdGhlbWUtY2hhbGsvZm9udHMvZWxlbWVudC1pY29ucy53b2ZmPzk1ODgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLHFCQUF1QiIsImZpbGUiOiIzMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcInN0YXRpYy9pbWcvZWxlbWVudC1pY29ucy53b2ZmPzUzNTg3N2Y1MDAzOWMwY2I0OWE2MTk2YTViNzUxN2NkXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdGhlbWUtY2hhbGsvZm9udHMvZWxlbWVudC1pY29ucy53b2ZmXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///31\n");

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"static/img/element-icons.ttf?732389ded34cb9c52dd88271f1345af9\";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdGhlbWUtY2hhbGsvZm9udHMvZWxlbWVudC1pY29ucy50dGY/OGVkMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwic3RhdGljL2ltZy9lbGVtZW50LWljb25zLnR0Zj83MzIzODlkZWQzNGNiOWM1MmRkODgyNzFmMTM0NWFmOVwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvbGliL3RoZW1lLWNoYWxrL2ZvbnRzL2VsZW1lbnQtaWNvbnMudHRmXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///32\n");

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction Drag(options) {\n    this.drag = null;\n    this.disX = 0;\n    this.disY = 0;\n    this.options = {\n        dragAimClass: options.dragAimClass ? options.dragAimClass : '',\n        dragServerClass: options.dragServerClass ? options.dragServerClass : '',\n        moveFun: options.moveFun ? options.moveFun : function () {},\n        upFun: options.upFun ? options.upFun : function () {}\n\n    };\n\n    this.init();\n}\nDrag.prototype.addEvents = function (target, eventType, handle) {\n    if (target.addEventListener) {\n        target.addEventListener(eventType, handle, false);\n    } else {\n        target.attachEvent('on' + eventType, function () {\n            handle.call(target, arguments);\n        });\n    };\n};\n\nDrag.prototype.removeEvents = function (target, eventType, handle) {\n    if (target.removeEventListener) {\n        target.removeEventListener(eventType, handle, false);\n    } else if (target.detachEvent) {\n        target.detachEvent('on' + eventType, handle);\n    } else {\n        element['on' + eventType] = null;\n    }\n};\n\nDrag.prototype.init = function () {\n    this.mouseMove();\n};\nDrag.prototype.createDragDom = function (x, y, w, h, domId) {\n    var d = document.createElement('div');\n    d.id = \"dragDom\";\n    d.style.position = 'absolute';\n    d.style.zIndex = 9999;\n    d.style.border = 'dashed red 1px';\n    d.style.boxSizing = 'border-box';\n    d.style.transform = \"translate3d(0,0,0)\";\n    d.style.left = x + 'px';\n    d.style.top = y + 'px';\n    d.style.width = w + 'px';\n    d.style.height = h + 'px';\n    d.dataset.id = domId;\n\n    document.getElementById('qflow_lay').appendChild(d);\n\n\n    this.drag = d;\n    var _this = this;\n    this.addEvents(d, 'mouseup', function (event) {\n\n        var e = event || window.event;\n        var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;\n        var scrollY = document.documentElement.scrollTop || document.body.scrollTop;\n        var x = e.pageX || e.clientX + scrollX;\n        var y = e.pageY || e.clientY + scrollY;\n\n        var layX = _this.getElementLeft(document.getElementById('qflow_lay'));\n        var layY = _this.getElementTop(document.getElementById('qflow_lay'));\n\n        _this.disX = 0;\n        _this.disY = 0;\n        _this.removeEvents(d, 'mouseup', null);\n        document.getElementById('dragDom') && document.getElementById('qflow_lay').removeChild(document.getElementById('dragDom'));\n\n\n        _this.options.upFun({ x: x - layX, y: y - layY, id: _this.drag.getAttribute('data-id') });\n        _this.drag = null;\n    });\n};\n\nDrag.prototype.getElementLeft = function (element) {\n    var actualLeft = element.offsetLeft;\n    var current = element.offsetParent;\n\n    while (current !== null) {\n        actualLeft += current.offsetLeft;\n        current = current.offsetParent;\n    }\n\n    return actualLeft;\n};\nDrag.prototype.getElementTop = function (element) {\n\n    var actualTop = element.offsetTop;\n    var current = element.offsetParent;\n\n    while (current !== null) {\n        actualTop += current.offsetTop;\n        current = current.offsetParent;\n    }\n\n    return actualTop;\n};\n\nDrag.prototype.mouseMove = function () {\n    var _this = this;\n\n    this.addEvents(document, 'mouseleave', function (event) {\n        _this.disX = 0;\n        _this.disY = 0;\n        _this.drag = null;\n\n        document.getElementById('dragDom') && document.getElementById('qflow_lay').removeChild(document.getElementById('dragDom'));\n    });\n\n    this.addEvents(document, 'mouseup', function (event) {\n        _this.disX = 0;\n        _this.disY = 0;\n\n        _this.drag = null;\n\n        document.getElementById('dragDom') && document.getElementById('qflow_lay').removeChild(document.getElementById('dragDom'));\n    });\n\n    this.addEvents(document, 'mousedown', function (event) {\n\n        var e = event || window.event;\n\n        if (e.target.className.toLowerCase().indexOf(_this.options.dragAimClass) > -1) {\n            _this.drag = e.target;\n\n            var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;\n            var scrollY = document.documentElement.scrollTop || document.body.scrollTop;\n            var x = e.pageX || e.clientX + scrollX;\n            var y = e.pageY || e.clientY + scrollY;\n\n            _this.disX = x - e.target.offsetLeft;\n            _this.disY = y - e.target.offsetTop;\n\n            _this.createDragDom(e.target.offsetLeft - scrollX, e.target.offsetTop - scrollY, e.target.offsetWidth, e.target.offsetHeight, e.target.getAttribute('data-id'));\n        }\n    });\n\n    this.addEvents(document, 'mousemove', function (event) {\n        if (_this.drag !== null) {\n            var e = event || window.event;\n\n            var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;\n            var scrollY = document.documentElement.scrollTop || document.body.scrollTop;\n            var x = e.pageX || e.clientX + scrollX;\n            var y = e.pageY || e.clientY + scrollY;\n\n            _this.drag.style.left = x - _this.disX - scrollX + 'px';\n            _this.drag.style.top = y - _this.disY - scrollY + 'px';\n\n            _this.options.moveFun(x, y);\n        }\n    });\n};\n\nmodule.exports.Drag = Drag;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL0RyYWcuanM/MDljYSJdLCJuYW1lcyI6WyJEcmFnIiwib3B0aW9ucyIsImRyYWciLCJkaXNYIiwiZGlzWSIsImRyYWdBaW1DbGFzcyIsImRyYWdTZXJ2ZXJDbGFzcyIsIm1vdmVGdW4iLCJ1cEZ1biIsImluaXQiLCJwcm90b3R5cGUiLCJhZGRFdmVudHMiLCJ0YXJnZXQiLCJldmVudFR5cGUiLCJoYW5kbGUiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJjYWxsIiwiYXJndW1lbnRzIiwicmVtb3ZlRXZlbnRzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRldGFjaEV2ZW50IiwiZWxlbWVudCIsIm1vdXNlTW92ZSIsImNyZWF0ZURyYWdEb20iLCJ4IiwieSIsInciLCJoIiwiZG9tSWQiLCJkIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaWQiLCJzdHlsZSIsInBvc2l0aW9uIiwiekluZGV4IiwiYm9yZGVyIiwiYm94U2l6aW5nIiwidHJhbnNmb3JtIiwibGVmdCIsInRvcCIsIndpZHRoIiwiaGVpZ2h0IiwiZGF0YXNldCIsImdldEVsZW1lbnRCeUlkIiwiYXBwZW5kQ2hpbGQiLCJfdGhpcyIsImV2ZW50IiwiZSIsIndpbmRvdyIsInNjcm9sbFgiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JvbGxMZWZ0IiwiYm9keSIsInNjcm9sbFkiLCJzY3JvbGxUb3AiLCJwYWdlWCIsImNsaWVudFgiLCJwYWdlWSIsImNsaWVudFkiLCJsYXlYIiwiZ2V0RWxlbWVudExlZnQiLCJsYXlZIiwiZ2V0RWxlbWVudFRvcCIsInJlbW92ZUNoaWxkIiwiZ2V0QXR0cmlidXRlIiwiYWN0dWFsTGVmdCIsIm9mZnNldExlZnQiLCJjdXJyZW50Iiwib2Zmc2V0UGFyZW50IiwiYWN0dWFsVG9wIiwib2Zmc2V0VG9wIiwiY2xhc3NOYW1lIiwidG9Mb3dlckNhc2UiLCJpbmRleE9mIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWln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eEI7QUFFSDtBQUdKLEtBdkJMO0FBd0JILENBeEZEOztBQTBGQW9ELE9BQU9DLE9BQVAsQ0FBZS9FLElBQWYsR0FBc0JBLElBQXRCIiwiZmlsZSI6IjMzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gRHJhZyhvcHRpb25zKXtcbiAgICB0aGlzLmRyYWcgPSBudWxsO1xuICAgIHRoaXMuZGlzWCA9IDA7XG4gICAgdGhpcy5kaXNZID0gMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB7IFxuICAgICAgICBkcmFnQWltQ2xhc3M6b3B0aW9ucy5kcmFnQWltQ2xhc3M/b3B0aW9ucy5kcmFnQWltQ2xhc3M6JycsXG4gICAgICAgIGRyYWdTZXJ2ZXJDbGFzczpvcHRpb25zLmRyYWdTZXJ2ZXJDbGFzcz9vcHRpb25zLmRyYWdTZXJ2ZXJDbGFzczonJyxcbiAgICAgICAgbW92ZUZ1bjpvcHRpb25zLm1vdmVGdW4/b3B0aW9ucy5tb3ZlRnVuOmZ1bmN0aW9uKCl7fSxcbiAgICAgICAgdXBGdW46b3B0aW9ucy51cEZ1bj9vcHRpb25zLnVwRnVuOmZ1bmN0aW9uKCl7fSxcblxuICAgIH1cblxuICAgIHRoaXMuaW5pdCgpO1xufVxuRHJhZy5wcm90b3R5cGUuYWRkRXZlbnRzID0gZnVuY3Rpb24odGFyZ2V0LGV2ZW50VHlwZSxoYW5kbGUpe1xuICAgIGlmKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKXsgXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsaGFuZGxlLGZhbHNlKTtcbiAgICAgICAgXG4gICAgfWVsc2V7XG4gICAgICAgICAgICB0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJytldmVudFR5cGUsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBoYW5kbGUuY2FsbCh0YXJnZXQsYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICB9O1xufVxuXG5EcmFnLnByb3RvdHlwZS5yZW1vdmVFdmVudHMgPSBmdW5jdGlvbih0YXJnZXQsZXZlbnRUeXBlLGhhbmRsZSl7XG4gICAgICAgIGlmKHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKXtcbiAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZSwgZmFsc2UpO1xuICAgICAgICAgfSBlbHNlIGlmKHRhcmdldC5kZXRhY2hFdmVudCl7XG4gICAgICAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGhhbmRsZSk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIGVsZW1lbnRbJ29uJyArIGV2ZW50VHlwZV0gPSBudWxsO1xuICAgICAgICAgfVxufVxuXG5EcmFnLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLm1vdXNlTW92ZSgpO1xufVxuRHJhZy5wcm90b3R5cGUuY3JlYXRlRHJhZ0RvbSA9IGZ1bmN0aW9uKHgseSx3LGgsZG9tSWQpeyBcbiAgICB2YXIgZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGQuaWQ9XCJkcmFnRG9tXCI7XG4gICAgZC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZC5zdHlsZS56SW5kZXggPSA5OTk5O1xuICAgIGQuc3R5bGUuYm9yZGVyID0gJ2Rhc2hlZCByZWQgMXB4JztcbiAgICBkLnN0eWxlLmJveFNpemluZyA9ICdib3JkZXItYm94JztcbiAgICBkLnN0eWxlLnRyYW5zZm9ybT1cInRyYW5zbGF0ZTNkKDAsMCwwKVwiO1xuICAgIGQuc3R5bGUubGVmdCA9IHgrJ3B4JztcbiAgICBkLnN0eWxlLnRvcCA9IHkrJ3B4JztcbiAgICBkLnN0eWxlLndpZHRoID0gdysncHgnO1xuICAgIGQuc3R5bGUuaGVpZ2h0ID0gaCsncHgnO1xuICAgIGQuZGF0YXNldC5pZCA9IGRvbUlkO1xuXG5cblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdxZmxvd19sYXknKS5hcHBlbmRDaGlsZChkKTtcbiAgICAvLyBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGQpO1xuXG4gICAgdGhpcy5kcmFnID0gZDsgXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLmFkZEV2ZW50cyhkLCdtb3VzZXVwJyxmdW5jdGlvbihldmVudCl7XG5cbiAgICAgICAgICAgIHZhciBlID0gZXZlbnQgfHwgd2luZG93LmV2ZW50O1xuICAgICAgICAgICAgdmFyIHNjcm9sbFggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQ7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsWSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XG4gICAgICAgICAgICB2YXIgeCA9IGUucGFnZVggfHwgZS5jbGllbnRYICsgc2Nyb2xsWDtcbiAgICAgICAgICAgIHZhciB5ID0gZS5wYWdlWSB8fCBlLmNsaWVudFkgKyBzY3JvbGxZO1xuXG4gICAgICAgICAgICAvLyB2YXIgbGF5WCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdxZmxvd19sYXknKS5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgLy8gdmFyIGxheVkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncWZsb3dfbGF5Jykub2Zmc2V0VG9wO1xuXG4gICAgICAgICAgICB2YXIgbGF5WCA9IF90aGlzLmdldEVsZW1lbnRMZWZ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdxZmxvd19sYXknKSk7XG4gICAgICAgICAgICB2YXIgbGF5WSA9IF90aGlzLmdldEVsZW1lbnRUb3AoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3FmbG93X2xheScpKTtcblxuXG5cbiAgICAgICAgX3RoaXMuZGlzWCA9IDA7XG4gICAgICAgIF90aGlzLmRpc1kgPSAwO1xuICAgICAgICBfdGhpcy5yZW1vdmVFdmVudHMoZCwnbW91c2V1cCcsbnVsbCk7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkcmFnRG9tJykgJiYgXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdxZmxvd19sYXknKS5yZW1vdmVDaGlsZChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZHJhZ0RvbScpKTtcbiAgICAgICAgLy8gZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZHJhZ0RvbScpKTtcbiBcbiAgICAgICAgX3RoaXMub3B0aW9ucy51cEZ1bih7eDp4LWxheVgseTp5LWxheVksaWQ6X3RoaXMuZHJhZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnKX0pO1xuICAgICAgICBfdGhpcy5kcmFnID0gbnVsbDsgXG5cblxuICAgIH0pXG5cbn1cblxuRHJhZy5wcm90b3R5cGUuZ2V0RWxlbWVudExlZnQgPSBmdW5jdGlvbihlbGVtZW50KXtcbuOAgOOAgOOAgOOAgHZhciBhY3R1YWxMZWZ0ID0gZWxlbWVudC5vZmZzZXRMZWZ0O1xu44CA44CA44CA44CAdmFyIGN1cnJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcblxu44CA44CA44CA44CAd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpe1xu44CA44CA44CA44CA44CA44CAYWN0dWFsTGVmdCArPSBjdXJyZW50Lm9mZnNldExlZnQ7XG7jgIDjgIDjgIDjgIDjgIDjgIBjdXJyZW50ID0gY3VycmVudC5vZmZzZXRQYXJlbnQ7XG7jgIDjgIDjgIDjgIB9XG5cbuOAgOOAgOOAgOOAgHJldHVybiBhY3R1YWxMZWZ0O1xu44CA44CAfVxuRHJhZy5wcm90b3R5cGUuZ2V0RWxlbWVudFRvcCA9IGZ1bmN0aW9uKGVsZW1lbnQpe1xuXG7jgIDjgIDjgIDjgIB2YXIgYWN0dWFsVG9wID0gZWxlbWVudC5vZmZzZXRUb3A7XG7jgIDjgIDjgIDjgIB2YXIgY3VycmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuXG7jgIDjgIDjgIDjgIB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCl7XG7jgIDjgIDjgIDjgIDjgIDjgIBhY3R1YWxUb3AgKz0gY3VycmVudC5vZmZzZXRUb3A7XG7jgIDjgIDjgIDjgIDjgIDjgIBjdXJyZW50ID0gY3VycmVudC5vZmZzZXRQYXJlbnQ7XG7jgIDjgIDjgIDjgIB9XG5cbuOAgOOAgOOAgOOAgHJldHVybiBhY3R1YWxUb3A7XG7jgIDjgIB9XG5cbkRyYWcucHJvdG90eXBlLm1vdXNlTW92ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuYWRkRXZlbnRzKGRvY3VtZW50LCdtb3VzZWxlYXZlJyxmdW5jdGlvbihldmVudCl7XG4gICAgICAgIF90aGlzLmRpc1ggPSAwO1xuICAgICAgICBfdGhpcy5kaXNZID0gMDsgXG4gICAgICAgIF90aGlzLmRyYWcgPSBudWxsOyBcblxuICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RyYWdEb20nKSAmJiBcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3FmbG93X2xheScpLnJlbW92ZUNoaWxkKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkcmFnRG9tJykpO1xuICAgICAgICAgXG4gICAgICAgIC8vIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RyYWdEb20nKSk7XG4gICAgfSlcblxuICAgIHRoaXMuYWRkRXZlbnRzKGRvY3VtZW50LCdtb3VzZXVwJyxmdW5jdGlvbihldmVudCl7XG4gICAgICAgIF90aGlzLmRpc1ggPSAwO1xuICAgICAgICBfdGhpcy5kaXNZID0gMDsgIFxuXG5cbiAgICAgICAgX3RoaXMuZHJhZyA9IG51bGw7IFxuXG4gICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZHJhZ0RvbScpICYmIFxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncWZsb3dfbGF5JykucmVtb3ZlQ2hpbGQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RyYWdEb20nKSk7XG5cbiAgICAgICAgLy8gZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZHJhZ0RvbScpKTtcbiAgICB9KVxuXG5cbiAgICB0aGlzLmFkZEV2ZW50cyhkb2N1bWVudCwnbW91c2Vkb3duJyxmdW5jdGlvbihldmVudCl7XG5cbiAgICAgICAgIHZhciBlID0gZXZlbnQgfHwgd2luZG93LmV2ZW50OyBcbiBcbiAgICAgICAgLy/ngrnkuK3kuobopoHmi5bliqjnmoTlhYPntKBcbiAgICAgICAgaWYoZS50YXJnZXQuY2xhc3NOYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihfdGhpcy5vcHRpb25zLmRyYWdBaW1DbGFzcyk+LTEpe1xuICAgICAgICAgICAgX3RoaXMuZHJhZyA9IGUudGFyZ2V0O1xuIFxuXG4gICAgICAgICAgICB2YXIgc2Nyb2xsWCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIHZhciBzY3JvbGxZID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcbiAgICAgICAgICAgIHZhciB4ID0gZS5wYWdlWCB8fCBlLmNsaWVudFggKyBzY3JvbGxYO1xuICAgICAgICAgICAgdmFyIHkgPSBlLnBhZ2VZIHx8IGUuY2xpZW50WSArIHNjcm9sbFk7IFxuXG4gICAgICAgICAgICBfdGhpcy5kaXNYID0geCAtIGUudGFyZ2V0Lm9mZnNldExlZnQ7XG4gICAgICAgICAgICBfdGhpcy5kaXNZID0geSAtIGUudGFyZ2V0Lm9mZnNldFRvcDtcblxuXG4gICAgICAgICAgICAvLyB2YXIgbGF5WCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdxZmxvd19sYXknKS5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgLy8gdmFyIGxheVkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncWZsb3dfbGF5Jykub2Zmc2V0VG9wO1xuXG5cblxuICAgICAgICAgICAgX3RoaXMuY3JlYXRlRHJhZ0RvbShcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5vZmZzZXRMZWZ0LXNjcm9sbFgsXG4gICAgICAgICAgICAgICAgZS50YXJnZXQub2Zmc2V0VG9wLXNjcm9sbFksIFxuXG4gICAgICAgICAgICAgICAgZS50YXJnZXQub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgZS50YXJnZXQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgICAgIGUudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1pZCcpXG5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gXG5cbiAgICB9KVxuXG4gICAgdGhpcy5hZGRFdmVudHMoZG9jdW1lbnQsJ21vdXNlbW92ZScsZnVuY3Rpb24oZXZlbnQpeyBcbiAgICAgICAgICAgICAgICBpZihfdGhpcy5kcmFnICE9PSBudWxsKXtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcbiBcblxuXG4gICAgICAgICAgICB2YXIgc2Nyb2xsWCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIHZhciBzY3JvbGxZID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcbiAgICAgICAgICAgIHZhciB4ID0gZS5wYWdlWCB8fCBlLmNsaWVudFggKyBzY3JvbGxYO1xuICAgICAgICAgICAgdmFyIHkgPSBlLnBhZ2VZIHx8IGUuY2xpZW50WSArIHNjcm9sbFk7ICBcblxuXG4gICAgICAgICAgICAvLyB2YXIgbGF5WCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdxZmxvd19sYXknKS5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgLy8gdmFyIGxheVkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncWZsb3dfbGF5Jykub2Zmc2V0VG9wO1xuXG4gICAgICAgICAgICAgICAgX3RoaXMuZHJhZy5zdHlsZS5sZWZ0ID0gKHggLSBfdGhpcy5kaXNYIC0gc2Nyb2xsWCkrJ3B4JztcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnLnN0eWxlLnRvcCA9ICh5IC0gX3RoaXMuZGlzWSAtIHNjcm9sbFkpKydweCc7XG5cbiAgICAgICAgICAgICAgICBfdGhpcy5vcHRpb25zLm1vdmVGdW4oeCx5KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgfSlcbn0gXG5cbm1vZHVsZS5leHBvcnRzLkRyYWcgPSBEcmFnOyBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbGliL0RyYWcuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///33\n");

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction Qflow(options) {\n\tthis.options = options;\n\tthis.toolLayer = null;\n\tthis.menuLayer = null;\n\tthis.qnodes = [];\n\tthis.baseNodesWithCoordinates = [];\n\tthis.containerPadding = 10;\n\tthis.containerChildMargin = 10;\n\tthis.containerTitleHeight = 20;\n\tthis.childNodeWidth = 100;\n\tthis.childNodeHeight = 30;\n\n\tthis.tipNodeWidth = 150;\n\tthis.tipContext = null;\n\n\tthis.containerNodeWidth = 120;\n\tthis.containerNodeHeight = 70;\n\n\tthis.draging = false;\n\n\tthis.contextSettingNode = null;\n\tthis.contextAimAttr = '';\n\n\tthis.modiTitleObj = null;\n\n\tthis.colorRect = {\n\t\t\"red\": \"#FF0000\",\n\t\t\"orange\": \"#FFA500\",\n\t\t\"yellow\": \"#FFFF00\",\n\t\t\"green\": \"#008000\",\n\t\t\"blue\": \"#0000FF\",\n\t\t\"white\": \"#FFFFFF\",\n\t\t\"black\": \"#000000\",\n\t\t\"aqua\": \"#00FFFF\",\n\t\t\"fuchsia\": \"#FF00FF\",\n\t\t\"gray\": \"#808080\",\n\t\t\"lime\": \"#00FF00\",\n\t\t\"maroon\": \"#800000\",\n\t\t\"navy\": \"#000080\",\n\t\t\"olive\": \"#808000\",\n\t\t\"purple\": \"#800080\",\n\t\t\"silver\": \"#C0C0C0\",\n\t\t\"teal\": \"#008080\"\n\t};\n\n\tthis.lineColor = '#FF912D';\n\tthis.childNodeFillColor = '#585DCB';\n\tthis.childNodeBorderColor = '#70BDC4';\n\tthis.containerFillColor = \"#9093DC\";\n\n\tthis.line1Like = {\n\t\t'-': '-',\n\t\t'--': '--',\n\t\t'->': '-',\n\t\t'-->': '--',\n\t\t'<-': '<-',\n\t\t'<--': '<--',\n\t\t'<->': '<-',\n\t\t'<-->': '<--'\n\t};\n\tthis.line2Like = {\n\t\t'-': '-',\n\t\t'--': '--',\n\t\t'->': '-',\n\t\t'-->': '--',\n\t\t'<-': '-',\n\t\t'<--': '--',\n\t\t'<->': '-',\n\t\t'<-->': '--'\n\t};\n\tthis.line3Like = {\n\t\t'-': '-',\n\t\t'--': '--',\n\t\t'->': '->',\n\t\t'-->': '-->',\n\t\t'<-': '-',\n\t\t'<--': '--',\n\t\t'<->': '->',\n\t\t'<-->': '-->'\n\t};\n\n\tthis.init();\n}\nQflow.prototype.init = function () {\n\tthis.reSizeByInitData();\n\n\tthis.initChildPosition();\n\n\tthis.initCanvas();\n\n\tthis.initNode();\n\n\tthis.lineLayer = this.qcanvas.qlayer.layer();\n\tthis.lineCache = {};\n\tthis.solveLink();\n\tthis.initLink();\n\n\tthis.contextSettingLayer = this.qcanvas.qlayer.layer();\n\tthis.contextSettingLayer.setDisplay('none');\n\n\tthis.settingIco = null;\n\tthis.initSettingIco();\n\n\tthis.contextMenuLayer = this.qcanvas.qlayer.layer();\n\tthis.contextMenuLayer.setDisplay('none');\n\tthis.contextMenuNode = null;\n\n\tthis.initMenu();\n\n\tthis.tmpLine = null;\n\tthis.contextLineMenuLayer = this.qcanvas.qlayer.layer();\n\tthis.contextLineMenuLayer.setDisplay('none');\n\tthis.contextLineMenuNode = null;\n\n\tthis.createFps();\n};\nQflow.prototype.createFps = function () {\n\tvar _this = this;\n\tthis.qcanvas.qtext.text({\n\t\ttext: 'qrelation Version v1.0.108',\n\t\tcolor: '#dcdcdc',\n\t\tfontSize: '10px',\n\t\ttextAlign: 'left',\n\t\tstart: [5, 50],\n\t\tpointerEvent: 'none'\n\t});\n};\nQflow.prototype.returnSaveData = function () {\n\tvar tmp = JSON.parse(JSON.stringify(this.options.initData));\n\n\ttmp.node && tmp.node.forEach(function (item) {\n\t\tdelete item.childNodes;\n\t});\n\n\ttmp.link && tmp.link.forEach(function (item) {\n\t\tdelete item.fromNode;\n\t\tdelete item.toNode;\n\t});\n\n\treturn tmp;\n};\nQflow.prototype.initContextLineMenuArea = function (pos) {\n\tvar _this = this;\n\n\tvar tmp = this.qcanvas.qrect.rect({\n\t\tstart: [pos.x, pos.y],\n\t\twidth: 150,\n\t\theight: 150,\n\t\tborderColor: '',\n\t\tfillColor: 'yellow',\n\t\tdrag: false\n\t});\n\n\tthis.contextLineMenuLayer.push(tmp);\n};\nQflow.prototype.resetPosOfLineModiTitleNode = function () {\n\tvar ele = this.contextLineMenuLayer.elements[0];\n\tvar x = ele.start[0] + 5;\n\tvar y = ele.start[1] + 5;\n\tvar w = (ele.width - 10) * 0.5;\n\tvar h = 30;\n\n\tvar d = document.getElementById('lineTitleInput');\n\td.style.left = x + 'px';\n\td.style.top = y + 'px';\n\td.style.width = w + 'px';\n\td.style.height = h + 'px';\n\td.style.display = 'block';\n};\nQflow.prototype.modiLineTitle = function (v) {\n\tif (this.modiTitleObj !== null) {\n\t\tthis.modiTitleObj.setText(v);\n\t}\n\n\tvar json = this.getLineJsonByNodeId(this.contextLineMenuNode.id);\n\tjson.attr.text = v;\n};\nQflow.prototype.modiLineLike = function (v) {\n\n\tif (this.contextLineMenuNode.relationLineId) {\n\n\t\tvar l1 = this.lineLayer.getEleById(this.contextLineMenuNode.relationLineId[0]);\n\t\tvar l3 = this.lineLayer.getEleById(this.contextLineMenuNode.relationLineId[1]);\n\n\t\tl1.setLike(this.line1Like[v]);\n\t\tl3.setLike(this.line3Like[v]);\n\t\tthis.contextLineMenuNode.setLike(this.line2Like[v]);\n\t} else {\n\t\tthis.contextLineMenuNode.setLike(v);\n\t}\n\n\tvar json = this.getLineJsonByNodeId(this.contextLineMenuNode.id);\n\tjson.attr.like = v;\n};\n\nQflow.prototype.modiLineType = function (v) {\n\n\tvar json = this.getLineJsonByNodeId(this.contextLineMenuNode.id);\n\n\tif (typeof json.attr.type != 'undefined' && v != json.attr.type || typeof json.attr.type == 'undefined') {\n\n\t\tjson.attr.type = v;\n\n\t\tthis.lineLayer.destroy();\n\t\tthis.initLink();\n\n\t\tthis.lineMenuLayerHide();\n\t}\n};\n\nQflow.prototype.initLineModiTitleNode = function () {\n\n\tvar ele = this.contextLineMenuLayer.elements[0];\n\tvar x = ele.start[0] + 5;\n\tvar y = ele.start[1] + 5;\n\tvar w = (ele.width - 10) * 0.5;\n\tvar h = 30;\n\n\tvar d = document.getElementById('lineTitleInput');\n\td.style.left = x + 'px';\n\td.style.top = y + 'px';\n\td.style.width = w + 'px';\n\td.style.height = h + 'px';\n\td.style.display = 'block';\n\n\tconsole.log(this.contextLineMenuNode);\n\tthis.modiTitleObj = this.lineLayer.getEleById(this.contextLineMenuNode.withTextId);\n\tconsole.log(this.modiTitleObj);\n\td.value = this.modiTitleObj.text;\n};\nQflow.prototype.initLineLikeNode = function () {\n\tvar ele = this.contextLineMenuLayer.elements[0];\n\tvar x = ele.start[0] + ele.width * 0.5;\n\tvar y = ele.start[1] + 5;\n\tvar w = (ele.width - 10) * 0.5;\n\tvar h = 30;\n\n\tvar d = document.getElementById('lineLike');\n\td.style.left = x + 'px';\n\td.style.top = y + 'px';\n\td.style.width = w + 'px';\n\td.style.height = h + 'px';\n\td.style.display = 'block';\n\n\td.value = this.contextLineMenuNode.like;\n};\nQflow.prototype.initLineTypeNode = function () {\n\n\tvar ele = this.contextLineMenuLayer.elements[0];\n\tvar x = ele.start[0] + 5;\n\tvar y = ele.start[1] + ele.height - 40;\n\tvar w = (ele.width - 10) * 0.5;\n\tvar h = 30;\n\n\tvar d = document.getElementById('lineType');\n\td.style.left = x + 'px';\n\td.style.top = y + 'px';\n\td.style.width = w + 'px';\n\td.style.height = h + 'px';\n\td.style.display = 'block';\n\n\td.value = '';\n};\n\nQflow.prototype.initLineColorRect = function () {\n\tvar _this = this;\n\tvar disTop = 10;\n\tvar padding = 10;\n\tvar rectW = 13;\n\tvar rectH = 13;\n\n\tvar tmp = this.contextLineMenuLayer.elements[0];\n\n\tvar areaPosition = [{\n\t\tx: tmp.start[0] + 10,\n\t\ty: tmp.start[1] + 30 + disTop\n\t}, {\n\t\tx: tmp.start[0] + tmp.width - 10,\n\t\ty: tmp.start[1] + tmp.height + 30 - 10\n\t}];\n\n\tvar pos = this.childPositionByRow(4, 6, areaPosition, rectW, rectH);\n\n\tvar color = [];\n\tfor (var i in this.colorRect) {\n\t\tcolor.push(this.colorRect[i]);\n\t}\n\n\tfor (var i = 0; i < color.length; i++) {\n\t\tthis.contextLineMenuLayer.push(this.qcanvas.qrect.rect({\n\t\t\tstart: [pos[i].x, pos[i].y],\n\t\t\twidth: rectW,\n\t\t\theight: rectH,\n\t\t\tfillColor: color[i],\n\t\t\tdrag: false,\n\t\t\tmouseup: function mouseup() {\n\n\t\t\t\t_this.contextLineMenuNode.setColor(this.fillColor);\n\n\t\t\t\tvar json = _this.getLineJsonByNodeId(_this.contextLineMenuNode.id);\n\t\t\t\tjson.attr.color = this.fillColor;\n\n\t\t\t\tvar textObj = _this.lineLayer.getEleById(_this.contextLineMenuNode.withTextId);\n\t\t\t\ttextObj.setColor(this.fillColor);\n\t\t\t}\n\t\t}));\n\t}\n};\nQflow.prototype.delLineNode = function () {\n\tvar _this = this;\n\n\tvar tmp = this.options.initData.link.filter(function (item) {\n\t\treturn item.lineId != _this.contextLineMenuNode.id;\n\t});\n\tthis.options.initData.link = tmp;\n\n\tif (typeof this.contextLineMenuNode.withTextId != 'undefined') {\n\t\tvar textObj = this.lineLayer.getEleById(this.contextLineMenuNode.withTextId);\n\t\tthis.lineLayer.removeEle(textObj);\n\n\t\tthis.lineLayer.removeEleById(this.contextLineMenuNode.withTextId);\n\t}\n\n\tif (typeof this.contextLineMenuNode.relationLineId != 'undefined') {\n\n\t\tthis.contextLineMenuNode.relationLineId.forEach(function (item) {\n\t\t\t_this.lineLayer.removeEleById(item);\n\t\t});\n\t}\n\n\tthis.lineLayer.removeEle(this.contextLineMenuNode);\n};\nQflow.prototype.initLineDelBtn = function () {\n\tvar _this = this;\n\tvar ele = this.contextLineMenuLayer.elements[0];\n\n\tthis.contextLineMenuLayer.push(this.qcanvas.qrect.rect({\n\t\tstart: [ele.start[0] + ele.width - 70, ele.start[1] + ele.height - 40],\n\t\twidth: 60,\n\t\theight: 30,\n\t\tfillColor: '#fff',\n\t\tdrag: false,\n\t\tmouseup: function mouseup() {\n\t\t\tconsole.log('del');\n\n\t\t\t_this.delLineNode();\n\n\t\t\t_this.lineMenuLayerHide();\n\t\t}\n\t}), this.qcanvas.qtext.text({\n\t\ttext: '删除',\n\t\tstart: [ele.start[0] + ele.width - 40, ele.start[1] + ele.height - 25],\n\t\tfontSize: '12px',\n\t\tcolor: '#000',\n\t\tpointerEvent: 'none'\n\t}));\n};\nQflow.prototype.initLineMenu = function (pos) {\n\n\tthis.lineMenuLayerHide();\n\n\tthis.initContextLineMenuArea(pos);\n\n\tthis.initLineModiTitleNode();\n\n\tthis.initLineLikeNode();\n\n\tthis.initLineTypeNode();\n\n\tthis.initLineColorRect();\n\n\tthis.initLineDelBtn();\n};\nQflow.prototype.download = function () {\n\tvar obj = document.getElementById(this.options.id);\n\n\tvar tmp = document.createElement('canvas');\n\tvar context = tmp.getContext('2d');\n\ttmp.width = this.options.width;\n\ttmp.height = this.options.height;\n\tcontext.fillStyle = \"#fff\";\n\tcontext.fillRect(0, 0, parseInt(obj.style.width), parseInt(obj.style.height));\n\tcontext.drawImage(obj, 0, -40, parseInt(obj.style.width), parseInt(obj.style.height));\n\n\tvar oA = document.createElement(\"a\");\n\toA.download = '';\n\toA.href = tmp.toDataURL(\"image/png\", 1.0);\n\tdocument.body.appendChild(oA);\n\toA.click();\n\toA.remove();\n};\nQflow.prototype.destroy = function () {\n\n\tthis.qcanvas.elements.forEach(function (item) {\n\t\tif (item.TYPE == 'layer') {\n\t\t\titem.destroy();\n\t\t}\n\t});\n\n\tthis.qcanvas.destroy();\n};\nQflow.prototype.lineMenuLayerShow = function (pos) {\n\n\tthis.contextLineMenuLayer.setDisplay('block');\n};\nQflow.prototype.lineMenuLayerHide = function () {\n\tthis.contextLineMenuLayer.setDisplay('none');\n\tthis.contextLineMenuLayer.destroy();\n\n\n\tvar d1 = document.getElementById('lineTitleInput');\n\tvar d2 = document.getElementById('lineLike');\n\tvar d3 = document.getElementById('lineType');\n\n\td1.style.display = 'none';\n\td2.style.display = 'none';\n\td3.style.display = 'none';\n};\nQflow.prototype.updateTmpLineEndPos = function (pos) {\n\n\tif (this.tmpLine !== null) {\n\t\tthis.tmpLine.setEnd([pos.x, pos.y]);\n\t}\n};\nQflow.prototype.delTmpLine = function () {\n\tif (this.tmpLine !== null) {\n\t\tvar text = this.qcanvas.getEleById(this.tmpLine.withTextId);\n\t\tthis.qcanvas.removeEle(this.tmpLine);\n\t\tthis.qcanvas.removeEle(text);\n\n\t\tthis.tmpLine = null;\n\t}\n};\n\nQflow.prototype.createNewLine = function (node, jsonObj) {\n\tvar _this = this;\n\n\tif (this.contextMenuNode !== null) {\n\n\t\tvar fromJSON = this.getJsonObj(this.contextMenuNode.id);\n\n\t\tif (fromJSON.id == jsonObj.id) {\n\t\t\tthis.contextMenuNode = null;\n\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.options.initData.link.push({\n\t\t\tfromId: fromJSON.id,\n\t\t\ttoId: jsonObj.id,\n\t\t\tattr: {\n\t\t\t\tlike: '->',\n\t\t\t\tcolor: this.lineColor,\n\t\t\t\ttext: '连线关系'\n\t\t\t}\n\t\t});\n\t\tthis.solveLink();\n\n\t\tvar json = this.options.initData.link[this.options.initData.link.length - 1];\n\t\tvar tmp = this.qcanvas.qline.line({\n\t\t\tstart: function start() {\n\t\t\t\treturn _this.calcLineStartPos(json.fromNode, json.toNode, this.id);\n\t\t\t},\n\t\t\tend: function end() {\n\t\t\t\treturn _this.calcLineEndPos(json.fromNode, json.toNode, this.id);\n\t\t\t},\n\t\t\twidth: 1,\n\n\t\t\tdrag: false,\n\t\t\tlike: json.attr.like,\n\t\t\tcolor: json.attr.color,\n\t\t\twithText: '连接关系',\n\t\t\tmouseup: function mouseup(e, pos) {\n\t\t\t\tif (e.button == '2') {\n\n\t\t\t\t\t_this.contextLineMenuNode = this;\n\n\t\t\t\t\t_this.qcanvas.raiseToTop(_this.contextLineMenuLayer);\n\t\t\t\t\t_this.initLineMenu(pos);\n\t\t\t\t\t_this.lineMenuLayerShow();\n\n\t\t\t\t\t_this.contextSettingHide();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.lineLayer.push(tmp);\n\n\t\tjson.lineId = tmp.id;\n\n\t\tthis.contextMenuNode = null;\n\t}\n};\nQflow.prototype.createTmpLine = function (pos) {\n\tvar centerPos = this.contextMenuNode.centerPoints();\n\tthis.tmpLine = this.qcanvas.qline.line({\n\t\tstart: [centerPos.x, centerPos.y],\n\t\tend: [pos.x, pos.y],\n\t\twidth: 1,\n\t\tlike: '->',\n\t\tcolor: this.lineColor,\n\t\twithText: '连接关系',\n\t\twithTextAlign: 'left',\n\t\tpointerEvent: 'none'\n\t});\n};\nQflow.prototype.getLineObj = function (nodeId) {\n\tvar tmp = this.lineLayer.elements.filter(function (item) {\n\t\treturn item.id == nodeId;\n\t});\n\n\tif (tmp.length > 0) {\n\t\treturn tmp[0];\n\t} else {\n\t\treturn null;\n\t}\n};\n\nQflow.prototype.getLineJsonByNodeId = function (nodeId) {\n\tvar tmp = this.options.initData.link.filter(function (item) {\n\t\treturn item.lineId == nodeId;\n\t});\n\n\tif (tmp.length > 0) {\n\t\treturn tmp[0];\n\t} else {\n\t\treturn null;\n\t}\n};\nQflow.prototype.getDelLineObj = function (nodeObj) {\n\tvar _this = this;\n\n\tvar lineObj = [];\n\n\tnodeObj.forEach(function (item) {\n\n\t\t_this.options.initData.link.forEach(function (l) {\n\n\t\t\tif (l.fromNode.id == item.id || l.toNode.id == item.id) {\n\n\t\t\t\tlineObj.push(_this.getLineObj(l.lineId));\n\t\t\t}\n\t\t});\n\t});\n\n\treturn lineObj;\n};\nQflow.prototype.getDelTextObj = function (nodeObj) {\n\tvar _this = this;\n\n\tvar textObj = [];\n\n\tvar allTextObj = this.qcanvas.elements.filter(function (item) {\n\t\treturn item.TYPE == 'text';\n\t});\n\n\tnodeObj.forEach(function (item) {\n\n\t\tallTextObj.forEach(function (t) {\n\n\t\t\tif (typeof t.ownerId !== 'undefined' && t.ownerId == item.id) {\n\t\t\t\ttextObj.push(t);\n\t\t\t}\n\t\t});\n\t});\n\n\treturn textObj;\n};\nQflow.prototype.getWithTextObj = function (nodeObj) {\n\tvar _this = this;\n\tvar textObj = [];\n\tnodeObj.forEach(function (item) {\n\n\t\t_this.lineLayer.elements.forEach(function (t) {\n\n\t\t\tif (typeof item.withTextId !== 'undefined' && t.id == item.withTextId) {\n\t\t\t\ttextObj.push(t);\n\t\t\t}\n\t\t});\n\t});\n\n\treturn textObj;\n};\nQflow.prototype.updateNodeJsonAfterDelNode = function (nodeObj) {\n\tvar _this = this;\n\n\tnodeObj.forEach(function (item) {\n\t\tvar node = _this.getJsonObj(item.id);\n\t\tnode.isDel = true;\n\t});\n\n\tvar tmp = [];\n\n\tfor (var i = 0; i < this.options.initData.node.length; i++) {\n\n\t\tif (typeof this.options.initData.node[i].isDel != 'undefined' && this.options.initData.node[i].isDel) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\ttmp.push(this.options.initData.node[i]);\n\n\t\t\tif (typeof tmp[tmp.length - 1].child != 'undefined') {\n\t\t\t\ttmp[tmp.length - 1].child = tmp[tmp.length - 1].child.filter(function (item) {\n\n\t\t\t\t\treturn typeof item.isDel == 'undefined' || !item.isDel;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.options.initData.node = tmp;\n};\nQflow.prototype.updatelinkJsonAfterDelNode = function (nodeObj) {\n\tvar _this = this;\n\tnodeObj.forEach(function (l) {\n\n\t\t_this.options.initData.link.forEach(function (item) {\n\t\t\tif (item.lineId == l.id) {\n\t\t\t\titem.isDel = true;\n\t\t\t}\n\t\t});\n\t});\n\n\tthis.options.initData.link = this.options.initData.link.filter(function (item) {\n\t\treturn typeof item.isDel == 'undefined' || !item.isDel;\n\t});\n};\nQflow.prototype.delNode = function () {\n\tvar _this = this;\n\n\tvar nodeId = this.contextMenuNode.id;\n\tthis.contextMenuNode = null;\n\tvar nodeJson = this.getJsonObj(nodeId);\n\n\tvar delNodeObj = [];\n\tif (nodeJson.nodeType == 'container') {\n\t\tdelNodeObj = delNodeObj.concat(nodeJson.childNodes);\n\t\tdelNodeObj.push(this.getNodeObj(nodeJson.nodeId));\n\t} else {\n\n\t\tdelNodeObj.push(this.getNodeObj(nodeJson.nodeId));\n\t}\n\n\n\tvar delLineObj = this.getDelLineObj(delNodeObj);\n\tthis.updateNodeJsonAfterDelNode(delNodeObj);\n\tthis.updatelinkJsonAfterDelNode(delLineObj);\n\n\tdelLineObj.forEach(function (item) {\n\t\tif (typeof item.withTextId != 'undefined') {\n\t\t\t_this.lineLayer.removeEleById(item.withTextId);\n\t\t}\n\n\t\tif (typeof item.relationLineId != 'undefined') {\n\t\t\titem.relationLineId.forEach(function (r) {\n\t\t\t\t_this.lineLayer.removeEleById(r);\n\t\t\t});\n\t\t}\n\n\t\t_this.lineLayer.removeEleById(item.id);\n\t});\n\n\tdelNodeObj.forEach(function (item) {\n\t\tif (typeof item.ownerId != 'undefined') {\n\t\t\tvar jsonObj = _this.getJsonObj(item.ownerId);\n\n\t\t\tif (jsonObj !== null) {\n\n\t\t\t\tjsonObj.childNodes.forEach(function (c) {\n\t\t\t\t\tif (c.id == item.id) {\n\t\t\t\t\t\tc.isDel = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tjsonObj.childNodes = jsonObj.childNodes.filter(function (item) {\n\t\t\t\t\treturn typeof item.isDel == 'undefined' || !item.isDel;\n\t\t\t\t});\n\n\t\t\t\tjsonObj.childNodes.forEach(function (item, index) {\n\t\t\t\t\titem.sort = index;\n\t\t\t\t});\n\n\t\t\t\tif (jsonObj.attr.titlePosition == 'top-center') {\n\t\t\t\t\tvar startPlaceHolderY = _this.containerTitleHeight + _this.containerPadding;\n\t\t\t\t\tvar row = Math.ceil((jsonObj.child.length == 0 ? 1 : jsonObj.child.length) / jsonObj.grid[1]);\n\t\t\t\t\tjsonObj.height = startPlaceHolderY + _this.childNodeHeight * row + row * _this.containerChildMargin;\n\t\t\t\t\tjsonObj.grid[0] = row;\n\t\t\t\t\tvar containerObj = _this.getNodeObj(item.ownerId);\n\t\t\t\t\tcontainerObj.setHeight(jsonObj.height);\n\t\t\t\t}\n\n\t\t\t\tvar childAreaPosition = _this.getChildAreaPosition(jsonObj);\n\n\t\t\t\tvar childPosition = _this.getChildPosition(jsonObj, childAreaPosition);\n\n\t\t\t\tjsonObj.attr.gridPosition = childPosition;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof item.ownerId !== 'undefined') {\n\t\t\t_this.lineLayer.removeEleById(item.ownerId);\n\t\t}\n\n\t\t_this.qcanvas.removeEle(item);\n\t});\n\n\t_this.contextMenuNode = null;\n};\nQflow.prototype.cloneNode = function () {\n\tvar _this = this;\n\tvar nodeObj = this.contextMenuNode;\n\tvar nodeJsonObj = this.getJsonObj(nodeObj.id);\n\n\n\tif (nodeJsonObj.nodeType == 'node') {\n\n\t\tif (typeof nodeObj.ownerId == 'undefined') {\n\n\t\t\tthis.addNode({ x: nodeJsonObj.x + 20, y: nodeJsonObj.y + 20 }, nodeJsonObj.text);\n\t\t} else {\n\n\t\t\tthis.inSertToContainer({}, { id: nodeObj.ownerId }, nodeJsonObj.text);\n\t\t}\n\t}\n\n\tif (nodeJsonObj.nodeType == 'container') {\n\t\tvar id = this.addContainer({ x: nodeJsonObj.x + 20, y: nodeJsonObj.y + 20 }, {\n\t\t\ttext: nodeJsonObj.text,\n\t\t\tgrid: nodeJsonObj.grid,\n\t\t\twidth: nodeJsonObj.width,\n\t\t\theight: nodeJsonObj.height\n\t\t});\n\n\n\t\tnodeJsonObj.child.forEach(function (item) {\n\t\t\t_this.inSertToContainer({}, { id: id }, item.text);\n\t\t});\n\t}\n\n\tif (nodeJsonObj.nodeType == 'tip') {\n\t\tconsole.log('clone tip');\n\t\tthis.cloneTipNode();\n\t}\n\n\tthis.contextMenuNode = null;\n};\nQflow.prototype.initMenu = function () {\n\tvar _this = this;\n\tvar area = this.qcanvas.qrect.rect({\n\t\tstart: [0, 0],\n\t\twidth: 100,\n\t\theight: 75,\n\t\tborderColor: '',\n\t\tfillColor: '#fff',\n\t\tdrag: false\n\t});\n\tvar linkRect = this.qcanvas.qrect.rect({\n\t\tstart: function start() {\n\n\t\t\treturn area.start;\n\t\t},\n\t\twidth: 100,\n\t\theight: 25,\n\t\tborderColor: '',\n\t\tfillColor: '#fff',\n\t\tdrag: false,\n\t\tmouseup: function mouseup(e, pos) {\n\t\t\t_this.menuLayerHide();\n\t\t\t_this.createTmpLine(pos);\n\t\t}\n\t});\n\tvar linkTxt = this.qcanvas.qtext.text({\n\t\ttext: '连接到',\n\t\tstart: function start() {\n\t\t\treturn [_this.contextMenuLayer.elements[0].start[0] + _this.contextMenuLayer.elements[0].width * 0.5, _this.contextMenuLayer.elements[0].start[1] + 25 * 0.5];\n\t\t},\n\t\tfontSize: '12px',\n\t\tcolor: '#000',\n\t\tpointerEvent: 'none'\n\t});\n\tvar cloneRect = this.qcanvas.qrect.rect({\n\t\tstart: function start() {\n\n\t\t\treturn [area.start[0], area.start[1] + 25];\n\t\t},\n\t\twidth: 100,\n\t\theight: 25,\n\t\tborderColor: '',\n\t\tfillColor: '#fff',\n\t\tdrag: false,\n\t\tmouseup: function mouseup(e, pos) {\n\t\t\tconsole.log('clone');\n\t\t\t_this.menuLayerHide();\n\n\t\t\t_this.cloneNode();\n\t\t}\n\t});\n\tvar cloneText = this.qcanvas.qtext.text({\n\t\ttext: '克隆',\n\t\tstart: function start() {\n\t\t\treturn [_this.contextMenuLayer.elements[0].start[0] + _this.contextMenuLayer.elements[0].width * 0.5, _this.contextMenuLayer.elements[0].start[1] + 25 + 25 * 0.5];\n\t\t},\n\t\tfontSize: '12px',\n\t\tcolor: '#000',\n\t\tpointerEvent: 'none'\n\t});\n\n\tvar delRect = this.qcanvas.qrect.rect({\n\t\tstart: function start() {\n\n\t\t\treturn [area.start[0], area.start[1] + 50];\n\t\t},\n\t\twidth: 100,\n\t\theight: 25,\n\t\tborderColor: '',\n\t\tfillColor: '#fff',\n\t\tdrag: false,\n\t\tmouseup: function mouseup(e, pos) {\n\t\t\tconsole.log('删除');\n\t\t\t_this.menuLayerHide();\n\n\n\t\t\t_this.delNode();\n\t\t}\n\t});\n\tvar delTxt = this.qcanvas.qtext.text({\n\t\ttext: '删除',\n\t\tstart: function start() {\n\t\t\treturn [_this.contextMenuLayer.elements[0].start[0] + _this.contextMenuLayer.elements[0].width * 0.5, _this.contextMenuLayer.elements[0].start[1] + 50 + 25 * 0.5];\n\t\t},\n\t\tfontSize: '12px',\n\t\tcolor: '#000',\n\t\tpointerEvent: 'none'\n\t});\n\n\tthis.contextMenuLayer.push(area, linkRect, linkTxt, cloneRect, cloneText, delRect, delTxt);\n};\nQflow.prototype.menuLayerShow = function (pos) {\n\n\tthis.contextMenuLayer.elements[0].setStart([pos.x, pos.y]);\n\tthis.contextMenuLayer.setDisplay('block');\n\tthis.qcanvas.raiseToTop(this.contextMenuLayer);\n};\n\nQflow.prototype.menuLayerHide = function () {\n\tthis.contextMenuLayer.setDisplay('none');\n};\nQflow.prototype.initSettingIco = function () {\n\tvar _this = this;\n\n\tthis.settingIco = this.qcanvas.qarc.arc({\n\t\tstart: [0, 0],\n\t\tsAngle: 0,\n\t\teAngle: 360,\n\t\tborderColor: 'red',\n\t\tfillColor: 'red',\n\t\topacity: 0.5,\n\t\tr: 5,\n\t\tdisplay: 'none',\n\t\tdrag: false,\n\t\tmousemove: function mousemove() {\n\t\t\tthis.setDisplay('block');\n\t\t},\n\t\tmouseup: function mouseup(e, pos) {\n\t\t\t_this.contextSettingHide();\n\n\t\t\t_this.delTmpLine();\n\t\t\t_this.contextMenuNode = null;\n\n\t\t\t_this.contextSettingNode = this.contextSettingNode;\n\n\t\t\t_this.qcanvas.raiseToTop(_this.contextSettingLayer);\n\n\t\t\t_this.contextSettingShow(pos);\n\n\t\t\t_this.lineMenuLayerHide();\n\t\t}\n\t});\n};\nQflow.prototype.settingIcoShow = function (node) {\n\tvar start = this.qcanvas.isFun(node.start) ? node.start() : node.start;\n\tvar x = start[0] + node.width - 8;\n\tvar y = start[1] + 8;\n\n\tthis.settingIco.contextSettingNode = node;\n\n\tthis.settingIco.setStart([x, y]);\n\n\tthis.settingIco.setDisplay('block');\n\tthis.qcanvas.raiseToTop(this.settingIco);\n};\nQflow.prototype.settingIcoHide = function () {\n\tthis.settingIco.setDisplay('none');\n};\n\nQflow.prototype.initContextCover = function () {\n\tvar _this = this;\n\n\tthis.contextSettingLayer.push(this.qcanvas.qrect.rect({\n\t\tstart: [0, 0],\n\t\twidth: this.qcanvas.stage.width,\n\t\theight: this.qcanvas.stage.height,\n\t\tborderColor: '',\n\t\tfillColor: '#000',\n\t\topacity: 0.1,\n\t\tdrag: false,\n\t\tmouseup: function mouseup() {\n\t\t\t_this.contextSettingHide();\n\t\t}\n\t}));\n};\nQflow.prototype.contextSettingShow = function (pos) {\n\tthis.initContextMenuArea(pos);\n\n\tthis.initModiTitleNode();\n\n\tthis.initContextMenuTab();\n\n\tthis.initColorRect();\n\n\tthis.contextSettingLayer.setDisplay('block');\n};\nQflow.prototype.initDelBtn = function () {\n\tvar _this = this;\n\tvar ele = this.contextSettingLayer.elements[1];\n\n\tthis.contextSettingLayer.push(this.qcanvas.qrect.rect({\n\t\tstart: [ele.start[0] + ele.width - 70, ele.start[1] + ele.height - 40],\n\t\twidth: 60,\n\t\theight: 30,\n\t\tfillColor: '#fff',\n\t\tdrag: false,\n\t\tmouseup: function mouseup() {\n\t\t\t_this.delNode();\n\n\t\t\t_this.contextSettingHide();\n\t\t}\n\t}), this.qcanvas.qtext.text({\n\t\ttext: '删除',\n\t\tstart: [ele.start[0] + ele.width - 40, ele.start[1] + ele.height - 25],\n\t\tfontSize: '12px',\n\t\tcolor: '#000',\n\t\tpointerEvent: 'none'\n\t}));\n};\nQflow.prototype.modiTitle = function (v) {\n\tconsole.log(this.modiTitleObj);\n\tif (this.modiTitleObj) {\n\t\tthis.modiTitleObj.setText(v);\n\t}\n\n\tvar jsonObj = this.getJsonObj(this.contextSettingNode.nodeId);\n\tjsonObj.text = v;\n\n\tvar bgRect = this.getNodeObj(this.contextSettingNode.nodeId);\n\n\tvar textPolyPoints = this.modiTitleObj.polyPoints();\n\tconsole.log(textPolyPoints);\n\tvar tmp = this.modiTitleObj.formatText.call(this, this.modiTitleObj);\n\n\tvar w = Math.max.apply(null, tmp.width);\n\tw = w > bgRect.width ? w : bgRect.width;\n\tvar start = this.qcanvas.isFun(bgRect.start) ? bgRect.start() : bgRect.start;\n\n\tvar x = w > bgRect.width ? start[0] - (w - bgRect.width) * 0.5 : start[0];\n\n\tvar d = document.getElementById('titleInput');\n\td.style.width = w + 'px';\n\td.style.left = x + 'px';\n};\nQflow.prototype.initModiTitleNode = function () {\n\n\tvar rectJsonObj = this.getJsonObj(this.contextSettingNode.id);\n\n\n\tvar ele = this.contextSettingLayer.elements[0];\n\tvar x = ele.start[0] + 10;\n\tvar y = ele.start[1] + 10;\n\tvar w = ele.width - 20;\n\tvar h = 30;\n\n\tif (rectJsonObj.nodeType == 'container') {\n\n\t\tthis.contextSettingLayer.push(this.qcanvas.qtext.text({\n\t\t\tstart: [x + 10, y + 120],\n\t\t\ttext: '列:',\n\t\t\tcolor: '#000'\n\t\t}));\n\n\t\tvar c = document.getElementById('containerGridColumn');\n\t\tc.style.left = x + 30 + 'px';\n\t\tc.style.top = y + 105 + 'px';\n\t\tc.style.width = w - 30 + 'px';\n\t\tc.style.height = h + 'px';\n\t\tc.style.display = 'block';\n\n\t\tc.value = rectJsonObj.grid[1];\n\t}\n};\nQflow.prototype.contextSettingHide = function () {\n\tvar _this = this;\n\n\tthis.contextSettingNode = null;\n\n\tthis.contextSettingLayer.setDisplay('none');\n\n\tvar d = document.getElementById('titleInput');\n\tvar c = document.getElementById('containerGridColumn');\n\td.style.display = 'none';\n\tc.style.display = 'none';\n\n\tthis.contextSettingLayer.destroy();\n};\n\nQflow.prototype.initColorRect = function () {\n\tvar _this = this;\n\tvar disTop = 30;\n\tvar padding = 10;\n\tvar rectW = 20;\n\tvar rectH = 20;\n\n\tvar tmp = this.contextSettingLayer.elements[0];\n\n\tvar areaPosition = [{\n\t\tx: tmp.start[0] + 10,\n\t\ty: tmp.start[1] + disTop\n\t}, {\n\t\tx: tmp.start[0] + tmp.width - 10,\n\t\ty: tmp.start[1] + tmp.height - 10\n\t}];\n\n\tvar pos = this.childPositionByRow(4, 6, areaPosition, rectW, rectH);\n\n\tvar color = [];\n\tfor (var i in this.colorRect) {\n\t\tcolor.push(this.colorRect[i]);\n\t}\n\n\tfor (var i = 0; i < color.length; i++) {\n\t\tthis.contextSettingLayer.push(this.qcanvas.qrect.rect({\n\t\t\tstart: [pos[i].x, pos[i].y],\n\t\t\twidth: rectW,\n\t\t\theight: rectH,\n\t\t\tfillColor: color[i],\n\t\t\tdrag: false,\n\t\t\tmouseup: function mouseup() {\n\n\t\t\t\tif (_this.contextAimAttr == 'color') {\n\t\t\t\t\t_this.updateNodeTitleColor(this.fillColor);\n\t\t\t\t} else {\n\n\t\t\t\t\t_this.contextSettingNode[_this.contextAimAttr] = this.fillColor;\n\t\t\t\t}\n\n\t\t\t\t_this.updateInitDataAttr(this.fillColor);\n\t\t\t}\n\t\t}));\n\t}\n};\nQflow.prototype.updateNodeTitleColor = function (v) {\n\n\tvar _this = this;\n\n\tvar getTitleNodeJSON = function getTitleNodeJSON() {\n\n\t\tvar tmp = _this.options.initData.node.filter(function (item) {\n\t\t\treturn item.nodeId == _this.contextSettingNode.id;\n\t\t});\n\n\t\tif (tmp.length > 0) {\n\t\t\treturn tmp[0];\n\t\t} else {\n\t\t\tconsole.log('没有找到');\n\n\t\t\tvar tmp;\n\t\t\t_this.options.initData.node.forEach(function (item) {\n\t\t\t\tif (item.nodeType == 'container') {\n\t\t\t\t\tfor (var i = 0; i < item.child.length; i++) {\n\t\t\t\t\t\tif (item.child[i].nodeId == _this.contextSettingNode.id) {\n\t\t\t\t\t\t\ttmp = item.child[i];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn tmp;\n\t\t}\n\t};\n\n\tvar titleJSON = getTitleNodeJSON();\n\n\tvar tmp = this.qnodes.filter(function (item) {\n\t\treturn item.id == titleJSON.attr.titleId;\n\t});\n\n\tif (tmp.length > 0) {\n\t\ttmp[0][_this.contextAimAttr] = v;\n\t}\n};\n\nQflow.prototype.updateInitDataAttr = function (v) {\n\n\tvar _this = this;\n\tvar getTitleNodeJSON = function getTitleNodeJSON() {\n\n\t\tvar tmp = _this.options.initData.node.filter(function (item) {\n\t\t\treturn item.nodeId == _this.contextSettingNode.id;\n\t\t});\n\n\t\tif (tmp.length > 0) {\n\t\t\treturn tmp[0];\n\t\t} else {\n\t\t\tconsole.log('没有找到');\n\n\t\t\tvar tmp;\n\t\t\t_this.options.initData.node.forEach(function (item) {\n\t\t\t\tif (item.nodeType == 'container') {\n\t\t\t\t\tfor (var i = 0; i < item.child.length; i++) {\n\t\t\t\t\t\tif (item.child[i].nodeId == _this.contextSettingNode.id) {\n\t\t\t\t\t\t\ttmp = item.child[i];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn tmp;\n\t\t}\n\t};\n\n\tvar titleNodeJSON = getTitleNodeJSON();\n\ttitleNodeJSON.attr[_this.contextAimAttr] = v;\n};\n\nQflow.prototype.initContextMenuTab = function () {\n\tvar _this = this;\n\tvar tmp = this.contextSettingLayer.elements[0];\n\n\tvar textArr = [{ text: '边框颜色', aimAttr: 'borderColor' }, { text: '背景颜色', aimAttr: 'fillColor' }, { text: '文字颜色', aimAttr: 'color' }];\n\n\ttextArr.forEach(function (item, index) {\n\t\tvar x = tmp.start[0] + index * (200 / textArr.length) + 200 / textArr.length * 0.5;\n\n\t\tif (index == 0) {\n\t\t\t_this.contextAimAttr = item.aimAttr;\n\t\t}\n\n\t\tvar c = _this.qcanvas.qtext.text({\n\t\t\ttext: item.text,\n\t\t\tstart: [x, tmp.start[1] + 15],\n\n\t\t\tcolor: index == 0 ? '#000' : '#ccc',\n\t\t\taimAttr: item.aimAttr,\n\t\t\tdrag: false,\n\t\t\tmouseup: function mouseup() {\n\t\t\t\tvar _self = this;\n\t\t\t\t_this.contextSettingLayer.elements.forEach(function (item) {\n\n\t\t\t\t\tif (item.TYPE == \"text\") {\n\t\t\t\t\t\titem.color = '#ccc';\n\n\t\t\t\t\t\tif (item.id == _self.id) {\n\t\t\t\t\t\t\t_this.contextAimAttr = item.aimAttr;\n\t\t\t\t\t\t\titem.color = '#000';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\t_this.contextSettingLayer.push(c);\n\t});\n};\nQflow.prototype.initContextMenuArea = function (pos) {\n\tvar _this = this;\n\n\tthis.contextSettingLayer.push(this.qcanvas.qrect.rect({\n\t\tstart: [pos.x, pos.y],\n\t\twidth: 200,\n\t\theight: 200,\n\t\tborderColor: '',\n\t\tfillColor: 'yellow',\n\t\tdrag: false\n\t}));\n};\nQflow.prototype.getContainerNodes = function () {\n\tvar containerNode = [];\n\tif (this.options.initData.node !== null && this.options.initData.node.length > 0) {\n\t\tcontainerNode = this.options.initData.node.filter(function (item) {\n\t\t\treturn item.nodeType == 'container';\n\t\t});\n\t}\n\n\treturn containerNode;\n};\nQflow.prototype.getChildAreaPosition = function (containerNode) {\n\tvar titlePosition = containerNode.attr.titlePosition;\n\n\tvar startPlaceHolderX = 0;\n\tvar startPlaceHolderY = 0;\n\tvar endPlaceHolderX = 0;\n\tvar endPlaceHolderY = 0;\n\tif (titlePosition == 'top-center') {\n\t\tstartPlaceHolderY += this.containerTitleHeight + this.containerPadding;\n\t}\n\n\treturn [{\n\t\tx: containerNode.x + startPlaceHolderX + this.containerChildMargin,\n\t\ty: containerNode.y + startPlaceHolderY\n\t}, {\n\t\tx: containerNode.x + containerNode.width - endPlaceHolderX,\n\t\ty: containerNode.y + containerNode.height - endPlaceHolderY\n\t}];\n};\n\nQflow.prototype.childPositionByRow = function (row, column, areaPosition, w, h) {\n\tvar tmp = [];\n\n\tfor (var i = 0; i < row; i++) {\n\t\tfor (var j = 0; j < column; j++) {\n\t\t\tif (tmp[i]) {\n\t\t\t\ttmp[i].push({\n\t\t\t\t\tx: areaPosition[0].x + j * w + j * this.containerChildMargin,\n\t\t\t\t\ty: areaPosition[0].y + i * h + i * this.containerChildMargin\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\ttmp[i] = [{\n\t\t\t\t\tx: areaPosition[0].x + j * w + j * this.containerChildMargin,\n\t\t\t\t\ty: areaPosition[0].y + i * h + i * this.containerChildMargin\n\t\t\t\t}];\n\t\t\t}\n\t\t}\n\t}\n\n\tvar t = [];\n\ttmp.forEach(function (item) {\n\t\tt = t.concat(item);\n\t});\n\n\treturn t;\n};\n\nQflow.prototype.getChildPosition = function (containerNode, areaPosition) {\n\tvar _this = this;\n\n\tvar grid = containerNode.grid;\n\tvar child = containerNode.child;\n\tvar childNum = containerNode.child.length;\n\tvar row = grid[0];\n\tvar column = grid[1];\n\tvar areaWidth = areaPosition[1].x - areaPosition[0].x;\n\tvar areaHeight = areaPosition[1].y - areaPosition[0].y;\n\n\treturn this.childPositionByRow(row, column, areaPosition, this.childNodeWidth, this.childNodeHeight);\n};\nQflow.prototype.initChildPosition = function () {\n\tif (this.options.initData === null) {\n\t\treturn;\n\t}\n\n\tvar containerNodes = this.getContainerNodes();\n\n\tfor (var i = 0; i < containerNodes.length; i++) {\n\t\tvar childAreaPosition = this.getChildAreaPosition(containerNodes[i]);\n\n\t\tvar childPosition = this.getChildPosition(containerNodes[i], childAreaPosition);\n\n\t\tcontainerNodes[i].attr.gridPosition = childPosition;\n\t}\n};\nQflow.prototype.reSizeByInitData = function () {\n\n\tif (this.options.initData === null) {\n\t\treturn;\n\t}\n\n\tif (this.options.initData.node !== null && this.options.initData.node.length > 0) {\n\t\tvar _this = this,\n\t\t    x = [],\n\t\t    y = [];\n\t\tthis.options.initData.node.map(function (item) {\n\n\t\t\tif (item.nodeType == 'container') {\n\t\t\t\tx.push(item.x + item.width);\n\t\t\t\ty.push(item.y + item.height);\n\t\t\t} else {\n\n\t\t\t\tx.push(item.x + _this.childNodeWidth);\n\t\t\t\ty.push(item.y + _this.childNodeHeight);\n\t\t\t}\n\t\t});\n\n\t\tvar maxX = Math.max.apply(null, x);\n\t\tvar maxY = Math.max.apply(null, y);\n\n\t\tthis.options.width = maxX >= this.options.width ? maxX : this.options.width;\n\t\tthis.options.height = maxY >= this.options.height ? maxY : this.options.height;\n\t}\n};\nQflow.prototype.getNodeIdFromJsonById = function (id) {\n\n\tvar tmp = null;\n\n\tfor (var i = 0; i < this.options.initData.node.length; i++) {\n\n\t\tif (this.options.initData.node[i].id == id) {\n\t\t\ttmp = this.options.initData.node[i].nodeId;\n\t\t\tbreak;\n\t\t}\n\t\tif (this.options.initData.node[i].child) {\n\t\t\tfor (var j = 0; j < this.options.initData.node[i].child.length; j++) {\n\t\t\t\tif (this.options.initData.node[i].child[j].id == id) {\n\t\t\t\t\ttmp = this.options.initData.node[i].child[j].nodeId;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn tmp;\n};\nQflow.prototype.calcLineStartPos = function (A, B, nodeId) {\n\tvar _this = this;\n\n\n\tvar F = function F() {\n\n\t\tvar A_center = A.centerPoints();\n\t\tvar B_center = B.centerPoints();\n\t\tvar A_rangePos = A.getRangePoints();\n\t\tvar B_rangePos = B.getRangePoints();\n\n\t\tvar startPos = [0, 0];\n\t\tvar endPos = [0, 0];\n\n\t\tif (A_center.y >= B_center.y) {\n\t\t\tif (A_rangePos[0][1] <= B_rangePos[6][1]) {\n\t\t\t\tif (A_rangePos[0][0] >= B_rangePos[2][0]) {\n\n\t\t\t\t\tstartPos = A_rangePos[7];\n\t\t\t\t} else if (A_rangePos[2][0] <= B_rangePos[0][0]) {\n\t\t\t\t\tstartPos = A_rangePos[3];\n\t\t\t\t} else {\n\n\t\t\t\t\tstartPos = A_rangePos[1];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (A_rangePos[0][0] >= B_rangePos[2][0]) {\n\n\t\t\t\t\tstartPos = A_rangePos[1];\n\t\t\t\t} else if (A_rangePos[2][0] <= B_rangePos[2][0]) {\n\t\t\t\t\tstartPos = A_rangePos[1];\n\t\t\t\t} else {\n\n\t\t\t\t\tstartPos = A_rangePos[1];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (B_rangePos[0][1] <= A_rangePos[6][1]) {\n\t\t\t\tif (A_rangePos[0][0] >= B_rangePos[2][0]) {\n\t\t\t\t\tstartPos = A_rangePos[7];\n\t\t\t\t} else if (A_rangePos[2][0] <= B_rangePos[0][0]) {\n\t\t\t\t\tstartPos = A_rangePos[3];\n\t\t\t\t} else {\n\t\t\t\t\tstartPos = A_rangePos[5];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (A_rangePos[0][0] >= B_rangePos[2][0]) {\n\t\t\t\t\tstartPos = A_rangePos[5];\n\t\t\t\t} else if (A_rangePos[2][0] <= B_rangePos[0][0]) {\n\t\t\t\t\tstartPos = A_rangePos[5];\n\t\t\t\t} else {\n\t\t\t\t\tstartPos = A_rangePos[5];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn startPos;\n\t};\n\n\tif (typeof this.lineCache['\"' + nodeId + '\"'] !== 'undefined' && typeof this.lineCache['\"' + nodeId + '\"'].oldStart !== 'undefined') {\n\n\t\tif (new Date().getTime() - _this.lineCache['\"' + nodeId + '\"'].startCallTime > 300) {\n\t\t\t_this.lineCache['\"' + nodeId + '\"'].startCallTime = new Date().getTime();\n\t\t\t_this.lineCache['\"' + nodeId + '\"'].oldStart = F();\n\t\t}\n\t} else {\n\n\t\tif (typeof _this.lineCache['\"' + nodeId + '\"'] == 'undefined') {\n\n\t\t\t_this.lineCache['\"' + nodeId + '\"'] = {};\n\t\t}\n\n\t\t_this.lineCache['\"' + nodeId + '\"'].startCallTime = new Date().getTime();\n\t\t_this.lineCache['\"' + nodeId + '\"'].oldStart = F();\n\t}\n\n\treturn _this.lineCache['\"' + nodeId + '\"'].oldStart;\n};\nQflow.prototype.calcLineEndPos = function (A, B, nodeId) {\n\tvar _this = this;\n\n\tvar F = function F() {\n\n\t\tvar A_center = A.centerPoints();\n\t\tvar B_center = B.centerPoints();\n\t\tvar A_rangePos = A.getRangePoints();\n\t\tvar B_rangePos = B.getRangePoints();\n\n\t\tvar startPos = [0, 0];\n\t\tvar endPos = [0, 0];\n\n\t\tif (A_center.y >= B_center.y) {\n\t\t\tif (A_rangePos[0][1] <= B_rangePos[6][1]) {\n\t\t\t\tif (A_rangePos[0][0] >= B_rangePos[2][0]) {\n\t\t\t\t\tendPos = B_rangePos[3];\n\t\t\t\t} else if (A_rangePos[2][0] <= B_rangePos[0][0]) {\n\t\t\t\t\tendPos = B_rangePos[7];\n\t\t\t\t} else {\n\t\t\t\t\tendPos = B_rangePos[1];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (A_rangePos[0][0] >= B_rangePos[2][0]) {\n\t\t\t\t\tendPos = B_rangePos[5];\n\t\t\t\t} else if (A_rangePos[2][0] <= B_rangePos[2][0]) {\n\t\t\t\t\tendPos = B_rangePos[5];\n\t\t\t\t} else {\n\t\t\t\t\tendPos = B_rangePos[5];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (B_rangePos[0][1] <= A_rangePos[6][1]) {\n\t\t\t\tif (A_rangePos[0][0] >= B_rangePos[2][0]) {\n\t\t\t\t\tendPos = B_rangePos[3];\n\t\t\t\t} else if (A_rangePos[2][0] <= B_rangePos[0][0]) {\n\t\t\t\t\tendPos = B_rangePos[7];\n\t\t\t\t} else {\n\t\t\t\t\tendPos = B_rangePos[5];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (A_rangePos[0][0] >= B_rangePos[2][0]) {\n\t\t\t\t\tendPos = B_rangePos[1];\n\t\t\t\t} else if (A_rangePos[2][0] <= B_rangePos[0][0]) {\n\t\t\t\t\tendPos = B_rangePos[1];\n\t\t\t\t} else {\n\t\t\t\t\tendPos = B_rangePos[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn endPos;\n\t};\n\n\tif (typeof this.lineCache['\"' + nodeId + '\"'] !== 'undefined' && typeof this.lineCache['\"' + nodeId + '\"'].oldEnd !== 'undefined') {\n\n\t\tif (new Date().getTime() - _this.lineCache['\"' + nodeId + '\"'].endCallTime > 300) {\n\t\t\t_this.lineCache['\"' + nodeId + '\"'].endCallTime = new Date().getTime();\n\t\t\t_this.lineCache['\"' + nodeId + '\"'].oldEnd = F();\n\t\t}\n\t} else {\n\n\t\tif (typeof _this.lineCache['\"' + nodeId + '\"'] == 'undefined') {\n\n\t\t\t_this.lineCache['\"' + nodeId + '\"'] = {};\n\t\t}\n\t\t_this.lineCache['\"' + nodeId + '\"'].endCallTime = new Date().getTime();\n\t\t_this.lineCache['\"' + nodeId + '\"'].oldEnd = F();\n\t}\n\n\treturn _this.lineCache['\"' + nodeId + '\"'].oldEnd;\n};\nQflow.prototype.calcLinePos = function (A, B, nodeId) {\n\n\tvar F = function F() {\n\t\tvar A_center = A.centerPoints();\n\t\tvar B_center = B.centerPoints();\n\t\tvar A_rangePos = A.getRangePoints();\n\t\tvar B_rangePos = B.getRangePoints();\n\n\t\tvar startPos = [0, 0];\n\t\tvar endPos = [0, 0];\n\n\t\tif (A_center.y >= B_center.y) {\n\t\t\tif (A_rangePos[0][1] <= B_rangePos[6][1]) {\n\t\t\t\tif (A_rangePos[0][0] >= B_rangePos[2][0]) {\n\n\t\t\t\t\tstartPos = A_rangePos[7];\n\t\t\t\t\tendPos = B_rangePos[3];\n\t\t\t\t} else if (A_rangePos[2][0] <= B_rangePos[0][0]) {\n\t\t\t\t\tstartPos = A_rangePos[3];\n\t\t\t\t\tendPos = B_rangePos[7];\n\t\t\t\t} else {\n\n\t\t\t\t\tstartPos = A_rangePos[1];\n\t\t\t\t\tendPos = B_rangePos[1];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (A_rangePos[0][0] >= B_rangePos[2][0]) {\n\n\t\t\t\t\tstartPos = A_rangePos[1];\n\t\t\t\t\tendPos = B_rangePos[5];\n\t\t\t\t} else if (A_rangePos[2][0] <= B_rangePos[2][0]) {\n\t\t\t\t\tstartPos = A_rangePos[1];\n\t\t\t\t\tendPos = B_rangePos[5];\n\t\t\t\t} else {\n\n\t\t\t\t\tstartPos = A_rangePos[1];\n\t\t\t\t\tendPos = B_rangePos[5];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (B_rangePos[0][1] <= A_rangePos[6][1]) {\n\t\t\t\tif (A_rangePos[0][0] >= B_rangePos[2][0]) {\n\t\t\t\t\tstartPos = A_rangePos[7];\n\t\t\t\t\tendPos = B_rangePos[3];\n\t\t\t\t} else if (A_rangePos[2][0] <= B_rangePos[0][0]) {\n\t\t\t\t\tstartPos = A_rangePos[3];\n\t\t\t\t\tendPos = B_rangePos[7];\n\t\t\t\t} else {\n\t\t\t\t\tstartPos = A_rangePos[5];\n\t\t\t\t\tendPos = B_rangePos[5];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (A_rangePos[0][0] >= B_rangePos[2][0]) {\n\t\t\t\t\tstartPos = A_rangePos[5];\n\t\t\t\t\tendPos = B_rangePos[1];\n\t\t\t\t} else if (A_rangePos[2][0] <= B_rangePos[0][0]) {\n\t\t\t\t\tstartPos = A_rangePos[5];\n\t\t\t\t\tendPos = B_rangePos[1];\n\t\t\t\t} else {\n\t\t\t\t\tstartPos = A_rangePos[5];\n\t\t\t\t\tendPos = B_rangePos[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tstart: startPos,\n\t\t\tend: endPos\n\t\t};\n\t};\n\n\tif (typeof this.lineCache['\"' + nodeId + '\"'] !== 'undefined') {\n\n\t\tif (new Date().getTime() - this.lineCache['\"' + nodeId + '\"'].callTime > 300) {\n\n\t\t\tthis.lineCache['\"' + nodeId + '\"'].callTime = new Date().getTime();\n\t\t\tthis.lineCache['\"' + nodeId + '\"'].position = F();\n\t\t}\n\t} else {\n\n\t\tthis.lineCache['\"' + nodeId + '\"'] = {\n\t\t\tcallTime: new Date().getTime(),\n\t\t\tposition: F()\n\t\t};\n\t}\n\n\treturn this.lineCache['\"' + nodeId + '\"'].position;\n};\nQflow.prototype.solveLink = function () {\n\tvar _this = this;\n\tthis.options.initData.link.forEach(function (item) {\n\n\t\titem.fromNode = _this.getNodeObj(_this.getNodeIdFromJsonById(item.fromId));\n\t\titem.toNode = _this.getNodeObj(_this.getNodeIdFromJsonById(item.toId));\n\n\t\tif (typeof item.attr.color == 'undefined') {\n\n\t\t\titem.attr.color = _this.lineColor;\n\t\t}\n\t});\n};\nQflow.prototype.caleHandler1 = function () {\n\tif (typeof this.caleTime1 == 'undefined' || typeof this.caleTime1 !== 'undefined' && new Date().getTime() - this.caleTime1 > 1000) {\n\n\t\tvar start = this.start();\n\t\tvar end = this.end();\n\t\tvar returnHandler1 = function () {\n\t\t\tif (start[0] < end[0] && start[1] <= end[1]) {\n\n\t\t\t\treturn [Math.abs(start[0] - end[0]) * 0.25 + start[0], Math.abs(start[1] - end[1]) * 0.75 + start[1]];\n\t\t\t}\n\n\t\t\tif (start[0] >= end[0] && start[1] <= end[1]) {\n\t\t\t\treturn [Math.abs(start[0] - end[0]) * 0.75 + end[0], Math.abs(start[1] - end[1]) * 0.75 + start[1]];\n\t\t\t}\n\n\t\t\tif (start[0] > end[0] && start[1] >= end[1]) {\n\t\t\t\treturn [Math.abs(start[0] - end[0]) * 0.25 + end[0], Math.abs(start[1] - end[1]) * 0.75 + end[1]];\n\t\t\t}\n\n\t\t\tif (start[0] <= end[0] && start[1] >= end[1]) {\n\t\t\t\treturn [Math.abs(start[0] - end[0]) * 0.75 + start[0], Math.abs(start[1] - end[1]) * 0.75 + end[1]];\n\t\t\t}\n\t\t}();\n\n\t\tthis.oldHandler1 = returnHandler1;\n\n\t\tthis.caleTime1 = new Date().getTime();\n\n\t\treturn this.oldHandler1;\n\t} else {\n\n\t\treturn this.oldHandler1;\n\t}\n};\nQflow.prototype.caleHandler2 = function () {\n\tif (typeof this.caleTime2 == 'undefined' || typeof this.caleTime2 !== 'undefined' && new Date().getTime() - this.caleTime2 > 1000) {\n\n\t\tvar start = this.start();\n\t\tvar end = this.end();\n\t\tvar returnHandler2 = function () {\n\t\t\tif (start[0] < end[0] && start[1] <= end[1]) {\n\n\t\t\t\treturn [Math.abs(start[0] - end[0]) * 0.75 + start[0], Math.abs(start[1] - end[1]) * 0.25 + start[1]];\n\t\t\t}\n\n\t\t\tif (start[0] >= end[0] && start[1] <= end[1]) {\n\t\t\t\treturn [Math.abs(start[0] - end[0]) * 0.25 + end[0], Math.abs(start[1] - end[1]) * 0.25 + start[1]];\n\t\t\t}\n\n\t\t\tif (start[0] > end[0] && start[1] > end[1]) {\n\t\t\t\treturn [Math.abs(start[0] - end[0]) * 0.75 + end[0], Math.abs(start[1] - end[1]) * 0.25 + end[1]];\n\t\t\t}\n\n\t\t\tif (start[0] <= end[0] && start[1] > end[1]) {\n\t\t\t\treturn [Math.abs(start[0] - end[0]) * 0.25 + start[0], Math.abs(start[1] - end[1]) * 0.25 + end[1]];\n\t\t\t}\n\t\t}();\n\n\t\tthis.oldHandler2 = returnHandler2;\n\n\t\tthis.caleTime2 = new Date().getTime();\n\n\t\treturn this.oldHandler2;\n\t} else {\n\n\t\treturn this.oldHandler2;\n\t}\n};\nQflow.prototype.caleQuadraticCurveHandler = function () {\n\tif (typeof this.caleTime1 == 'undefined' || typeof this.caleTime1 !== 'undefined' && new Date().getTime() - this.caleTime1 > 1000) {\n\n\t\tvar start = this.start();\n\t\tvar end = this.end();\n\t\tvar returnHandler1 = function () {\n\t\t\tif (start[0] < end[0] && start[1] <= end[1]) {\n\n\t\t\t\treturn [Math.abs(start[0] - end[0]) * 0.25 + start[0], Math.abs(start[1] - end[1]) * 0.75 + start[1]];\n\t\t\t}\n\n\t\t\tif (start[0] >= end[0] && start[1] <= end[1]) {\n\t\t\t\treturn [Math.abs(start[0] - end[0]) * 0.75 + end[0], Math.abs(start[1] - end[1]) * 0.75 + start[1]];\n\t\t\t}\n\n\t\t\tif (start[0] > end[0] && start[1] >= end[1]) {\n\t\t\t\treturn [Math.abs(start[0] - end[0]) * 0.75 + end[0], Math.abs(start[1] - end[1]) * 0.25 + end[1]];\n\t\t\t}\n\n\t\t\tif (start[0] <= end[0] && start[1] >= end[1]) {\n\t\t\t\treturn [Math.abs(start[0] - end[0]) * 0.25 + start[0], Math.abs(start[1] - end[1]) * 0.25 + end[1]];\n\t\t\t}\n\t\t}();\n\n\t\tthis.oldQuadraticCurveHandler = returnHandler1;\n\n\t\tthis.caleTime1 = new Date().getTime();\n\n\t\treturn this.oldQuadraticCurveHandler;\n\t} else {\n\n\t\treturn this.oldQuadraticCurveHandler;\n\t}\n};\nQflow.prototype.initLink = function () {\n\tvar _this = this;\n\tthis.options.initData.link.forEach(function (item) {\n\n\t\tif (typeof item.attr.type != 'undefined') {\n\n\t\t\tswitch (item.attr.type) {\n\t\t\t\tcase 'bezierCurve':\n\t\t\t\t\tvar tmp = _this.qcanvas.qbezierCurve.bezierCurve({\n\t\t\t\t\t\tstart: function start() {\n\t\t\t\t\t\t\tvar tmp = _this.calcLinePos(item.fromNode, item.toNode, this.id);\n\n\t\t\t\t\t\t\treturn tmp.start;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tend: function end() {\n\t\t\t\t\t\t\tvar tmp = _this.calcLinePos(item.fromNode, item.toNode, this.id);\n\n\t\t\t\t\t\t\treturn tmp.end;\n\t\t\t\t\t\t},\n\t\t\t\t\t\thandler1: _this.caleHandler1,\n\t\t\t\t\t\thandler2: _this.caleHandler2,\n\t\t\t\t\t\twidth: 1,\n\n\t\t\t\t\t\tdrag: false,\n\t\t\t\t\t\tlike: item.attr.like,\n\t\t\t\t\t\tcolor: item.attr.color ? item.attr.color : this.lineColor,\n\t\t\t\t\t\twithText: item.attr.text,\n\t\t\t\t\t\tmouseup: function mouseup(e, pos) {\n\t\t\t\t\t\t\tif (e.button == '2') {\n\n\t\t\t\t\t\t\t\t_this.contextLineMenuNode = this;\n\n\t\t\t\t\t\t\t\t_this.qcanvas.raiseToTop(_this.contextLineMenuLayer);\n\t\t\t\t\t\t\t\t_this.initLineMenu(pos);\n\t\t\t\t\t\t\t\t_this.lineMenuLayerShow();\n\n\t\t\t\t\t\t\t\t_this.contextSettingHide();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'quadraticCurve':\n\t\t\t\t\tvar tmp = _this.qcanvas.qquadraticCurve.quadraticCurve({\n\t\t\t\t\t\tstart: function start() {\n\t\t\t\t\t\t\tvar tmp = _this.calcLinePos(item.fromNode, item.toNode, this.id);\n\n\t\t\t\t\t\t\treturn tmp.start;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tend: function end() {\n\t\t\t\t\t\t\tvar tmp = _this.calcLinePos(item.fromNode, item.toNode, this.id);\n\n\t\t\t\t\t\t\treturn tmp.end;\n\t\t\t\t\t\t},\n\t\t\t\t\t\thandler: _this.caleQuadraticCurveHandler,\n\t\t\t\t\t\twidth: 1,\n\n\t\t\t\t\t\tdrag: false,\n\t\t\t\t\t\tlike: item.attr.like,\n\t\t\t\t\t\tcolor: item.attr.color ? item.attr.color : this.lineColor,\n\t\t\t\t\t\twithText: item.attr.text,\n\t\t\t\t\t\tmouseup: function mouseup(e, pos) {\n\t\t\t\t\t\t\tif (e.button == '2') {\n\n\t\t\t\t\t\t\t\t_this.contextLineMenuNode = this;\n\n\t\t\t\t\t\t\t\t_this.qcanvas.raiseToTop(_this.contextLineMenuLayer);\n\t\t\t\t\t\t\t\t_this.initLineMenu(pos);\n\t\t\t\t\t\t\t\t_this.lineMenuLayerShow();\n\n\t\t\t\t\t\t\t\t_this.contextSettingHide();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'line':\n\t\t\t\t\tvar tmp = _this.qcanvas.qline.line({\n\t\t\t\t\t\tstart: function start() {\n\t\t\t\t\t\t\tvar tmp = _this.calcLinePos(item.fromNode, item.toNode, this.id);\n\n\t\t\t\t\t\t\treturn tmp.start;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tend: function end() {\n\t\t\t\t\t\t\tvar tmp = _this.calcLinePos(item.fromNode, item.toNode, this.id);\n\n\t\t\t\t\t\t\treturn tmp.end;\n\t\t\t\t\t\t},\n\t\t\t\t\t\twidth: 1,\n\n\t\t\t\t\t\tdrag: false,\n\t\t\t\t\t\tlike: item.attr.like,\n\t\t\t\t\t\tcolor: item.attr.color ? item.attr.color : this.lineColor,\n\t\t\t\t\t\twithText: item.attr.text,\n\t\t\t\t\t\tmouseup: function mouseup(e, pos) {\n\t\t\t\t\t\t\tif (e.button == '2') {\n\n\t\t\t\t\t\t\t\t_this.contextLineMenuNode = this;\n\n\t\t\t\t\t\t\t\t_this.qcanvas.raiseToTop(_this.contextLineMenuLayer);\n\t\t\t\t\t\t\t\t_this.initLineMenu(pos);\n\t\t\t\t\t\t\t\t_this.lineMenuLayerShow();\n\n\t\t\t\t\t\t\t\t_this.contextSettingHide();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"foldLine1\":\n\t\t\t\tcase \"foldLine2\":\n\t\t\t\t\tvar tmp = _this.createFoldLine(item.fromNode, item.toNode, item.attr);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\n\t\t\tvar tmp = _this.qcanvas.qline.line({\n\t\t\t\tstart: function start() {\n\t\t\t\t\tvar tmp = _this.calcLinePos(item.fromNode, item.toNode, this.id);\n\n\t\t\t\t\treturn tmp.start;\n\t\t\t\t},\n\t\t\t\tend: function end() {\n\t\t\t\t\tvar tmp = _this.calcLinePos(item.fromNode, item.toNode, this.id);\n\n\t\t\t\t\treturn tmp.end;\n\t\t\t\t},\n\t\t\t\twidth: 1,\n\n\t\t\t\tdrag: false,\n\t\t\t\tlike: item.attr.like,\n\t\t\t\tcolor: item.attr.color ? item.attr.color : this.lineColor,\n\t\t\t\twithText: item.attr.text,\n\t\t\t\tmouseup: function mouseup(e, pos) {\n\t\t\t\t\tif (e.button == '2') {\n\n\t\t\t\t\t\t_this.contextLineMenuNode = this;\n\n\t\t\t\t\t\t_this.qcanvas.raiseToTop(_this.contextLineMenuLayer);\n\t\t\t\t\t\t_this.initLineMenu(pos);\n\t\t\t\t\t\t_this.lineMenuLayerShow();\n\n\t\t\t\t\t\t_this.contextSettingHide();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (_this.qcanvas.isArr(tmp)) {\n\t\t\titem.lineId = tmp[1].id;\n\t\t\t_this.lineLayer.push(tmp[0], tmp[1], tmp[2]);\n\t\t} else {\n\n\t\t\titem.lineId = tmp.id;\n\t\t\t_this.lineLayer.push(tmp);\n\t\t}\n\t});\n};\n\nQflow.prototype.caleFoldLinePosition = function (fromNode, toNode, attr, id) {\n\tvar tmp = this.calcLinePos(fromNode, toNode, id);\n\tvar start = tmp.start;\n\tvar end = tmp.end;\n\n\tvar percent = attr.disPercent ? attr.disPercent : 0.5;\n\n\tif (attr.type == 'foldLine1') {\n\t\treturn {\n\t\t\t'l1': function l1() {\n\t\t\t\treturn [start, [start[0], (end[1] - start[1]) * percent + start[1]]];\n\t\t\t},\n\t\t\t'l2': function l2() {\n\t\t\t\treturn [[start[0], (end[1] - start[1]) * percent + start[1]], [end[0], (end[1] - start[1]) * percent + start[1]]];\n\t\t\t},\n\t\t\t'l3': function l3() {\n\t\t\t\treturn [[end[0], (end[1] - start[1]) * percent + start[1]], end];\n\t\t\t}\n\t\t};\n\t}\n\n\tif (attr.type == 'foldLine2') {\n\t\treturn {\n\t\t\t'l1': function l1() {\n\t\t\t\treturn [start, [(end[0] - start[0]) * percent + start[0], start[1]]];\n\t\t\t},\n\t\t\t'l2': function l2() {\n\t\t\t\treturn [[(end[0] - start[0]) * percent + start[0], start[1]], [(end[0] - start[0]) * percent + start[0], end[1]]];\n\t\t\t},\n\t\t\t'l3': function l3() {\n\t\t\t\treturn [[(end[0] - start[0]) * percent + start[0], end[1]], end];\n\t\t\t}\n\t\t};\n\t}\n};\n\nQflow.prototype.createFoldLine = function (fromNode, toNode, attr) {\n\n\tvar _this = this;\n\tvar l1 = function (fromNode, toNode, attr) {\n\t\tvar tmp = null;\n\t\treturn _this.qcanvas.qline.line({\n\t\t\tstart: function start() {\n\t\t\t\tvar points = tmp === null ? _this.caleFoldLinePosition(fromNode, toNode, attr, this.id) : tmp;\n\n\n\t\t\t\tvar t = points['l1']();\n\t\t\t\treturn t[0];\n\t\t\t},\n\t\t\tend: function end() {\n\t\t\t\tvar points = tmp === null ? _this.caleFoldLinePosition(fromNode, toNode, attr, this.id) : tmp;\n\n\n\t\t\t\tvar t = points['l1']();\n\t\t\t\treturn t[1];\n\t\t\t},\n\t\t\tpointerEvent: 'none',\n\t\t\twidth: 1,\n\t\t\tlike: _this.line1Like[attr.like],\n\t\t\tcolor: attr.color ? attr.color : _this.lineColor\n\t\t});\n\t}(fromNode, toNode, attr);\n\n\tvar l3 = function (fromNode, toNode, attr) {\n\t\tvar tmp = null;\n\t\treturn _this.qcanvas.qline.line({\n\t\t\tstart: function start() {\n\t\t\t\tvar points = tmp === null ? _this.caleFoldLinePosition(fromNode, toNode, attr, this.id) : tmp;\n\n\n\t\t\t\tvar t = points['l3']();\n\t\t\t\treturn t[0];\n\t\t\t},\n\t\t\tend: function end() {\n\t\t\t\tvar points = tmp === null ? _this.caleFoldLinePosition(fromNode, toNode, attr, this.id) : tmp;\n\n\n\t\t\t\tvar t = points['l3']();\n\t\t\t\treturn t[1];\n\t\t\t},\n\t\t\tpointerEvent: 'none',\n\t\t\twidth: 1,\n\t\t\tlike: _this.line3Like[attr.like],\n\t\t\tcolor: attr.color ? attr.color : _this.lineColor\n\t\t});\n\t}(fromNode, toNode, attr);\n\n\tvar l2 = function (fromNode, toNode, attr) {\n\t\tvar tmp = null;\n\t\treturn _this.qcanvas.qline.line({\n\t\t\tstart: function start() {\n\t\t\t\tvar points = tmp === null ? _this.caleFoldLinePosition(fromNode, toNode, attr, this.id) : tmp;\n\n\n\t\t\t\tvar t = points['l2']();\n\t\t\t\treturn t[0];\n\t\t\t},\n\t\t\tend: function end() {\n\t\t\t\tvar points = tmp === null ? _this.caleFoldLinePosition(fromNode, toNode, attr, this.id) : tmp;\n\n\n\t\t\t\tvar t = points['l2']();\n\t\t\t\treturn t[1];\n\t\t\t},\n\n\t\t\tdrag: false,\n\t\t\twidth: 1,\n\t\t\tlike: _this.line2Like[attr.like],\n\t\t\tcolor: attr.color ? attr.color : _this.lineColor,\n\t\t\twithText: attr.text,\n\n\t\t\trelationLineId: [l1.id, l3.id],\n\t\t\tmouseup: function mouseup(e, pos) {\n\t\t\t\tif (e.button == '2') {\n\n\t\t\t\t\t_this.contextLineMenuNode = this;\n\n\t\t\t\t\t_this.qcanvas.raiseToTop(_this.contextLineMenuLayer);\n\t\t\t\t\t_this.initLineMenu(pos);\n\t\t\t\t\t_this.lineMenuLayerShow();\n\n\t\t\t\t\t_this.contextSettingHide();\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\t}(fromNode, toNode, attr);\n\n\treturn [l1, l2, l3];\n};\nQflow.prototype.updateInitData = function (obj, jsonObj) {\n\tjsonObj.x = obj.start[0];\n\tjsonObj.y = obj.start[1];\n\n\tif (jsonObj.nodeType == 'container') {\n\t\tvar childAreaPosition = this.getChildAreaPosition(jsonObj);\n\n\t\tvar childPosition = this.getChildPosition(jsonObj, childAreaPosition);\n\n\t\tjsonObj.attr.gridPosition = childPosition;\n\t}\n};\nQflow.prototype.initNodeTitle = function (jsonObj, nodeObj) {\n\tvar _this = this;\n\tvar t = this.qcanvas.qtext.text({\n\t\tstart: function start() {\n\t\t\tvar start = _this.qcanvas.isFun(nodeObj.start) ? nodeObj.start() : nodeObj.start;\n\t\t\treturn [start[0] + nodeObj.width * 0.5, start[1] + nodeObj.height * 0.5];\n\t\t},\n\t\ttext: jsonObj.text,\n\t\tpointerEvent: 'none',\n\t\tcolor: jsonObj.attr && jsonObj.attr.color ? jsonObj.attr.color : '#000',\n\t\tfontSize: '12px',\n\t\townerId: jsonObj.nodeId\n\n\t});\n\n\tthis.qnodes.push(t);\n\tjsonObj.attr.titleId = t.id;\n};\n\nQflow.prototype.initContainerTitle = function (obj, qobj) {\n\tvar _this = this;\n\n\tvar t = this.qcanvas.qtext.text({\n\t\tstart: function start() {\n\t\t\treturn [qobj.start[0] + qobj.width * 0.5, qobj.start[1] + _this.containerTitleHeight * 0.5];\n\t\t},\n\t\ttext: obj.text,\n\t\tpointerEvent: 'none',\n\t\tcolor: obj.attr ? obj.attr.color : '#000',\n\t\tfontSize: '12px',\n\t\townerId: obj.nodeId\n\t});\n\n\tthis.qnodes.push(t);\n\n\tobj.attr.titleId = t.id;\n};\nQflow.prototype.drawNode = function (parentNode, nodes) {\n\n\tvar _this = this;\n\tfor (var i = 0; i < nodes.length; i++) {\n\n\t\tif (parentNode !== null) {\n\t\t\t_this.createChildsOfContainer(parentNode, nodes[i], i);\n\t\t} else {\n\n\t\t\tif (nodes[i].nodeType == 'tip') {\n\t\t\t\t_this.createTipNode(nodes[i]);\n\t\t\t} else {\n\t\t\t\t_this.createContainerOrNode(nodes[i]);\n\t\t\t}\n\t\t}\n\t}\n};\n\nQflow.prototype.createChildsOfContainer = function (parentNode, jsonObj, index) {\n\tvar _this = this;\n\tvar tmp = this.qcanvas.qrect.rect({\n\n\t\tstart: function start() {\n\t\t\treturn [parentNode.attr.gridPosition[this.sort].x, parentNode.attr.gridPosition[this.sort].y];\n\t\t},\n\t\tsort: index,\n\t\tnodeType: jsonObj.nodeType,\n\t\twidth: jsonObj.width ? jsonObj.width : this.childNodeWidth,\n\t\theight: jsonObj.height ? jsonObj.height : this.childNodeHeight,\n\t\tborderColor: jsonObj.attr && jsonObj.attr.borderColor ? jsonObj.attr.borderColor : this.childNodeBorderColor,\n\t\tfillColor: jsonObj.attr && jsonObj.attr.fillColor ? jsonObj.attr.fillColor : this.childNodeFillColor,\n\t\tdashed: jsonObj.attr && jsonObj.attr.dashed ? jsonObj.attr.dashed : false,\n\t\tdrag: false,\n\t\townerId: parentNode.nodeId,\n\t\tlineWidth: 1,\n\t\tgetRangePoints: function getRangePoints() {\n\t\t\treturn _this.createRangePoints(this.polyPoints());\n\t\t},\n\t\tmouseenter: function mouseenter() {\n\t\t\t_this.settingIcoShow(this);\n\t\t},\n\t\tmousedown: function mousedown() {\n\t\t\t_this.delTmpLine();\n\t\t\t_this.createNewLine(this, jsonObj);\n\n\t\t\t_this.tipTextHide();\n\n\t\t\t_this.menuLayerHide();\n\t\t\t_this.draging = true;\n\t\t},\n\t\tmouseup: function mouseup(e, pos) {\n\t\t\t_this.settingIcoHide();\n\t\t\t_this.menuLayerHide();\n\n\t\t\t_this.draging = false;\n\n\t\t\tif (e.button == '2') {\n\t\t\t\t_this.contextMenuNode = this;\n\t\t\t\t_this.menuLayerShow(pos);\n\t\t\t}\n\t\t},\n\t\tmousemove: function mousemove(e, pos) {\n\n\t\t\t_this.updateTmpLineEndPos(pos);\n\n\t\t\t_this.settingIcoShow(this);\n\n\t\t\t_this.draging && _this.updateInitData.call(_this, this, jsonObj);\n\t\t},\n\t\tmouseout: function mouseout() {\n\t\t\t_this.settingIcoHide();\n\t\t},\n\t\tdblclick: function dblclick(e, pos) {\n\n\t\t\tconsole.log('dbl');\n\t\t\t_this.settingIcoHide();\n\t\t\t_this.menuLayerHide();\n\n\t\t\t_this.containerDblclick.call(_this, this, e, pos, jsonObj);\n\t\t}\n\t});\n\n\tif (typeof jsonObj.id == 'undefined') {\n\t\tjsonObj.id = tmp.id;\n\t}\n\tjsonObj.nodeId = tmp.id;\n\tparentNode.childNodes ? parentNode.childNodes.push(tmp) : parentNode.childNodes = [tmp];\n\n\tthis.qnodes.push(tmp);\n\n\tthis.initNodeTitle(jsonObj, tmp);\n};\nQflow.prototype.getNodeObj = function (nodeId) {\n\tvar tmp = this.qnodes.filter(function (item) {\n\t\treturn item.id == nodeId;\n\t});\n\n\tif (tmp.length > 0) {\n\t\treturn tmp[0];\n\t} else {\n\t\treturn null;\n\t}\n};\n\nQflow.prototype.getJsonObj = function (nodeId) {\n\n\tvar tmp = null;\n\n\tfor (var i = 0; i < this.options.initData.node.length; i++) {\n\n\t\tif (this.options.initData.node[i].nodeId == nodeId) {\n\t\t\ttmp = this.options.initData.node[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (this.options.initData.node[i].child) {\n\t\t\tfor (var j = 0; j < this.options.initData.node[i].child.length; j++) {\n\t\t\t\tif (this.options.initData.node[i].child[j].nodeId == nodeId) {\n\t\t\t\t\ttmp = this.options.initData.node[i].child[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn tmp;\n};\n\nQflow.prototype.containerMouseDown = function (container, jsonObj) {\n\tvar _this = this;\n\n\tthis.qcanvas.raiseToTop(container);\n\n\tthis.qcanvas.raiseToTop(this.lineLayer);\n\n\tvar titleNode = _this.getNodeObj(jsonObj.attr.titleId);\n\ttitleNode !== null && _this.qcanvas.raiseToTop(titleNode);\n\n\tif (jsonObj.nodeType == 'container') {\n\n\t\tjsonObj.childNodes && jsonObj.childNodes.forEach(function (item) {\n\t\t\t_this.qcanvas.raiseToTop(item);\n\t\t\titem.setPointerEvent('none');\n\t\t});\n\n\t\tjsonObj.child && jsonObj.child.forEach(function (item) {\n\t\t\tvar titleNode = _this.getNodeObj(item.attr.titleId);\n\t\t\tif (titleNode !== null) {\n\t\t\t\t_this.qcanvas.raiseToTop(titleNode);\n\t\t\t\ttitleNode.setPointerEvent('none');\n\t\t\t}\n\t\t});\n\n\t\tthis.qcanvas.raiseToTop(this.lineLayer);\n\t}\n\n\t_this.draging = true;\n};\nQflow.prototype.containerMouseUp = function (container, e, pos, jsonObj) {\n\tvar _this = this;\n\t_this.draging = false;\n\n\tif (jsonObj.nodeType == 'container') {\n\n\t\tjsonObj.childNodes && jsonObj.childNodes.forEach(function (item) {\n\t\t\titem.setPointerEvent('auto');\n\t\t});\n\t}\n\n\tthis.isResizeCanvas(jsonObj.nodeId);\n\n\tif (e.button == '2') {\n\t\t_this.contextMenuNode = container;\n\t\t_this.menuLayerShow(pos);\n\t}\n};\nQflow.prototype.containerDblclick = function (node, e, pos, jsonObj) {\n\tconsole.log(jsonObj);\n\tconsole.log(node);\n\tif (jsonObj.nodeType == 'node') {\n\n\t\tthis.contextSettingNode = jsonObj;\n\n\t\tvar titleObj = this.getNodeObj(jsonObj.attr.titleId);\n\t\tconsole.log(titleObj);\n\t\tthis.modiTitleObj = titleObj;\n\n\t\tvar tmp = titleObj.formatText.call(this, titleObj);\n\n\t\tvar w = Math.max.apply(null, tmp.width);\n\t\tw = w > node.width ? w : node.width;\n\t\tvar start = this.qcanvas.isFun(node.start) ? node.start() : node.start;\n\n\t\tvar x = w > node.width ? start[0] - (w - node.width) * 0.5 : start[0];\n\n\t\tvar h = this.childNodeHeight;\n\t\tvar y = start[1];\n\n\t\tvar d = document.getElementById('titleInput');\n\t\td.style.left = x + 'px';\n\t\td.style.top = y + 'px';\n\t\td.style.width = w + 'px';\n\t\td.style.height = h + 'px';\n\t\td.style.display = 'block';\n\t\td.style.textAlign = 'center';\n\t\td.value = titleObj.text;\n\t\td.focus();\n\t}\n\n\tif (jsonObj.nodeType == 'container') {\n\t\tvar titleAreaHeight = 16;\n\t\tvar start = this.qcanvas.isFun(node.start) ? node.start() : node.start;\n\t\tif (this.rayCasting(pos, [{\n\t\t\tx: start[0],\n\t\t\ty: start[1]\n\n\t\t}, {\n\t\t\tx: start[0] + node.width,\n\t\t\ty: start[1]\n\n\t\t}, {\n\t\t\tx: start[0] + node.width,\n\t\t\ty: start[1] + titleAreaHeight\n\n\t\t}, {\n\t\t\tx: start[0],\n\t\t\ty: start[1] + titleAreaHeight\n\n\t\t}]) == 'in') {\n\n\t\t\tconsole.log('开始编辑容器标题');\n\n\t\t\tthis.contextSettingNode = jsonObj;\n\n\t\t\tvar titleObj = this.getNodeObj(jsonObj.attr.titleId);\n\t\t\tconsole.log(titleObj);\n\t\t\tthis.modiTitleObj = titleObj;\n\n\t\t\tvar tmp = titleObj.formatText.call(this, titleObj);\n\n\t\t\tvar w = Math.max.apply(null, tmp.width);\n\t\t\tw = w > node.width ? w : node.width;\n\t\t\tvar start = this.qcanvas.isFun(node.start) ? node.start() : node.start;\n\n\t\t\tvar x = w > node.width ? start[0] - (w - node.width) * 0.5 : start[0];\n\n\t\t\tvar h = this.childNodeHeight;\n\t\t\tvar y = start[1];\n\n\t\t\tvar d = document.getElementById('titleInput');\n\t\t\td.style.left = x + 'px';\n\t\t\td.style.top = y + 'px';\n\t\t\td.style.width = w + 'px';\n\t\t\td.style.height = h + 'px';\n\t\t\td.style.display = 'block';\n\t\t\td.style.textAlign = 'center';\n\t\t\td.value = titleObj.text;\n\t\t\td.focus();\n\t\t}\n\t}\n};\nQflow.prototype.resizeCanvas = function (width, height) {\n\tvar dpr = window.devicePixelRatio;\n\n\tvar c_obj = this.qcanvas.stage.canvas;\n\tc_obj.width = width * dpr;\n\tc_obj.height = height * dpr;\n\tc_obj.style.width = width + 'px';\n\tc_obj.style.height = height + 'px';\n\n\tvar context = c_obj.getContext('2d');\n\n\tcontext.scale(dpr, dpr);\n\n\tthis.qcanvas.elements.forEach(function (item) {\n\t\tif (item.TYPE == 'layer') {\n\t\t\tvar layer_canvas = item.canvasEle;\n\t\t\tlayer_canvas.width = width * dpr;\n\t\t\tlayer_canvas.height = height * dpr;\n\t\t\tvar context = layer_canvas.getContext('2d');\n\n\t\t\tcontext.scale(dpr, dpr);\n\t\t}\n\t});\n\n\tthis.options.width = width;\n\tthis.options.height = height;\n\n\tthis.qcanvas.stage.width = width;\n\tthis.qcanvas.stage.height = height;\n};\nQflow.prototype.isResizeCanvas = function (nodeId) {\n\tvar _this = this;\n\tvar F = function F() {\n\n\t\tvar obj = _this.getNodeObj(nodeId);\n\t\tif (obj !== null) {\n\t\t\tvar start = _this.qcanvas.isFun(obj.start) ? obj.start() : obj.start;\n\n\t\t\tvar maxX = start[0] + obj.width;\n\t\t\tvar maxY = start[1] + obj.height;\n\n\t\t\tif (maxX > _this.options.width || maxY > _this.options.height) {\n\n\t\t\t\tconsole.log('需要重置canvas尺寸');\n\n\t\t\t\t_this.resizeCanvas(maxX > _this.options.width ? maxX : _this.options.width, maxY > _this.options.height ? maxY : _this.options.height);\n\t\t\t}\n\t\t}\n\t};\n\tsetTimeout(F, 200);\n};\n\nQflow.prototype.containerMouseMove = function (container, jsonObj) {\n\n\tthis.draging && this.updateInitData(container, jsonObj);\n};\nQflow.prototype.getMiddleCoordinate = function (s, e) {\n\n\tvar start = [s.x, s.y],\n\t    end = [e.x, e.y];\n\n\treturn [(start[0] < end[0] ? start[0] : end[0]) + Math.abs(start[0] - end[0]) * 0.5, (start[1] < end[1] ? start[1] : end[1]) + Math.abs(start[1] - end[1]) * 0.5];\n};\nQflow.prototype.createRangePoints = function (polyPoints) {\n\tvar tmp = [];\n\tfor (var i = 0; i < polyPoints.length; i++) {\n\t\ttmp.push([polyPoints[i].x, polyPoints[i].y]);\n\t\ttmp.push(this.getMiddleCoordinate(polyPoints[i], polyPoints[i + 1 == polyPoints.length ? 0 : i + 1]));\n\t}\n\n\treturn tmp;\n};\n\nQflow.prototype.tipTextHide = function () {\n\tif (this.tipContext !== null) {\n\t\tthis.tipContext.setColor('#B58105');\n\t\tvar jsonObj = this.getJsonObj(this.tipContext.ownerId);\n\n\t\tjsonObj.text = this.tipContext.text;\n\n\n\t\tjsonObj.width = this.tipNodeWidth;\n\t\tjsonObj.height = this.tipContext.range.height;\n\n\t\tthis.tipContext = null;\n\t}\n\tdocument.getElementById('tip').style.display = 'none';\n};\nQflow.prototype.updateTipText = function (v, h) {\n\n\tif (this.tipContext !== null) {\n\n\t\tv = this.formatTipText(v);\n\t\tthis.tipContext.setText(v);\n\n\t\tvar tipRect = this.getNodeObj(this.tipContext.ownerId);\n\t\ttipRect.setHeight(h);\n\t}\n};\nQflow.prototype.measureTextWidth = function (v) {\n\treturn this.qcanvas.context.measureText(v).width;\n};\nQflow.prototype.formatTipText = function (str) {\n\tvar lineWidth = 0;\n\tvar lastSubStrIndex = 0;\n\tvar c = [];\n\tfor (var i = 0; i < str.length; i++) {\n\t\tlineWidth += this.measureTextWidth(str[i]);\n\n\t\tif (str[i] == '\\n') {\n\t\t\tlineWidth = 0;\n\t\t}\n\n\t\tif (lineWidth > this.tipNodeWidth) {\n\t\t\tc.push(str.substring(lastSubStrIndex, i));\n\t\t\tlineWidth = this.measureTextWidth(str[i]);\n\t\t\tlastSubStrIndex = i;\n\t\t}\n\t\tif (i == str.length - 1) {\n\t\t\tc.push(str.substring(lastSubStrIndex, i + 1));\n\t\t}\n\t}\n\n\treturn c.join('\\n');\n};\nQflow.prototype.cloneTipNode = function () {\n\tconsole.log(this.contextMenuNode);\n\tvar jsonObj = this.getJsonObj(this.contextMenuNode.id);\n\tvar json = {\n\t\tnodeType: 'tip',\n\t\tx: this.contextMenuNode.start[0] + 20,\n\t\ty: this.contextMenuNode.start[1] + 20,\n\t\twidth: this.tipNodeWidth,\n\t\theight: this.contextMenuNode.height,\n\t\ttext: jsonObj.text,\n\t\tattr: {\n\t\t\tborderColor: '#7EC8CE',\n\t\t\tcolor: '#fff',\n\t\t\tfillColor: '#585DCB',\n\t\t\tdashed: false\n\t\t}\n\t};\n\n\tthis.createTipNode(json);\n\n\tthis.options.initData.node.push(json);\n};\nQflow.prototype.addTipNode = function (obj) {\n\n\tvar json = {\n\t\tnodeType: 'tip',\n\t\tx: obj.x,\n\t\ty: obj.y,\n\t\twidth: this.tipNodeWidth,\n\t\ttext: '备注',\n\t\tattr: {\n\t\t\tborderColor: '#7EC8CE',\n\t\t\tcolor: '#fff',\n\t\t\tfillColor: '#585DCB',\n\t\t\tdashed: false\n\t\t}\n\t};\n\n\tthis.createTipNode(json);\n\n\tthis.options.initData.node.push(json);\n};\nQflow.prototype.createTipNode = function (jsonObj) {\n\tvar _this = this;\n\tvar tmp = this.qcanvas.qrect.rect({\n\t\tstart: [jsonObj.x, jsonObj.y],\n\t\tnodeType: jsonObj.nodeType,\n\t\twidth: jsonObj.width ? jsonObj.width : this.tipNodeWidth,\n\t\theight: jsonObj.height ? jsonObj.height : this.childNodeHeight,\n\t\tborderColor: 'orange',\n\t\tfillColor: '#FEF8DE',\n\t\tdashed: jsonObj.attr.dashed,\n\t\tgetRangePoints: function getRangePoints() {\n\t\t\treturn _this.createRangePoints(this.polyPoints());\n\t\t},\n\t\tdblclick: function dblclick(e, pos) {\n\t\t\tvar x = this.start[0],\n\t\t\t    y = this.start[1];\n\t\t\tvar doc = document.getElementById('tip');\n\t\t\tdoc.style.top = y + 'px';\n\t\t\tdoc.style.left = x + 'px';\n\t\t\tdoc.style.width = this.width + 'px';\n\t\t\tdoc.style.height = this.height + 'px';\n\t\t\tdoc.style.fontSize = \"12px\";\n\t\t\tdoc.style.lineHeight = \"14px\";\n\t\t\tdoc.style.display = 'block';\n\n\t\t\t_this.tipContext = _this.getNodeObj(jsonObj.attr.titleId);\n\t\t\t_this.tipContext.setColor('#FEF8DE');\n\n\t\t\tdoc.value = _this.tipContext.text;\n\n\t\t\tdoc.focus();\n\t\t},\n\t\tmousedown: function mousedown() {\n\n\t\t\t_this.delTmpLine();\n\t\t\t_this.createNewLine(this, jsonObj);\n\n\t\t\t_this.menuLayerHide();\n\t\t\t_this.containerMouseDown.call(_this, this, jsonObj);\n\t\t},\n\t\tmouseup: function mouseup(e, pos) {\n\t\t\t_this.settingIcoHide();\n\t\t\t_this.menuLayerHide();\n\n\t\t\t_this.containerMouseUp.call(_this, this, e, pos, jsonObj);\n\t\t},\n\t\tmousemove: function mousemove(e, pos) {\n\t\t\t_this.updateTmpLineEndPos(pos);\n\n\t\t\t_this.containerMouseMove.call(_this, this, jsonObj);\n\n\t\t\tif (_this.qcanvas.dragAim === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t});\n\n\tif (typeof jsonObj.id == 'undefined') {\n\t\tjsonObj.id = tmp.id;\n\t}\n\tjsonObj.nodeId = tmp.id;\n\n\tthis.qnodes.push(tmp);\n\tthis.baseNodesWithCoordinates.push(tmp);\n\n\tthis.initTipText(jsonObj, tmp);\n};\nQflow.prototype.initTipText = function (obj, qobj) {\n\n\tvar _this = this;\n\tvar t = this.qcanvas.qtext.text({\n\t\tstart: function start() {\n\t\t\treturn [qobj.start[0], qobj.start[1] + 3];\n\t\t},\n\n\t\ttext: obj.text,\n\t\tfontSize: '12px',\n\t\tlineHeight: '14px',\n\t\tcolor: '#B58105',\n\t\ttextAlign: 'left',\n\t\ttextBaseline: 'top',\n\t\tpointerEvent: 'none',\n\t\townerId: obj.nodeId\n\t});\n\n\tthis.qnodes.push(t);\n\n\tobj.attr.titleId = t.id;\n};\nQflow.prototype.createContainerOrNode = function (jsonObj) {\n\tvar _this = this;\n\tvar tmp = this.qcanvas.qrect.rect({\n\t\tstart: [jsonObj.x, jsonObj.y],\n\t\tnodeType: jsonObj.nodeType,\n\t\twidth: jsonObj.width ? jsonObj.width : this.childNodeWidth,\n\t\theight: jsonObj.height ? jsonObj.height : this.childNodeHeight,\n\t\tborderColor: jsonObj.attr.borderColor,\n\t\tfillColor: jsonObj.attr.fillColor,\n\t\tdashed: jsonObj.attr.dashed,\n\t\tgetRangePoints: function getRangePoints() {\n\t\t\treturn _this.createRangePoints(this.polyPoints());\n\t\t},\n\t\tmouseenter: function mouseenter() {\n\t\t\t_this.settingIcoShow(this);\n\t\t},\n\t\tmousedown: function mousedown() {\n\n\t\t\t_this.delTmpLine();\n\t\t\t_this.createNewLine(this, jsonObj);\n\n\t\t\t_this.tipTextHide();\n\t\t\t_this.menuLayerHide();\n\t\t\t_this.containerMouseDown.call(_this, this, jsonObj);\n\n\t\t\t_this.contextMenuNode = null;\n\t\t\t_this.contextSettingHide();\n\t\t},\n\t\tmouseup: function mouseup(e, pos) {\n\t\t\t_this.settingIcoHide();\n\t\t\t_this.menuLayerHide();\n\n\t\t\t_this.containerMouseUp.call(_this, this, e, pos, jsonObj);\n\t\t},\n\t\tmousemove: function mousemove(e, pos) {\n\t\t\t_this.updateTmpLineEndPos(pos);\n\t\t\t_this.settingIcoShow(this);\n\n\t\t\t_this.containerMouseMove.call(_this, this, jsonObj);\n\t\t},\n\t\tmouseout: function mouseout() {\n\t\t\t_this.settingIcoHide();\n\t\t},\n\t\tdblclick: function dblclick(e, pos) {\n\t\t\t_this.settingIcoHide();\n\t\t\t_this.menuLayerHide();\n\n\t\t\t_this.containerDblclick.call(_this, this, e, pos, jsonObj);\n\t\t}\n\t});\n\n\tjsonObj.nodeId = tmp.id;\n\n\tthis.qnodes.push(tmp);\n\tthis.baseNodesWithCoordinates.push(tmp);\n\n\tjsonObj.nodeType == 'container' && this.initContainerTitle(jsonObj, tmp);\n\n\tjsonObj.nodeType == 'node' && this.initNodeTitle(jsonObj, tmp);\n\n\tjsonObj.nodeType == 'container' && typeof jsonObj.child != 'undefined' && this.initNode(jsonObj);\n};\nQflow.prototype.initNode = function (parentNode) {\n\n\tif (parentNode) {\n\t\tthis.drawNode(parentNode, parentNode.child);\n\t} else {\n\n\t\tthis.drawNode(null, this.options.initData.node);\n\t}\n};\nQflow.prototype.initCanvas = function () {\n\n\tthis.qcanvas = new Qcanvas({\n\t\tid: this.options.id,\n\t\twidth: this.options.width,\n\t\theight: this.options.height,\n\t\tmousedown: this.canvasDownFun.bind(this),\n\t\tmousemove: this.canvasMoveFun.bind(this),\n\t\tmouseup: this.canvasUpFun.bind(this),\n\t\tdelayRender: true\n\n\t});\n};\nQflow.prototype.addContainer = function (obj, attrObj) {\n\n\tvar _this = this;\n\n\tvar tmp = this.qcanvas.qrect.rect({\n\t\tstart: [obj.x, obj.y],\n\n\t\twidth: attrObj && attrObj.width ? attrObj.width : this.containerNodeWidth,\n\t\theight: attrObj && attrObj.height ? attrObj.height : this.containerNodeHeight,\n\t\tborderColor: this.containerFillColor,\n\t\tfillColor: this.containerFillColor,\n\t\tdashed: false,\n\n\t\tgetRangePoints: function getRangePoints() {\n\t\t\treturn _this.createRangePoints(this.polyPoints());\n\t\t},\n\t\tmouseenter: function mouseenter() {\n\t\t\t_this.settingIcoShow(this);\n\t\t},\n\t\tmousedown: function mousedown() {\n\n\t\t\t_this.delTmpLine();\n\t\t\t_this.createNewLine(this, jsonObj);\n\n\t\t\t_this.menuLayerHide();\n\t\t\t_this.containerMouseDown.call(_this, this, jsonObj);\n\n\t\t\t_this.contextMenuNode = null;\n\t\t\t_this.contextSettingHide();\n\t\t},\n\t\tmouseup: function mouseup(e, pos) {\n\t\t\t_this.settingIcoHide();\n\t\t\t_this.menuLayerHide();\n\n\t\t\t_this.containerMouseUp.call(_this, this, e, pos, jsonObj);\n\t\t},\n\t\tmousemove: function mousemove(e, pos) {\n\t\t\t_this.updateTmpLineEndPos(pos);\n\t\t\t_this.settingIcoShow(this);\n\n\t\t\t_this.containerMouseMove.call(_this, this, jsonObj);\n\t\t},\n\t\tmouseout: function mouseout() {\n\t\t\t_this.settingIcoHide();\n\t\t},\n\t\tdblclick: function dblclick(e, pos) {\n\t\t\t_this.settingIcoHide();\n\t\t\t_this.menuLayerHide();\n\n\t\t\t_this.containerDblclick.call(_this, this, e, pos, jsonObj);\n\t\t}\n\n\t});\n\n\tthis.qnodes.push(tmp);\n\tthis.baseNodesWithCoordinates.push(tmp);\n\n\tvar jsonObj = {\n\t\tid: tmp.id,\n\t\tnodeId: tmp.id,\n\t\tnodeType: 'container',\n\t\tx: obj.x,\n\t\ty: obj.y,\n\t\ttext: attrObj && attrObj.text ? attrObj.text : '容器标题',\n\t\twidth: attrObj && attrObj.width ? attrObj.width : this.containerNodeWidth,\n\t\theight: attrObj && attrObj.height ? attrObj.height : this.containerNodeHeight,\n\t\tgrid: attrObj && attrObj.grid ? attrObj.grid : [1, 1],\n\t\tchild: [],\n\t\tchildNodes: [],\n\t\tattr: {\n\t\t\ttitlePosition: 'top-center',\n\t\t\tcolor: '#fff',\n\t\t\tborderColor: this.containerFillColor,\n\t\t\tfillColor: this.containerFillColor,\n\t\t\tdashed: false\n\t\t}\n\t};\n\tthis.options.initData.node.push(jsonObj);\n\n\tthis.updateInitData(tmp, jsonObj);\n\n\tthis.initContainerTitle(jsonObj, tmp);\n\n\treturn tmp.id;\n};\nQflow.prototype.modiContainerGridColumn = function (column) {\n\tvar containerNode = this.getNodeObj(this.contextSettingNode.id);\n\tvar parentJsonNode = this.getJsonObj(this.contextSettingNode.id);\n\n\tparentJsonNode.width = this.childNodeWidth * column + (column + 1) * this.containerChildMargin;\n\n\tif (parentJsonNode.attr.titlePosition == 'top-center') {\n\t\tvar startPlaceHolderY = this.containerTitleHeight + this.containerPadding;\n\t\tvar row = Math.ceil((parentJsonNode.child.length == 0 ? 1 : parentJsonNode.child.length) / column);\n\t\tparentJsonNode.height = startPlaceHolderY + this.childNodeHeight * row + row * this.containerChildMargin;\n\t\tparentJsonNode.grid = [row, column];\n\t}\n\n\tcontainerNode.setWidth(parentJsonNode.width);\n\tcontainerNode.setHeight(parentJsonNode.height);\n\n\tvar childAreaPosition = this.getChildAreaPosition(parentJsonNode);\n\n\tvar childPosition = this.getChildPosition(parentJsonNode, childAreaPosition);\n\n\tparentJsonNode.attr.gridPosition = childPosition;\n};\nQflow.prototype.inSertToContainer = function (obj, aim, text) {\n\tconsole.log('创建的节点需要初始到容器里');\n\n\tvar parentJsonNode = this.getJsonObj(aim.id);\n\tvar parentNode = this.getNodeObj(aim.id);\n\n\tif (parentJsonNode.attr.gridPosition.length <= parentJsonNode.child.length) {\n\t\tparentJsonNode.height += this.childNodeHeight + this.containerChildMargin;\n\t\tparentJsonNode.grid[0] += 1;\n\n\t\tparentNode.setHeight(parentJsonNode.height);\n\n\t\tvar childAreaPosition = this.getChildAreaPosition(parentJsonNode);\n\n\t\tvar childPosition = this.getChildPosition(parentJsonNode, childAreaPosition);\n\n\t\tparentJsonNode.attr.gridPosition = childPosition;\n\t}\n\n\tvar jsonObj = {\n\t\tnodeType: 'node',\n\t\ttext: text ? text : '我是新来的',\n\t\tattr: {\n\t\t\tcolor: '#fff'\n\t\t}\n\t};\n\n\tthis.createChildsOfContainer(parentJsonNode, jsonObj, parentJsonNode.child.length);\n\n\tparentJsonNode.child.push(jsonObj);\n};\nQflow.prototype.addNode = function (obj, title) {\n\n\tvar _this = this;\n\n\tvar tmp = this.qcanvas.qrect.rect({\n\t\tstart: [obj.x, obj.y],\n\t\twidth: this.childNodeWidth,\n\t\theight: this.childNodeHeight,\n\t\tborderColor: this.childNodeBorderColor,\n\t\tfillColor: this.childNodeFillColor,\n\t\tdashed: false,\n\t\tgetRangePoints: function getRangePoints() {\n\t\t\treturn _this.createRangePoints(this.polyPoints());\n\t\t},\n\t\tmouseenter: function mouseenter() {\n\t\t\t_this.settingIcoShow(this);\n\t\t},\n\t\tmousedown: function mousedown() {\n\n\t\t\t_this.delTmpLine();\n\t\t\t_this.createNewLine(this, jsonObj);\n\n\t\t\t_this.menuLayerHide();\n\t\t\t_this.containerMouseDown.call(_this, this, jsonObj);\n\t\t},\n\t\tmouseup: function mouseup(e, pos) {\n\t\t\t_this.settingIcoHide();\n\t\t\t_this.menuLayerHide();\n\n\t\t\t_this.containerMouseUp.call(_this, this, e, pos, jsonObj);\n\t\t},\n\t\tmousemove: function mousemove(e, pos) {\n\t\t\t_this.updateTmpLineEndPos(pos);\n\t\t\t_this.settingIcoShow(this);\n\n\t\t\t_this.containerMouseMove.call(_this, this, jsonObj);\n\t\t},\n\t\tmouseout: function mouseout() {\n\t\t\t_this.settingIcoHide();\n\t\t},\n\t\tdblclick: function dblclick(e, pos) {\n\n\t\t\tconsole.log('dbl');\n\t\t\t_this.settingIcoHide();\n\t\t\t_this.menuLayerHide();\n\n\t\t\t_this.containerDblclick.call(_this, this, e, pos, jsonObj);\n\t\t}\n\t});\n\n\tthis.qnodes.push(tmp);\n\tthis.baseNodesWithCoordinates.push(tmp);\n\n\tvar jsonObj = {\n\t\tid: tmp.id,\n\t\tnodeId: tmp.id,\n\t\tnodeType: 'node',\n\t\tx: obj.x,\n\t\ty: obj.y,\n\t\ttext: title ? title : '标题',\n\t\tattr: {\n\t\t\tborderColor: this.childNodeBorderColor,\n\t\t\tcolor: '#fff',\n\t\t\tfillColor: this.childNodeFillColor,\n\t\t\tdashed: false\n\t\t}\n\t};\n\n\tthis.options.initData.node.push(jsonObj);\n\n\tthis.initNodeTitle(jsonObj, tmp);\n};\n\nQflow.prototype.rayCasting = function (p, poly) {\n\tvar px = p.x,\n\t    py = p.y,\n\t    flag = false;\n\n\tfor (var i = 0, l = poly.length, j = l - 1; i < l; j = i, i++) {\n\t\tvar sx = poly[i].x,\n\t\t    sy = poly[i].y,\n\t\t    tx = poly[j].x,\n\t\t    ty = poly[j].y;\n\n\t\tif (sx === px && sy === py || tx === px && ty === py) {\n\t\t\treturn 'on';\n\t\t}\n\n\t\tif (sy < py && ty >= py || sy >= py && ty < py) {\n\t\t\tvar x = sx + (py - sy) * (tx - sx) / (ty - sy);\n\n\t\t\tif (x === px) {\n\t\t\t\treturn 'on';\n\t\t\t}\n\n\t\t\tif (x > px) {\n\t\t\t\tflag = !flag;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn flag ? 'in' : 'out';\n};\nQflow.prototype.inContainer = function (obj) {\n\n\tvar ele = this.qcanvas.elements;\n\n\tvar aim = null;\n\tfor (var i = ele.length - 1; i >= 0; i--) {\n\t\tif (ele[i].display != 'none' && ele[i].TYPE != 'layer' && this.rayCasting({ x: obj.x, y: obj.y }, ele[i].polyPoints()) == 'in') {\n\t\t\tconsole.log('找到了');\n\t\t\taim = ele[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar sign = false;\n\tif (aim !== null) {\n\n\t\tif (typeof aim.ownerId != 'undefined') {\n\n\t\t\tvar ownerObj = this.getJsonObj(aim.ownerId);\n\t\t\taim = this.getNodeObj(aim.ownerId);\n\t\t\tif (ownerObj.nodeType == 'container') {\n\t\t\t\tsign = true;\n\t\t\t}\n\t\t} else {\n\n\t\t\tvar tmp = this.getJsonObj(aim.id);\n\t\t\tif (tmp !== null && tmp.nodeType == 'container') {\n\t\t\t\tsign = true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tsign: sign,\n\t\taim: aim\n\t};\n};\n\nQflow.prototype.addEle = function (obj) {\n\n\tswitch (obj.id) {\n\t\tcase '-1':\n\t\t\tvar id = this.addContainer(obj);\n\n\t\t\tthis.inSertToContainer({}, { id: id }, '标题');\n\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tvar tmp = this.inContainer(obj);\n\t\t\tif (tmp.sign) {\n\t\t\t\tthis.inSertToContainer(obj, tmp.aim);\n\t\t\t} else {\n\t\t\t\tthis.addNode(obj);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tthis.addTipNode(obj);\n\t\t\tbreak;\n\n\t}\n};\nQflow.prototype.canvasUpFun = function () {\n\tconsole.log('canvasUpFun');\n};\nQflow.prototype.canvasMoveFun = function (e, pos) {\n\tvar _this = this;\n\tthis.updateTmpLineEndPos(pos);\n\n\tif (this.qcanvas.dragAim !== null && this.qcanvas.dragAim.id == this.qcanvas.id) {\n\n\t\tif (this.qnodes.length == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.baseNodesWithCoordinates.forEach(function (item) {\n\n\t\t\titem.start = [pos.x - item.dis.x, pos.y - item.dis.y];\n\n\t\t\t_this.getJsonObj(item.id) !== null && _this.updateInitData(item, _this.getJsonObj(item.id));\n\t\t});\n\t}\n};\nQflow.prototype.canvasDownFun = function (e, pos) {\n\tthis.delTmpLine();\n\tthis.contextMenuNode = null;\n\n\tthis.menuLayerHide();\n\tthis.lineMenuLayerHide();\n\n\tthis.contextSettingHide();\n\n\tthis.tipTextHide();\n\n\tthis.baseNodesWithCoordinates.forEach(function (item) {\n\n\t\titem.dis = {\n\t\t\tx: pos.x - item.start[0],\n\t\t\ty: pos.y - item.start[1]\n\t\t};\n\t});\n};\n\nQflow.prototype.rectDown = function (pos) {};\n\nQflow.prototype.initTool = function () {\n\n\tvar h = this.options[2];\n\tvar tool = this.qcanvas.qrect.rect({\n\t\tstart: [0, 0],\n\t\twidth: 200,\n\t\tlineWidth: 0.5,\n\t\theight: h,\n\t\tdrag: false\n\t});\n\tvar rect = this.qcanvas.qrect.rect({\n\t\tstart: function start() {\n\t\t\treturn [tool.start[0] + 20, tool.start[1] + 20];\n\t\t},\n\t\twidth: 70,\n\t\theight: 50,\n\t\tdrag: false,\n\t\tmousedown: this.rectDown\n\t});\n\tvar diamond = this.qcanvas.qshape.shape({\n\t\tfillColor: '',\n\t\tpoints: function points() {\n\t\t\treturn [[tool.start[0] + rect.width + 30, tool.start[1] + 45], [tool.start[0] + rect.width + 70, tool.start[1] + 20], [tool.start[0] + rect.width + 110, tool.start[1] + 45], [tool.start[0] + rect.width + 70, tool.start[1] + 70]];\n\t\t},\n\t\tdrag: false\n\t});\n\n\tvar arc = this.qcanvas.qarc.arc({\n\t\tstart: [300, 100],\n\t\tsAngle: 0,\n\t\teAngle: 200,\n\t\tfillColor: '',\n\t\tr: 10\n\t});\n\n\tthis.toolLayer.push(tool, rect, diamond, arc);\n};\n\nmodule.exports.Qflow = Qflow;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL1FmbG93LmpzPzdiODUiXSwibmFtZXMiOlsiUWZsb3ciLCJvcHRpb25zIiwidG9vbExheWVyIiwibWVudUxheWVyIiwicW5vZGVzIiwiYmFzZU5vZGVzV2l0aENvb3JkaW5hdGVzIiwiY29udGFpbmVyUGFkZGluZyIsImNvbnRhaW5lckNoaWxkTWFyZ2luIiwiY29udGFpbmVyVGl0bGVIZWlnaHQiLCJjaGlsZE5vZGVXaWR0aCIsImNoaWxkTm9kZUhlaWdodCIsInRpcE5vZGVXaWR0aCIsInRpcENvbnRleHQiLCJjb250YWluZXJOb2RlV2lkdGgiLCJjb250YWluZXJOb2RlSGVpZ2h0IiwiZHJhZ2luZyIsImNvbnRleHRTZXR0aW5nTm9kZSIsImNvbnRleHRBaW1BdHRyIiwibW9kaVRpdGxlT2JqIiwiY29sb3JSZWN0IiwibGluZUNvbG9yIiwiY2hpbGROb2RlRmlsbENvbG9yIiwiY2hpbGROb2RlQm9yZGVyQ29sb3IiLCJjb250YWluZXJGaWxsQ29sb3IiLCJsaW5lMUxpa2UiLCJsaW5lMkxpa2UiLCJsaW5lM0xpa2UiLCJpbml0IiwicHJvdG90eXBlIiwicmVTaXplQnlJbml0RGF0YSIsImluaXRDaGlsZFBvc2l0aW9uIiwiaW5pdENhbnZhcyIsImluaXROb2RlIiwibGluZUxheWVyIiwicWNhbnZhcyIsInFsYXllciIsImxheWVyIiwibGluZUNhY2hlIiwic29sdmVMaW5rIiwiaW5pdExpbmsiLCJjb250ZXh0U2V0dGluZ0xheWVyIiwic2V0RGlzcGxheSIsInNldHRpbmdJY28iLCJpbml0U2V0dGluZ0ljbyIsImNvbnRleHRNZW51TGF5ZXIiLCJjb250ZXh0TWVudU5vZGUiLCJpbml0TWVudSIsInRtcExpbmUiLCJjb250ZXh0TGluZU1lbnVMYXllciIsImNvbnRleHRMaW5lTWVudU5vZGUiLCJjcmVhdGVGcHMiLCJfdGhpcyIsInF0ZXh0IiwidGV4dCIsImNvbG9yIiwiZm9udFNpemUiLCJ0ZXh0QWxpZ24iLCJzdGFydCIsInBvaW50ZXJFdmVudCIsInJldHVyblNhdmVEYXRhIiwidG1wIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiaW5pdERhdGEiLCJub2RlIiwiZm9yRWFjaCIsIml0ZW0iLCJjaGlsZE5vZGVzIiwibGluayIsImZyb21Ob2RlIiwidG9Ob2RlIiwiaW5pdENvbnRleHRMaW5lTWVudUFyZWEiLCJwb3MiLCJxcmVjdCIsInJlY3QiLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0IiwiYm9yZGVyQ29sb3IiLCJmaWxsQ29sb3IiLCJkcmFnIiwicHVzaCIsInJlc2V0UG9zT2ZMaW5lTW9kaVRpdGxlTm9kZSIsImVsZSIsImVsZW1lbnRzIiwidyIsImgiLCJkIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInN0eWxlIiwibGVmdCIsInRvcCIsImRpc3BsYXkiLCJtb2RpTGluZVRpdGxlIiwidiIsInNldFRleHQiLCJqc29uIiwiZ2V0TGluZUpzb25CeU5vZGVJZCIsImlkIiwiYXR0ciIsIm1vZGlMaW5lTGlrZSIsInJlbGF0aW9uTGluZUlkIiwibDEiLCJnZXRFbGVCeUlkIiwibDMiLCJzZXRMaWtlIiwibGlrZSIsIm1vZGlMaW5lVHlwZSIsInR5cGUiLCJkZXN0cm95IiwibGluZU1lbnVMYXllckhpZGUiLCJpbml0TGluZU1vZGlUaXRsZU5vZGUiLCJjb25zb2xlIiwibG9nIiwid2l0aFRleHRJZCIsInZhbHVlIiwiaW5pdExpbmVMaWtlTm9kZSIsImluaXRMaW5lVHlwZU5vZGUiLCJpbml0TGluZUNvbG9yUmVjdCIsImRpc1RvcCIsInBhZGRpbmciLCJyZWN0VyIsInJlY3RIIiwiYXJlYVBvc2l0aW9uIiwiY2hpbGRQb3NpdGlvbkJ5Um93IiwiaSIsImxlbmd0aCIsIm1vdXNldXAiLCJzZXRDb2xvciIsInRleHRPYmoiLCJkZWxMaW5lTm9kZSIsImZpbHRlciIsImxpbmVJZCIsInJlbW92ZUVsZSIsInJlbW92ZUVsZUJ5SWQiLCJpbml0TGluZURlbEJ0biIsImluaXRMaW5lTWVudSIsImRvd25sb2FkIiwib2JqIiwiY3JlYXRlRWxlbWVudCIsImNvbnRleHQiLCJnZXRDb250ZXh0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJwYXJzZUludCIsImRyYXdJbWFnZSIsIm9BIiwiaHJlZiIsInRvRGF0YVVSTCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNsaWNrIiwicmVtb3ZlIiwiVFlQRSIsImxpbmVNZW51TGF5ZXJTaG93IiwiZDEiLCJkMiIsImQzIiwidXBkYXRlVG1wTGluZUVuZFBvcyIsInNldEVuZCIsImRlbFRtcExpbmUiLCJjcmVhdGVOZXdMaW5lIiwianNvbk9iaiIsImZyb21KU09OIiwiZ2V0SnNvbk9iaiIsImZyb21JZCIsInRvSWQiLCJxbGluZSIsImxpbmUiLCJjYWxjTGluZVN0YXJ0UG9zIiwiZW5kIiwiY2FsY0xpbmVFbmRQb3MiLCJ3aXRoVGV4dCIsImUiLCJidXR0b24iLCJyYWlzZVRvVG9wIiwiY29udGV4dFNldHRpbmdIaWRlIiwiY3JlYXRlVG1wTGluZSIsImNlbnRlclBvcyIsImNlbnRlclBvaW50cyIsIndpdGhUZXh0QWxpZ24iLCJnZXRMaW5lT2JqIiwibm9kZUlkIiwiZ2V0RGVsTGluZU9iaiIsIm5vZGVPYmoiLCJsaW5lT2JqIiwibCIsImdldERlbFRleHRPYmoiLCJhbGxUZXh0T2JqIiwidCIsIm93bmVySWQiLCJnZXRXaXRoVGV4dE9iaiIsInVwZGF0ZU5vZGVKc29uQWZ0ZXJEZWxOb2RlIiwiaXNEZWwiLCJjaGlsZCIsInVwZGF0ZWxpbmtKc29uQWZ0ZXJEZWxOb2RlIiwiZGVsTm9kZSIsIm5vZGVKc29uIiwiZGVsTm9kZU9iaiIsIm5vZGVUeXBlIiwiY29uY2F0IiwiZ2V0Tm9kZU9iaiIsImRlbExpbmVPYmoiLCJyIiwiYyIsImluZGV4Iiwic29ydCIsInRpdGxlUG9zaXRpb24iLCJzdGFydFBsYWNlSG9sZGVyWSIsInJvdyIsIk1hdGgiLCJjZWlsIiwiZ3JpZCIsImNvbnRhaW5lck9iaiIsInNldEhlaWdodCIsImNoaWxkQXJlYVBvc2l0aW9uIiwiZ2V0Q2hpbGRBcmVhUG9zaXRpb24iLCJjaGlsZFBvc2l0aW9uIiwiZ2V0Q2hpbGRQb3NpdGlvbiIsImdyaWRQb3NpdGlvbiIsImNsb25lTm9kZSIsIm5vZGVKc29uT2JqIiwiYWRkTm9kZSIsImluU2VydFRvQ29udGFpbmVyIiwiYWRkQ29udGFpbmVyIiwiY2xvbmVUaXBOb2RlIiwiYXJlYSIsImxpbmtSZWN0IiwibWVudUxheWVySGlkZSIsImxpbmtUeHQiLCJjbG9uZVJlY3QiLCJjbG9uZVRleHQiLCJkZWxSZWN0IiwiZGVsVHh0IiwibWVudUxheWVyU2hvdyIsInNldFN0YXJ0IiwicWFyYyIsImFyYyIsInNBbmdsZSIsImVBbmdsZSIsIm9wYWNpdHkiLCJtb3VzZW1vdmUiLCJjb250ZXh0U2V0dGluZ1Nob3ciLCJzZXR0aW5nSWNvU2hvdyIsImlzRnVuIiwic2V0dGluZ0ljb0hpZGUiLCJpbml0Q29udGV4dENvdmVyIiwic3RhZ2UiLCJpbml0Q29udGV4dE1lbnVBcmVhIiwiaW5pdE1vZGlUaXRsZU5vZGUiLCJpbml0Q29udGV4dE1lbnVUYWIiLCJpbml0Q29sb3JSZWN0IiwiaW5pdERlbEJ0biIsIm1vZGlUaXRsZSIsImJnUmVjdCIsInRleHRQb2x5UG9pbnRzIiwicG9seVBvaW50cyIsImZvcm1hdFRleHQiLCJjYWxsIiwibWF4IiwiYXBwbHkiLCJyZWN0SnNvbk9iaiIsInVwZGF0ZU5vZGVUaXRsZUNvbG9yIiwidXBkYXRlSW5pdERhdGFBdHRyIiwiZ2V0VGl0bGVOb2RlSlNPTiIsInRpdGxlSlNPTiIsInRpdGxlSWQiLCJ0aXRsZU5vZGVKU09OIiwidGV4dEFyciIsImFpbUF0dHIiLCJfc2VsZiIsImdldENvbnRhaW5lck5vZGVzIiwiY29udGFpbmVyTm9kZSIsInN0YXJ0UGxhY2VIb2xkZXJYIiwiZW5kUGxhY2VIb2xkZXJYIiwiZW5kUGxhY2VIb2xkZXJZIiwiY29sdW1uIiwiaiIsImNoaWxkTnVtIiwiYXJlYVdpZHRoIiwiYXJlYUhlaWdodCIsImNvbnRhaW5lck5vZGVzIiwibWFwIiwibWF4WCIsIm1heFkiLCJnZXROb2RlSWRGcm9tSnNvbkJ5SWQiLCJBIiwiQiIsIkYiLCJBX2NlbnRlciIsIkJfY2VudGVyIiwiQV9yYW5nZVBvcyIsImdldFJhbmdlUG9pbnRzIiwiQl9yYW5nZVBvcyIsInN0YXJ0UG9zIiwiZW5kUG9zIiwib2xkU3RhcnQiLCJEYXRlIiwiZ2V0VGltZSIsInN0YXJ0Q2FsbFRpbWUiLCJvbGRFbmQiLCJlbmRDYWxsVGltZSIsImNhbGNMaW5lUG9zIiwiY2FsbFRpbWUiLCJwb3NpdGlvbiIsImNhbGVIYW5kbGVyMSIsImNhbGVUaW1lMSIsInJldHVybkhhbmRsZXIxIiwiYWJzIiwib2xkSGFuZGxlcjEiLCJjYWxlSGFuZGxlcjIiLCJjYWxlVGltZTIiLCJyZXR1cm5IYW5kbGVyMiIsIm9sZEhhbmRsZXIyIiwiY2FsZVF1YWRyYXRpY0N1cnZlSGFuZGxlciIsIm9sZFF1YWRyYXRpY0N1cnZlSGFuZGxlciIsInFiZXppZXJDdXJ2ZSIsImJlemllckN1cnZlIiwiaGFuZGxlcjEiLCJoYW5kbGVyMiIsInFxdWFkcmF0aWNDdXJ2ZSIsInF1YWRyYXRpY0N1cnZlIiwiaGFuZGxlciIsImNyZWF0ZUZvbGRMaW5lIiwiaXNBcnIiLCJjYWxlRm9sZExpbmVQb3NpdGlvbiIsInBlcmNlbnQiLCJkaXNQZXJjZW50IiwicG9pbnRzIiwibDIiLCJ1cGRhdGVJbml0RGF0YSIsImluaXROb2RlVGl0bGUiLCJpbml0Q29udGFpbmVyVGl0bGUiLCJxb2JqIiwiZHJhd05vZGUiLCJwYXJlbnROb2RlIiwibm9kZXMiLCJjcmVhdGVDaGlsZHNPZkNvbnRhaW5lciIsImNyZWF0ZVRpcE5vZGUiLCJjcmVhdGVDb250YWluZXJPck5vZGUiLCJkYXNoZWQiLCJsaW5lV2lkdGgiLCJjcmVhdGVSYW5nZVBvaW50cyIsIm1vdXNlZW50ZXIiLCJtb3VzZWRvd24iLCJ0aXBUZXh0SGlkZSIsIm1vdXNlb3V0IiwiZGJsY2xpY2siLCJjb250YWluZXJEYmxjbGljayIsImNvbnRhaW5lck1vdXNlRG93biIsImNvbnRhaW5lciIsInRpdGxlTm9kZSIsInNldFBvaW50ZXJFdmVudCIsImNvbnRhaW5lck1vdXNlVXAiLCJpc1Jlc2l6ZUNhbnZhcyIsInRpdGxlT2JqIiwiZm9jdXMiLCJ0aXRsZUFyZWFIZWlnaHQiLCJyYXlDYXN0aW5nIiwicmVzaXplQ2FudmFzIiwiZHByIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImNfb2JqIiwiY2FudmFzIiwic2NhbGUiLCJsYXllcl9jYW52YXMiLCJjYW52YXNFbGUiLCJzZXRUaW1lb3V0IiwiY29udGFpbmVyTW91c2VNb3ZlIiwiZ2V0TWlkZGxlQ29vcmRpbmF0ZSIsInMiLCJyYW5nZSIsInVwZGF0ZVRpcFRleHQiLCJmb3JtYXRUaXBUZXh0IiwidGlwUmVjdCIsIm1lYXN1cmVUZXh0V2lkdGgiLCJtZWFzdXJlVGV4dCIsInN0ciIsImxhc3RTdWJTdHJJbmRleCIsInN1YnN0cmluZyIsImpvaW4iLCJhZGRUaXBOb2RlIiwiZG9jIiwibGluZUhlaWdodCIsImRyYWdBaW0iLCJpbml0VGlwVGV4dCIsInRleHRCYXNlbGluZSIsIlFjYW52YXMiLCJjYW52YXNEb3duRnVuIiwiYmluZCIsImNhbnZhc01vdmVGdW4iLCJjYW52YXNVcEZ1biIsImRlbGF5UmVuZGVyIiwiYXR0ck9iaiIsIm1vZGlDb250YWluZXJHcmlkQ29sdW1uIiwicGFyZW50SnNvbk5vZGUiLCJzZXRXaWR0aCIsImFpbSIsInRpdGxlIiwicCIsInBvbHkiLCJweCIsInB5IiwiZmxhZyIsInN4Iiwic3kiLCJ0eCIsInR5IiwiaW5Db250YWluZXIiLCJzaWduIiwib3duZXJPYmoiLCJhZGRFbGUiLCJkaXMiLCJyZWN0RG93biIsImluaXRUb29sIiwidG9vbCIsImRpYW1vbmQiLCJxc2hhcGUiLCJzaGFwZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7O0FBS0EsU0FBU0EsS0FBVCxDQUFlQyxPQUFmLEVBQXVCO0FBQ3RCLE1BQUtBLE9BQUwsR0FBZUEsT0FBZjtBQUNBLE1BQUtDLFNBQUwsR0FB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QVY7O0FBUUEsTUFBSzVNLFNBQUwsQ0FBZWlGLElBQWYsQ0FBb0JnVixJQUFwQixFQUF5QnhWLElBQXpCLEVBQThCeVYsT0FBOUIsRUFBc0NwTCxHQUF0QztBQUtBLENBN0NEOztBQStDQXVMLE9BQU9DLE9BQVAsQ0FBZXhhLEtBQWYsR0FBdUJBLEtBQXZCIiwiZmlsZSI6IjM0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy9cbi8v55uu5YmN5pmu6YCabm9kZeWbuuWumuWuveW6pigxMDAqNTApXG4vL+WuueWZqGNvbnRhaW5lcueahOWuvemrmOmaj+edgOWug+WMheWQq+eahGNoaWxk55qE5pWw6YeP6ICM5Y+Y5YyWIOaaguS4jeaUr+aMgeaJi+WKqOe8qeaUvlxuLy9cbi8vXG5mdW5jdGlvbiBRZmxvdyhvcHRpb25zKXtcblx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0dGhpcy50b29sTGF5ZXIgPSBudWxsO1xuXHR0aGlzLm1lbnVMYXllciA9IG51bGw7XG5cdHRoaXMucW5vZGVzID0gW107ICAvL+aJgOacieWIm+W7uueahOWvueixoVxuXHR0aGlzLmJhc2VOb2Rlc1dpdGhDb29yZGluYXRlcyA9IFtdOyAgLy/luKbmnInlnZDmoIfnmoTln7rnoYDlr7nosaFcblx0dGhpcy5jb250YWluZXJQYWRkaW5nID0gMTA7ICAgICAvL+WuueWZqOWGhei+uei3nVxuXHR0aGlzLmNvbnRhaW5lckNoaWxkTWFyZ2luID0gMTA7IC8v5a2Q6aG55aSW6L656LedXG5cdHRoaXMuY29udGFpbmVyVGl0bGVIZWlnaHQgPSAyMDsgLy/lrrnlmajmoIfpopjmlofmnKzljaDnmoTpq5jluqZcblxuXHQvL+WIneWni+aZrumAmuiKgueCueWkp+Wwj1xuXHR0aGlzLmNoaWxkTm9kZVdpZHRoID0gMTAwO1xuXHR0aGlzLmNoaWxkTm9kZUhlaWdodCA9IDMwO1xuXG5cblx0dGhpcy50aXBOb2RlV2lkdGggPSAxNTA7XG5cdHRoaXMudGlwQ29udGV4dCA9IG51bGw7XG5cblxuXHQvL+WIneWni+WuueWZqOWkp+Wwj1xuXHR0aGlzLmNvbnRhaW5lck5vZGVXaWR0aCA9IDEyMDtcblx0dGhpcy5jb250YWluZXJOb2RlSGVpZ2h0ID0gNzA7XG5cblxuXHR0aGlzLmRyYWdpbmcgPSBmYWxzZTtcblxuXHR0aGlzLmNvbnRleHRTZXR0aW5nTm9kZSA9IG51bGw7IC8v6K6+572u6I+c5Y2V55qE5a+56LGhXG5cdHRoaXMuY29udGV4dEFpbUF0dHIgPSAnJzsgICAgLy/lj7PplK50YWLmjIflkJHnmoTlsZ7mgKdcblxuXG5cdHRoaXMubW9kaVRpdGxlT2JqID0gbnVsbDtcblxuXHQvLzE356eN5Z+65pys6aKc6ImyXG5cdHRoaXMuY29sb3JSZWN0ID0geyBcblx0XHRcInJlZFwiOlwiI0ZGMDAwMFwiLFxuXHRcdFwib3JhbmdlXCI6XCIjRkZBNTAwXCIsXG5cdFx0XCJ5ZWxsb3dcIjpcIiNGRkZGMDBcIixcblx0XHRcImdyZWVuXCI6XCIjMDA4MDAwXCIsXG5cdFx0XCJibHVlXCI6XCIjMDAwMEZGXCIsXG5cdFx0XCJ3aGl0ZVwiOlwiI0ZGRkZGRlwiLFxuXHRcdFwiYmxhY2tcIjpcIiMwMDAwMDBcIixcblx0XHRcImFxdWFcIjpcIiMwMEZGRkZcIixcblx0XHRcImZ1Y2hzaWFcIjpcIiNGRjAwRkZcIixcblx0XHRcImdyYXlcIjpcIiM4MDgwODBcIixcblx0XHRcImxpbWVcIjpcIiMwMEZGMDBcIixcblx0XHRcIm1hcm9vblwiOlwiIzgwMDAwMFwiLFxuXHRcdFwibmF2eVwiOlwiIzAwMDA4MFwiLFxuXHRcdFwib2xpdmVcIjpcIiM4MDgwMDBcIixcblx0XHRcInB1cnBsZVwiOlwiIzgwMDA4MFwiLFxuXHRcdFwic2lsdmVyXCI6XCIjQzBDMEMwXCIsXG5cdFx0XCJ0ZWFsXCI6XCIjMDA4MDgwXCIsXG5cdH07XG5cblx0dGhpcy5saW5lQ29sb3IgPSAnI0ZGOTEyRCc7XG5cdHRoaXMuY2hpbGROb2RlRmlsbENvbG9yID0gJyM1ODVEQ0InO1xuXHR0aGlzLmNoaWxkTm9kZUJvcmRlckNvbG9yID0gJyM3MEJEQzQnO1xuXHR0aGlzLmNvbnRhaW5lckZpbGxDb2xvciA9IFwiIzkwOTNEQ1wiO1xuXG5cblxuXHQvL+aKmOe6v+eahOmFjee9rumhuVxuXHR0aGlzLmxpbmUxTGlrZSA9IHtcblx0XHQnLSc6Jy0nLFxuXHRcdCctLSc6Jy0tJyxcblx0XHQnLT4nOictJyxcblx0XHQnLS0+JzonLS0nLFxuXHRcdCc8LSc6JzwtJyxcblx0XHQnPC0tJzonPC0tJyxcblx0XHQnPC0+JzonPC0nLFxuXHRcdCc8LS0+JzonPC0tJ1xuXHR9XG5cdHRoaXMubGluZTJMaWtlID0ge1xuXHRcdCctJzonLScsXG5cdFx0Jy0tJzonLS0nLFxuXHRcdCctPic6Jy0nLFxuXHRcdCctLT4nOictLScsXG5cdFx0JzwtJzonLScsXG5cdFx0JzwtLSc6Jy0tJyxcblx0XHQnPC0+JzonLScsXG5cdFx0JzwtLT4nOictLSdcblx0fVxuXHR0aGlzLmxpbmUzTGlrZSA9IHtcblx0XHQnLSc6Jy0nLFxuXHRcdCctLSc6Jy0tJyxcblx0XHQnLT4nOictPicsXG5cdFx0Jy0tPic6Jy0tPicsXG5cdFx0JzwtJzonLScsXG5cdFx0JzwtLSc6Jy0tJyxcblx0XHQnPC0+JzonLT4nLFxuXHRcdCc8LS0+JzonLS0+J1xuXHR9XG5cblx0dGhpcy5pbml0KCk7XG5cblx0Ly8gY29uc29sZS5sb2codGhpcy5xY2FudmFzLmVsZW1lbnRzKTtcbiBcbn1cblFmbG93LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG5cdC8v5Yqg5bel5Yid5aeL5pWw5o2uIOmHjee9rueUu+W4g3NpemVcblx0dGhpcy5yZVNpemVCeUluaXREYXRhKCk7XG5cblx0Ly/liJ3lp4vljJblrZDpobnnmoTnmoTkvY3nva5cblx0dGhpcy5pbml0Q2hpbGRQb3NpdGlvbigpO1xuXG5cdC8v5Yid5aeL55S75biDXG5cdHRoaXMuaW5pdENhbnZhcygpO1xuXG5cdC8v5Yid5aeL6IqC54K5XG5cdHRoaXMuaW5pdE5vZGUoKTtcblxuXG5cdC8v5Yid5aeL6L+e57q/XG5cdHRoaXMubGluZUxheWVyID0gdGhpcy5xY2FudmFzLnFsYXllci5sYXllcigpO1xuXHR0aGlzLmxpbmVDYWNoZSA9IHt9O1xuXHR0aGlzLnNvbHZlTGluaygpO1xuXHR0aGlzLmluaXRMaW5rKCk7XG5cblxuXHQvL+eCueWHu+iuvue9ruaMiemSruWHuueOsOiPnOWNlWxheWVy5a+56LGhXG5cdHRoaXMuY29udGV4dFNldHRpbmdMYXllciA9IHRoaXMucWNhbnZhcy5xbGF5ZXIubGF5ZXIoKTtcblx0dGhpcy5jb250ZXh0U2V0dGluZ0xheWVyLnNldERpc3BsYXkoJ25vbmUnKTtcblxuXHQvL+eCueWHu+iuvue9ruaMiemSruaYvuekuuWNiumAj+aYjuimhuebluWxglxuXHQvLyB0aGlzLmluaXRDb250ZXh0Q292ZXIoKTtcblxuXG5cdC8v5Yid5aeL5YyW6K6+572u5oyJ6ZKu77yI6byg5qCH5YiS6L+H5YWD57Sg5pe25pi+56S677yJXG5cdHRoaXMuc2V0dGluZ0ljbyA9IG51bGw7XG5cdHRoaXMuaW5pdFNldHRpbmdJY28oKTtcblxuXG5cdC8v6IqC54K55Y+z6ZSu6I+c5Y2VXG5cdHRoaXMuY29udGV4dE1lbnVMYXllciA9IHRoaXMucWNhbnZhcy5xbGF5ZXIubGF5ZXIoKTtcblx0dGhpcy5jb250ZXh0TWVudUxheWVyLnNldERpc3BsYXkoJ25vbmUnKTtcblx0dGhpcy5jb250ZXh0TWVudU5vZGUgPSBudWxsOyAvL+WPs+mUruiPnOWNleWvueixoVxuXG5cdHRoaXMuaW5pdE1lbnUoKTtcblxuXHR0aGlzLnRtcExpbmUgPSBudWxsOyAgIC8v5Yib5bu65Li05pe255qE6L+e5o6l57q/XG5cblxuXHQvL+e6v+eahOWPs+mUruiPnOWNlVxuXHR0aGlzLmNvbnRleHRMaW5lTWVudUxheWVyID0gdGhpcy5xY2FudmFzLnFsYXllci5sYXllcigpO1xuXHR0aGlzLmNvbnRleHRMaW5lTWVudUxheWVyLnNldERpc3BsYXkoJ25vbmUnKTtcblx0dGhpcy5jb250ZXh0TGluZU1lbnVOb2RlID0gbnVsbDsgLy/lj7PplK7oj5zljZXlr7nosaFcblxuXHQvLyB0aGlzLmluaXRMaW5lTWVudSgpO1xuXHQvLyBjb25zb2xlLmxvZyh0aGlzLnFjYW52YXMpO1xuXHRcblx0dGhpcy5jcmVhdGVGcHMoKTtcbn07XG5RZmxvdy5wcm90b3R5cGUuY3JlYXRlRnBzID0gZnVuY3Rpb24oKSB7XG5cdHZhciBfdGhpcyA9IHRoaXM7XG5cdHRoaXMucWNhbnZhcy5xdGV4dC50ZXh0KHtcblx0XHQvLyB0ZXh0OmZ1bmN0aW9uKCl7XG5cdFx0Ly8gXHRyZXR1cm4gJ0ZQUzonK190aGlzLnFjYW52YXMuY3VyckZwcysnJztcblx0XHQvLyB9LFxuXHRcdHRleHQ6J3FyZWxhdGlvbiBWZXJzaW9uIHYxLjAuMTA4Jyxcblx0XHRjb2xvcjonI2RjZGNkYycsXG5cdFx0Zm9udFNpemU6JzEwcHgnLFxuXHRcdHRleHRBbGlnbjonbGVmdCcsXG5cdFx0c3RhcnQ6WzUsNTBdLFxuXHRcdHBvaW50ZXJFdmVudDonbm9uZSdcblx0fSlcbn07XG5RZmxvdy5wcm90b3R5cGUucmV0dXJuU2F2ZURhdGEgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRtcCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5vcHRpb25zLmluaXREYXRhKSk7XG5cblx0dG1wLm5vZGUgJiYgdG1wLm5vZGUuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcblx0XHRkZWxldGUgaXRlbS5jaGlsZE5vZGVzXG5cdH0pXG5cblx0dG1wLmxpbmsgJiYgdG1wLmxpbmsuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcblx0XHRkZWxldGUgaXRlbS5mcm9tTm9kZTtcblx0XHRkZWxldGUgaXRlbS50b05vZGU7XG5cdH0pXG5cblx0cmV0dXJuIHRtcDtcbn07XG5RZmxvdy5wcm90b3R5cGUuaW5pdENvbnRleHRMaW5lTWVudUFyZWEgPSBmdW5jdGlvbihwb3MpIHtcblx0dmFyIF90aGlzID0gdGhpczsgXG5cblx0Ly/lj7Plh7vmmL7npLrnmoToj5zljZXlnZdcblx0dmFyIHRtcCA9IHRoaXMucWNhbnZhcy5xcmVjdC5yZWN0KHtcblx0XHRzdGFydDpbcG9zLngscG9zLnldLFxuXHRcdHdpZHRoOjE1MCxcblx0XHRoZWlnaHQ6MTUwLFxuXHRcdGJvcmRlckNvbG9yOicnLFxuXHRcdGZpbGxDb2xvcjoneWVsbG93Jyxcblx0XHRkcmFnOmZhbHNlXG5cdH0pXG5cblx0dGhpcy5jb250ZXh0TGluZU1lbnVMYXllci5wdXNoKHRtcCk7XG59O1xuUWZsb3cucHJvdG90eXBlLnJlc2V0UG9zT2ZMaW5lTW9kaVRpdGxlTm9kZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgZWxlID0gdGhpcy5jb250ZXh0TGluZU1lbnVMYXllci5lbGVtZW50c1swXTtcblx0dmFyIHggPSBlbGUuc3RhcnRbMF0rNTtcblx0dmFyIHkgPSBlbGUuc3RhcnRbMV0rNTsgXG5cdHZhciB3ID0gKGVsZS53aWR0aCAtIDEwKSowLjU7XG5cdHZhciBoID0gMzA7XG5cblx0dmFyIGQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGluZVRpdGxlSW5wdXQnKTtcblx0ZC5zdHlsZS5sZWZ0ID0geCsncHgnO1xuXHRkLnN0eWxlLnRvcCA9IHkrJ3B4Jztcblx0ZC5zdHlsZS53aWR0aCA9IHcrJ3B4Jztcblx0ZC5zdHlsZS5oZWlnaHQgPSBoKydweCc7XG5cdGQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG59O1xuUWZsb3cucHJvdG90eXBlLm1vZGlMaW5lVGl0bGUgPSBmdW5jdGlvbih2KSB7XG5cdGlmKHRoaXMubW9kaVRpdGxlT2JqICE9PSBudWxsKXtcblx0XHR0aGlzLm1vZGlUaXRsZU9iai5zZXRUZXh0KHYpO1xuXHR9XG5cblx0dmFyIGpzb24gPSB0aGlzLmdldExpbmVKc29uQnlOb2RlSWQodGhpcy5jb250ZXh0TGluZU1lbnVOb2RlLmlkKTtcbiAgXHRqc29uLmF0dHIudGV4dCA9IHY7XG5cbn07XG5RZmxvdy5wcm90b3R5cGUubW9kaUxpbmVMaWtlID0gZnVuY3Rpb24odikgeyBcblxuXG5cdGlmKHRoaXMuY29udGV4dExpbmVNZW51Tm9kZS5yZWxhdGlvbkxpbmVJZCl7ICAvL+aKmOe6v1xuXG5cblx0XHR2YXIgbDEgPSB0aGlzLmxpbmVMYXllci5nZXRFbGVCeUlkKHRoaXMuY29udGV4dExpbmVNZW51Tm9kZS5yZWxhdGlvbkxpbmVJZFswXSk7XG5cdFx0dmFyIGwzID0gdGhpcy5saW5lTGF5ZXIuZ2V0RWxlQnlJZCh0aGlzLmNvbnRleHRMaW5lTWVudU5vZGUucmVsYXRpb25MaW5lSWRbMV0pO1xuIFxuXG5cdFx0bDEuc2V0TGlrZSh0aGlzLmxpbmUxTGlrZVt2XSk7XG5cdFx0bDMuc2V0TGlrZSh0aGlzLmxpbmUzTGlrZVt2XSk7XG5cdFx0dGhpcy5jb250ZXh0TGluZU1lbnVOb2RlLnNldExpa2UodGhpcy5saW5lMkxpa2Vbdl0pO1xuXG5cdH1lbHNle1xuXHRcdHRoaXMuY29udGV4dExpbmVNZW51Tm9kZS5zZXRMaWtlKHYpO1xuXHR9XG5cblxuXHR2YXIganNvbiA9IHRoaXMuZ2V0TGluZUpzb25CeU5vZGVJZCh0aGlzLmNvbnRleHRMaW5lTWVudU5vZGUuaWQpO1xuICBcdGpzb24uYXR0ci5saWtlID0gdjtcbn07XG5cblFmbG93LnByb3RvdHlwZS5tb2RpTGluZVR5cGUgPSBmdW5jdGlvbih2KSB7XG4gXG5cdHZhciBqc29uID0gdGhpcy5nZXRMaW5lSnNvbkJ5Tm9kZUlkKHRoaXMuY29udGV4dExpbmVNZW51Tm9kZS5pZCk7XG5cblx0aWYoKHR5cGVvZiBqc29uLmF0dHIudHlwZSAhPSd1bmRlZmluZWQnKSAmJiBcblx0KHYgIT0ganNvbi5hdHRyLnR5cGUpIHx8ICh0eXBlb2YganNvbi5hdHRyLnR5cGUgPT0ndW5kZWZpbmVkJylcblx0KXsgLy/nur/nmoTnsbvlnovkuI3kuIDmoLdcblxuXG5cdCAgXHRqc29uLmF0dHIudHlwZSA9IHY7XG5cblx0ICBcdC8v5Yig6Zmk5Y6f5p2l55qE57q/5Y+K5paH5pysXG5cdCAgXHQvLyB0eXBlb2YgdGhpcy5jb250ZXh0TGluZU1lbnVOb2RlLndpdGhUZXh0SWQgIT0ndW5kZWZpbmVkJyAmJiAgXG5cdCAgXHQvLyB0aGlzLmxpbmVMYXllci5yZW1vdmVFbGUodGhpcy5saW5lTGF5ZXIuZ2V0RWxlQnlJZCh0aGlzLmNvbnRleHRMaW5lTWVudU5vZGUud2l0aFRleHRJZCkpO1xuXHQgIFx0Ly8gdGhpcy5saW5lTGF5ZXIucmVtb3ZlRWxlKHRoaXMuY29udGV4dExpbmVNZW51Tm9kZSlcblxuXG5cdCAgXHQvL+WFqOmDqOa4hemZpCDph43mlrDnlLvkuIDmrKFcblx0ICBcdHRoaXMubGluZUxheWVyLmRlc3Ryb3koKTtcblx0ICBcdHRoaXMuaW5pdExpbmsoKTtcblxuXHQgIFx0Ly/muIXpmaTlj7Plh7voj5zljZVcblx0ICBcdHRoaXMubGluZU1lbnVMYXllckhpZGUoKTtcblxuXHR9XG59XG5cblxuXG5RZmxvdy5wcm90b3R5cGUuaW5pdExpbmVNb2RpVGl0bGVOb2RlID0gZnVuY3Rpb24oKSB7XG5cblx0dmFyIGVsZSA9IHRoaXMuY29udGV4dExpbmVNZW51TGF5ZXIuZWxlbWVudHNbMF07XG5cdHZhciB4ID0gZWxlLnN0YXJ0WzBdKzU7XG5cdHZhciB5ID0gZWxlLnN0YXJ0WzFdKzU7XG5cdHZhciB3ID0gKGVsZS53aWR0aCAtIDEwKSowLjU7XG5cdHZhciBoID0gMzA7XG4gXG5cblx0dmFyIGQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGluZVRpdGxlSW5wdXQnKTtcblx0ZC5zdHlsZS5sZWZ0ID0geCsncHgnO1xuXHRkLnN0eWxlLnRvcCA9IHkrJ3B4Jztcblx0ZC5zdHlsZS53aWR0aCA9IHcrJ3B4Jztcblx0ZC5zdHlsZS5oZWlnaHQgPSBoKydweCc7XG5cdGQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gXG5cdGNvbnNvbGUubG9nKHRoaXMuY29udGV4dExpbmVNZW51Tm9kZSk7XG5cdHRoaXMubW9kaVRpdGxlT2JqID0gdGhpcy5saW5lTGF5ZXIuZ2V0RWxlQnlJZCh0aGlzLmNvbnRleHRMaW5lTWVudU5vZGUud2l0aFRleHRJZCk7XG5cdGNvbnNvbGUubG9nKHRoaXMubW9kaVRpdGxlT2JqKTtcblx0ZC52YWx1ZSA9IHRoaXMubW9kaVRpdGxlT2JqLnRleHQ7XG4gXG5cblxufTsgXG5RZmxvdy5wcm90b3R5cGUuaW5pdExpbmVMaWtlTm9kZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgZWxlID0gdGhpcy5jb250ZXh0TGluZU1lbnVMYXllci5lbGVtZW50c1swXTtcblx0dmFyIHggPSBlbGUuc3RhcnRbMF0rZWxlLndpZHRoKjAuNTtcblx0dmFyIHkgPSBlbGUuc3RhcnRbMV0rNTtcblx0dmFyIHcgPSAoZWxlLndpZHRoIC0gMTApKjAuNTtcblx0dmFyIGggPSAzMDtcblxuXHR2YXIgZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsaW5lTGlrZScpO1xuXHRkLnN0eWxlLmxlZnQgPSB4KydweCc7XG5cdGQuc3R5bGUudG9wID0geSsncHgnO1xuXHRkLnN0eWxlLndpZHRoID0gdysncHgnO1xuXHRkLnN0eWxlLmhlaWdodCA9IGgrJ3B4Jztcblx0ZC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuXHRkLnZhbHVlID0gdGhpcy5jb250ZXh0TGluZU1lbnVOb2RlLmxpa2U7XG5cblxuXG59O1xuUWZsb3cucHJvdG90eXBlLmluaXRMaW5lVHlwZU5vZGUgPSBmdW5jdGlvbigpIHtcblxuXHR2YXIgZWxlID0gdGhpcy5jb250ZXh0TGluZU1lbnVMYXllci5lbGVtZW50c1swXTtcblx0dmFyIHggPSBlbGUuc3RhcnRbMF0rNTtcblx0dmFyIHkgPSBlbGUuc3RhcnRbMV0rZWxlLmhlaWdodC00MDtcblx0dmFyIHcgPSAoZWxlLndpZHRoIC0gMTApKjAuNTtcblx0dmFyIGggPSAzMDtcblxuXHR2YXIgZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsaW5lVHlwZScpO1xuXHRkLnN0eWxlLmxlZnQgPSB4KydweCc7XG5cdGQuc3R5bGUudG9wID0geSsncHgnO1xuXHRkLnN0eWxlLndpZHRoID0gdysncHgnO1xuXHRkLnN0eWxlLmhlaWdodCA9IGgrJ3B4Jztcblx0ZC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuXHRkLnZhbHVlID0gJyc7XG5cblxuXG5cbn1cblxuXG5cblFmbG93LnByb3RvdHlwZS5pbml0TGluZUNvbG9yUmVjdCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXHR2YXIgZGlzVG9wID0gMTA7XG5cdHZhciBwYWRkaW5nID0gMTA7XG5cdHZhciByZWN0VyA9IDEzO1xuXHR2YXIgcmVjdEggPSAxMztcblxuXHR2YXIgdG1wID0gdGhpcy5jb250ZXh0TGluZU1lbnVMYXllci5lbGVtZW50c1swXTtcblxuXG5cdC8v5pqC5pe25o6SNOihjDXliJcgXG5cdHZhciBhcmVhUG9zaXRpb24gPSBbXG5cdFx0e1xuXHRcdFx0eDp0bXAuc3RhcnRbMF0rMTAsXG5cdFx0XHR5OnRtcC5zdGFydFsxXSszMCtkaXNUb3Bcblx0XHR9LFxuXHRcdHtcblx0XHRcdHg6dG1wLnN0YXJ0WzBdK3RtcC53aWR0aC0xMCxcblx0XHRcdHk6dG1wLnN0YXJ0WzFdK3RtcC5oZWlnaHQrMzAtMTBcblx0XHR9XG5cdF07XG5cblx0dmFyIHBvcyA9IHRoaXMuY2hpbGRQb3NpdGlvbkJ5Um93KDQsNixhcmVhUG9zaXRpb24sIHJlY3RXLHJlY3RIKTtcblxuXHR2YXIgY29sb3IgPSBbXTtcblx0Zm9yKHZhciBpIGluIHRoaXMuY29sb3JSZWN0KXtcblx0XHRjb2xvci5wdXNoKHRoaXMuY29sb3JSZWN0W2ldKTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3IubGVuZ3RoOyBpKyspIHtcblx0XHR0aGlzLmNvbnRleHRMaW5lTWVudUxheWVyLnB1c2godGhpcy5xY2FudmFzLnFyZWN0LnJlY3Qoe1xuXHRcdFx0c3RhcnQ6W3Bvc1tpXS54LHBvc1tpXS55XSxcblx0XHRcdHdpZHRoOnJlY3RXLFxuXHRcdFx0aGVpZ2h0OnJlY3RILFxuXHRcdFx0ZmlsbENvbG9yOmNvbG9yW2ldLFxuXHRcdFx0ZHJhZzpmYWxzZSxcblx0XHRcdG1vdXNldXA6ZnVuY3Rpb24oKXtcblxuXHRcdFx0XHRfdGhpcy5jb250ZXh0TGluZU1lbnVOb2RlLnNldENvbG9yKHRoaXMuZmlsbENvbG9yKTtcblxuXHRcdFx0XHR2YXIganNvbiA9IF90aGlzLmdldExpbmVKc29uQnlOb2RlSWQoX3RoaXMuY29udGV4dExpbmVNZW51Tm9kZS5pZCk7XG5cdFx0XHQgIFx0anNvbi5hdHRyLmNvbG9yID0gdGhpcy5maWxsQ29sb3I7XG5cblxuXHRcdFx0ICBcdHZhciB0ZXh0T2JqID0gX3RoaXMubGluZUxheWVyLmdldEVsZUJ5SWQoX3RoaXMuY29udGV4dExpbmVNZW51Tm9kZS53aXRoVGV4dElkKTtcblx0XHRcdFx0dGV4dE9iai5zZXRDb2xvcih0aGlzLmZpbGxDb2xvcik7XG5cblx0XHRcdFx0Ly8gaWYoX3RoaXMuY29udGV4dEFpbUF0dHIgPT0gJ2NvbG9yJyl7XG5cdFx0XHRcdC8vIFx0Ly/orr7nva7oioLngrnmoIfpopjpopzoibJcblx0XHRcdFx0Ly8gXHRfdGhpcy51cGRhdGVOb2RlVGl0bGVDb2xvcih0aGlzLmZpbGxDb2xvcik7XG5cblxuXHRcdFx0XHQvLyB9ZWxzZXtcblxuXHRcdFx0XHQvLyBcdF90aGlzLmNvbnRleHRTZXR0aW5nTm9kZVtfdGhpcy5jb250ZXh0QWltQXR0cl0gPSB0aGlzLmZpbGxDb2xvcjtcblx0XHRcdFx0XHQgXG5cdFx0XHRcdC8vIH1cblxuXHRcdFx0XHQvLyBcdC8v5pu05pawanNvbuaVsOaNruebuOWFs+WxnuaAp+WAvFxuXHRcdFx0XHQvLyBcdF90aGlzLnVwZGF0ZUluaXREYXRhQXR0cih0aGlzLmZpbGxDb2xvcik7XG5cblxuXHRcdFx0fVxuXHRcdH0pKVxuXHR9XG59O1xuUWZsb3cucHJvdG90eXBlLmRlbExpbmVOb2RlID0gZnVuY3Rpb24oKSB7XG5cdHZhciBfdGhpcyA9IHRoaXM7XG5cdC8v5pu05pawanNvbuaVsOaNrlxuXHR2YXIgdG1wID0gdGhpcy5vcHRpb25zLmluaXREYXRhLmxpbmsuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdHJldHVybiBpdGVtLmxpbmVJZCAhPSBfdGhpcy5jb250ZXh0TGluZU1lbnVOb2RlLmlkO1xuXHR9KVxuXHR0aGlzLm9wdGlvbnMuaW5pdERhdGEubGluayA9IHRtcDtcblxuXG5cdC8v5aaC5p6c5pyJ6YCa6L+Hd2l0aFRleHTnlJ/miJDnmoTmloflrZflr7nosaEg5YWI5Yig6Zmk5paH5a2XXG5cdGlmKHR5cGVvZiB0aGlzLmNvbnRleHRMaW5lTWVudU5vZGUud2l0aFRleHRJZCAhPSAndW5kZWZpbmVkJyl7XG5cdFx0dmFyIHRleHRPYmogPSB0aGlzLmxpbmVMYXllci5nZXRFbGVCeUlkKHRoaXMuY29udGV4dExpbmVNZW51Tm9kZS53aXRoVGV4dElkKTtcblx0XHR0aGlzLmxpbmVMYXllci5yZW1vdmVFbGUodGV4dE9iaik7XG5cblx0XHR0aGlzLmxpbmVMYXllci5yZW1vdmVFbGVCeUlkKHRoaXMuY29udGV4dExpbmVNZW51Tm9kZS53aXRoVGV4dElkKTtcblxuXHR9XG5cblx0Ly/lpoLmnpzmmK/mipjnur8g6ZyA6KaB5oqK5YWz6IGU57q/5Lmf5LiA5bm25Yig6ZmkXG5cdGlmKHR5cGVvZiB0aGlzLmNvbnRleHRMaW5lTWVudU5vZGUucmVsYXRpb25MaW5lSWQgIT0gJ3VuZGVmaW5lZCcpe1xuXG5cdFx0dGhpcy5jb250ZXh0TGluZU1lbnVOb2RlLnJlbGF0aW9uTGluZUlkLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XG5cdFx0XHRfdGhpcy5saW5lTGF5ZXIucmVtb3ZlRWxlQnlJZChpdGVtKTtcblx0XHR9KVxuXHR9XG5cblx0XG5cdHRoaXMubGluZUxheWVyLnJlbW92ZUVsZSh0aGlzLmNvbnRleHRMaW5lTWVudU5vZGUpO1xuXG59O1xuUWZsb3cucHJvdG90eXBlLmluaXRMaW5lRGVsQnRuID0gZnVuY3Rpb24oKSB7XG5cdHZhciBfdGhpcyA9IHRoaXM7XG5cdHZhciBlbGUgPSB0aGlzLmNvbnRleHRMaW5lTWVudUxheWVyLmVsZW1lbnRzWzBdO1xuXG5cdHRoaXMuY29udGV4dExpbmVNZW51TGF5ZXIucHVzaChcblx0XHR0aGlzLnFjYW52YXMucXJlY3QucmVjdCh7XG5cdFx0XHRzdGFydDpbZWxlLnN0YXJ0WzBdK2VsZS53aWR0aC03MCxlbGUuc3RhcnRbMV0rZWxlLmhlaWdodC00MF0sXG5cdFx0XHR3aWR0aDo2MCxcblx0XHRcdGhlaWdodDozMCxcblx0XHRcdGZpbGxDb2xvcjonI2ZmZicsXG5cdFx0XHRkcmFnOmZhbHNlLCAgXG5cdFx0XHRtb3VzZXVwOmZ1bmN0aW9uKCl7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdkZWwnKTtcblx0XHRcdFx0Ly/liKDpmaTmk43kvZxcblx0XHRcdFx0X3RoaXMuZGVsTGluZU5vZGUoKTtcbiBcdFx0XHRcdFxuIFx0XHRcdFx0X3RoaXMubGluZU1lbnVMYXllckhpZGUoKTtcblx0XHRcdH1cblx0XHR9KSxcblx0XHR0aGlzLnFjYW52YXMucXRleHQudGV4dCh7XG5cdFx0XHR0ZXh0OifliKDpmaQnLFxuXHRcdFx0c3RhcnQ6W2VsZS5zdGFydFswXStlbGUud2lkdGgtNDAsZWxlLnN0YXJ0WzFdK2VsZS5oZWlnaHQtMjVdLFxuXHRcdFx0Zm9udFNpemU6JzEycHgnLFxuXHRcdFx0Y29sb3I6JyMwMDAnLFxuXHRcdFx0cG9pbnRlckV2ZW50Oidub25lJ1xuXHRcdH0pXG5cdCk7XG5cbn07XG5RZmxvdy5wcm90b3R5cGUuaW5pdExpbmVNZW51ID0gZnVuY3Rpb24ocG9zKSB7XG5cblx0dGhpcy5saW5lTWVudUxheWVySGlkZSgpO1xuXG5cdC8v5Yid5aeL5YyWY29udGV4dExpbmVNZW515Y+z6ZSu6I+c5Y2V5Yy6cmVjdFxuXHR0aGlzLmluaXRDb250ZXh0TGluZU1lbnVBcmVhKHBvcyk7XG5cblx0Ly/kv67mlLnmoIfpopjmoYYo55So5LqO5a6a5L2N5LiA5LiqaW5wdXTmoYYpXG5cdHRoaXMuaW5pdExpbmVNb2RpVGl0bGVOb2RlKCk7XG5cblx0Ly/kv67mlLnmoLflvI9zZWxlY3TmoYblrprkvY1cblx0dGhpcy5pbml0TGluZUxpa2VOb2RlKCk7XG5cblxuXHR0aGlzLmluaXRMaW5lVHlwZU5vZGUoKTtcblxuXG5cdC8vMTfpopzoibLlnZfnlLvliLDlj7Plh7voj5zljZXljLpcblx0dGhpcy5pbml0TGluZUNvbG9yUmVjdCgpO1xuXG5cdC8v5Yig6Zmk5oyJ6ZKuXG5cdHRoaXMuaW5pdExpbmVEZWxCdG4oKTtcbiBcblxuXG5cblx0Ly8gdGhpcy5jb250ZXh0TGluZU1lbnVMYXllci5zZXREaXNwbGF5KCdibG9jaycpO1xuXG59O1xuUWZsb3cucHJvdG90eXBlLmRvd25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvYmogPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLm9wdGlvbnMuaWQpOyBcblxuXHR2YXIgdG1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdHZhciBjb250ZXh0ID0gdG1wLmdldENvbnRleHQoJzJkJyk7XG5cdHRtcC53aWR0aCA9IHRoaXMub3B0aW9ucy53aWR0aDtcblx0dG1wLmhlaWdodCA9IHRoaXMub3B0aW9ucy5oZWlnaHQ7IFxuXHRjb250ZXh0LmZpbGxTdHlsZT1cIiNmZmZcIlxuXHRjb250ZXh0LmZpbGxSZWN0KDAsIDAscGFyc2VJbnQob2JqLnN0eWxlLndpZHRoKSxwYXJzZUludChvYmouc3R5bGUuaGVpZ2h0KSk7XG5cdGNvbnRleHQuZHJhd0ltYWdlKG9iaiwwLC00MCxwYXJzZUludChvYmouc3R5bGUud2lkdGgpLHBhcnNlSW50KG9iai5zdHlsZS5oZWlnaHQpKTtcblxuXG5cdHZhciBvQSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgIG9BLmRvd25sb2FkID0gJyc7Ly8g6K6+572u5LiL6L2955qE5paH5Lu25ZCN77yM6buY6K6k5pivJ+S4i+i9vSdcbiAgICBvQS5ocmVmID0gdG1wLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiLDEuMCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvQSk7XG4gICAgb0EuY2xpY2soKTtcbiAgICBvQS5yZW1vdmUoKTsgLy8g5LiL6L295LmL5ZCO5oqK5Yib5bu655qE5YWD57Sg5Yig6ZmkXG5cdFxufTtcblFmbG93LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cblx0dGhpcy5xY2FudmFzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XG5cdFx0aWYoaXRlbS5UWVBFID09ICdsYXllcicpe1xuXHRcdFx0aXRlbS5kZXN0cm95KCk7XG5cdFx0fVxuXHR9KVxuXG5cdHRoaXMucWNhbnZhcy5kZXN0cm95KCk7XG5cdFxufTtcblFmbG93LnByb3RvdHlwZS5saW5lTWVudUxheWVyU2hvdyA9IGZ1bmN0aW9uKHBvcykgeyBcblxuXG5cdHRoaXMuY29udGV4dExpbmVNZW51TGF5ZXIuc2V0RGlzcGxheSgnYmxvY2snKTsgXG59O1xuUWZsb3cucHJvdG90eXBlLmxpbmVNZW51TGF5ZXJIaWRlID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuY29udGV4dExpbmVNZW51TGF5ZXIuc2V0RGlzcGxheSgnbm9uZScpO1xuXHR0aGlzLmNvbnRleHRMaW5lTWVudUxheWVyLmRlc3Ryb3koKTtcblx0Ly8gdGhpcy5tb2RpVGl0bGVPYmogPSBudWxsO1xuXG5cdHZhciBkMSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsaW5lVGl0bGVJbnB1dCcpOyBcblx0dmFyIGQyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xpbmVMaWtlJyk7XG5cdHZhciBkMyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsaW5lVHlwZScpOyBcblxuXG5cdFxuXHRkMS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRkMi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRkMy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG5cblxuXG59O1xuUWZsb3cucHJvdG90eXBlLnVwZGF0ZVRtcExpbmVFbmRQb3MgPSBmdW5jdGlvbihwb3MpIHtcblxuXHRpZih0aGlzLnRtcExpbmUgIT09IG51bGwpe1xuXHRcdHRoaXMudG1wTGluZS5zZXRFbmQoW3Bvcy54LHBvcy55XSk7XG5cdH1cblx0XG59O1xuUWZsb3cucHJvdG90eXBlLmRlbFRtcExpbmUgPSBmdW5jdGlvbigpIHtcblx0aWYodGhpcy50bXBMaW5lICE9PSBudWxsKXtcblx0XHQvLyBjb25zb2xlLmxvZyh0aGlzLnRtcExpbmUpO1xuXHRcdCBcblx0XHQgXG5cdFx0IC8v5ZCM5pe25Yig6Zmk57q/5LiK5omA5bim55qE5paH5a2XXG5cdFx0IHZhciB0ZXh0ID0gdGhpcy5xY2FudmFzLmdldEVsZUJ5SWQodGhpcy50bXBMaW5lLndpdGhUZXh0SWQpO1xuXHRcdCB0aGlzLnFjYW52YXMucmVtb3ZlRWxlKHRoaXMudG1wTGluZSk7XG5cdFx0IHRoaXMucWNhbnZhcy5yZW1vdmVFbGUodGV4dCk7XG5cblx0XHQgdGhpcy50bXBMaW5lID1udWxsO1xuXHR9XG59O1xuLyoqXG4gKiBbY3JlYXRlTmV3TGluZSBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge1t0eXBlXX0gbm9kZSAgICBb55uu5qCH5a+56LGhXVxuICogQHBhcmFtICB7W3R5cGVdfSBqc29uT2JqIFvnm67moIflr7nosaFqc29uXVxuICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuUWZsb3cucHJvdG90eXBlLmNyZWF0ZU5ld0xpbmUgPSBmdW5jdGlvbihub2RlLGpzb25PYmopIHtcblx0dmFyIF90aGlzID0gdGhpcztcblx0Ly/lvIDlp4vliJvlu7rmlrDnmoTov57nur9cblx0aWYodGhpcy5jb250ZXh0TWVudU5vZGUhPT0gbnVsbCl7ICBcblxuXHRcdHZhciBmcm9tSlNPTiA9IHRoaXMuZ2V0SnNvbk9iaih0aGlzLmNvbnRleHRNZW51Tm9kZS5pZCk7IFxuIFxuXHRcdGlmKGZyb21KU09OLmlkID09IGpzb25PYmouaWQpeyAvL+aMh+WQkeiHquW3sueahOi/nue6vyDlkI7mnJ/lho3lrp7njrBcblx0XHRcdHRoaXMuY29udGV4dE1lbnVOb2RlID0gbnVsbDtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMub3B0aW9ucy5pbml0RGF0YS5saW5rLnB1c2goe1xuXHRcdFx0ZnJvbUlkOmZyb21KU09OLmlkLFxuXHRcdFx0dG9JZDpqc29uT2JqLmlkLFxuXHRcdFx0YXR0cjp7XG5cdFx0XHRcdGxpa2U6Jy0+Jyxcblx0XHRcdFx0Y29sb3I6dGhpcy5saW5lQ29sb3IsXG5cdFx0XHRcdHRleHQ6J+i/nue6v+WFs+ezuydcblx0XHRcdH1cblx0XHR9KVxuXHRcdHRoaXMuc29sdmVMaW5rKCk7XG5cblxuXHRcdHZhciBqc29uID0gdGhpcy5vcHRpb25zLmluaXREYXRhLmxpbmtbdGhpcy5vcHRpb25zLmluaXREYXRhLmxpbmsubGVuZ3RoIC0xXTtcblx0XHR2YXIgdG1wID0gdGhpcy5xY2FudmFzLnFsaW5lLmxpbmUoe1xuXHRcdFx0c3RhcnQ6ZnVuY3Rpb24oKXtyZXR1cm4gX3RoaXMuY2FsY0xpbmVTdGFydFBvcyhqc29uLmZyb21Ob2RlLGpzb24udG9Ob2RlLHRoaXMuaWQpfSxcblx0XHRcdGVuZDpmdW5jdGlvbigpe3JldHVybiBfdGhpcy5jYWxjTGluZUVuZFBvcyhqc29uLmZyb21Ob2RlLGpzb24udG9Ob2RlLHRoaXMuaWQpfSwgXG5cdFx0XHR3aWR0aDoxLFxuXHRcdFx0Ly8gcG9pbnRlckV2ZW50Oidub25lJyxcblx0XHRcdGRyYWc6ZmFsc2UsXG5cdFx0XHRsaWtlOmpzb24uYXR0ci5saWtlLFxuXHRcdFx0Y29sb3I6anNvbi5hdHRyLmNvbG9yLFxuXHRcdFx0d2l0aFRleHQ6J+i/nuaOpeWFs+ezuycsXG5cdFx0XHRtb3VzZXVwOmZ1bmN0aW9uKGUscG9zKSB7XG5cdFx0XHRcdC8v5Y+z5Ye75pi+56S66I+c5Y2VXG5cdFx0XHRcdGlmKGUuYnV0dG9uID09ICcyJyl7IFxuXG5cdFx0XHRcdFx0X3RoaXMuY29udGV4dExpbmVNZW51Tm9kZSA9IHRoaXM7XG5cblx0XHRcdFx0XHRfdGhpcy5xY2FudmFzLnJhaXNlVG9Ub3AoX3RoaXMuY29udGV4dExpbmVNZW51TGF5ZXIpO1xuXHRcdFx0XHRcdF90aGlzLmluaXRMaW5lTWVudShwb3MpO1xuXHRcdFx0XHRcdF90aGlzLmxpbmVNZW51TGF5ZXJTaG93KCk7XG5cblxuXG5cdFx0XHRcdFx0X3RoaXMuY29udGV4dFNldHRpbmdIaWRlKCk7XG5cblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSlcblx0XHR0aGlzLmxpbmVMYXllci5wdXNoKHRtcCk7XG5cblx0XHRqc29uLmxpbmVJZCA9IHRtcC5pZDtcblxuXG5cdFx0dGhpcy5jb250ZXh0TWVudU5vZGUgPSBudWxsO1xuXHR9XG59O1xuUWZsb3cucHJvdG90eXBlLmNyZWF0ZVRtcExpbmUgPSBmdW5jdGlvbihwb3MpIHtcblxuXHQvL3N0YXJ0OnRoaXMuY29udGV4dE1lbnVOb2Rl55qE5Lit5b+D54K5XG5cdC8vZW5kOltwb3MueCxwb3MueV1cblx0dmFyIGNlbnRlclBvcyA9IHRoaXMuY29udGV4dE1lbnVOb2RlLmNlbnRlclBvaW50cygpO1xuXHR0aGlzLnRtcExpbmUgPSB0aGlzLnFjYW52YXMucWxpbmUubGluZSh7XG5cdCAgICBzdGFydDpbY2VudGVyUG9zLngsY2VudGVyUG9zLnldLFxuXHQgICAgZW5kOltwb3MueCxwb3MueV0sXG5cdCAgICB3aWR0aDoxLFxuXHQgICAgbGlrZTonLT4nLFxuXHQgICAgY29sb3I6dGhpcy5saW5lQ29sb3IsXG5cdCAgICB3aXRoVGV4dDon6L+e5o6l5YWz57O7Jyxcblx0ICAgIHdpdGhUZXh0QWxpZ246J2xlZnQnLFxuXHQgICAgcG9pbnRlckV2ZW50Oidub25lJ1xuXHR9KTtcblxufTtcblFmbG93LnByb3RvdHlwZS5nZXRMaW5lT2JqID0gZnVuY3Rpb24obm9kZUlkKSB7XG5cdHZhciB0bXAgPSB0aGlzLmxpbmVMYXllci5lbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24oaXRlbSl7XG4gXHRcdHJldHVybiBpdGVtLmlkID09IG5vZGVJZDtcbiBcdH0pXG5cbiBcdGlmKHRtcC5sZW5ndGg+MCl7XG4gXHRcdHJldHVybiB0bXBbMF07XG4gXHR9ZWxzZXtcbiBcdFx0cmV0dXJuIG51bGw7XG4gXHR9XG59O1xuXG5RZmxvdy5wcm90b3R5cGUuZ2V0TGluZUpzb25CeU5vZGVJZCA9IGZ1bmN0aW9uKG5vZGVJZCkge1xuXHR2YXIgdG1wID0gdGhpcy5vcHRpb25zLmluaXREYXRhLmxpbmsuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdHJldHVybiBpdGVtLmxpbmVJZCA9PSBub2RlSWQ7XG5cdH0pXG5cblx0aWYodG1wLmxlbmd0aD4wKXtcbiBcdFx0cmV0dXJuIHRtcFswXTtcbiBcdH1lbHNle1xuIFx0XHRyZXR1cm4gbnVsbDtcbiBcdH1cbn07XG5RZmxvdy5wcm90b3R5cGUuZ2V0RGVsTGluZU9iaiA9IGZ1bmN0aW9uKG5vZGVPYmopIHtcblx0dmFyIF90aGlzID0gdGhpcztcblx0Ly/lnKh0aGlzLm9wdGlvbnMuaW5pdERhdGEubGlua+S4reaJvuWIsOS4jm5vZGVPYmroioLngrnmnInlhbPns7vnmoTnur9cblx0dmFyIGxpbmVPYmogPSBbXTtcblxuXHRub2RlT2JqLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XG5cblx0XHRfdGhpcy5vcHRpb25zLmluaXREYXRhLmxpbmsuZm9yRWFjaChmdW5jdGlvbihsKXtcblxuXHRcdFx0aWYobC5mcm9tTm9kZS5pZCA9PSBpdGVtLmlkIHx8IFxuXHRcdFx0XHRsLnRvTm9kZS5pZCA9PSBpdGVtLmlkIFxuXHRcdFx0XHQpe1xuXG5cdFx0XHRcdGxpbmVPYmoucHVzaChfdGhpcy5nZXRMaW5lT2JqKGwubGluZUlkKSk7XG5cblx0XHRcdFx0Ly8gLy/lpoLmnpzmmK/mipjnur8g6ZyA6KaB5oqK5YWz6IGU55qE57q/5Lmf5LiA5bm26L+U5ZueXG5cdFx0XHRcdC8vIGlmKHR5cGVvZiBsLnJlbGF0aW9uTGluZUlkICE9ICd1bmRlZmluZWQnKXtcblx0XHRcdFx0Ly8gXHRsLnJlbGF0aW9uTGluZUlkLmZvckVhY2goZnVuY3Rpb24ocil7XG5cdFx0XHRcdC8vIFx0XHRjb25zb2xlLmxvZyhyKTtcblx0XHRcdFx0Ly8gXHRcdGxpbmVPYmoucHVzaChfdGhpcy5saW5lTGF5ZXIuZ2V0RWxlQnlJZChyKSk7XG5cdFx0XHRcdC8vIFx0fSlcblx0XHRcdFx0Ly8gfVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0fSlcblxuXHRyZXR1cm4gbGluZU9iajtcblxufTtcblFmbG93LnByb3RvdHlwZS5nZXREZWxUZXh0T2JqID0gZnVuY3Rpb24obm9kZU9iaikge1xuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXHQvL+WcqHRoaXMucWNhbnZhcy5lbGVtZW50c+mHjOaJvuWIsOS4jm5vZGVPYmroioLngrnmnInlhbPogZTnmoTmoIfpopjoioLngrlcblx0dmFyIHRleHRPYmogPSBbXTtcblxuXHR2YXIgYWxsVGV4dE9iaiA9IHRoaXMucWNhbnZhcy5lbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24oaXRlbSl7XG5cdFx0cmV0dXJuIGl0ZW0uVFlQRSA9PSAndGV4dCdcblx0fSlcblxuXHRub2RlT2JqLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XG5cblx0XHRhbGxUZXh0T2JqLmZvckVhY2goZnVuY3Rpb24odCl7XG5cblx0XHRcdGlmKHR5cGVvZiB0Lm93bmVySWQgIT09ICd1bmRlZmluZWQnICYmIHQub3duZXJJZCA9PSBpdGVtLmlkKXtcblx0XHRcdFx0dGV4dE9iai5wdXNoKHQpO1xuXHRcdFx0fVxuXG5cdFx0fSlcblxuXHR9KVxuXG5cdHJldHVybiB0ZXh0T2JqO1xufTtcblFmbG93LnByb3RvdHlwZS5nZXRXaXRoVGV4dE9iaiA9IGZ1bmN0aW9uKG5vZGVPYmopIHtcblx0dmFyIF90aGlzID0gdGhpcztcblx0dmFyIHRleHRPYmogPSBbXTtcblx0bm9kZU9iai5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuXG5cdFx0X3RoaXMubGluZUxheWVyLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24odCl7XG5cblx0XHRcdGlmKHR5cGVvZiBpdGVtLndpdGhUZXh0SWQgIT09ICd1bmRlZmluZWQnICYmIHQuaWQgPT0gaXRlbS53aXRoVGV4dElkKXtcblx0XHRcdFx0dGV4dE9iai5wdXNoKHQpO1xuXHRcdFx0fVxuXHRcdH0pXG5cblx0fSlcblxuXHRyZXR1cm4gdGV4dE9iajtcblx0XG59O1xuUWZsb3cucHJvdG90eXBlLnVwZGF0ZU5vZGVKc29uQWZ0ZXJEZWxOb2RlID0gZnVuY3Rpb24obm9kZU9iaikge1xuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cblx0bm9kZU9iai5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdHZhciBub2RlID0gX3RoaXMuZ2V0SnNvbk9iaihpdGVtLmlkKTtcblx0XHRub2RlLmlzRGVsID0gdHJ1ZTtcblx0fSlcbiBcdFxuIFx0dmFyIHRtcCA9W107XG5cdC8v5pCc57Si54i2IOWtkOmhuVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3B0aW9ucy5pbml0RGF0YS5ub2RlLmxlbmd0aDsgaSsrKSB7XG5cblx0XHRpZih0eXBlb2YgdGhpcy5vcHRpb25zLmluaXREYXRhLm5vZGVbaV0uaXNEZWwgIT0ndW5kZWZpbmVkJyAmJiAgXG5cdFx0XHR0aGlzLm9wdGlvbnMuaW5pdERhdGEubm9kZVtpXS5pc0RlbCl7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9ZWxzZXtcblx0XHRcdHRtcC5wdXNoKHRoaXMub3B0aW9ucy5pbml0RGF0YS5ub2RlW2ldKTtcblxuXHRcdFx0aWYodHlwZW9mIHRtcFt0bXAubGVuZ3RoLTFdLmNoaWxkICE9J3VuZGVmaW5lZCcpe1xuXHRcdFx0XHR0bXBbdG1wLmxlbmd0aC0xXS5jaGlsZCA9IHRtcFt0bXAubGVuZ3RoLTFdLmNoaWxkLmZpbHRlcihmdW5jdGlvbihpdGVtKXtcblxuXHRcdFx0XHRcdHJldHVybiAgdHlwZW9mIGl0ZW0uaXNEZWwgPT0gJ3VuZGVmaW5lZCcgfHwgIWl0ZW0uaXNEZWw7XG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHR9XG5cblxuXHR0aGlzLm9wdGlvbnMuaW5pdERhdGEubm9kZSA9IHRtcDtcbn07XG5RZmxvdy5wcm90b3R5cGUudXBkYXRlbGlua0pzb25BZnRlckRlbE5vZGUgPSBmdW5jdGlvbihub2RlT2JqKSB7XG5cdHZhciBfdGhpcyA9IHRoaXM7XG5cdG5vZGVPYmouZm9yRWFjaChmdW5jdGlvbihsKXtcblxuXHRcdF90aGlzLm9wdGlvbnMuaW5pdERhdGEubGluay5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdFx0aWYoaXRlbS5saW5lSWQgPT0gbC5pZCl7XG5cdFx0XHRcdGl0ZW0uaXNEZWwgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0pXG5cdH0pXG5cblx0dGhpcy5vcHRpb25zLmluaXREYXRhLmxpbmsgPSB0aGlzLm9wdGlvbnMuaW5pdERhdGEubGluay5maWx0ZXIoZnVuY3Rpb24oaXRlbSl7XG5cdFx0cmV0dXJuIHR5cGVvZiBpdGVtLmlzRGVsID09ICd1bmRlZmluZWQnIHx8ICFpdGVtLmlzRGVsO1xuXHR9KVxuXHRcbn07XG5RZmxvdy5wcm90b3R5cGUuZGVsTm9kZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXHQvL+mAmui/h3RoaXMuY29udGV4dE1lbnVOb2Rl5om+5Ye66ZyA6KaB5Yig6Zmk55qE5YWD57Sg77yI5LiO5a6D6IGU57O755qE5omA5pyJ5YWD57Sg77yJXG5cdC8v5aaC5p6c5pivY29udGFpbmVyIOagh+mimOWPiuWug+eahOWtkOmhueS5n+S4gOW5tuWIoOmZpO+8iOWcqOS4u+eUu+W4g+S4iu+8iVxuXHQvL+WmguaenOaciei/nue6v+WFs+ezuyjmjIflkJHlroPnmoTmiJbmmK/lroPmjIflkJHliKvnmoToioLngrnnmoQpIOmcgOimgeaKiue6v+S5n+S4gOW5tuWIoOmZpO+8iOWcqGxpbmVMYXllcuS4iu+8iVxuXHR2YXIgbm9kZUlkID0gdGhpcy5jb250ZXh0TWVudU5vZGUuaWQ7XG5cdHRoaXMuY29udGV4dE1lbnVOb2RlID0gbnVsbDtcblx0dmFyIG5vZGVKc29uID0gdGhpcy5nZXRKc29uT2JqKG5vZGVJZCk7XG5cblxuXHR2YXIgZGVsTm9kZU9iaiA9IFtdO1xuXHRpZihub2RlSnNvbi5ub2RlVHlwZSA9PSAnY29udGFpbmVyJyl7XG5cdFx0ZGVsTm9kZU9iaiA9IGRlbE5vZGVPYmouY29uY2F0KG5vZGVKc29uLmNoaWxkTm9kZXMpO1xuXHRcdGRlbE5vZGVPYmoucHVzaCh0aGlzLmdldE5vZGVPYmoobm9kZUpzb24ubm9kZUlkKSk7XG5cdH1lbHNle1xuXG5cdFx0ZGVsTm9kZU9iai5wdXNoKHRoaXMuZ2V0Tm9kZU9iaihub2RlSnNvbi5ub2RlSWQpKTtcblxuXHR9XG5cdC8vIGNvbnNvbGUubG9nKCfpnIDopoHliKDpmaTnmoRub2RlJyk7XG5cdC8vIGNvbnNvbGUubG9nKGRlbE5vZGVPYmopO1xuXG5cdHZhciBkZWxMaW5lT2JqID0gdGhpcy5nZXREZWxMaW5lT2JqKGRlbE5vZGVPYmopOyAvL+i/nue6v+WvueixoSjlnKh0aGlzLmxpbmVMYXllcuS4iilcblx0Ly8gdmFyIGRlbFdpdGhUZXh0T2JqID0gdGhpcy5nZXRXaXRoVGV4dE9iaihkZWxMaW5lT2JqKTsgLy/ov57nur/kuIrnmoTmloflrZflr7nosaHvvIjlnKh0aGlzLmxpbmVMYXllcuS4iu+8iVxuXHQvLyB2YXIgZGVsVGV4dE9iaiA9IHRoaXMuZ2V0RGVsVGV4dE9iaihkZWxOb2RlT2JqKTsgLy/oioLngrnkuIrnmoTmloflrZflr7nosaFcblxuXG5cdC8vIGNvbnNvbGUubG9nKCfpnIDopoHliKDpmaTnmoRsaW5lJyk7XG5cdC8vIGNvbnNvbGUubG9nKGRlbExpbmVPYmopO1xuXG5cdC8vIGNvbnNvbGUubG9nKCfpnIDopoHliKDpmaTnmoR0ZXh0Jyk7XG5cdC8vIGNvbnNvbGUubG9nKGRlbFRleHRPYmopO1xuXG5cdC8vIGNvbnNvbGUubG9nKCfpnIDopoHliKDpmaTnmoRsaW5l5LiKd2l0aFRleHQnKTtcblx0Ly8gY29uc29sZS5sb2coZGVsV2l0aFRleHRPYmopO1xuXG5cblxuXHQvL+WQjOatpWpzb27lr7nosaFcblx0dGhpcy51cGRhdGVOb2RlSnNvbkFmdGVyRGVsTm9kZShkZWxOb2RlT2JqKTtcblx0dGhpcy51cGRhdGVsaW5rSnNvbkFmdGVyRGVsTm9kZShkZWxMaW5lT2JqKTtcblxuXG5cdC8v5Yig6Zmk5a+56LGhIO+8iOmhuuW6j++8mui/nue6v+S4iueahOaWh+Wtly0+6L+e57q/LT5ub2Rl5LiK55qE5qCH6aKY5paH5a2XLT5ub2Rl77yJXG5cdC8vIGRlbFdpdGhUZXh0T2JqLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XG5cdC8vIFx0X3RoaXMubGluZUxheWVyLnJlbW92ZUVsZUJ5SWQoaXRlbS5pZCk7XG5cdC8vIH0pXG5cblx0ZGVsTGluZU9iai5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuXG5cdFx0Ly/lhYjliKDnur/kuIrnmoTmloflrZdcblx0XHRpZih0eXBlb2YgaXRlbS53aXRoVGV4dElkICE9ICd1bmRlZmluZWQnKXtcblx0XHRcdF90aGlzLmxpbmVMYXllci5yZW1vdmVFbGVCeUlkKGl0ZW0ud2l0aFRleHRJZCk7XG5cdFx0fVxuXG5cdFx0Ly/lhYjliKDpmaTlhbPogZTnmoTnur9cblx0XHRpZih0eXBlb2YgaXRlbS5yZWxhdGlvbkxpbmVJZCAhPSAndW5kZWZpbmVkJyl7XG5cdFx0XHRpdGVtLnJlbGF0aW9uTGluZUlkLmZvckVhY2goZnVuY3Rpb24ocil7XG5cdFx0XHRcdF90aGlzLmxpbmVMYXllci5yZW1vdmVFbGVCeUlkKHIpO1xuXHRcdFx0fSlcblx0XHR9XG5cblx0XHRfdGhpcy5saW5lTGF5ZXIucmVtb3ZlRWxlQnlJZChpdGVtLmlkKTtcblx0fSlcblx0Ly8gZGVsVGV4dE9iai5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuXHQvLyBcdF90aGlzLnFjYW52YXMucmVtb3ZlRWxlQnlJZChpdGVtLmlkKTtcblx0Ly8gfSlcblxuXHQvLyBjb25zb2xlLmxvZyhkZWxOb2RlT2JqKSAgXG5cdGRlbE5vZGVPYmouZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcblx0XHRpZih0eXBlb2YgaXRlbS5vd25lcklkICE9J3VuZGVmaW5lZCcpeyBcblx0XHQvL+WIoOmZpOeahOaYr+WuueWZqOmHjOeahOiKgueCuSBcblx0XHQvL+mcgOimgeabtOaWsGpzb27lr7nosaHkuK3nmoRjaGlsZE5vZGVz5pWw57uEXG5cdFx0Ly/mm7TmlrDlrrnlmajnmoTpq5jluqZcblx0XHRcdHZhciBqc29uT2JqID0gX3RoaXMuZ2V0SnNvbk9iaihpdGVtLm93bmVySWQpO1xuXG5cdFx0XHRpZihqc29uT2JqICE9PSBudWxsKXtcblxuXHRcdFx0XHRqc29uT2JqLmNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbihjKXtcblx0XHRcdFx0XHRpZihjLmlkID09IGl0ZW0uaWQgKXtcblx0XHRcdFx0XHRcdGMuaXNEZWwgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0anNvbk9iai5jaGlsZE5vZGVzID0ganNvbk9iai5jaGlsZE5vZGVzLmZpbHRlcihmdW5jdGlvbihpdGVtKXtcblx0XHRcdFx0XHRyZXR1cm4gdHlwZW9mIGl0ZW0uaXNEZWwgPT0gJ3VuZGVmaW5lZCcgfHwgIWl0ZW0uaXNEZWw7XG5cdFx0XHRcdH0pXG5cblx0XHRcdFx0anNvbk9iai5jaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSxpbmRleCl7XG5cdFx0XHRcdFx0aXRlbS5zb3J0ID0gaW5kZXg7XG5cdFx0XHRcdH0pXG5cblx0XHRcdFx0Ly/mm7TmlrDpq5jluqZcblx0XHRcdFx0aWYoanNvbk9iai5hdHRyLnRpdGxlUG9zaXRpb24gPT0gJ3RvcC1jZW50ZXInKXtcblx0XHRcdFx0XHR2YXIgc3RhcnRQbGFjZUhvbGRlclkgPSAoX3RoaXMuY29udGFpbmVyVGl0bGVIZWlnaHQrX3RoaXMuY29udGFpbmVyUGFkZGluZyk7XG5cdFx0XHRcdFx0dmFyIHJvdyA9IE1hdGguY2VpbCgoanNvbk9iai5jaGlsZC5sZW5ndGggPT0gMD8xOmpzb25PYmouY2hpbGQubGVuZ3RoKS9qc29uT2JqLmdyaWRbMV0pO1xuXHRcdFx0XHRcdGpzb25PYmouaGVpZ2h0ID0gc3RhcnRQbGFjZUhvbGRlclkgKyBfdGhpcy5jaGlsZE5vZGVIZWlnaHQqcm93Kyhyb3cpKl90aGlzLmNvbnRhaW5lckNoaWxkTWFyZ2luO1xuXHRcdFx0XHRcdGpzb25PYmouZ3JpZFswXSA9IHJvdztcblx0XHRcdFx0XHR2YXIgY29udGFpbmVyT2JqID0gX3RoaXMuZ2V0Tm9kZU9iaihpdGVtLm93bmVySWQpO1xuXHRcdFx0XHRcdGNvbnRhaW5lck9iai5zZXRIZWlnaHQoanNvbk9iai5oZWlnaHQpOyBcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8v5pu05pawZ3JpZFBvc3Rpb24tLS0tLS0tLVxuXHRcdFx0XHRcdC8v5Y+v5Lul5pGG5pS+5a2Q6aG555qE5Yy65Z+f5L2N572uW+W3puS4iuinkuW8gOWni+S9jee9ru+8jOWPs+S4i+inkue7k+adn+S9jee9rl1cblx0XHRcdFx0XHR2YXIgY2hpbGRBcmVhUG9zaXRpb24gPSBfdGhpcy5nZXRDaGlsZEFyZWFQb3NpdGlvbihqc29uT2JqKTtcblxuXHRcdFx0XHRcdC8v5Y+v5Lul5pGG5pS+5a2Q6aG555qE5Yy65Z+f5L2N572uIOiuoeeul+WHuuWQhOS4quagvOWtkOeahOWdkOagh1xuXHRcdFx0XHRcdHZhciBjaGlsZFBvc2l0aW9uID0gX3RoaXMuZ2V0Q2hpbGRQb3NpdGlvbihqc29uT2JqLGNoaWxkQXJlYVBvc2l0aW9uKTtcblxuXHRcdFx0XHRcdC8v5oqK5qC85a2Q5Z2Q5qCH5re75Yqg5YiwYXR0cumHjFxuXHRcdFx0XHRcdGpzb25PYmouYXR0ci5ncmlkUG9zaXRpb24gPSBjaGlsZFBvc2l0aW9uO1xuXG5cdFx0XHRcdC8vLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL+WFiOWIoOmZpG5vZGXkuIrnmoTmloflrZdcblx0XHRpZih0eXBlb2YgaXRlbS5vd25lcklkICE9PSAndW5kZWZpbmVkJyl7XG5cdFx0XHRfdGhpcy5saW5lTGF5ZXIucmVtb3ZlRWxlQnlJZChpdGVtLm93bmVySWQpO1xuXHRcdH1cblxuXG5cdFx0X3RoaXMucWNhbnZhcy5yZW1vdmVFbGUoaXRlbSk7XG5cdH0pXG5cblxuXHRfdGhpcy5jb250ZXh0TWVudU5vZGUgPSBudWxsO1xuXG5cdFxufTtcblFmbG93LnByb3RvdHlwZS5jbG9uZU5vZGUgPSBmdW5jdGlvbigpIHtcblx0dmFyIF90aGlzID0gdGhpcztcblx0dmFyIG5vZGVPYmogPSB0aGlzLmNvbnRleHRNZW51Tm9kZTtcblx0dmFyIG5vZGVKc29uT2JqID0gdGhpcy5nZXRKc29uT2JqKG5vZGVPYmouaWQpO1xuXHQvLyBjb25zb2xlLmxvZyhub2RlT2JqKTtcblx0Ly8gY29uc29sZS5sb2cobm9kZUpzb25PYmopO1xuXG5cdGlmKG5vZGVKc29uT2JqLm5vZGVUeXBlID09J25vZGUnKXtcblxuXHRcdGlmKHR5cGVvZiBub2RlT2JqLm93bmVySWQgPT0ndW5kZWZpbmVkJyl7Ly/lpI3liLboioLngrlcblxuXHRcdFx0dGhpcy5hZGROb2RlKHt4Om5vZGVKc29uT2JqLngrMjAseTpub2RlSnNvbk9iai55KzIwfSxub2RlSnNvbk9iai50ZXh0KTtcblxuXHRcdH1lbHNleyAvL+WkjeWItuWuueWZqOmHjOeahOiKgueCuVxuXG5cdFx0XHR0aGlzLmluU2VydFRvQ29udGFpbmVyKHt9LHtpZDpub2RlT2JqLm93bmVySWR9LG5vZGVKc29uT2JqLnRleHQpO1xuXG5cdFx0fVxuXG5cblx0fVxuXG5cblx0aWYobm9kZUpzb25PYmoubm9kZVR5cGUgPT0gJ2NvbnRhaW5lcicpe1xuXHRcdHZhciBpZCA9IHRoaXMuYWRkQ29udGFpbmVyKFxuXHRcdFx0XHR7eDpub2RlSnNvbk9iai54KzIwLHk6bm9kZUpzb25PYmoueSsyMH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0ZXh0Om5vZGVKc29uT2JqLnRleHQsXG5cdFx0XHRcdFx0Z3JpZDpub2RlSnNvbk9iai5ncmlkLFxuXHRcdFx0XHRcdHdpZHRoOm5vZGVKc29uT2JqLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDpub2RlSnNvbk9iai5oZWlnaHRcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHQvLyBjb25zb2xlLmxvZyhpZCk7XG5cblx0XHRub2RlSnNvbk9iai5jaGlsZC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdFx0X3RoaXMuaW5TZXJ0VG9Db250YWluZXIoe30se2lkOmlkfSxpdGVtLnRleHQpO1xuXHRcdFx0Ly8gaW5TZXJ0VG9Db250YWluZXIgPSBmdW5jdGlvbihvYmosYWltLHRleHQpXG5cdFx0fSlcblx0fVxuXG5cblx0aWYobm9kZUpzb25PYmoubm9kZVR5cGUgPT0gJ3RpcCcpe1xuXHRcdGNvbnNvbGUubG9nKCdjbG9uZSB0aXAnKTtcblx0XHR0aGlzLmNsb25lVGlwTm9kZSgpO1xuXHR9XG5cblxuXG5cblx0dGhpcy5jb250ZXh0TWVudU5vZGUgPSBudWxsO1xufTtcblFmbG93LnByb3RvdHlwZS5pbml0TWVudSA9IGZ1bmN0aW9uKCkgeyBcblx0dmFyIF90aGlzID0gdGhpcztcblx0dmFyIGFyZWEgPSB0aGlzLnFjYW52YXMucXJlY3QucmVjdCh7XG5cdFx0XHQgc3RhcnQ6WzAsMF0sICBcblx0XHRcdCB3aWR0aDoxMDAsXG5cdFx0XHQgaGVpZ2h0Ojc1LFxuXHRcdFx0IGJvcmRlckNvbG9yOicnLCBcblx0XHRcdCBmaWxsQ29sb3I6JyNmZmYnLCAgXG5cdFx0XHQgZHJhZzpmYWxzZSwgXG5cdFx0XHR9KVxuICAgIHZhciBsaW5rUmVjdCA9IHRoaXMucWNhbnZhcy5xcmVjdC5yZWN0KHtcblx0XHRcdCBzdGFydDpmdW5jdGlvbigpe1xuXG5cdFx0XHQgXHRyZXR1cm4gYXJlYS5zdGFydFxuXHRcdFx0IH0sXG5cdFx0XHQgd2lkdGg6MTAwLFxuXHRcdFx0IGhlaWdodDoyNSxcblx0XHRcdCBib3JkZXJDb2xvcjonJywgXG5cdFx0XHQgZmlsbENvbG9yOicjZmZmJywgICBcblx0XHRcdCBkcmFnOmZhbHNlLCBcblx0XHRcdCBtb3VzZXVwOmZ1bmN0aW9uKGUscG9zKXsgXG5cdFx0XHQgXHRfdGhpcy5tZW51TGF5ZXJIaWRlKCk7XG5cdFx0XHQgXHRfdGhpcy5jcmVhdGVUbXBMaW5lKHBvcyk7XG5cdFx0XHQgfVxuXHRcdFx0fSlcbiAgICB2YXIgbGlua1R4dCA9IHRoaXMucWNhbnZhcy5xdGV4dC50ZXh0KHtcblx0XHRcdHRleHQ6J+i/nuaOpeWIsCcsXG5cdFx0XHRzdGFydDpmdW5jdGlvbigpe1xuXHRcdFx0XHRyZXR1cm4gW190aGlzLmNvbnRleHRNZW51TGF5ZXIuZWxlbWVudHNbMF0uc3RhcnRbMF0rX3RoaXMuY29udGV4dE1lbnVMYXllci5lbGVtZW50c1swXS53aWR0aCowLjUsX3RoaXMuY29udGV4dE1lbnVMYXllci5lbGVtZW50c1swXS5zdGFydFsxXSsyNSowLjVdO1xuXHRcdFx0fSxcblx0XHRcdGZvbnRTaXplOicxMnB4Jyxcblx0XHRcdGNvbG9yOicjMDAwJyxcblx0XHRcdHBvaW50ZXJFdmVudDonbm9uZSdcblx0XHR9KVxuICAgIHZhciBjbG9uZVJlY3QgPSB0aGlzLnFjYW52YXMucXJlY3QucmVjdCh7XG5cdFx0XHQgc3RhcnQ6ZnVuY3Rpb24oKXtcblxuXHRcdFx0IFx0cmV0dXJuIFthcmVhLnN0YXJ0WzBdLGFyZWEuc3RhcnRbMV0rMjVdO1xuXHRcdFx0IH0sXG5cdFx0XHQgd2lkdGg6MTAwLFxuXHRcdFx0IGhlaWdodDoyNSxcblx0XHRcdCBib3JkZXJDb2xvcjonJywgXG5cdFx0XHQgZmlsbENvbG9yOicjZmZmJywgICBcblx0XHRcdCBkcmFnOmZhbHNlLCBcblx0XHRcdCBtb3VzZXVwOmZ1bmN0aW9uKGUscG9zKXsgXG5cdFx0XHQgXHRjb25zb2xlLmxvZygnY2xvbmUnKTtcblx0XHRcdCBcdF90aGlzLm1lbnVMYXllckhpZGUoKTtcblxuXHRcdFx0IFx0X3RoaXMuY2xvbmVOb2RlKCk7XG5cdFx0XHQgfVxuXHRcdFx0fSlcbiAgICB2YXIgY2xvbmVUZXh0ID0gdGhpcy5xY2FudmFzLnF0ZXh0LnRleHQoe1xuXHRcdFx0dGV4dDon5YWL6ZqGJyxcblx0XHRcdHN0YXJ0OmZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdF90aGlzLmNvbnRleHRNZW51TGF5ZXIuZWxlbWVudHNbMF0uc3RhcnRbMF0rX3RoaXMuY29udGV4dE1lbnVMYXllci5lbGVtZW50c1swXS53aWR0aCowLjUsXG5cdFx0XHRcdF90aGlzLmNvbnRleHRNZW51TGF5ZXIuZWxlbWVudHNbMF0uc3RhcnRbMV0rMjUrMjUqMC41XG5cdFx0XHRcdF07XG5cdFx0XHR9LFxuXHRcdFx0Zm9udFNpemU6JzEycHgnLFxuXHRcdFx0Y29sb3I6JyMwMDAnLFxuXHRcdFx0cG9pbnRlckV2ZW50Oidub25lJ1xuXHRcdH0pXG5cbiAgICB2YXIgZGVsUmVjdCA9IHRoaXMucWNhbnZhcy5xcmVjdC5yZWN0KHtcblx0XHRcdCBzdGFydDpmdW5jdGlvbigpe1xuXG5cdFx0XHQgXHRyZXR1cm4gW2FyZWEuc3RhcnRbMF0sYXJlYS5zdGFydFsxXSs1MF07XG5cdFx0XHQgfSxcblx0XHRcdCB3aWR0aDoxMDAsXG5cdFx0XHQgaGVpZ2h0OjI1LFxuXHRcdFx0IGJvcmRlckNvbG9yOicnLCBcblx0XHRcdCBmaWxsQ29sb3I6JyNmZmYnLCAgIFxuXHRcdFx0IGRyYWc6ZmFsc2UsIFxuXHRcdFx0IG1vdXNldXA6ZnVuY3Rpb24oZSxwb3MpeyBcblx0XHRcdCBcdGNvbnNvbGUubG9nKCfliKDpmaQnKTtcblx0XHRcdCBcdF90aGlzLm1lbnVMYXllckhpZGUoKTtcblx0XHRcdCBcdC8vIF90aGlzLmNvbnRleHRNZW51Tm9kZSA9IG51bGw7XG5cblxuXHRcdFx0IFx0X3RoaXMuZGVsTm9kZSgpO1xuXHRcdFx0IH1cblx0XHRcdH0pXG4gICAgdmFyIGRlbFR4dCA9IHRoaXMucWNhbnZhcy5xdGV4dC50ZXh0KHtcblx0XHRcdHRleHQ6J+WIoOmZpCcsXG5cdFx0XHRzdGFydDpmdW5jdGlvbigpe1xuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRfdGhpcy5jb250ZXh0TWVudUxheWVyLmVsZW1lbnRzWzBdLnN0YXJ0WzBdK190aGlzLmNvbnRleHRNZW51TGF5ZXIuZWxlbWVudHNbMF0ud2lkdGgqMC41LFxuXHRcdFx0XHRfdGhpcy5jb250ZXh0TWVudUxheWVyLmVsZW1lbnRzWzBdLnN0YXJ0WzFdKzUwKzI1KjAuNVxuXHRcdFx0XHRdO1xuXHRcdFx0fSxcblx0XHRcdGZvbnRTaXplOicxMnB4Jyxcblx0XHRcdGNvbG9yOicjMDAwJyxcblx0XHRcdHBvaW50ZXJFdmVudDonbm9uZSdcblx0XHR9KVxuXG4gICAgdGhpcy5jb250ZXh0TWVudUxheWVyLnB1c2goYXJlYSxsaW5rUmVjdCxsaW5rVHh0LGNsb25lUmVjdCxjbG9uZVRleHQsZGVsUmVjdCxkZWxUeHQpO1xuXG59O1xuUWZsb3cucHJvdG90eXBlLm1lbnVMYXllclNob3cgPSBmdW5jdGlvbihwb3MpIHtcblxuXHQvLyB2YXIgc3RhcnQgPSB0aGlzLnFjYW52YXMuaXNGdW4obm9kZS5zdGFydCk/bm9kZS5zdGFydCgpOm5vZGUuc3RhcnQ7XG4gLy8gXHR2YXIgeCA9IHN0YXJ0WzBdK25vZGUud2lkdGggLSAxNTtcblx0Ly8gdmFyIHkgPSBzdGFydFsxXSs1OyBcblxuXHQvLyB0aGlzLmNvbnRleHRNZW51Tm9kZSA9IG5vZGU7IFxuXHRcblx0dGhpcy5jb250ZXh0TWVudUxheWVyLmVsZW1lbnRzWzBdLnNldFN0YXJ0KFtwb3MueCxwb3MueV0pO1xuXHR0aGlzLmNvbnRleHRNZW51TGF5ZXIuc2V0RGlzcGxheSgnYmxvY2snKTtcblx0dGhpcy5xY2FudmFzLnJhaXNlVG9Ub3AodGhpcy5jb250ZXh0TWVudUxheWVyKTtcbiBcbn07XG5cblFmbG93LnByb3RvdHlwZS5tZW51TGF5ZXJIaWRlID0gZnVuY3Rpb24oKSB7XG5cdC8vIHRoaXMuY29udGV4dE1lbnVOb2RlID0gbnVsbDtcblx0dGhpcy5jb250ZXh0TWVudUxheWVyLnNldERpc3BsYXkoJ25vbmUnKTtcblxufTtcblFmbG93LnByb3RvdHlwZS5pbml0U2V0dGluZ0ljbyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgX3RoaXMgPSB0aGlzOyBcblxuXHR0aGlzLnNldHRpbmdJY28gPSB0aGlzLnFjYW52YXMucWFyYy5hcmMoe1xuXHRcdHN0YXJ0OlswLDBdLFxuXHRcdHNBbmdsZTowLFxuXHRcdGVBbmdsZTozNjAsXG5cdFx0Ym9yZGVyQ29sb3I6J3JlZCcsXG5cdFx0ZmlsbENvbG9yOidyZWQnLFxuXHRcdG9wYWNpdHk6MC41LFxuXHRcdHI6NSxcblx0XHRkaXNwbGF5Oidub25lJyxcblx0XHRkcmFnOmZhbHNlLFxuXHRcdG1vdXNlbW92ZTpmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5zZXREaXNwbGF5KCdibG9jaycpO1xuXHRcdH0sXG5cdFx0bW91c2V1cDpmdW5jdGlvbihlLHBvcyl7IFxuXHRcdFx0X3RoaXMuY29udGV4dFNldHRpbmdIaWRlKCk7XG5cblx0XHRcdC8v5aaC5p6c5Y+W5raI6L+e57q/5YWz57O7XG5cdFx0XHRfdGhpcy5kZWxUbXBMaW5lKCk7XG5cdFx0XHRfdGhpcy5jb250ZXh0TWVudU5vZGUgPSBudWxsO1xuXG5cdFx0XHRfdGhpcy5jb250ZXh0U2V0dGluZ05vZGUgPSB0aGlzLmNvbnRleHRTZXR0aW5nTm9kZTtcbiBcblxuXHRcdFx0X3RoaXMucWNhbnZhcy5yYWlzZVRvVG9wKF90aGlzLmNvbnRleHRTZXR0aW5nTGF5ZXIpO1xuXHRcdFx0Ly8gX3RoaXMuY29udGV4dFNldHRpbmdTaG93LmNhbGwoX3RoaXMuY29udGV4dFNldHRpbmdOb2RlLHt4OnRoaXMuc1N0YXJ0WzBdLHk6dGhpcy5zU3RhcnRbMV19KTtcblx0XHRcdC8vIF90aGlzLmNvbnRleHRTZXR0aW5nU2hvdyh7eDp0aGlzLnNTdGFydFswXSx5OnRoaXMuc1N0YXJ0WzFdfSk7XG5cdFx0XHRfdGhpcy5jb250ZXh0U2V0dGluZ1Nob3cocG9zKTtcblxuXG5cdFx0XHRfdGhpcy5saW5lTWVudUxheWVySGlkZSgpO1xuXG5cdFx0fVxuXHR9KTtcdFxuXG5cblxufTtcblFmbG93LnByb3RvdHlwZS5zZXR0aW5nSWNvU2hvdyA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0Ly8gY29uc29sZS5sb2coJ3NldHRpbmdJY29TaG93Jyk7XG5cdHZhciBzdGFydCA9IHRoaXMucWNhbnZhcy5pc0Z1bihub2RlLnN0YXJ0KT9ub2RlLnN0YXJ0KCk6bm9kZS5zdGFydDtcbiBcdHZhciB4ID0gc3RhcnRbMF0rbm9kZS53aWR0aCAtIDg7XG5cdHZhciB5ID0gc3RhcnRbMV0rODsgXG5cblxuXHR0aGlzLnNldHRpbmdJY28uY29udGV4dFNldHRpbmdOb2RlID0gbm9kZTtcblx0Ly8gdGhpcy5zZXR0aW5nSWNvLnNldFRTdGFydChbeCx5XSk7XG5cdHRoaXMuc2V0dGluZ0ljby5zZXRTdGFydChbeCx5XSk7XG5cblx0dGhpcy5zZXR0aW5nSWNvLnNldERpc3BsYXkoJ2Jsb2NrJyk7XG5cdHRoaXMucWNhbnZhcy5yYWlzZVRvVG9wKHRoaXMuc2V0dGluZ0ljbyk7XG59O1xuUWZsb3cucHJvdG90eXBlLnNldHRpbmdJY29IaWRlID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuc2V0dGluZ0ljby5zZXREaXNwbGF5KCdub25lJyk7XG59O1xuXG5cblFmbG93LnByb3RvdHlwZS5pbml0Q29udGV4dENvdmVyID0gZnVuY3Rpb24oKSB7XG5cdHZhciBfdGhpcyA9IHRoaXM7XG5cdC8v5Y2K6YCP5piO5bGC6KaG55uW5pW05Liq55S75biDXG5cdHRoaXMuY29udGV4dFNldHRpbmdMYXllci5wdXNoKHRoaXMucWNhbnZhcy5xcmVjdC5yZWN0KHtcblx0XHRcdCBzdGFydDpbMCwwXSwgIFxuXHRcdFx0IHdpZHRoOnRoaXMucWNhbnZhcy5zdGFnZS53aWR0aCxcblx0XHRcdCBoZWlnaHQ6dGhpcy5xY2FudmFzLnN0YWdlLmhlaWdodCxcblx0XHRcdCBib3JkZXJDb2xvcjonJywgXG5cdFx0XHQgZmlsbENvbG9yOicjMDAwJywgXG5cdFx0XHQgb3BhY2l0eTowLjEsXG5cdFx0XHQgZHJhZzpmYWxzZSwgXG5cdFx0XHQgbW91c2V1cDpmdW5jdGlvbigpe1xuXHRcdFx0IFx0X3RoaXMuY29udGV4dFNldHRpbmdIaWRlKCk7XG5cdFx0XHQgfVxuXHRcdFx0fSkpXG59O1xuUWZsb3cucHJvdG90eXBlLmNvbnRleHRTZXR0aW5nU2hvdyA9IGZ1bmN0aW9uKHBvcykge1xuIFxuIFxuXG5cdC8v5Yid5aeL5YyWY29udGV4dE1lbnXlj7PplK7oj5zljZXljLpyZWN0XG5cdHRoaXMuaW5pdENvbnRleHRNZW51QXJlYShwb3MpO1xuXG5cdC8v5L+u5pS55qCH6aKY5qGGKOeUqOS6juWumuS9jeS4gOS4qmlucHV05qGGKVxuXHR0aGlzLmluaXRNb2RpVGl0bGVOb2RlKCk7XG5cblx0Ly/liJ3lp4vljJZjb250ZXh0TWVudeS4reeahHRhYumhuVxuXHR0aGlzLmluaXRDb250ZXh0TWVudVRhYigpO1xuXG5cdC8vMTfpopzoibLlnZfnlLvliLDlj7Plh7voj5zljZXljLpcblx0dGhpcy5pbml0Q29sb3JSZWN0KCk7XG5cblx0Ly/liKDpmaTmjInpkq5cblx0Ly8gdGhpcy5pbml0RGVsQnRuKCk7XG5cblx0dGhpcy5jb250ZXh0U2V0dGluZ0xheWVyLnNldERpc3BsYXkoJ2Jsb2NrJyk7XG5cblx0Ly8gY29uc29sZS5sb2codGhpcy5jb250ZXh0U2V0dGluZ0xheWVyKTtcblx0Ly8gY29uc29sZS5sb2codGhpcy5xY2FudmFzKTtcbiBcbn07IFxuUWZsb3cucHJvdG90eXBlLmluaXREZWxCdG4gPSBmdW5jdGlvbigpIHtcblx0dmFyIF90aGlzID0gdGhpcztcblx0dmFyIGVsZSA9IHRoaXMuY29udGV4dFNldHRpbmdMYXllci5lbGVtZW50c1sxXTtcblxuXHR0aGlzLmNvbnRleHRTZXR0aW5nTGF5ZXIucHVzaChcblx0XHR0aGlzLnFjYW52YXMucXJlY3QucmVjdCh7XG5cdFx0XHRzdGFydDpbZWxlLnN0YXJ0WzBdK2VsZS53aWR0aC03MCxlbGUuc3RhcnRbMV0rZWxlLmhlaWdodC00MF0sXG5cdFx0XHR3aWR0aDo2MCxcblx0XHRcdGhlaWdodDozMCxcblx0XHRcdGZpbGxDb2xvcjonI2ZmZicsXG5cdFx0XHRkcmFnOmZhbHNlLCAgXG5cdFx0XHRtb3VzZXVwOmZ1bmN0aW9uKCl7XG5cdFx0XHRcdC8v5Yig6Zmk5pON5L2cXG5cdFx0XHRcdF90aGlzLmRlbE5vZGUoKTtcblxuXHRcdFx0XHRfdGhpcy5jb250ZXh0U2V0dGluZ0hpZGUoKTtcblx0XHRcdH1cblx0XHR9KSxcblx0XHR0aGlzLnFjYW52YXMucXRleHQudGV4dCh7XG5cdFx0XHR0ZXh0OifliKDpmaQnLFxuXHRcdFx0c3RhcnQ6W2VsZS5zdGFydFswXStlbGUud2lkdGgtNDAsZWxlLnN0YXJ0WzFdK2VsZS5oZWlnaHQtMjVdLFxuXHRcdFx0Zm9udFNpemU6JzEycHgnLFxuXHRcdFx0Y29sb3I6JyMwMDAnLFxuXHRcdFx0cG9pbnRlckV2ZW50Oidub25lJ1xuXHRcdH0pXG5cdCk7XG5cbn07XG5RZmxvdy5wcm90b3R5cGUubW9kaVRpdGxlID0gZnVuY3Rpb24odikge1xuXHRjb25zb2xlLmxvZyh0aGlzLm1vZGlUaXRsZU9iaik7XG5cdGlmKHRoaXMubW9kaVRpdGxlT2JqKXtcblx0XHR0aGlzLm1vZGlUaXRsZU9iai5zZXRUZXh0KHYpO1xuXHR9XG4gXG5cblx0dmFyIGpzb25PYmogPSB0aGlzLmdldEpzb25PYmoodGhpcy5jb250ZXh0U2V0dGluZ05vZGUubm9kZUlkKTtcblx0anNvbk9iai50ZXh0ID0gdjtcblxuIFx0dmFyIGJnUmVjdCA9IHRoaXMuZ2V0Tm9kZU9iaih0aGlzLmNvbnRleHRTZXR0aW5nTm9kZS5ub2RlSWQpO1xuXG5cblxuIFx0Ly/moLnmja7lhoXlrrkg5Yqo5oCB5pS55Y+YaW5wdXTkvY3nva7lkozlrr3luqZcbiBcdHZhciB0ZXh0UG9seVBvaW50cyA9IHRoaXMubW9kaVRpdGxlT2JqLnBvbHlQb2ludHMoKTtcbiBcdGNvbnNvbGUubG9nKHRleHRQb2x5UG9pbnRzKTtcbiBcdHZhciB0bXAgPSB0aGlzLm1vZGlUaXRsZU9iai5mb3JtYXRUZXh0LmNhbGwodGhpcyx0aGlzLm1vZGlUaXRsZU9iaik7XG5cbiBcdHZhciB3ID0gTWF0aC5tYXguYXBwbHkobnVsbCx0bXAud2lkdGgpO1xuIFx0dyA9IHc+YmdSZWN0LndpZHRoP3c6YmdSZWN0LndpZHRoO1xuXHR2YXIgc3RhcnQgPSB0aGlzLnFjYW52YXMuaXNGdW4oYmdSZWN0LnN0YXJ0KT9iZ1JlY3Quc3RhcnQoKTpiZ1JlY3Quc3RhcnQ7XG5cblxuIFx0dmFyIHggPSB3ID4gYmdSZWN0LndpZHRoPyhzdGFydFswXS0odyAtIGJnUmVjdC53aWR0aCkqMC41KTpzdGFydFswXTtcbiBcblxuIFx0dmFyIGQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGl0bGVJbnB1dCcpO1xuIFx0ZC5zdHlsZS53aWR0aCA9IHcrJ3B4JztcbiBcdGQuc3R5bGUubGVmdCA9IHgrJ3B4JztcblxuXG4gICAgIFxuXG59O1xuUWZsb3cucHJvdG90eXBlLmluaXRNb2RpVGl0bGVOb2RlID0gZnVuY3Rpb24oKSB7XG5cblxuXHR2YXIgcmVjdEpzb25PYmogPSB0aGlzLmdldEpzb25PYmoodGhpcy5jb250ZXh0U2V0dGluZ05vZGUuaWQpO1xuXHQvLyBjb25zb2xlLmxvZyhyZWN0SnNvbk9iaik7XG5cblx0dmFyIGVsZSA9IHRoaXMuY29udGV4dFNldHRpbmdMYXllci5lbGVtZW50c1swXTtcblx0dmFyIHggPSBlbGUuc3RhcnRbMF0rMTA7XG5cdHZhciB5ID0gZWxlLnN0YXJ0WzFdKzEwO1xuXHR2YXIgdyA9IGVsZS53aWR0aCAtIDIwO1xuXHR2YXIgaCA9IDMwO1xuXG5cdC8vIHRoaXMuY29udGV4dFNldHRpbmdMYXllci5wdXNoKHRoaXMucWNhbnZhcy5xcmVjdC5yZWN0KHtcblx0Ly8gXHRcdHN0YXJ0Olt4LHldLFxuXHQvLyBcdFx0d2lkdGg6dyxcblx0Ly8gXHRcdGhlaWdodDpoLFxuXHQvLyBcdFx0ZmlsbENvbG9yOicjZmZmJyxcblx0Ly8gXHRcdGRyYWc6ZmFsc2UsXG5cdC8vIFx0XHRwb2ludGVyRXZlbnQ6J25vbmUnXG5cdC8vIFx0fSkpO1xuXG5cdFxuXG5cdC8vIHZhciBkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RpdGxlSW5wdXQnKTtcblx0Ly8gZC5zdHlsZS5sZWZ0ID0geCsncHgnO1xuXHQvLyBkLnN0eWxlLnRvcCA9IHkrJ3B4Jztcblx0Ly8gZC5zdHlsZS53aWR0aCA9IHJlY3RKc29uT2JqLm5vZGVUeXBlID09J2NvbnRhaW5lcic/IHcgKiAwLjUrJ3B4Jzp3KydweCc7XG5cblx0Ly8gZC5zdHlsZS5oZWlnaHQgPSBoKydweCc7XG5cdC8vIGQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gXG5cblx0Ly8gaWYocmVjdEpzb25PYmouYXR0ciAmJiByZWN0SnNvbk9iai5hdHRyLnRpdGxlSWQpe1xuXHQvLyBcdHRoaXMubW9kaVRpdGxlT2JqID0gdGhpcy5nZXROb2RlT2JqKHJlY3RKc29uT2JqLmF0dHIudGl0bGVJZCk7XG5cblx0Ly8gXHRkLnZhbHVlID0gdGhpcy5tb2RpVGl0bGVPYmoudGV4dDtcblx0Ly8gfVx0XG5cblx0Ly/mmL7npLrlrrnlmajliJfnmoRpbnB1dOahhlxuXHRpZihyZWN0SnNvbk9iai5ub2RlVHlwZSA9PSAnY29udGFpbmVyJyl7XG5cblx0XHR0aGlzLmNvbnRleHRTZXR0aW5nTGF5ZXIucHVzaCh0aGlzLnFjYW52YXMucXRleHQudGV4dCh7XG5cdFx0XHRzdGFydDpbeCsxMCx5KzEyMF0sXG5cdFx0XHR0ZXh0OifliJc6Jyxcblx0XHRcdGNvbG9yOicjMDAwJ1xuXHRcdH0pKVxuXG5cblx0XHR2YXIgYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXJHcmlkQ29sdW1uJyk7XG5cdFx0Yy5zdHlsZS5sZWZ0ID0geCszMCsncHgnO1xuXHRcdGMuc3R5bGUudG9wID0geSsxMDUrJ3B4Jztcblx0XHRjLnN0eWxlLndpZHRoID0gdy0zMCsncHgnO1xuXHRcdGMuc3R5bGUuaGVpZ2h0ID0gaCsncHgnO1xuXHRcdGMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cblx0XHRjLnZhbHVlID0gcmVjdEpzb25PYmouZ3JpZFsxXTtcblxuXHR9XG59O1xuUWZsb3cucHJvdG90eXBlLmNvbnRleHRTZXR0aW5nSGlkZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdHRoaXMuY29udGV4dFNldHRpbmdOb2RlID0gbnVsbDtcblx0Ly8gdGhpcy5tb2RpVGl0bGVPYmogPSBudWxsO1xuXHR0aGlzLmNvbnRleHRTZXR0aW5nTGF5ZXIuc2V0RGlzcGxheSgnbm9uZScpOyBcblxuXHR2YXIgZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aXRsZUlucHV0Jyk7IFxuXHR2YXIgYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXJHcmlkQ29sdW1uJyk7XG5cdGQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0Yy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG5cblxuXG5cdC8v5L+d55WZ5q+P5LiA5Liq5Y2K6YCP5piO6KaG55uW5bGC5a+56LGhIOS4i+asoeW8ueWHuuWPs+mUruiPnOWNlSDlhoXlrrnph43mlrDliJ3lp4vljJZcblx0Ly8gdGhpcy5jb250ZXh0U2V0dGluZ0xheWVyLmVsZW1lbnRzLmxlbmd0aCA9PSAxO1xuXHQvLyB2YXIgdG1wID0gW107XG5cdC8vIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5jb250ZXh0U2V0dGluZ0xheWVyLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdC8vIFx0dG1wLnB1c2godGhpcy5jb250ZXh0U2V0dGluZ0xheWVyLmVsZW1lbnRzW2ldKTtcblx0Ly8gfVxuXHQvLyB0bXAuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcblx0Ly8gXHRfdGhpcy5jb250ZXh0U2V0dGluZ0xheWVyLnJlbW92ZUVsZShpdGVtKTtcblx0Ly8gfSlcblxuXHR0aGlzLmNvbnRleHRTZXR0aW5nTGF5ZXIuZGVzdHJveSgpO1xuXG5cblx0Ly8gY29uc29sZS5sb2codGhpcy5jb250ZXh0U2V0dGluZ0xheWVyKTtcblx0Ly8gY29uc29sZS5sb2codGhpcy5xY2FudmFzKTtcblxuXHRcbn07XG5cblFmbG93LnByb3RvdHlwZS5pbml0Q29sb3JSZWN0ID0gZnVuY3Rpb24oKSB7XG5cdHZhciBfdGhpcyA9IHRoaXM7XG5cdHZhciBkaXNUb3AgPSAzMDtcblx0dmFyIHBhZGRpbmcgPSAxMDtcblx0dmFyIHJlY3RXID0gMjA7XG5cdHZhciByZWN0SCA9IDIwO1xuXG5cdHZhciB0bXAgPSB0aGlzLmNvbnRleHRTZXR0aW5nTGF5ZXIuZWxlbWVudHNbMF07XG5cblxuXHQvL+aaguaXtuaOkjTooYw15YiXIFxuXHR2YXIgYXJlYVBvc2l0aW9uID0gW1xuXHRcdHtcblx0XHRcdHg6dG1wLnN0YXJ0WzBdKzEwLFxuXHRcdFx0eTp0bXAuc3RhcnRbMV0rZGlzVG9wXG5cdFx0fSxcblx0XHR7XG5cdFx0XHR4OnRtcC5zdGFydFswXSt0bXAud2lkdGgtMTAsXG5cdFx0XHR5OnRtcC5zdGFydFsxXSt0bXAuaGVpZ2h0LTEwXG5cdFx0fVxuXHRdO1xuXG5cdHZhciBwb3MgPSB0aGlzLmNoaWxkUG9zaXRpb25CeVJvdyg0LDYsYXJlYVBvc2l0aW9uLCByZWN0VyxyZWN0SCk7XG5cblx0dmFyIGNvbG9yID0gW107XG5cdGZvcih2YXIgaSBpbiB0aGlzLmNvbG9yUmVjdCl7XG5cdFx0Y29sb3IucHVzaCh0aGlzLmNvbG9yUmVjdFtpXSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yLmxlbmd0aDsgaSsrKSB7XG5cdFx0dGhpcy5jb250ZXh0U2V0dGluZ0xheWVyLnB1c2godGhpcy5xY2FudmFzLnFyZWN0LnJlY3Qoe1xuXHRcdFx0c3RhcnQ6W3Bvc1tpXS54LHBvc1tpXS55XSxcblx0XHRcdHdpZHRoOnJlY3RXLFxuXHRcdFx0aGVpZ2h0OnJlY3RILFxuXHRcdFx0ZmlsbENvbG9yOmNvbG9yW2ldLFxuXHRcdFx0ZHJhZzpmYWxzZSxcblx0XHRcdG1vdXNldXA6ZnVuY3Rpb24oKXtcblxuXHRcdFx0XHRpZihfdGhpcy5jb250ZXh0QWltQXR0ciA9PSAnY29sb3InKXtcblx0XHRcdFx0XHQvL+iuvue9ruiKgueCueagh+mimOminOiJslxuXHRcdFx0XHRcdF90aGlzLnVwZGF0ZU5vZGVUaXRsZUNvbG9yKHRoaXMuZmlsbENvbG9yKTtcblxuXG5cdFx0XHRcdH1lbHNle1xuXG5cdFx0XHRcdFx0X3RoaXMuY29udGV4dFNldHRpbmdOb2RlW190aGlzLmNvbnRleHRBaW1BdHRyXSA9IHRoaXMuZmlsbENvbG9yO1xuXHRcdFx0XHRcdCBcblx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly/mm7TmlrBqc29u5pWw5o2u55u45YWz5bGe5oCn5YC8XG5cdFx0XHRcdFx0X3RoaXMudXBkYXRlSW5pdERhdGFBdHRyKHRoaXMuZmlsbENvbG9yKTtcblxuXG5cdFx0XHR9XG5cdFx0fSkpXG5cdH1cbn07XG5RZmxvdy5wcm90b3R5cGUudXBkYXRlTm9kZVRpdGxlQ29sb3IgPSBmdW5jdGlvbih2KSB7XG5cblx0dmFyIF90aGlzID0gdGhpcztcblxuXHQvL+esrOS4gOatpSDmib7liLDmoIfpopjnmoRpZFxuXHR2YXIgZ2V0VGl0bGVOb2RlSlNPTiA9IGZ1bmN0aW9uKCl7IFxuXG5cdFx0dmFyIHRtcCA9IF90aGlzLm9wdGlvbnMuaW5pdERhdGEubm9kZS5maWx0ZXIoZnVuY3Rpb24oaXRlbSl7XG5cdFx0XHRyZXR1cm4gaXRlbS5ub2RlSWQgPT0gX3RoaXMuY29udGV4dFNldHRpbmdOb2RlLmlkO1xuXHRcdH0pXG5cblx0XHRpZih0bXAubGVuZ3RoPjApe1xuXHRcdFx0cmV0dXJuIHRtcFswXTtcblx0XHR9ZWxzZXtcblx0XHRcdGNvbnNvbGUubG9nKCfmsqHmnInmib7liLAnKTtcblx0XHRcdC8v5aaC5p6c5rKh5pyJ5Y+W5YiwICDpgqPlsLHmmK/lnKjlrZDpobnph4xcblx0XHRcdHZhciB0bXA7XG5cdFx0XHRfdGhpcy5vcHRpb25zLmluaXREYXRhLm5vZGUuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcblx0XHRcdFx0aWYoaXRlbS5ub2RlVHlwZSA9PSAnY29udGFpbmVyJyl7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtLmNoaWxkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZihpdGVtLmNoaWxkW2ldLm5vZGVJZCA9PSBfdGhpcy5jb250ZXh0U2V0dGluZ05vZGUuaWQpe1xuXHRcdFx0XHRcdFx0XHR0bXAgPSBpdGVtLmNoaWxkW2ldO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cblx0XHRcdHJldHVybiB0bXA7XG5cdFx0fVxuXHR9IFxuIFx0XG4gXHR2YXIgdGl0bGVKU09OID0gZ2V0VGl0bGVOb2RlSlNPTigpO1xuXG5cdHZhciB0bXAgPSB0aGlzLnFub2Rlcy5maWx0ZXIoZnVuY3Rpb24oaXRlbSl7XG5cdFx0cmV0dXJuIGl0ZW0uaWQgPT0gdGl0bGVKU09OLmF0dHIudGl0bGVJZDtcblx0fSlcbiBcblx0aWYodG1wLmxlbmd0aD4wKXtcblx0XHR0bXBbMF1bX3RoaXMuY29udGV4dEFpbUF0dHJdID0gdjtcblx0fVxuXHQgXG59O1xuXG5cblFmbG93LnByb3RvdHlwZS51cGRhdGVJbml0RGF0YUF0dHIgPSBmdW5jdGlvbih2KSB7XG5cblx0dmFyIF90aGlzID0gdGhpcztcblx0dmFyIGdldFRpdGxlTm9kZUpTT04gPSBmdW5jdGlvbigpeyBcblxuXHRcdHZhciB0bXAgPSBfdGhpcy5vcHRpb25zLmluaXREYXRhLm5vZGUuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdFx0cmV0dXJuIGl0ZW0ubm9kZUlkID09IF90aGlzLmNvbnRleHRTZXR0aW5nTm9kZS5pZDtcblx0XHR9KVxuXG5cdFx0aWYodG1wLmxlbmd0aD4wKXtcblx0XHRcdHJldHVybiB0bXBbMF07XG5cdFx0fWVsc2V7XG5cdFx0XHRjb25zb2xlLmxvZygn5rKh5pyJ5om+5YiwJyk7XG5cdFx0XHQvL+WmguaenOayoeacieWPluWIsCAg6YKj5bCx5piv5Zyo5a2Q6aG56YeMXG5cdFx0XHR2YXIgdG1wO1xuXHRcdFx0X3RoaXMub3B0aW9ucy5pbml0RGF0YS5ub2RlLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XG5cdFx0XHRcdGlmKGl0ZW0ubm9kZVR5cGUgPT0gJ2NvbnRhaW5lcicpe1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbS5jaGlsZC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYoaXRlbS5jaGlsZFtpXS5ub2RlSWQgPT0gX3RoaXMuY29udGV4dFNldHRpbmdOb2RlLmlkKXtcblx0XHRcdFx0XHRcdFx0dG1wID0gaXRlbS5jaGlsZFtpXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXG5cdFx0XHRyZXR1cm4gdG1wO1xuXHRcdH1cblx0fSBcblxuXG5cdHZhciB0aXRsZU5vZGVKU09OID0gZ2V0VGl0bGVOb2RlSlNPTigpO1xuXHR0aXRsZU5vZGVKU09OLmF0dHJbX3RoaXMuY29udGV4dEFpbUF0dHJdID0gdjtcdFx0XG5cblxufTtcblxuUWZsb3cucHJvdG90eXBlLmluaXRDb250ZXh0TWVudVRhYiA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXHR2YXIgdG1wID0gdGhpcy5jb250ZXh0U2V0dGluZ0xheWVyLmVsZW1lbnRzWzBdO1xuXG5cdHZhciB0ZXh0QXJyID0gW1xuXHRcdHt0ZXh0OifovrnmoYbpopzoibInLCBhaW1BdHRyOidib3JkZXJDb2xvcid9LFxuXHRcdHt0ZXh0Oifog4zmma/popzoibInLCBhaW1BdHRyOidmaWxsQ29sb3InfSxcblx0XHR7dGV4dDon5paH5a2X6aKc6ImyJywgYWltQXR0cjonY29sb3InfSxcblx0XTtcblxuXG5cblx0dGV4dEFyci5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0saW5kZXgpe1xuXHRcdHZhciB4ID0gdG1wLnN0YXJ0WzBdK2luZGV4KigyMDAvKHRleHRBcnIubGVuZ3RoKSkgKyAyMDAvKHRleHRBcnIubGVuZ3RoKSowLjU7XG5cblx0XHRpZihpbmRleD09MCl7XG5cdFx0XHRfdGhpcy5jb250ZXh0QWltQXR0ciA9IGl0ZW0uYWltQXR0clxuXHRcdH1cblxuXG5cdFx0dmFyIGMgPSBfdGhpcy5xY2FudmFzLnF0ZXh0LnRleHQoe1xuXHRcdFx0dGV4dDppdGVtLnRleHQsXG5cdFx0XHRzdGFydDpbeCx0bXAuc3RhcnRbMV0rMTVdLFxuXG5cdFx0XHRjb2xvcjppbmRleD09MD8nIzAwMCc6JyNjY2MnLFxuXHRcdFx0YWltQXR0cjppdGVtLmFpbUF0dHIsXG5cdFx0XHRkcmFnOmZhbHNlLFxuXHRcdFx0bW91c2V1cDpmdW5jdGlvbigpeyAgIFxuXHRcdFx0XHR2YXIgX3NlbGYgPSB0aGlzOyBcblx0XHRcdFx0X3RoaXMuY29udGV4dFNldHRpbmdMYXllci5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuXG5cdFx0XHRcdFx0aWYoaXRlbS5UWVBFID09IFwidGV4dFwiKXtcblx0XHRcdFx0XHRcdGl0ZW0uY29sb3IgPSAnI2NjYyc7XG5cblx0XHRcdFx0XHRcdGlmKGl0ZW0uaWQgPT0gX3NlbGYuaWQpeyBcblx0XHRcdFx0XHRcdFx0X3RoaXMuY29udGV4dEFpbUF0dHIgPSBpdGVtLmFpbUF0dHI7XG5cdFx0XHRcdFx0XHRcdGl0ZW0uY29sb3IgPSAnIzAwMCc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0pIFxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cblx0XHRfdGhpcy5jb250ZXh0U2V0dGluZ0xheWVyLnB1c2goYyk7XG5cdH0pXG5cdFxufTtcblFmbG93LnByb3RvdHlwZS5pbml0Q29udGV4dE1lbnVBcmVhID0gZnVuY3Rpb24ocG9zKSB7XG5cdHZhciBfdGhpcyA9IHRoaXM7IFxuXG5cdC8v5Y+z5Ye75pi+56S655qE6I+c5Y2V5Z2XIFxuXHR0aGlzLmNvbnRleHRTZXR0aW5nTGF5ZXIucHVzaCh0aGlzLnFjYW52YXMucXJlY3QucmVjdCh7XG5cdFx0c3RhcnQ6W3Bvcy54LHBvcy55XSxcblx0XHR3aWR0aDoyMDAsXG5cdFx0aGVpZ2h0OjIwMCxcblx0XHRib3JkZXJDb2xvcjonJyxcblx0XHRmaWxsQ29sb3I6J3llbGxvdycsXG5cdFx0ZHJhZzpmYWxzZVxuXHR9KSk7XG5cdFxufTtcblFmbG93LnByb3RvdHlwZS5nZXRDb250YWluZXJOb2RlcyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgY29udGFpbmVyTm9kZSA9IFtdO1xuXHRpZih0aGlzLm9wdGlvbnMuaW5pdERhdGEubm9kZSAhPT0gbnVsbCAmJlxuIFx0XHR0aGlzLm9wdGlvbnMuaW5pdERhdGEubm9kZS5sZW5ndGg+MFxuIFx0XHQpe1xuXHRcdGNvbnRhaW5lck5vZGUgPSB0aGlzLm9wdGlvbnMuaW5pdERhdGEubm9kZS5maWx0ZXIoZnVuY3Rpb24oaXRlbSl7XG5cdFx0XHRyZXR1cm4gaXRlbS5ub2RlVHlwZSA9PSAnY29udGFpbmVyJztcblx0XHR9KVxuXHR9XG5cblx0cmV0dXJuIGNvbnRhaW5lck5vZGU7XG59O1xuUWZsb3cucHJvdG90eXBlLmdldENoaWxkQXJlYVBvc2l0aW9uID0gZnVuY3Rpb24oY29udGFpbmVyTm9kZSkge1xuXHR2YXIgdGl0bGVQb3NpdGlvbiA9IGNvbnRhaW5lck5vZGUuYXR0ci50aXRsZVBvc2l0aW9uO1xuXG5cdHZhciBzdGFydFBsYWNlSG9sZGVyWCA9IDA7XG5cdHZhciBzdGFydFBsYWNlSG9sZGVyWSA9IDA7XG5cdHZhciBlbmRQbGFjZUhvbGRlclggPSAwO1xuXHR2YXIgZW5kUGxhY2VIb2xkZXJZID0gMDtcblx0aWYodGl0bGVQb3NpdGlvbiA9PSAndG9wLWNlbnRlcicpe1xuXHRcdHN0YXJ0UGxhY2VIb2xkZXJZICs9ICh0aGlzLmNvbnRhaW5lclRpdGxlSGVpZ2h0K3RoaXMuY29udGFpbmVyUGFkZGluZyk7XG5cdH1cblxuXG5cdHJldHVybiBbXG5cdFx0e1xuXHRcdFx0eDpjb250YWluZXJOb2RlLnggKyBzdGFydFBsYWNlSG9sZGVyWCArIHRoaXMuY29udGFpbmVyQ2hpbGRNYXJnaW4sXG5cdFx0XHR5OmNvbnRhaW5lck5vZGUueSArIHN0YXJ0UGxhY2VIb2xkZXJZXG5cdFx0fSxcblx0XHR7XG5cdFx0XHR4OmNvbnRhaW5lck5vZGUueCArIGNvbnRhaW5lck5vZGUud2lkdGggLSBlbmRQbGFjZUhvbGRlclgsXG5cdFx0XHR5OmNvbnRhaW5lck5vZGUueSArIGNvbnRhaW5lck5vZGUuaGVpZ2h0IC0gZW5kUGxhY2VIb2xkZXJZXG5cdFx0fVxuXHRdXG5cblxufTtcblxuUWZsb3cucHJvdG90eXBlLmNoaWxkUG9zaXRpb25CeVJvdyA9IGZ1bmN0aW9uKHJvdyxjb2x1bW4sYXJlYVBvc2l0aW9uLHcsaCkge1xuXHR2YXIgdG1wID0gW107XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCByb3c7IGkrKykge1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uOyBqKyspIHtcblx0XHRcdGlmKHRtcFtpXSl7XG5cdFx0XHRcdHRtcFtpXS5wdXNoKHtcblx0XHRcdFx0XHR4OmFyZWFQb3NpdGlvblswXS54K2oqdytqKnRoaXMuY29udGFpbmVyQ2hpbGRNYXJnaW4sXG5cdFx0XHRcdFx0eTphcmVhUG9zaXRpb25bMF0ueStpKmgraSp0aGlzLmNvbnRhaW5lckNoaWxkTWFyZ2luXG5cdFx0XHRcdH0pXG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0dG1wW2ldPVt7XG5cdFx0XHRcdFx0eDphcmVhUG9zaXRpb25bMF0ueCtqKncraip0aGlzLmNvbnRhaW5lckNoaWxkTWFyZ2luLFxuXHRcdFx0XHRcdHk6YXJlYVBvc2l0aW9uWzBdLnkraSpoK2kqdGhpcy5jb250YWluZXJDaGlsZE1hcmdpblxuXHRcdFx0XHR9XTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgdCA9IFtdO1xuXHR0bXAuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcblx0XHR0ID0gdC5jb25jYXQoaXRlbSk7XG5cdH0pIFxuXG5cdHJldHVybiB0O1xufTtcblxuUWZsb3cucHJvdG90eXBlLmdldENoaWxkUG9zaXRpb24gPSBmdW5jdGlvbihjb250YWluZXJOb2RlLGFyZWFQb3NpdGlvbikge1xuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdC8v5a2Q6aG56KaB5YiG5aSa5bCR5Liq6KGM5YiX5pa55byP55S75YiwY29udGFpbmVy5LitXG5cdHZhciBncmlkID0gY29udGFpbmVyTm9kZS5ncmlkO1xuXHR2YXIgY2hpbGQgPSBjb250YWluZXJOb2RlLmNoaWxkO1xuXHR2YXIgY2hpbGROdW0gPSBjb250YWluZXJOb2RlLmNoaWxkLmxlbmd0aDtcblx0dmFyIHJvdyA9IGdyaWRbMF07XG5cdHZhciBjb2x1bW4gPSBncmlkWzFdO1xuXHR2YXIgYXJlYVdpZHRoICA9IGFyZWFQb3NpdGlvblsxXS54IC0gYXJlYVBvc2l0aW9uWzBdLng7XG5cdHZhciBhcmVhSGVpZ2h0ID0gYXJlYVBvc2l0aW9uWzFdLnkgLSBhcmVhUG9zaXRpb25bMF0ueVxuXG5cdC8v5YWI6KGM5ZCO5YiXXG5cdC8vIHZhciBjaGlsZE5vZGVXaWR0aCA9IChhcmVhV2lkdGggLSAoY29sdW1uLTEpKnRoaXMuY29udGFpbmVyQ2hpbGRNYXJnaW4pL2NvbHVtbjtcblx0Ly8gdmFyIGNoaWxkTm9kZUhlaWdodCA9IChhcmVhSGVpZ2h0IC0gKHJvdy0xKSp0aGlzLmNvbnRhaW5lckNoaWxkTWFyZ2luKS9yb3c7XG5cblx0Ly8gY29uc29sZS5sb2coY2hpbGROb2RlV2lkdGgpO1xuXG5cdC8vIC8v6ZmQ5Yi25LiA5LiL5pyA5bCP6auY5bqmXG5cdC8vIGNoaWxkTm9kZUhlaWdodCA9IGNoaWxkTm9kZUhlaWdodDx0aGlzLmNoaWxkTm9kZUhlaWdodD90aGlzLmNoaWxkTm9kZUhlaWdodDpjaGlsZE5vZGVIZWlnaHQ7XG5cblx0Ly8gY29uc29sZS5sb2cocm93LGNvbHVtbixhcmVhUG9zaXRpb24sY2hpbGROb2RlV2lkdGgsY2hpbGROb2RlSGVpZ2h0KTtcblxuXHQvL+WFiOaKimNoaWxk5oyJ6KGMIOi/m+ihjOWIhue7hCDorqHnrpflnZDmoIdcblx0Ly8gcmV0dXJuIHRoaXMuY2hpbGRQb3NpdGlvbkJ5Um93KHJvdyxjb2x1bW4sYXJlYVBvc2l0aW9uLGNoaWxkTm9kZVdpZHRoLGNoaWxkTm9kZUhlaWdodCk7XG5cdHJldHVybiB0aGlzLmNoaWxkUG9zaXRpb25CeVJvdyhyb3csY29sdW1uLGFyZWFQb3NpdGlvbix0aGlzLmNoaWxkTm9kZVdpZHRoLHRoaXMuY2hpbGROb2RlSGVpZ2h0KTtcblxuXG5cdFxufTtcblFmbG93LnByb3RvdHlwZS5pbml0Q2hpbGRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHQvL+aJgOaciW5vZGVUeXBlID09ICdjb250YWluZXIn55qE6IqC54K555qE5a2Q6aG555Sf5oiQeCx5XG5cdGlmKHRoaXMub3B0aW9ucy5pbml0RGF0YSA9PT0gbnVsbCl7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIGNvbnRhaW5lck5vZGVzID0gdGhpcy5nZXRDb250YWluZXJOb2RlcygpO1xuXHRcblxuXHQvL+mAmui/h2NvbnRhaW5lcueahGdyaWTnmoTlsZ7mgKforqHnrpflrZDpobnkvY3nva4gXG5cdC8v5rOo5oSP5a655Zmo5pyJ5qCH6aKY5pe2IOagh+mimOS5n+mcgOimgeWNoOS4gOWumuepuumXtFxuXHQvL+agh+mimOS9jee9rjpcblx0Ly90b3AtbGVmdCB0b3AtY2VudGVyIHRvcC1yaWdodFxuXHQvL2xlZnQtdG9wIGxlZnQtY2VudGVyIGxlZnQtYm90dG9tXG5cdC8vcmlnaHQtdG9wIHJpZ2h0LWNlbnRlciByaWdodC1ib3R0b21cblx0Ly9ib3R0b20tbGVmdCBib3R0b20tY2VudGVyIGJvdHRvbS1yaWdodFxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRhaW5lck5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cblx0XHQvL+WFiOWunueOsHRvcC1jZW50ZXJcblx0XHQvL+WPr+S7peaRhuaUvuWtkOmhueeahOWMuuWfn+S9jee9rlvlt6bkuIrop5LlvIDlp4vkvY3nva7vvIzlj7PkuIvop5Lnu5PmnZ/kvY3nva5dXG5cdFx0dmFyIGNoaWxkQXJlYVBvc2l0aW9uID0gdGhpcy5nZXRDaGlsZEFyZWFQb3NpdGlvbihjb250YWluZXJOb2Rlc1tpXSk7XG5cblx0XHQvL+WPr+S7peaRhuaUvuWtkOmhueeahOWMuuWfn+S9jee9riDorqHnrpflh7rlkITkuKrmoLzlrZDnmoTlnZDmoIdcblx0XHR2YXIgY2hpbGRQb3NpdGlvbiA9IHRoaXMuZ2V0Q2hpbGRQb3NpdGlvbihjb250YWluZXJOb2Rlc1tpXSxjaGlsZEFyZWFQb3NpdGlvbik7XG5cblx0XHQvL+aKiuagvOWtkOWdkOagh+a3u+WKoOWIsGV0dHLph4xcblx0XHRjb250YWluZXJOb2Rlc1tpXS5hdHRyLmdyaWRQb3NpdGlvbiA9IGNoaWxkUG9zaXRpb247XG5cdH1cblxuXG5cdFxufTtcblFmbG93LnByb3RvdHlwZS5yZVNpemVCeUluaXREYXRhID0gZnVuY3Rpb24oKSB7XG5cblx0aWYodGhpcy5vcHRpb25zLmluaXREYXRhID09PSBudWxsKXtcblx0XHRyZXR1cm47XG5cdH1cbiBcdFxuIFx0Ly/mib7lh7rmqKrnurXlnZDmoIfmnIDlpKflgLwg5Yik5pat55S75biD5piv5ZCm5Y+v5Lul5pS+5b6X5LiLIFxuIFx0aWYodGhpcy5vcHRpb25zLmluaXREYXRhLm5vZGUgIT09IG51bGwgJiZcbiBcdFx0dGhpcy5vcHRpb25zLmluaXREYXRhLm5vZGUubGVuZ3RoPjBcbiBcdFx0KXtcblxuXHQgICAgLy/lj5bku6XkuIvkuKTkuKrnu4TnmoTmnIDlpKflgLxcblx0ICAgIC8veCvlhYPntKDlrr1cblx0ICAgIC8veSvlhYPntKDpq5hcblx0ICAgIHZhciBfdGhpcyA9IHRoaXMseD1bXSx5PVtdO1xuXHRcdHRoaXMub3B0aW9ucy5pbml0RGF0YS5ub2RlLm1hcChmdW5jdGlvbihpdGVtKXtcblxuXHRcdFx0aWYoaXRlbS5ub2RlVHlwZSA9PSAnY29udGFpbmVyJyl7XG5cdFx0XHRcdHgucHVzaChpdGVtLngraXRlbS53aWR0aCk7XG5cdFx0XHRcdHkucHVzaChpdGVtLnkraXRlbS5oZWlnaHQpO1xuXHRcdFx0fWVsc2V7XG5cblx0XHRcdFx0eC5wdXNoKGl0ZW0ueCtfdGhpcy5jaGlsZE5vZGVXaWR0aCk7XG5cdFx0XHRcdHkucHVzaChpdGVtLnkrX3RoaXMuY2hpbGROb2RlSGVpZ2h0KTtcblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0dmFyIG1heFggPSBNYXRoLm1heC5hcHBseShudWxsLHgpO1xuXHRcdHZhciBtYXhZID0gTWF0aC5tYXguYXBwbHkobnVsbCx5KTsgXG5cblx0IFx0dGhpcy5vcHRpb25zLndpZHRoID0gbWF4WD49dGhpcy5vcHRpb25zLndpZHRoP21heFg6dGhpcy5vcHRpb25zLndpZHRoO1xuXHQgXHR0aGlzLm9wdGlvbnMuaGVpZ2h0ID0gbWF4WT49dGhpcy5vcHRpb25zLmhlaWdodD9tYXhZOnRoaXMub3B0aW9ucy5oZWlnaHQ7IFxuIFx0fVxufTtcblFmbG93LnByb3RvdHlwZS5nZXROb2RlSWRGcm9tSnNvbkJ5SWQgPSBmdW5jdGlvbihpZCkge1xuXG5cdHZhciB0bXAgPSBudWxsO1xuXHQvL+aQnOe0oueItiDlrZDpoblcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMuaW5pdERhdGEubm9kZS5sZW5ndGg7IGkrKykge1xuXG5cdFx0aWYodGhpcy5vcHRpb25zLmluaXREYXRhLm5vZGVbaV0uaWQgPT0gaWQpe1xuXHRcdFx0dG1wID0gdGhpcy5vcHRpb25zLmluaXREYXRhLm5vZGVbaV0ubm9kZUlkO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGlmKHRoaXMub3B0aW9ucy5pbml0RGF0YS5ub2RlW2ldLmNoaWxkKXtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5vcHRpb25zLmluaXREYXRhLm5vZGVbaV0uY2hpbGQubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aWYodGhpcy5vcHRpb25zLmluaXREYXRhLm5vZGVbaV0uY2hpbGRbal0uaWQgPT0gaWQpe1xuXHRcdFx0XHRcdHRtcCA9IHRoaXMub3B0aW9ucy5pbml0RGF0YS5ub2RlW2ldLmNoaWxkW2pdLm5vZGVJZDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fSBcblx0XHR9XG5cdFx0XG5cdH1cblxuXHRyZXR1cm4gdG1wO1xufTtcblFmbG93LnByb3RvdHlwZS5jYWxjTGluZVN0YXJ0UG9zID0gZnVuY3Rpb24oQSxCLG5vZGVJZCkge1xuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXHQvLyBjb25zb2xlLmxvZyhzdGFydE5vZGUuZ2V0UmFuZ2VQb2ludHMoKSk7IC8vOOS4qui+ueeVjOeCuVxuXHQvLyA45Liq54K555qE56S65oSP5Zu+XG5cdC8vIDBfXzFfXzIgICAgMF9fMV9fMlxuXHQvLyB8ICAgICB8XHQgIHwgICAgIHxcblx0Ly8gNyDoioLngrkgM1x0ICA3IOiKgueCuSAzXG5cdC8vIHwgICAgIHwgICAgfCAgICAgfFxuXHQvLyA2X181X180XHQgIDZfXzVfXzRcblx0XG5cblxuXHR2YXIgRiA9IGZ1bmN0aW9uKCl7XG5cblx0XHR2YXIgQV9jZW50ZXIgPSBBLmNlbnRlclBvaW50cygpO1xuXHRcdHZhciBCX2NlbnRlciA9IEIuY2VudGVyUG9pbnRzKCk7XG5cdFx0dmFyIEFfcmFuZ2VQb3MgPSBBLmdldFJhbmdlUG9pbnRzKCk7IFxuXHRcdHZhciBCX3JhbmdlUG9zID0gQi5nZXRSYW5nZVBvaW50cygpOyBcbiBcbiBcblx0XHR2YXIgc3RhcnRQb3MgPSBbMCwwXTtcblx0ICAgIHZhciBlbmRQb3MgPSBbMCwwXTtcblxuXG5cdCAgICAvL+esrOS4gOenjeaDheWGte+8iEHlnKjkuIsgQuWcqOS4iu+8iVxuXHQgICAgLy8gMF9fMV9fMiAgICBcblx0ICAgIC8vIHwgICAgIHxcdCAgXG5cdCAgICAvLyA3ICBCXHQgM1x0IFxuXHQgICAgLy8gfCAgICAgfCAgICBcblx0ICAgIC8vIDZfXzVfXzRcdCAgXG5cdCAgICAvL1x0ICDihpFcblx0ICAgIC8vIDBfXzFfXzIgICAgXG5cdCAgICAvLyB8ICAgICB8XHQgIFxuXHQgICAgLy8gNyAgQSAgM1x0IFxuXHQgICAgLy8gfCAgICAgfCAgICBcblx0ICAgIC8vIDZfXzVfXzRcdCAgXG5cdCAgICBpZihBX2NlbnRlci55ID49IEJfY2VudGVyLnkpe1xuXG5cdCAgICAgICAgLy/kuKTngrnoioLngrnkuIrkuIvmsqHmnInpl7Tot51cblx0ICAgICAgICBpZihBX3JhbmdlUG9zWzBdWzFdIDw9IEJfcmFuZ2VQb3NbNl1bMV0peyBcblxuXHQgICAgICAgICAgICAvL0HngrnlnKhC55qE5Y+z5L6nXG5cdCAgICAgICAgICAgIGlmKEFfcmFuZ2VQb3NbMF1bMF0gPj0gQl9yYW5nZVBvc1syXVswXSl7XG5cblx0ICAgICAgICAgICAgICAgIHN0YXJ0UG9zID0gQV9yYW5nZVBvc1s3XTtcblx0ICAgICAgICAgICAgICAgIC8vIGVuZFBvcyA9IEJfcmFuZ2VQb3NbM107XG5cblx0ICAgICAgICAgICAgICAgIFxuXHQgICAgICAgICAgICB9ZWxzZSBpZihBX3JhbmdlUG9zWzJdWzBdIDw9IEJfcmFuZ2VQb3NbMF1bMF0pe1xuXHQgICAgICAgICAgICAgICAgLy9B54K55ZyoQueahOW3puS+p1xuXHQgICAgICAgICAgICAgICAgc3RhcnRQb3MgPSBBX3JhbmdlUG9zWzNdO1xuXHQgICAgICAgICAgICAgICAgLy8gZW5kUG9zID0gQl9yYW5nZVBvc1s3XTtcblxuXHQgICAgICAgICAgICB9ZWxzZXtcblxuXHQgICAgICAgICAgICAgICAgc3RhcnRQb3MgPSBBX3JhbmdlUG9zWzFdO1xuXHQgICAgICAgICAgICAgICAgLy8gZW5kUG9zID0gQl9yYW5nZVBvc1sxXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgfWVsc2V7IC8v5LiK5LiL5rKh5pyJ5Y+g5Yqg77yI5LiK5LiL5pyJ6Ze06Led77yJXG4gXG5cblx0ICAgICAgICAgICAgIC8vQeeCueWcqELnmoTlj7PkuIvkvqdcblx0ICAgICAgICAgICAgaWYoQV9yYW5nZVBvc1swXVswXSA+PSBCX3JhbmdlUG9zWzJdWzBdKXtcblxuXHQgICAgICAgICAgICAgICAgc3RhcnRQb3MgPSBBX3JhbmdlUG9zWzFdO1xuXHQgICAgICAgICAgICAgICAgLy8gZW5kUG9zID0gQl9yYW5nZVBvc1s0XTtcblxuXHQgICAgICAgICAgICAgICAgXG5cdCAgICAgICAgICAgIH1lbHNlIGlmKEFfcmFuZ2VQb3NbMl1bMF0gPD0gQl9yYW5nZVBvc1syXVswXSl7XG5cdCAgICAgICAgICAgICAgICAvL0HngrnlnKhC55qE5bem5LiL5L6nXG5cdCAgICAgICAgICAgICAgICBzdGFydFBvcyA9IEFfcmFuZ2VQb3NbMV07XG5cdCAgICAgICAgICAgICAgICAvLyBlbmRQb3MgPSBCX3JhbmdlUG9zWzZdO1xuXG5cdCAgICAgICAgICAgIH1lbHNle1xuXG5cdCAgICAgICAgICAgICAgICBzdGFydFBvcyA9IEFfcmFuZ2VQb3NbMV07XG5cdCAgICAgICAgICAgICAgICAvLyBlbmRQb3MgPSBCX3JhbmdlUG9zWzVdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfWVsc2V7XG5cdCAgICAgICAgLy/nrKzkuoznp43mg4XlhrUg77yIQeWcqOS4iiBC5Zyo5LiL77yJXG5cdCAgICAgICAgLy8gMF9fMV9fMiAgICBcblx0XHRcdC8vIHwgICAgIHxcdCAgXG5cdFx0XHQvLyA3ICBBXHQgM1x0IFxuXHRcdFx0Ly8gfCAgICAgfCAgICBcblx0XHRcdC8vIDZfXzVfXzRcdCAgXG5cdFx0XHQvL1x0ICDihpNcblx0XHRcdC8vIDBfXzFfXzIgICAgXG5cdFx0XHQvLyB8ICAgICB8XHQgIFxuXHRcdFx0Ly8gNyAgQiAgM1x0IFxuXHRcdFx0Ly8gfCAgICAgfCAgICBcblx0XHRcdC8vIDZfXzVfXzRcblxuXHQgICAgICAgIC8v5Lik54K56IqC54K55LiK5LiL5rKh5pyJ6Ze06LedXG5cdCAgICAgICAgaWYoQl9yYW5nZVBvc1swXVsxXTw9QV9yYW5nZVBvc1s2XVsxXSl7IFxuXHQgICAgICAgICAgICAvL0HlnKhC55qE5Y+z5L6nXG5cdCAgICAgICAgICAgIGlmKEFfcmFuZ2VQb3NbMF1bMF0gPj0gQl9yYW5nZVBvc1syXVswXSl7XG5cdCAgICAgICAgICAgICAgICBzdGFydFBvcyA9IEFfcmFuZ2VQb3NbN107XG5cdCAgICAgICAgICAgICAgICAvLyBlbmRQb3MgPSBCX3JhbmdlUG9zWzNdO1xuXG5cdCAgICAgICAgICAgIH1lbHNlIGlmKEFfcmFuZ2VQb3NbMl1bMF0gPD0gQl9yYW5nZVBvc1swXVswXSl7XG5cdCAgICAgICAgICAgICAgICAvL0HlnKhC55qE5bem5L6nXG5cdCAgICAgICAgICAgICAgICBzdGFydFBvcyA9IEFfcmFuZ2VQb3NbM107XG5cdCAgICAgICAgICAgICAgICAvLyBlbmRQb3MgPSBCX3JhbmdlUG9zWzddO1xuXG5cdCAgICAgICAgICAgIH1lbHNle1xuXHQgICAgICAgICAgICAgICAgc3RhcnRQb3MgPSBBX3JhbmdlUG9zWzVdO1xuXHQgICAgICAgICAgICAgICAgLy8gZW5kUG9zID0gQl9jZW50ZXJbNV07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgIH1lbHNleyAvL+S4iuS4i+ayoeacieWPoOWKoO+8iOS4iuS4i+aciemXtOi3ne+8iVxuIFxuXG5cdCAgICAgICAgICAgIC8vQeWcqELnmoTlj7PkuIrmlrlcblx0ICAgICAgICAgICAgaWYoQV9yYW5nZVBvc1swXVswXSA+PSBCX3JhbmdlUG9zWzJdWzBdKXtcblx0ICAgICAgICAgICAgICAgIHN0YXJ0UG9zID0gQV9yYW5nZVBvc1s1XTtcblx0ICAgICAgICAgICAgICAgIC8vIGVuZFBvcyA9IEJfcmFuZ2VQb3NbMl07XG5cdCAgICAgICAgICAgIH1lbHNlIGlmKEFfcmFuZ2VQb3NbMl1bMF0gPD0gQl9yYW5nZVBvc1swXVswXSl7XG5cdCAgICAgICAgICAgICAgICAvL0HlnKhC55qE5bem5LiK5pa5XG5cdCAgICAgICAgICAgICAgICBzdGFydFBvcyA9IEFfcmFuZ2VQb3NbNV07XG5cdCAgICAgICAgICAgICAgICAvLyBlbmRQb3MgPSBCX3JhbmdlUG9zWzBdO1xuXHQgICAgICAgICAgICB9ZWxzZXtcblx0ICAgICAgICAgICAgICAgIHN0YXJ0UG9zID0gQV9yYW5nZVBvc1s1XTtcblx0ICAgICAgICAgICAgICAgIC8vIGVuZFBvcyA9IEJfcmFuZ2VQb3NbMV07XG5cdCAgICAgICAgICAgIH1cblxuXG5cblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzdGFydFBvcztcblx0fVxuXHRcblx0aWYodHlwZW9mIHRoaXMubGluZUNhY2hlWydcIicrbm9kZUlkKydcIiddICE9PSd1bmRlZmluZWQnICYmXG5cdFx0dHlwZW9mIHRoaXMubGluZUNhY2hlWydcIicrbm9kZUlkKydcIiddLm9sZFN0YXJ0ICE9PSd1bmRlZmluZWQnKXtcblxuXHRcdGlmKCgobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gX3RoaXMubGluZUNhY2hlWydcIicrbm9kZUlkKydcIiddLnN0YXJ0Q2FsbFRpbWUpID4zMDApe1xuXHRcdFx0X3RoaXMubGluZUNhY2hlWydcIicrbm9kZUlkKydcIiddLnN0YXJ0Q2FsbFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHRcdFx0X3RoaXMubGluZUNhY2hlWydcIicrbm9kZUlkKydcIiddLm9sZFN0YXJ0ID0gRigpO1x0XG5cblx0XHR9XG5cblxuXHR9ZWxzZXtcblxuXHRcdGlmKHR5cGVvZiBfdGhpcy5saW5lQ2FjaGVbJ1wiJytub2RlSWQrJ1wiJ10gPT0gJ3VuZGVmaW5lZCcpe1xuXG5cdFx0XHRfdGhpcy5saW5lQ2FjaGVbJ1wiJytub2RlSWQrJ1wiJ10gPSB7fTtcblx0XHR9XG5cblx0XHRfdGhpcy5saW5lQ2FjaGVbJ1wiJytub2RlSWQrJ1wiJ10uc3RhcnRDYWxsVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cdFx0X3RoaXMubGluZUNhY2hlWydcIicrbm9kZUlkKydcIiddLm9sZFN0YXJ0ID0gRigpO1xuXG5cdFx0XG5cblx0fVxuXG5cdHJldHVybiBfdGhpcy5saW5lQ2FjaGVbJ1wiJytub2RlSWQrJ1wiJ10ub2xkU3RhcnQ7IFxuXG5cdFxufTtcblFmbG93LnByb3RvdHlwZS5jYWxjTGluZUVuZFBvcyA9IGZ1bmN0aW9uKEEsQixub2RlSWQpIHtcblx0dmFyIF90aGlzID0gdGhpczsgXG5cblx0Ly8gY29uc29sZS5sb2cobm9kZUlkKTtcblx0XG5cdHZhciBGID0gZnVuY3Rpb24oKXtcblxuXHRcdHZhciBBX2NlbnRlciA9IEEuY2VudGVyUG9pbnRzKCk7XG5cdFx0dmFyIEJfY2VudGVyID0gQi5jZW50ZXJQb2ludHMoKTtcblx0XHR2YXIgQV9yYW5nZVBvcyA9IEEuZ2V0UmFuZ2VQb2ludHMoKTsgXG5cdFx0dmFyIEJfcmFuZ2VQb3MgPSBCLmdldFJhbmdlUG9pbnRzKCk7ICBcblxuXG5cdFx0dmFyIHN0YXJ0UG9zID0gWzAsMF07XG5cdCAgICB2YXIgZW5kUG9zID0gWzAsMF07XG5cblxuXHQgICAgLy/nrKzkuIDnp43mg4XlhrXvvIhB5Zyo5LiLIELlnKjkuIrvvIlcblx0ICAgIC8vIDBfXzFfXzIgICAgXG5cdCAgICAvLyB8ICAgICB8XHQgIFxuXHQgICAgLy8gNyAgQlx0IDNcdCBcblx0ICAgIC8vIHwgICAgIHwgICAgXG5cdCAgICAvLyA2X181X180XHQgIFxuXHQgICAgLy9cdCAg4oaRXG5cdCAgICAvLyAwX18xX18yICAgIFxuXHQgICAgLy8gfCAgICAgfFx0ICBcblx0ICAgIC8vIDcgIEEgIDNcdCBcblx0ICAgIC8vIHwgICAgIHwgICAgXG5cdCAgICAvLyA2X181X180XHQgIFxuXHQgICAgaWYoQV9jZW50ZXIueSA+PSBCX2NlbnRlci55KXtcblxuXHQgICAgICAgIC8v5Lik54K56IqC54K55LiK5LiL5rKh5pyJ6Ze06LedXG5cdCAgICAgICAgaWYoQV9yYW5nZVBvc1swXVsxXSA8PSBCX3JhbmdlUG9zWzZdWzFdKXsgXG5cblx0ICAgICAgICAgICAgLy9B54K55ZyoQueahOWPs+S+p1xuXHQgICAgICAgICAgICBpZihBX3JhbmdlUG9zWzBdWzBdID49IEJfcmFuZ2VQb3NbMl1bMF0pe1xuXG5cdCAgICAgICAgICAgICAgICAvLyBzdGFydFBvcyA9IEFfcmFuZ2VQb3NbN107XG5cdCAgICAgICAgICAgICAgICBlbmRQb3MgPSBCX3JhbmdlUG9zWzNdO1xuXG5cdCAgICAgICAgICAgICAgICBcblx0ICAgICAgICAgICAgfWVsc2UgaWYoQV9yYW5nZVBvc1syXVswXSA8PSBCX3JhbmdlUG9zWzBdWzBdKXtcblx0ICAgICAgICAgICAgICAgIC8vQeeCueWcqELnmoTlt6bkvqdcblx0ICAgICAgICAgICAgICAgIC8vIHN0YXJ0UG9zID0gQV9yYW5nZVBvc1szXTtcblx0ICAgICAgICAgICAgICAgIGVuZFBvcyA9IEJfcmFuZ2VQb3NbN107XG5cblx0ICAgICAgICAgICAgfWVsc2V7XG5cblx0ICAgICAgICAgICAgICAgIC8vIHN0YXJ0UG9zID0gQV9yYW5nZVBvc1sxXTtcblx0ICAgICAgICAgICAgICAgIGVuZFBvcyA9IEJfcmFuZ2VQb3NbMV07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgIH1lbHNleyAvL+S4iuS4i+ayoeacieWPoOWKoO+8iOS4iuS4i+aciemXtOi3ne+8iSBcblxuXHQgICAgICAgICAgICAgLy9B54K55ZyoQueahOWPs+S4i+S+p1xuXHQgICAgICAgICAgICBpZihBX3JhbmdlUG9zWzBdWzBdID49IEJfcmFuZ2VQb3NbMl1bMF0pe1xuXG5cdCAgICAgICAgICAgICAgICAvLyBzdGFydFBvcyA9IEFfcmFuZ2VQb3NbMF07XG5cdCAgICAgICAgICAgICAgICBlbmRQb3MgPSBCX3JhbmdlUG9zWzVdO1xuXG5cdCAgICAgICAgICAgICAgICBcblx0ICAgICAgICAgICAgfWVsc2UgaWYoQV9yYW5nZVBvc1syXVswXSA8PSBCX3JhbmdlUG9zWzJdWzBdKXtcblx0ICAgICAgICAgICAgICAgIC8vQeeCueWcqELnmoTlt6bkuIvkvqdcblx0ICAgICAgICAgICAgICAgIC8vIHN0YXJ0UG9zID0gQV9yYW5nZVBvc1syXTtcblx0ICAgICAgICAgICAgICAgIGVuZFBvcyA9IEJfcmFuZ2VQb3NbNV07XG5cblx0ICAgICAgICAgICAgfWVsc2V7XG5cblx0ICAgICAgICAgICAgICAgIC8vIHN0YXJ0UG9zID0gQV9yYW5nZVBvc1sxXTtcblx0ICAgICAgICAgICAgICAgIGVuZFBvcyA9IEJfcmFuZ2VQb3NbNV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9ZWxzZXtcblx0ICAgICAgICAvL+esrOS6jOenjeaDheWGtSDvvIhB5Zyo5LiKIELlnKjkuIvvvIlcblx0ICAgICAgICAvLyAwX18xX18yICAgIFxuXHRcdFx0Ly8gfCAgICAgfFx0ICBcblx0XHRcdC8vIDcgIEFcdCAzXHQgXG5cdFx0XHQvLyB8ICAgICB8ICAgIFxuXHRcdFx0Ly8gNl9fNV9fNFx0ICBcblx0XHRcdC8vXHQgIOKGk1xuXHRcdFx0Ly8gMF9fMV9fMiAgICBcblx0XHRcdC8vIHwgICAgIHxcdCAgXG5cdFx0XHQvLyA3ICBCICAzXHQgXG5cdFx0XHQvLyB8ICAgICB8ICAgIFxuXHRcdFx0Ly8gNl9fNV9fNFxuXG5cdCAgICAgICAgLy/kuKTngrnoioLngrnkuIrkuIvmsqHmnInpl7Tot51cblx0ICAgICAgICBpZihCX3JhbmdlUG9zWzBdWzFdPD1BX3JhbmdlUG9zWzZdWzFdKXtcbiBcblxuXHQgICAgICAgICAgICAvL0HlnKhC55qE5Y+z5L6nXG5cdCAgICAgICAgICAgIGlmKEFfcmFuZ2VQb3NbMF1bMF0gPj0gQl9yYW5nZVBvc1syXVswXSl7XG5cdCAgICAgICAgICAgICAgICAvLyBzdGFydFBvcyA9IEFfcmFuZ2VQb3NbN107XG5cdCAgICAgICAgICAgICAgICBlbmRQb3MgPSBCX3JhbmdlUG9zWzNdO1xuXG5cdCAgICAgICAgICAgIH1lbHNlIGlmKEFfcmFuZ2VQb3NbMl1bMF0gPD0gQl9yYW5nZVBvc1swXVswXSl7XG5cdCAgICAgICAgICAgICAgICAvL0HlnKhC55qE5bem5L6nXG5cdCAgICAgICAgICAgICAgICAvLyBzdGFydFBvcyA9IEFfcmFuZ2VQb3NbM107XG5cdCAgICAgICAgICAgICAgICBlbmRQb3MgPSBCX3JhbmdlUG9zWzddO1xuXG5cdCAgICAgICAgICAgIH1lbHNle1xuXHQgICAgICAgICAgICAgICAgLy8gc3RhcnRQb3MgPSBBX3JhbmdlUG9zWzVdO1xuXHQgICAgICAgICAgICAgICAgZW5kUG9zID0gQl9yYW5nZVBvc1s1XTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgfWVsc2V7IC8v5LiK5LiL5rKh5pyJ5Y+g5Yqg77yI5LiK5LiL5pyJ6Ze06Led77yJXG5cblxuXHQgICAgICAgICAgICAvL0HlnKhC55qE5Y+z5LiK5pa5XG5cdCAgICAgICAgICAgIGlmKEFfcmFuZ2VQb3NbMF1bMF0gPj0gQl9yYW5nZVBvc1syXVswXSl7XG5cdCAgICAgICAgICAgICAgICAvLyBzdGFydFBvcyA9IEFfcmFuZ2VQb3NbNl07XG5cdCAgICAgICAgICAgICAgICBlbmRQb3MgPSBCX3JhbmdlUG9zWzFdO1xuXHQgICAgICAgICAgICB9ZWxzZSBpZihBX3JhbmdlUG9zWzJdWzBdIDw9IEJfcmFuZ2VQb3NbMF1bMF0pe1xuXHQgICAgICAgICAgICAgICAgLy9B5ZyoQueahOW3puS4iuaWuVxuXHQgICAgICAgICAgICAgICAgLy8gc3RhcnRQb3MgPSBBX3JhbmdlUG9zWzRdO1xuXHQgICAgICAgICAgICAgICAgZW5kUG9zID0gQl9yYW5nZVBvc1sxXTtcblx0ICAgICAgICAgICAgfWVsc2V7XG5cdCAgICAgICAgICAgICAgICAvLyBzdGFydFBvcyA9IEFfcmFuZ2VQb3NbNV07XG5cdCAgICAgICAgICAgICAgICBlbmRQb3MgPSBCX3JhbmdlUG9zWzFdO1xuXHQgICAgICAgICAgICB9XG5cblxuXG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZW5kUG9zO1xuXG5cdH1cblxuXG5cblx0aWYodHlwZW9mIHRoaXMubGluZUNhY2hlWydcIicrbm9kZUlkKydcIiddICE9PSd1bmRlZmluZWQnICYmXG5cdFx0dHlwZW9mIHRoaXMubGluZUNhY2hlWydcIicrbm9kZUlkKydcIiddLm9sZEVuZCAhPT0ndW5kZWZpbmVkJyl7XG5cblx0XHRpZigoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIF90aGlzLmxpbmVDYWNoZVsnXCInK25vZGVJZCsnXCInXS5lbmRDYWxsVGltZSkgPjMwMCl7XG5cdFx0XHRfdGhpcy5saW5lQ2FjaGVbJ1wiJytub2RlSWQrJ1wiJ10uZW5kQ2FsbFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHRcdFx0X3RoaXMubGluZUNhY2hlWydcIicrbm9kZUlkKydcIiddLm9sZEVuZCA9IEYoKTtcdFxuXHRcdH1cblxuXG5cdH1lbHNle1xuXG5cdFx0aWYodHlwZW9mIF90aGlzLmxpbmVDYWNoZVsnXCInK25vZGVJZCsnXCInXSA9PSAndW5kZWZpbmVkJyl7XG5cblx0XHRcdF90aGlzLmxpbmVDYWNoZVsnXCInK25vZGVJZCsnXCInXSA9IHt9O1xuXHRcdH1cblx0XHRfdGhpcy5saW5lQ2FjaGVbJ1wiJytub2RlSWQrJ1wiJ10uZW5kQ2FsbFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHRcdF90aGlzLmxpbmVDYWNoZVsnXCInK25vZGVJZCsnXCInXS5vbGRFbmQgPSBGKCk7XG4gXG5cblx0fVxuXG5cblx0cmV0dXJuIF90aGlzLmxpbmVDYWNoZVsnXCInK25vZGVJZCsnXCInXS5vbGRFbmQ7IFxufTtcblFmbG93LnByb3RvdHlwZS5jYWxjTGluZVBvcyA9IGZ1bmN0aW9uKEEsQixub2RlSWQpIHtcblxuXG5cdHZhciBGID0gZnVuY3Rpb24oKXtcblx0XHR2YXIgQV9jZW50ZXIgPSBBLmNlbnRlclBvaW50cygpO1xuXHRcdHZhciBCX2NlbnRlciA9IEIuY2VudGVyUG9pbnRzKCk7XG5cdFx0dmFyIEFfcmFuZ2VQb3MgPSBBLmdldFJhbmdlUG9pbnRzKCk7IFxuXHRcdHZhciBCX3JhbmdlUG9zID0gQi5nZXRSYW5nZVBvaW50cygpOyAgXG5cblxuXHRcdHZhciBzdGFydFBvcyA9IFswLDBdO1xuXHQgICAgdmFyIGVuZFBvcyA9IFswLDBdO1xuXG5cblx0ICAgIC8v56ys5LiA56eN5oOF5Ya177yIQeWcqOS4iyBC5Zyo5LiK77yJXG5cdCAgICAvLyAwX18xX18yICAgIFxuXHQgICAgLy8gfCAgICAgfFx0ICBcblx0ICAgIC8vIDcgIEJcdCAzXHQgXG5cdCAgICAvLyB8ICAgICB8ICAgIFxuXHQgICAgLy8gNl9fNV9fNFx0ICBcblx0ICAgIC8vXHQgIOKGkVxuXHQgICAgLy8gMF9fMV9fMiAgICBcblx0ICAgIC8vIHwgICAgIHxcdCAgXG5cdCAgICAvLyA3ICBBICAzXHQgXG5cdCAgICAvLyB8ICAgICB8ICAgIFxuXHQgICAgLy8gNl9fNV9fNFx0ICBcblx0ICAgIGlmKEFfY2VudGVyLnkgPj0gQl9jZW50ZXIueSl7XG5cblx0ICAgICAgICAvL+S4pOeCueiKgueCueS4iuS4i+ayoeaciemXtOi3nVxuXHQgICAgICAgIGlmKEFfcmFuZ2VQb3NbMF1bMV0gPD0gQl9yYW5nZVBvc1s2XVsxXSl7IFxuXG5cdCAgICAgICAgICAgIC8vQeeCueWcqELnmoTlj7Pkvqdcblx0ICAgICAgICAgICAgaWYoQV9yYW5nZVBvc1swXVswXSA+PSBCX3JhbmdlUG9zWzJdWzBdKXtcblxuXHQgICAgICAgICAgICAgICAgc3RhcnRQb3MgPSBBX3JhbmdlUG9zWzddO1xuXHQgICAgICAgICAgICAgICAgZW5kUG9zID0gQl9yYW5nZVBvc1szXTtcblxuXHQgICAgICAgICAgICAgICAgXG5cdCAgICAgICAgICAgIH1lbHNlIGlmKEFfcmFuZ2VQb3NbMl1bMF0gPD0gQl9yYW5nZVBvc1swXVswXSl7XG5cdCAgICAgICAgICAgICAgICAvL0HngrnlnKhC55qE5bem5L6nXG5cdCAgICAgICAgICAgICAgICBzdGFydFBvcyA9IEFfcmFuZ2VQb3NbM107XG5cdCAgICAgICAgICAgICAgICBlbmRQb3MgPSBCX3JhbmdlUG9zWzddO1xuXG5cdCAgICAgICAgICAgIH1lbHNle1xuXG5cdCAgICAgICAgICAgICAgICBzdGFydFBvcyA9IEFfcmFuZ2VQb3NbMV07XG5cdCAgICAgICAgICAgICAgICBlbmRQb3MgPSBCX3JhbmdlUG9zWzFdO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICB9ZWxzZXsgLy/kuIrkuIvmsqHmnInlj6DliqDvvIjkuIrkuIvmnInpl7Tot53vvIkgXG5cblx0ICAgICAgICAgICAgIC8vQeeCueWcqELnmoTlj7PkuIvkvqdcblx0ICAgICAgICAgICAgaWYoQV9yYW5nZVBvc1swXVswXSA+PSBCX3JhbmdlUG9zWzJdWzBdKXtcblxuXHQgICAgICAgICAgICAgICAgc3RhcnRQb3MgPSBBX3JhbmdlUG9zWzFdO1xuXHQgICAgICAgICAgICAgICAgZW5kUG9zID0gQl9yYW5nZVBvc1s1XTtcblxuXHQgICAgICAgICAgICAgICAgXG5cdCAgICAgICAgICAgIH1lbHNlIGlmKEFfcmFuZ2VQb3NbMl1bMF0gPD0gQl9yYW5nZVBvc1syXVswXSl7XG5cdCAgICAgICAgICAgICAgICAvL0HngrnlnKhC55qE5bem5LiL5L6nXG5cdCAgICAgICAgICAgICAgICBzdGFydFBvcyA9IEFfcmFuZ2VQb3NbMV07XG5cdCAgICAgICAgICAgICAgICBlbmRQb3MgPSBCX3JhbmdlUG9zWzVdO1xuXG5cdCAgICAgICAgICAgIH1lbHNle1xuXG5cdCAgICAgICAgICAgICAgICBzdGFydFBvcyA9IEFfcmFuZ2VQb3NbMV07XG5cdCAgICAgICAgICAgICAgICBlbmRQb3MgPSBCX3JhbmdlUG9zWzVdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfWVsc2V7XG5cdCAgICAgICAgLy/nrKzkuoznp43mg4XlhrUg77yIQeWcqOS4iiBC5Zyo5LiL77yJXG5cdCAgICAgICAgLy8gMF9fMV9fMiAgICBcblx0XHRcdC8vIHwgICAgIHxcdCAgXG5cdFx0XHQvLyA3ICBBXHQgM1x0IFxuXHRcdFx0Ly8gfCAgICAgfCAgICBcblx0XHRcdC8vIDZfXzVfXzRcdCAgXG5cdFx0XHQvL1x0ICDihpNcblx0XHRcdC8vIDBfXzFfXzIgICAgXG5cdFx0XHQvLyB8ICAgICB8XHQgIFxuXHRcdFx0Ly8gNyAgQiAgM1x0IFxuXHRcdFx0Ly8gfCAgICAgfCAgICBcblx0XHRcdC8vIDZfXzVfXzRcblxuXHQgICAgICAgIC8v5Lik54K56IqC54K55LiK5LiL5rKh5pyJ6Ze06LedXG5cdCAgICAgICAgaWYoQl9yYW5nZVBvc1swXVsxXTw9QV9yYW5nZVBvc1s2XVsxXSl7XG4gXG5cblx0ICAgICAgICAgICAgLy9B5ZyoQueahOWPs+S+p1xuXHQgICAgICAgICAgICBpZihBX3JhbmdlUG9zWzBdWzBdID49IEJfcmFuZ2VQb3NbMl1bMF0pe1xuXHQgICAgICAgICAgICAgICAgc3RhcnRQb3MgPSBBX3JhbmdlUG9zWzddO1xuXHQgICAgICAgICAgICAgICAgZW5kUG9zID0gQl9yYW5nZVBvc1szXTtcblxuXHQgICAgICAgICAgICB9ZWxzZSBpZihBX3JhbmdlUG9zWzJdWzBdIDw9IEJfcmFuZ2VQb3NbMF1bMF0pe1xuXHQgICAgICAgICAgICAgICAgLy9B5ZyoQueahOW3puS+p1xuXHQgICAgICAgICAgICAgICAgc3RhcnRQb3MgPSBBX3JhbmdlUG9zWzNdO1xuXHQgICAgICAgICAgICAgICAgZW5kUG9zID0gQl9yYW5nZVBvc1s3XTtcblxuXHQgICAgICAgICAgICB9ZWxzZXtcblx0ICAgICAgICAgICAgICAgIHN0YXJ0UG9zID0gQV9yYW5nZVBvc1s1XTtcblx0ICAgICAgICAgICAgICAgIGVuZFBvcyA9IEJfcmFuZ2VQb3NbNV07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgIH1lbHNleyAvL+S4iuS4i+ayoeacieWPoOWKoO+8iOS4iuS4i+aciemXtOi3ne+8iVxuXG5cblx0ICAgICAgICAgICAgLy9B5ZyoQueahOWPs+S4iuaWuVxuXHQgICAgICAgICAgICBpZihBX3JhbmdlUG9zWzBdWzBdID49IEJfcmFuZ2VQb3NbMl1bMF0pe1xuXHQgICAgICAgICAgICAgICAgc3RhcnRQb3MgPSBBX3JhbmdlUG9zWzVdO1xuXHQgICAgICAgICAgICAgICAgZW5kUG9zID0gQl9yYW5nZVBvc1sxXTtcblx0ICAgICAgICAgICAgfWVsc2UgaWYoQV9yYW5nZVBvc1syXVswXSA8PSBCX3JhbmdlUG9zWzBdWzBdKXtcblx0ICAgICAgICAgICAgICAgIC8vQeWcqELnmoTlt6bkuIrmlrlcblx0ICAgICAgICAgICAgICAgIHN0YXJ0UG9zID0gQV9yYW5nZVBvc1s1XTtcblx0ICAgICAgICAgICAgICAgIGVuZFBvcyA9IEJfcmFuZ2VQb3NbMV07XG5cdCAgICAgICAgICAgIH1lbHNle1xuXHQgICAgICAgICAgICAgICAgc3RhcnRQb3MgPSBBX3JhbmdlUG9zWzVdO1xuXHQgICAgICAgICAgICAgICAgZW5kUG9zID0gQl9yYW5nZVBvc1sxXTtcblx0ICAgICAgICAgICAgfVxuXG5cblxuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHtcblx0ICAgIFx0c3RhcnQ6c3RhcnRQb3MsXG5cdCAgICBcdGVuZDplbmRQb3Ncblx0ICAgIH1cblxuXHRcdFxuXHR9XG5cblx0aWYodHlwZW9mIHRoaXMubGluZUNhY2hlWydcIicrbm9kZUlkKydcIiddICE9PSd1bmRlZmluZWQnKXtcblxuXHRcdGlmKCgobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gdGhpcy5saW5lQ2FjaGVbJ1wiJytub2RlSWQrJ1wiJ10uY2FsbFRpbWUpID4zMDApe1xuXG5cdFx0XHR0aGlzLmxpbmVDYWNoZVsnXCInK25vZGVJZCsnXCInXS5jYWxsVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cdFx0XHR0aGlzLmxpbmVDYWNoZVsnXCInK25vZGVJZCsnXCInXS5wb3NpdGlvbiA9IEYoKTtcblx0XHR9XG5cblxuXHR9ZWxzZXtcblxuXHRcdHRoaXMubGluZUNhY2hlWydcIicrbm9kZUlkKydcIiddID0ge1xuXHRcdFx0Y2FsbFRpbWU6KG5ldyBEYXRlKCkpLmdldFRpbWUoKSxcblx0XHRcdHBvc2l0aW9uOkYoKVxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHRoaXMubGluZUNhY2hlWydcIicrbm9kZUlkKydcIiddLnBvc2l0aW9uO1xuXHQvLyByZXR1cm4gRigpO1xuXG59O1xuUWZsb3cucHJvdG90eXBlLnNvbHZlTGluayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXHR0aGlzLm9wdGlvbnMuaW5pdERhdGEubGluay5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuXG5cdFx0aXRlbS5mcm9tTm9kZSA9ICBfdGhpcy5nZXROb2RlT2JqKF90aGlzLmdldE5vZGVJZEZyb21Kc29uQnlJZChpdGVtLmZyb21JZCkpO1xuXHRcdGl0ZW0udG9Ob2RlID0gX3RoaXMuZ2V0Tm9kZU9iaihfdGhpcy5nZXROb2RlSWRGcm9tSnNvbkJ5SWQoaXRlbS50b0lkKSk7XG5cblx0XHRpZih0eXBlb2YgaXRlbS5hdHRyLmNvbG9yID09ICd1bmRlZmluZWQnKXtcblxuXHRcdFx0aXRlbS5hdHRyLmNvbG9yID0gX3RoaXMubGluZUNvbG9yO1xuXHRcdH1cblxuXHR9KVxufTtcblFmbG93LnByb3RvdHlwZS5jYWxlSGFuZGxlcjEgPSBmdW5jdGlvbigpIHtcblx0IGlmKHR5cGVvZiB0aGlzLmNhbGVUaW1lMSA9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgKHR5cGVvZiB0aGlzLmNhbGVUaW1lMSAhPT0ndW5kZWZpbmVkJykgJiYgXG4gICAgICAgICAgICAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKS10aGlzLmNhbGVUaW1lMT4xMDAwKVxuICAgICAgICApe1xuXG5cbiAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZCgpO1xuICAgICAgICAgICAgdmFyIHJldHVybkhhbmRsZXIxID0gKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLy9BXG4gICAgICAgICAgICAgICAgLy8gfFxuICAgICAgICAgICAgICAgIC8vaDEgXFwgaDJcbiAgICAgICAgICAgICAgICAvLyAgIOKGk1xuICAgICAgICAgICAgICAgIC8vICAgQlxuICAgICAgICAgICAgICAgIGlmKHN0YXJ0WzBdPGVuZFswXSAmJiBzdGFydFsxXTw9ZW5kWzFdKXtcbiAgICAgICAgICAgICAgICAgICAgLy9oMTogW01hdGguYWJzKHN0YXJ0WzBdIC0gZW5kWzBdKSowLjI1K3N0YXJ0WzBdLE1hdGguYWJzKHN0YXJ0WzFdIC0gZW5kWzFdKSowLjc1K3N0YXJ0WzFdXTtcbiAgICAgICAgICAgICAgICAgICAgLy9oMjogW01hdGguYWJzKHN0YXJ0WzBdIC0gZW5kWzBdKSowLjc1K3N0YXJ0WzBdLE1hdGguYWJzKHN0YXJ0WzFdIC0gZW5kWzFdKSowLjI1K3N0YXJ0WzFdXTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW01hdGguYWJzKHN0YXJ0WzBdIC0gZW5kWzBdKSowLjI1K3N0YXJ0WzBdLE1hdGguYWJzKHN0YXJ0WzFdIC0gZW5kWzFdKSowLjc1K3N0YXJ0WzFdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gIEFcbiAgICAgICAgICAgICAgICAvLyAgfFxuICAgICAgICAgICAgICAgIC8vaDIvaDFcbiAgICAgICAgICAgICAgICAvLyDihpNcbiAgICAgICAgICAgICAgICAvLyBCXG4gICAgICAgICAgICAgICAgaWYoc3RhcnRbMF0+PWVuZFswXSAmJiBzdGFydFsxXTw9ZW5kWzFdKXtcbiAgICAgICAgICAgICAgICAgICAgLy9oMTpbTWF0aC5hYnMoc3RhcnRbMF0gLSBlbmRbMF0pKjAuNzUrZW5kWzBdLE1hdGguYWJzKHN0YXJ0WzFdIC0gZW5kWzFdKSowLjc1K3N0YXJ0WzFdXVxuICAgICAgICAgICAgICAgICAgICAvL2gyOltNYXRoLmFicyhzdGFydFswXSAtIGVuZFswXSkqMC4yNStlbmRbMF0sTWF0aC5hYnMoc3RhcnRbMV0gLSBlbmRbMV0pKjAuMjUrc3RhcnRbMV1dXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbTWF0aC5hYnMoc3RhcnRbMF0gLSBlbmRbMF0pKjAuNzUrZW5kWzBdLE1hdGguYWJzKHN0YXJ0WzFdIC0gZW5kWzFdKSowLjc1K3N0YXJ0WzFdXVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEJcbiAgICAgICAgICAgICAgICAvLyDihpFcbiAgICAgICAgICAgICAgICAvL2gxXFxoMlxuICAgICAgICAgICAgICAgIC8vICB8XG4gICAgICAgICAgICAgICAgLy8gIEFcbiAgICAgICAgICAgICAgICBpZihzdGFydFswXT5lbmRbMF0gJiYgc3RhcnRbMV0+PWVuZFsxXSl7XG4gICAgICAgICAgICAgICAgICAgIC8vaDE6W01hdGguYWJzKHN0YXJ0WzBdIC0gZW5kWzBdKSowLjI1K2VuZFswXSxNYXRoLmFicyhzdGFydFsxXSAtIGVuZFsxXSkqMC43NStlbmRbMV1dO1xuICAgICAgICAgICAgICAgICAgICAvL2gyOltNYXRoLmFicyhzdGFydFswXSAtIGVuZFswXSkqMC43NStlbmRbMF0sTWF0aC5hYnMoc3RhcnRbMV0gLSBlbmRbMV0pKjAuMjUrZW5kWzFdXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtNYXRoLmFicyhzdGFydFswXSAtIGVuZFswXSkqMC4yNStlbmRbMF0sTWF0aC5hYnMoc3RhcnRbMV0gLSBlbmRbMV0pKjAuNzUrZW5kWzFdXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAgIEJcbiAgICAgICAgICAgICAgICAvLyAgIOKGkVxuICAgICAgICAgICAgICAgIC8vIGgyL2gxXG4gICAgICAgICAgICAgICAgLy8gIHxcbiAgICAgICAgICAgICAgICAvLyAgQVxuICAgICAgICAgICAgICAgIGlmKHN0YXJ0WzBdPD1lbmRbMF0gJiYgc3RhcnRbMV0+PWVuZFsxXSl7XG4gICAgICAgICAgICAgICAgICAgIC8vaDE6W01hdGguYWJzKHN0YXJ0WzBdIC0gZW5kWzBdKSowLjc1K3N0YXJ0WzBdLE1hdGguYWJzKHN0YXJ0WzFdIC0gZW5kWzFdKSowLjc1K2VuZFsxXV07XG4gICAgICAgICAgICAgICAgICAgIC8vaDI6W01hdGguYWJzKHN0YXJ0WzBdIC0gZW5kWzBdKSowLjI1K3N0YXJ0WzBdLE1hdGguYWJzKHN0YXJ0WzFdIC0gZW5kWzFdKSowLjI1K2VuZFsxXV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbTWF0aC5hYnMoc3RhcnRbMF0gLSBlbmRbMF0pKjAuNzUrc3RhcnRbMF0sTWF0aC5hYnMoc3RhcnRbMV0gLSBlbmRbMV0pKjAuNzUrZW5kWzFdXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0pKClcblxuXG4gICAgICAgICAgICAvLyB2YXIgeCA9IE1hdGguYWJzKHN0YXJ0WzBdIC0gZW5kWzBdKSooc3RhcnRbMF0gPiBlbmRbMF0/MC43NTowLjI1KStNYXRoLm1pbi5jYWxsKG51bGwsc3RhcnRbMF0sZW5kWzBdKTtcbiAgICAgICAgICAgIC8vIHZhciB5ID0gTWF0aC5hYnMoc3RhcnRbMV0gLSBlbmRbMV0pKjAuNzUrTWF0aC5taW4uY2FsbChudWxsLHN0YXJ0WzFdLGVuZFsxXSk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh4LHkpO1xuICAgICAgICAgICAgdGhpcy5vbGRIYW5kbGVyMSA9IHJldHVybkhhbmRsZXIxO1xuXG4gICAgICAgICAgICB0aGlzLmNhbGVUaW1lMSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcx6ZqU5q615pe26Ze05YaN5omn6KGMIOmZjeS9juaJp+ihjOmikeeOhycpXG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9sZEhhbmRsZXIxO1xuXG4gICAgICAgIH1lbHNleyBcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2xkSGFuZGxlcjE7XG4gICAgICAgIH1cbn07XG5RZmxvdy5wcm90b3R5cGUuY2FsZUhhbmRsZXIyID0gZnVuY3Rpb24oKSB7XG5cdGlmKHR5cGVvZiB0aGlzLmNhbGVUaW1lMiA9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgKHR5cGVvZiB0aGlzLmNhbGVUaW1lMiAhPT0ndW5kZWZpbmVkJykgJiYgXG4gICAgICAgICAgICAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKS10aGlzLmNhbGVUaW1lMj4xMDAwKVxuICAgICAgICApe1xuXG5cbiAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZCgpO1xuICAgICAgICAgICAgIHZhciByZXR1cm5IYW5kbGVyMiA9IChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8vQVxuICAgICAgICAgICAgICAgIC8vIHxcbiAgICAgICAgICAgICAgICAvL2gxIFxcIGgyXG4gICAgICAgICAgICAgICAgLy8gICDihpNcbiAgICAgICAgICAgICAgICAvLyAgIEJcbiAgICAgICAgICAgICAgICBpZihzdGFydFswXTxlbmRbMF0gJiYgc3RhcnRbMV08PWVuZFsxXSl7XG4gICAgICAgICAgICAgICAgICAgIC8vaDE6IFtNYXRoLmFicyhzdGFydFswXSAtIGVuZFswXSkqMC4yNStzdGFydFswXSxNYXRoLmFicyhzdGFydFsxXSAtIGVuZFsxXSkqMC43NStzdGFydFsxXV07XG4gICAgICAgICAgICAgICAgICAgIC8vaDI6IFtNYXRoLmFicyhzdGFydFswXSAtIGVuZFswXSkqMC43NStzdGFydFswXSxNYXRoLmFicyhzdGFydFsxXSAtIGVuZFsxXSkqMC4yNStzdGFydFsxXV07XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtNYXRoLmFicyhzdGFydFswXSAtIGVuZFswXSkqMC43NStzdGFydFswXSxNYXRoLmFicyhzdGFydFsxXSAtIGVuZFsxXSkqMC4yNStzdGFydFsxXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICBBXG4gICAgICAgICAgICAgICAgLy8gIHxcbiAgICAgICAgICAgICAgICAvL2gyL2gxXG4gICAgICAgICAgICAgICAgLy8g4oaTXG4gICAgICAgICAgICAgICAgLy8gQlxuICAgICAgICAgICAgICAgIGlmKHN0YXJ0WzBdPj1lbmRbMF0gJiYgc3RhcnRbMV08PWVuZFsxXSl7XG4gICAgICAgICAgICAgICAgICAgIC8vaDE6W01hdGguYWJzKHN0YXJ0WzBdIC0gZW5kWzBdKSowLjc1K2VuZFswXSxNYXRoLmFicyhzdGFydFsxXSAtIGVuZFsxXSkqMC43NStzdGFydFsxXV1cbiAgICAgICAgICAgICAgICAgICAgLy9oMjpbTWF0aC5hYnMoc3RhcnRbMF0gLSBlbmRbMF0pKjAuMjUrZW5kWzBdLE1hdGguYWJzKHN0YXJ0WzFdIC0gZW5kWzFdKSowLjI1K3N0YXJ0WzFdXVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW01hdGguYWJzKHN0YXJ0WzBdIC0gZW5kWzBdKSowLjI1K2VuZFswXSxNYXRoLmFicyhzdGFydFsxXSAtIGVuZFsxXSkqMC4yNStzdGFydFsxXV1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBCXG4gICAgICAgICAgICAgICAgLy8g4oaRXG4gICAgICAgICAgICAgICAgLy9oMVxcaDJcbiAgICAgICAgICAgICAgICAvLyAgfFxuICAgICAgICAgICAgICAgIC8vICBBXG4gICAgICAgICAgICAgICAgaWYoc3RhcnRbMF0+ZW5kWzBdICYmIHN0YXJ0WzFdPmVuZFsxXSl7XG4gICAgICAgICAgICAgICAgICAgIC8vaDE6W01hdGguYWJzKHN0YXJ0WzBdIC0gZW5kWzBdKSowLjI1K2VuZFswXSxNYXRoLmFicyhzdGFydFsxXSAtIGVuZFsxXSkqMC43NStlbmRbMV1dO1xuICAgICAgICAgICAgICAgICAgICAvL2gyOltNYXRoLmFicyhzdGFydFswXSAtIGVuZFswXSkqMC43NStlbmRbMF0sTWF0aC5hYnMoc3RhcnRbMV0gLSBlbmRbMV0pKjAuMjUrZW5kWzFdXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtNYXRoLmFicyhzdGFydFswXSAtIGVuZFswXSkqMC43NStlbmRbMF0sTWF0aC5hYnMoc3RhcnRbMV0gLSBlbmRbMV0pKjAuMjUrZW5kWzFdXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAgIEJcbiAgICAgICAgICAgICAgICAvLyAgIOKGkVxuICAgICAgICAgICAgICAgIC8vIGgyL2gxXG4gICAgICAgICAgICAgICAgLy8gIHxcbiAgICAgICAgICAgICAgICAvLyAgQVxuICAgICAgICAgICAgICAgIGlmKHN0YXJ0WzBdPD1lbmRbMF0gJiYgc3RhcnRbMV0+ZW5kWzFdKXtcbiAgICAgICAgICAgICAgICAgICAgLy9oMTpbTWF0aC5hYnMoc3RhcnRbMF0gLSBlbmRbMF0pKjAuNzUrc3RhcnRbMF0sTWF0aC5hYnMoc3RhcnRbMV0gLSBlbmRbMV0pKjAuNzUrZW5kWzFdXTtcbiAgICAgICAgICAgICAgICAgICAgLy9oMjpbTWF0aC5hYnMoc3RhcnRbMF0gLSBlbmRbMF0pKjAuMjUrc3RhcnRbMF0sTWF0aC5hYnMoc3RhcnRbMV0gLSBlbmRbMV0pKjAuMjUrZW5kWzFdXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtNYXRoLmFicyhzdGFydFswXSAtIGVuZFswXSkqMC4yNStzdGFydFswXSxNYXRoLmFicyhzdGFydFsxXSAtIGVuZFsxXSkqMC4yNStlbmRbMV1dO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSkoKVxuXG5cblxuXG4gICAgICAgICAgIC8vIHZhciB4ID0gTWF0aC5hYnMoc3RhcnRbMF0gLSBlbmRbMF0pKihzdGFydFswXSA+IGVuZFswXT8wLjI1OjAuNzUpK01hdGgubWluLmNhbGwobnVsbCxzdGFydFswXSxlbmRbMF0pO1xuICAgICAgICAgICAvLyB2YXIgeSA9IE1hdGguYWJzKHN0YXJ0WzFdIC0gZW5kWzFdKSowLjI1K01hdGgubWluLmNhbGwobnVsbCxzdGFydFsxXSxlbmRbMV0pO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coeCx5KTtcbiAgICAgICAgICAgIHRoaXMub2xkSGFuZGxlcjIgPSByZXR1cm5IYW5kbGVyMjtcblxuICAgICAgICAgICAgdGhpcy5jYWxlVGltZTIgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygn6ZqU5q615pe26Ze05YaN5omn6KGMIOmZjeS9juaJp+ihjOmikeeOhycpXG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9sZEhhbmRsZXIyO1xuXG4gICAgICAgIH1lbHNle1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbGRIYW5kbGVyMjtcbiAgICAgICAgfSBcbn07XG5RZmxvdy5wcm90b3R5cGUuY2FsZVF1YWRyYXRpY0N1cnZlSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRpZih0eXBlb2YgdGhpcy5jYWxlVGltZTEgPT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgICh0eXBlb2YgdGhpcy5jYWxlVGltZTEgIT09J3VuZGVmaW5lZCcpICYmIFxuICAgICAgICAgICAgKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCktdGhpcy5jYWxlVGltZTE+MTAwMClcbiAgICAgICAgKXtcblxuXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0KCk7XG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQoKTtcbiAgICAgICAgICAgIHZhciByZXR1cm5IYW5kbGVyMSA9IChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8vQVxuICAgICAgICAgICAgICAgIC8vIHxcbiAgICAgICAgICAgICAgICAvL2gxIFxcIGgyXG4gICAgICAgICAgICAgICAgLy8gICDihpNcbiAgICAgICAgICAgICAgICAvLyAgIEJcbiAgICAgICAgICAgICAgICBpZihzdGFydFswXTxlbmRbMF0gJiYgc3RhcnRbMV08PWVuZFsxXSl7XG4gICAgICAgICAgICAgICAgICAgIC8vaDE6IFtNYXRoLmFicyhzdGFydFswXSAtIGVuZFswXSkqMC4yNStzdGFydFswXSxNYXRoLmFicyhzdGFydFsxXSAtIGVuZFsxXSkqMC43NStzdGFydFsxXV07XG4gICAgICAgICAgICAgICAgICAgIC8vaDI6IFtNYXRoLmFicyhzdGFydFswXSAtIGVuZFswXSkqMC43NStzdGFydFswXSxNYXRoLmFicyhzdGFydFsxXSAtIGVuZFsxXSkqMC4yNStzdGFydFsxXV07XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtNYXRoLmFicyhzdGFydFswXSAtIGVuZFswXSkqMC4yNStzdGFydFswXSxNYXRoLmFicyhzdGFydFsxXSAtIGVuZFsxXSkqMC43NStzdGFydFsxXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICBBXG4gICAgICAgICAgICAgICAgLy8gIHxcbiAgICAgICAgICAgICAgICAvL2gyL2gxXG4gICAgICAgICAgICAgICAgLy8g4oaTXG4gICAgICAgICAgICAgICAgLy8gQlxuICAgICAgICAgICAgICAgIGlmKHN0YXJ0WzBdPj1lbmRbMF0gJiYgc3RhcnRbMV08PWVuZFsxXSl7XG4gICAgICAgICAgICAgICAgICAgIC8vaDE6W01hdGguYWJzKHN0YXJ0WzBdIC0gZW5kWzBdKSowLjc1K2VuZFswXSxNYXRoLmFicyhzdGFydFsxXSAtIGVuZFsxXSkqMC43NStzdGFydFsxXV1cbiAgICAgICAgICAgICAgICAgICAgLy9oMjpbTWF0aC5hYnMoc3RhcnRbMF0gLSBlbmRbMF0pKjAuMjUrZW5kWzBdLE1hdGguYWJzKHN0YXJ0WzFdIC0gZW5kWzFdKSowLjI1K3N0YXJ0WzFdXVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW01hdGguYWJzKHN0YXJ0WzBdIC0gZW5kWzBdKSowLjc1K2VuZFswXSxNYXRoLmFicyhzdGFydFsxXSAtIGVuZFsxXSkqMC43NStzdGFydFsxXV1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBCXG4gICAgICAgICAgICAgICAgLy8g4oaRXG4gICAgICAgICAgICAgICAgLy9oMVxcaDJcbiAgICAgICAgICAgICAgICAvLyAgfFxuICAgICAgICAgICAgICAgIC8vICBBXG4gICAgICAgICAgICAgICAgaWYoc3RhcnRbMF0+ZW5kWzBdICYmIHN0YXJ0WzFdPj1lbmRbMV0pe1xuICAgICAgICAgICAgICAgICAgICAvL2gxOltNYXRoLmFicyhzdGFydFswXSAtIGVuZFswXSkqMC4yNStlbmRbMF0sTWF0aC5hYnMoc3RhcnRbMV0gLSBlbmRbMV0pKjAuNzUrZW5kWzFdXTtcbiAgICAgICAgICAgICAgICAgICAgLy9oMjpbTWF0aC5hYnMoc3RhcnRbMF0gLSBlbmRbMF0pKjAuNzUrZW5kWzBdLE1hdGguYWJzKHN0YXJ0WzFdIC0gZW5kWzFdKSowLjI1K2VuZFsxXV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbTWF0aC5hYnMoc3RhcnRbMF0gLSBlbmRbMF0pKjAuNzUrZW5kWzBdLE1hdGguYWJzKHN0YXJ0WzFdIC0gZW5kWzFdKSowLjI1K2VuZFsxXV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gICBCXG4gICAgICAgICAgICAgICAgLy8gICDihpFcbiAgICAgICAgICAgICAgICAvLyBoMi9oMVxuICAgICAgICAgICAgICAgIC8vICB8XG4gICAgICAgICAgICAgICAgLy8gIEFcbiAgICAgICAgICAgICAgICBpZihzdGFydFswXTw9ZW5kWzBdICYmIHN0YXJ0WzFdPj1lbmRbMV0pe1xuICAgICAgICAgICAgICAgICAgICAvL2gxOltNYXRoLmFicyhzdGFydFswXSAtIGVuZFswXSkqMC43NStzdGFydFswXSxNYXRoLmFicyhzdGFydFsxXSAtIGVuZFsxXSkqMC43NStlbmRbMV1dO1xuICAgICAgICAgICAgICAgICAgICAvL2gyOltNYXRoLmFicyhzdGFydFswXSAtIGVuZFswXSkqMC4yNStzdGFydFswXSxNYXRoLmFicyhzdGFydFsxXSAtIGVuZFsxXSkqMC4yNStlbmRbMV1dO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW01hdGguYWJzKHN0YXJ0WzBdIC0gZW5kWzBdKSowLjI1K3N0YXJ0WzBdLE1hdGguYWJzKHN0YXJ0WzFdIC0gZW5kWzFdKSowLjI1K2VuZFsxXV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9KSgpXG5cblxuICAgICAgICAgICAgLy8gdmFyIHggPSBNYXRoLmFicyhzdGFydFswXSAtIGVuZFswXSkqKHN0YXJ0WzBdID4gZW5kWzBdPzAuNzU6MC4yNSkrTWF0aC5taW4uY2FsbChudWxsLHN0YXJ0WzBdLGVuZFswXSk7XG4gICAgICAgICAgICAvLyB2YXIgeSA9IE1hdGguYWJzKHN0YXJ0WzFdIC0gZW5kWzFdKSowLjc1K01hdGgubWluLmNhbGwobnVsbCxzdGFydFsxXSxlbmRbMV0pO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coeCx5KTtcbiAgICAgICAgICAgIHRoaXMub2xkUXVhZHJhdGljQ3VydmVIYW5kbGVyID0gcmV0dXJuSGFuZGxlcjE7XG5cbiAgICAgICAgICAgIHRoaXMuY2FsZVRpbWUxID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJzHpmpTmrrXml7bpl7Tlho3miafooYwg6ZmN5L2O5omn6KGM6aKR546HJylcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2xkUXVhZHJhdGljQ3VydmVIYW5kbGVyO1xuXG4gICAgICAgIH1lbHNleyBcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2xkUXVhZHJhdGljQ3VydmVIYW5kbGVyO1xuICAgICAgICB9XG59O1xuUWZsb3cucHJvdG90eXBlLmluaXRMaW5rID0gZnVuY3Rpb24oKSB7XG5cdHZhciBfdGhpcyA9IHRoaXM7XG5cdHRoaXMub3B0aW9ucy5pbml0RGF0YS5saW5rLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XG5cblx0aWYodHlwZW9mIGl0ZW0uYXR0ci50eXBlICE9J3VuZGVmaW5lZCcpeyAgXG5cblx0XHRzd2l0Y2ggKGl0ZW0uYXR0ci50eXBlKXtcblx0XHRcdGNhc2UgJ2JlemllckN1cnZlJzogLy/kuInmrKHmm7Lnur9cblx0XHRcdFx0dmFyIHRtcCA9IF90aGlzLnFjYW52YXMucWJlemllckN1cnZlLmJlemllckN1cnZlKHtcblx0XHRcdFx0XHRzdGFydDpmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0dmFyIHRtcCA9IF90aGlzLmNhbGNMaW5lUG9zKGl0ZW0uZnJvbU5vZGUsaXRlbS50b05vZGUsdGhpcy5pZCk7XG5cblx0XHRcdFx0XHRcdHJldHVybiB0bXAuc3RhcnQ7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRlbmQ6ZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdHZhciB0bXAgPSBfdGhpcy5jYWxjTGluZVBvcyhpdGVtLmZyb21Ob2RlLGl0ZW0udG9Ob2RlLHRoaXMuaWQpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdG1wLmVuZDtcblx0XHRcdFx0XHR9LCBcblx0XHRcdFx0XHRoYW5kbGVyMTpfdGhpcy5jYWxlSGFuZGxlcjEsXG5cdFx0XHRcdFx0aGFuZGxlcjI6X3RoaXMuY2FsZUhhbmRsZXIyLFxuXHRcdFx0XHRcdHdpZHRoOjEsXG5cdFx0XHRcdFx0Ly8gcG9pbnRlckV2ZW50Oidub25lJyxcblx0XHRcdFx0XHRkcmFnOmZhbHNlLFxuXHRcdFx0XHRcdGxpa2U6aXRlbS5hdHRyLmxpa2UsXG5cdFx0XHRcdFx0Y29sb3I6aXRlbS5hdHRyLmNvbG9yP2l0ZW0uYXR0ci5jb2xvcjp0aGlzLmxpbmVDb2xvcixcblx0XHRcdFx0XHR3aXRoVGV4dDppdGVtLmF0dHIudGV4dCxcblx0XHRcdFx0XHRtb3VzZXVwOmZ1bmN0aW9uKGUscG9zKXtcblx0XHRcdFx0XHRcdC8v5Y+z5Ye75pi+56S66I+c5Y2VXG5cdFx0XHRcdFx0XHRpZihlLmJ1dHRvbiA9PSAnMicpeyBcblxuXHRcdFx0XHRcdFx0XHRfdGhpcy5jb250ZXh0TGluZU1lbnVOb2RlID0gdGhpcztcblxuXHRcdFx0XHRcdFx0XHRfdGhpcy5xY2FudmFzLnJhaXNlVG9Ub3AoX3RoaXMuY29udGV4dExpbmVNZW51TGF5ZXIpO1xuXHRcdFx0XHRcdFx0XHRfdGhpcy5pbml0TGluZU1lbnUocG9zKTtcblx0XHRcdFx0XHRcdFx0X3RoaXMubGluZU1lbnVMYXllclNob3coKTtcblx0XHQgXG5cdFx0XHRcdFx0XHRcdF90aGlzLmNvbnRleHRTZXR0aW5nSGlkZSgpO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdxdWFkcmF0aWNDdXJ2ZSc6IC8v5LqM5qyh5puy57q/XG5cdFx0XHRcdHZhciB0bXAgPSBfdGhpcy5xY2FudmFzLnFxdWFkcmF0aWNDdXJ2ZS5xdWFkcmF0aWNDdXJ2ZSh7XG5cdFx0XHRcdFx0c3RhcnQ6ZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdHZhciB0bXAgPSBfdGhpcy5jYWxjTGluZVBvcyhpdGVtLmZyb21Ob2RlLGl0ZW0udG9Ob2RlLHRoaXMuaWQpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdG1wLnN0YXJ0O1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZW5kOmZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHR2YXIgdG1wID0gX3RoaXMuY2FsY0xpbmVQb3MoaXRlbS5mcm9tTm9kZSxpdGVtLnRvTm9kZSx0aGlzLmlkKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHRtcC5lbmQ7XG5cdFx0XHRcdFx0fSwgXG5cdFx0XHRcdFx0aGFuZGxlcjpfdGhpcy5jYWxlUXVhZHJhdGljQ3VydmVIYW5kbGVyLCBcblx0XHRcdFx0XHR3aWR0aDoxLFxuXHRcdFx0XHRcdC8vIHBvaW50ZXJFdmVudDonbm9uZScsXG5cdFx0XHRcdFx0ZHJhZzpmYWxzZSxcblx0XHRcdFx0XHRsaWtlOml0ZW0uYXR0ci5saWtlLFxuXHRcdFx0XHRcdGNvbG9yOml0ZW0uYXR0ci5jb2xvcj9pdGVtLmF0dHIuY29sb3I6dGhpcy5saW5lQ29sb3IsXG5cdFx0XHRcdFx0d2l0aFRleHQ6aXRlbS5hdHRyLnRleHQsXG5cdFx0XHRcdFx0bW91c2V1cDpmdW5jdGlvbihlLHBvcyl7XG5cdFx0XHRcdFx0XHQvL+WPs+WHu+aYvuekuuiPnOWNlVxuXHRcdFx0XHRcdFx0aWYoZS5idXR0b24gPT0gJzInKXsgXG5cblx0XHRcdFx0XHRcdFx0X3RoaXMuY29udGV4dExpbmVNZW51Tm9kZSA9IHRoaXM7XG5cblx0XHRcdFx0XHRcdFx0X3RoaXMucWNhbnZhcy5yYWlzZVRvVG9wKF90aGlzLmNvbnRleHRMaW5lTWVudUxheWVyKTtcblx0XHRcdFx0XHRcdFx0X3RoaXMuaW5pdExpbmVNZW51KHBvcyk7XG5cdFx0XHRcdFx0XHRcdF90aGlzLmxpbmVNZW51TGF5ZXJTaG93KCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRfdGhpcy5jb250ZXh0U2V0dGluZ0hpZGUoKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnbGluZSc6XG5cdFx0XHRcdHZhciB0bXAgPSBfdGhpcy5xY2FudmFzLnFsaW5lLmxpbmUoeyAgLy/nm7Tnur9cblx0XHRcdFx0XHRzdGFydDpmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0dmFyIHRtcCA9IF90aGlzLmNhbGNMaW5lUG9zKGl0ZW0uZnJvbU5vZGUsaXRlbS50b05vZGUsdGhpcy5pZCk7XG5cblx0XHRcdFx0XHRcdHJldHVybiB0bXAuc3RhcnQ7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRlbmQ6ZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdHZhciB0bXAgPSBfdGhpcy5jYWxjTGluZVBvcyhpdGVtLmZyb21Ob2RlLGl0ZW0udG9Ob2RlLHRoaXMuaWQpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdG1wLmVuZDtcblx0XHRcdFx0XHR9LCBcblx0XHRcdFx0XHR3aWR0aDoxLFxuXHRcdFx0XHRcdC8vIHBvaW50ZXJFdmVudDonbm9uZScsXG5cdFx0XHRcdFx0ZHJhZzpmYWxzZSxcblx0XHRcdFx0XHRsaWtlOml0ZW0uYXR0ci5saWtlLFxuXHRcdFx0XHRcdGNvbG9yOml0ZW0uYXR0ci5jb2xvcj9pdGVtLmF0dHIuY29sb3I6dGhpcy5saW5lQ29sb3IsXG5cdFx0XHRcdFx0d2l0aFRleHQ6aXRlbS5hdHRyLnRleHQsXG5cdFx0XHRcdFx0bW91c2V1cDpmdW5jdGlvbihlLHBvcyl7XG5cdFx0XHRcdFx0XHQvL+WPs+WHu+aYvuekuuiPnOWNlVxuXHRcdFx0XHRcdFx0aWYoZS5idXR0b24gPT0gJzInKXsgXG5cblx0XHRcdFx0XHRcdFx0X3RoaXMuY29udGV4dExpbmVNZW51Tm9kZSA9IHRoaXM7XG5cblx0XHRcdFx0XHRcdFx0X3RoaXMucWNhbnZhcy5yYWlzZVRvVG9wKF90aGlzLmNvbnRleHRMaW5lTWVudUxheWVyKTtcblx0XHRcdFx0XHRcdFx0X3RoaXMuaW5pdExpbmVNZW51KHBvcyk7XG5cdFx0XHRcdFx0XHRcdF90aGlzLmxpbmVNZW51TGF5ZXJTaG93KCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRfdGhpcy5jb250ZXh0U2V0dGluZ0hpZGUoKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiZm9sZExpbmUxXCI6ICAvL+aoquWQkeaKmOe6v1xuXHRcdFx0Ly8gXHQvL+aKmOe6v+aYr+S4ieadoee6vyDmiYDku6Xov5nph4zov5Tlm57kuIDkuKrmlbDnu4Rcblx0XHRcdC8vIFx0dmFyIHRtcCA9IF90aGlzLmNyZWF0ZUZvbGRMaW5lKGl0ZW0uZnJvbU5vZGUsaXRlbS50b05vZGUsaXRlbS5hdHRyKTtcblx0XHRcdC8vIGJyZWFrO1xuXHRcdFx0Y2FzZSBcImZvbGRMaW5lMlwiOiAgLy/nq5blkJHmipjnur9cblx0XHRcdFx0Ly/mipjnur/mmK/kuInmnaHnur8g5omA5Lul6L+Z6YeM6L+U5Zue5LiA5Liq5pWw57uEXG5cdFx0XHRcdHZhciB0bXAgPSBfdGhpcy5jcmVhdGVGb2xkTGluZShpdGVtLmZyb21Ob2RlLGl0ZW0udG9Ob2RlLGl0ZW0uYXR0cik7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblxuXHRcdFxuXHRcdFxuXHR9ZWxzZXtcblxuXHRcdHZhciB0bXAgPSBfdGhpcy5xY2FudmFzLnFsaW5lLmxpbmUoeyAgLy/nm7Tnur9cblx0XHRcdHN0YXJ0OmZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciB0bXAgPSBfdGhpcy5jYWxjTGluZVBvcyhpdGVtLmZyb21Ob2RlLGl0ZW0udG9Ob2RlLHRoaXMuaWQpO1xuXG5cdFx0XHRcdHJldHVybiB0bXAuc3RhcnQ7XG5cdFx0XHR9LFxuXHRcdFx0ZW5kOmZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciB0bXAgPSBfdGhpcy5jYWxjTGluZVBvcyhpdGVtLmZyb21Ob2RlLGl0ZW0udG9Ob2RlLHRoaXMuaWQpO1xuXG5cdFx0XHRcdHJldHVybiB0bXAuZW5kO1xuXHRcdFx0fSwgXG5cdFx0XHR3aWR0aDoxLFxuXHRcdFx0Ly8gcG9pbnRlckV2ZW50Oidub25lJyxcblx0XHRcdGRyYWc6ZmFsc2UsXG5cdFx0XHRsaWtlOml0ZW0uYXR0ci5saWtlLFxuXHRcdFx0Y29sb3I6aXRlbS5hdHRyLmNvbG9yP2l0ZW0uYXR0ci5jb2xvcjp0aGlzLmxpbmVDb2xvcixcblx0XHRcdHdpdGhUZXh0Oml0ZW0uYXR0ci50ZXh0LFxuXHRcdFx0bW91c2V1cDpmdW5jdGlvbihlLHBvcyl7XG5cdFx0XHRcdC8v5Y+z5Ye75pi+56S66I+c5Y2VXG5cdFx0XHRcdGlmKGUuYnV0dG9uID09ICcyJyl7IFxuXG5cdFx0XHRcdFx0X3RoaXMuY29udGV4dExpbmVNZW51Tm9kZSA9IHRoaXM7XG5cblx0XHRcdFx0XHRfdGhpcy5xY2FudmFzLnJhaXNlVG9Ub3AoX3RoaXMuY29udGV4dExpbmVNZW51TGF5ZXIpO1xuXHRcdFx0XHRcdF90aGlzLmluaXRMaW5lTWVudShwb3MpO1xuXHRcdFx0XHRcdF90aGlzLmxpbmVNZW51TGF5ZXJTaG93KCk7XG4gXG5cdFx0XHRcdFx0X3RoaXMuY29udGV4dFNldHRpbmdIaWRlKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0fSk7XG5cblxuXHR9XG5cblxuXHRcdGlmKF90aGlzLnFjYW52YXMuaXNBcnIodG1wKSl7XG5cdFx0XHRpdGVtLmxpbmVJZCA9IHRtcFsxXS5pZDtcblx0XHRcdF90aGlzLmxpbmVMYXllci5wdXNoKHRtcFswXSx0bXBbMV0sdG1wWzJdKTtcblxuXHRcdH1lbHNle1xuXG5cdFx0XHRpdGVtLmxpbmVJZCA9IHRtcC5pZDtcblx0XHRcdF90aGlzLmxpbmVMYXllci5wdXNoKHRtcCk7XG5cdFx0fVxuXHRcdC8vIF90aGlzLmxpbmVDYWNoZVt0bXAuaWRdID0gdG1wO1xuXG5cblx0fSlcblx0XG59OyBcblxuLyoqXG4gKiDorqHnrpfmipjnur/nmoTkvY3nva5cbiAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICovXG5RZmxvdy5wcm90b3R5cGUuY2FsZUZvbGRMaW5lUG9zaXRpb24gPSBmdW5jdGlvbihmcm9tTm9kZSx0b05vZGUsYXR0cixpZCl7XG5cdFx0dmFyIHRtcCA9IHRoaXMuY2FsY0xpbmVQb3MoZnJvbU5vZGUsdG9Ob2RlLGlkKTtcblx0XHR2YXIgc3RhcnQgPSB0bXAuc3RhcnQ7XG4gICAgICAgIHZhciBlbmQgPSB0bXAuZW5kOyAgXG5cbiAgICAgICAgdmFyIHBlcmNlbnQgPSBhdHRyLmRpc1BlcmNlbnQ/YXR0ci5kaXNQZXJjZW50OjAuNTtcblxuICAgICAgICBpZihhdHRyLnR5cGUgPT0gJ2ZvbGRMaW5lMScpe1xuXHRcdFx0Ly/mqKHlkJHmqKHlvI9cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAnbDEnOmZ1bmN0aW9uKCl7cmV0dXJuIFtzdGFydCxbc3RhcnRbMF0sKGVuZFsxXS1zdGFydFsxXSkqcGVyY2VudCtzdGFydFsxXV1dfSxcblx0ICAgICAgICAgICAgJ2wyJzpmdW5jdGlvbigpe3JldHVybiBbW3N0YXJ0WzBdLChlbmRbMV0tc3RhcnRbMV0pKnBlcmNlbnQrc3RhcnRbMV1dLFtlbmRbMF0sKGVuZFsxXS1zdGFydFsxXSkqcGVyY2VudCtzdGFydFsxXV1dfSxcblx0ICAgICAgICAgICAgJ2wzJzpmdW5jdGlvbigpe3JldHVybiBbW2VuZFswXSwoZW5kWzFdLXN0YXJ0WzFdKSpwZXJjZW50K3N0YXJ0WzFdXSxlbmRdfVxuXHQgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGF0dHIudHlwZSA9PSAnZm9sZExpbmUyJyl7XG4gICAgICAgIFx0Ly/nq5blkJHmqKHlvI9cbiAgICAgICAgXHRyZXR1cm4ge1xuICAgICAgICAgICAgICAgICdsMSc6ZnVuY3Rpb24oKXtyZXR1cm4gW3N0YXJ0LFsoZW5kWzBdLXN0YXJ0WzBdKSpwZXJjZW50K3N0YXJ0WzBdLHN0YXJ0WzFdXV19LFxuICAgICAgICAgICAgICAgICdsMic6ZnVuY3Rpb24oKXtyZXR1cm4gW1soZW5kWzBdLXN0YXJ0WzBdKSpwZXJjZW50K3N0YXJ0WzBdLHN0YXJ0WzFdXSxbKGVuZFswXS1zdGFydFswXSkqcGVyY2VudCtzdGFydFswXSxlbmRbMV1dXX0sXG4gICAgICAgICAgICAgICAgJ2wzJzpmdW5jdGlvbigpe3JldHVybiBbWyhlbmRbMF0tc3RhcnRbMF0pKnBlcmNlbnQrc3RhcnRbMF0sZW5kWzFdXSxlbmRdfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gXG4gICAgICAgXG59XG5cbi8qKlxuICog5Yib5bu65oqY57q/XG4gKiBAcGFyYW0gIHtbdHlwZV19IGZyb21Ob2RlIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge1t0eXBlXX0gdG9Ob2RlICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7W3R5cGVdfSBsaW5lSWQgICBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuUWZsb3cucHJvdG90eXBlLmNyZWF0ZUZvbGRMaW5lID0gZnVuY3Rpb24oZnJvbU5vZGUsdG9Ob2RlLGF0dHIpe1xuXHQvLyB2YXIgZm9sZExpbmVQb3N0aW9ucyA9IHRoaXMuY2FsZUZvbGRMaW5lUG9zaXRpb24oZnJvbU5vZGUsdG9Ob2RlKTtcblxuXHQvLyBjb25zb2xlLmxvZyhmb2xkTGluZVBvc3Rpb25zLmwxKCkpO1xuXHQvLyBjb25zb2xlLmxvZyhmb2xkTGluZVBvc3Rpb25zLmwyKCkpO1xuXHQvLyBjb25zb2xlLmxvZyhmb2xkTGluZVBvc3Rpb25zLmwzKCkpO1xuXHRcblx0XG4gXG5cblxuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXHR2YXIgbDEgPSAoZnVuY3Rpb24oZnJvbU5vZGUsdG9Ob2RlLGF0dHIpe1xuXHRcdHZhciB0bXAgPSBudWxsO1xuXHRcdHJldHVybiBfdGhpcy5xY2FudmFzLnFsaW5lLmxpbmUoe1xuXHQgICAgICAgIHN0YXJ0OmZ1bmN0aW9uKCl7XG5cdCAgICAgICAgICAgIHZhciBwb2ludHMgPSB0bXAgPT09IG51bGw/X3RoaXMuY2FsZUZvbGRMaW5lUG9zaXRpb24oZnJvbU5vZGUsdG9Ob2RlLGF0dHIsdGhpcy5pZCk6dG1wO1xuXHQgICAgICAgICAgICAvLyB2YXIgcG9pbnRzID0gX3RoaXMuY2FsZUZvbGRMaW5lUG9zaXRpb24oZnJvbU5vZGUsdG9Ob2RlLGF0dHIpO1xuXG5cdCAgICAgICAgICAgIHZhciB0ID0gcG9pbnRzWydsMSddKCk7XG5cdCAgICAgICAgICAgIHJldHVybiB0WzBdO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZW5kOmZ1bmN0aW9uKCl7XG5cdCAgICAgICAgICAgIHZhciBwb2ludHMgPSB0bXAgPT09IG51bGw/X3RoaXMuY2FsZUZvbGRMaW5lUG9zaXRpb24oZnJvbU5vZGUsdG9Ob2RlLGF0dHIsdGhpcy5pZCk6dG1wO1xuXHQgICAgICAgICAgICAvLyB2YXIgcG9pbnRzID0gX3RoaXMuY2FsZUZvbGRMaW5lUG9zaXRpb24oZnJvbU5vZGUsdG9Ob2RlLGF0dHIpO1xuXG5cdCAgICAgICAgICAgIHZhciB0ID0gcG9pbnRzWydsMSddKCk7XG5cdCAgICAgICAgICAgIHJldHVybiB0WzFdO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgcG9pbnRlckV2ZW50Oidub25lJyxcblx0ICAgICAgICB3aWR0aDoxLFxuXHRcdFx0bGlrZTpfdGhpcy5saW5lMUxpa2VbYXR0ci5saWtlXSxcblx0XHRcdGNvbG9yOmF0dHIuY29sb3I/YXR0ci5jb2xvcjpfdGhpcy5saW5lQ29sb3IsXG5cdCAgICB9KVxuXG5cdH0pKGZyb21Ob2RlLHRvTm9kZSxhdHRyKSBcblxuXG4gICAgdmFyIGwzID0oZnVuY3Rpb24oZnJvbU5vZGUsdG9Ob2RlLGF0dHIpe1xuICAgIFx0dmFyIHRtcCA9IG51bGw7XG4gICAgXHRyZXR1cm4gX3RoaXMucWNhbnZhcy5xbGluZS5saW5lKHtcblx0ICAgICAgICBzdGFydDpmdW5jdGlvbigpe1xuXHQgICAgICAgICAgICB2YXIgcG9pbnRzID0gdG1wID09PSBudWxsP190aGlzLmNhbGVGb2xkTGluZVBvc2l0aW9uKGZyb21Ob2RlLHRvTm9kZSxhdHRyLHRoaXMuaWQpOnRtcDtcblx0ICAgICAgICAgICAgLy8gdmFyIHBvaW50cyA9IF90aGlzLmNhbGVGb2xkTGluZVBvc2l0aW9uKGZyb21Ob2RlLHRvTm9kZSxhdHRyKTtcblxuXHQgICAgICAgICAgICB2YXIgdCA9IHBvaW50c1snbDMnXSgpO1xuXHQgICAgICAgICAgICByZXR1cm4gdFswXTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVuZDpmdW5jdGlvbigpe1xuXHQgICAgICAgICAgICB2YXIgcG9pbnRzID0gdG1wID09PSBudWxsP190aGlzLmNhbGVGb2xkTGluZVBvc2l0aW9uKGZyb21Ob2RlLHRvTm9kZSxhdHRyLHRoaXMuaWQpOnRtcDtcblx0ICAgICAgICAgICAgLy8gdmFyIHBvaW50cyA9IF90aGlzLmNhbGVGb2xkTGluZVBvc2l0aW9uKGZyb21Ob2RlLHRvTm9kZSxhdHRyKTtcblxuXHQgICAgICAgICAgICB2YXIgdCA9IHBvaW50c1snbDMnXSgpO1xuXHQgICAgICAgICAgICByZXR1cm4gdFsxXTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHBvaW50ZXJFdmVudDonbm9uZScsXG5cdCAgICAgICAgd2lkdGg6MSxcblx0ICAgICAgICBsaWtlOl90aGlzLmxpbmUzTGlrZVthdHRyLmxpa2VdLFxuXHRcdFx0Y29sb3I6YXR0ci5jb2xvcj9hdHRyLmNvbG9yOl90aGlzLmxpbmVDb2xvcixcblx0ICAgIH0pXG5cblxuICAgIH0pKGZyb21Ob2RlLHRvTm9kZSxhdHRyKSBcbiAgICBcblxuICAgIHZhciBsMiA9KGZ1bmN0aW9uKGZyb21Ob2RlLHRvTm9kZSxhdHRyKXtcbiAgICBcdHZhciB0bXAgPSBudWxsO1xuICAgIFx0IHJldHVybiBfdGhpcy5xY2FudmFzLnFsaW5lLmxpbmUoe1xuXHQgICAgICAgIHN0YXJ0OmZ1bmN0aW9uKCl7XG5cdCAgICAgICAgICAgIHZhciBwb2ludHMgPSB0bXAgPT09IG51bGw/X3RoaXMuY2FsZUZvbGRMaW5lUG9zaXRpb24oZnJvbU5vZGUsdG9Ob2RlLGF0dHIsdGhpcy5pZCk6dG1wO1xuXHQgICAgICAgICAgICAvLyB2YXIgcG9pbnRzID0gX3RoaXMuY2FsZUZvbGRMaW5lUG9zaXRpb24oZnJvbU5vZGUsdG9Ob2RlLGF0dHIpO1xuXG5cdCAgICAgICAgICAgIHZhciB0ID0gcG9pbnRzWydsMiddKCk7XG5cdCAgICAgICAgICAgIHJldHVybiB0WzBdO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZW5kOmZ1bmN0aW9uKCl7XG5cdCAgICAgICAgICAgIHZhciBwb2ludHMgPSB0bXAgPT09IG51bGw/X3RoaXMuY2FsZUZvbGRMaW5lUG9zaXRpb24oZnJvbU5vZGUsdG9Ob2RlLGF0dHIsdGhpcy5pZCk6dG1wO1xuXHQgICAgICAgICAgICAvLyB2YXIgcG9pbnRzID0gX3RoaXMuY2FsZUZvbGRMaW5lUG9zaXRpb24oZnJvbU5vZGUsdG9Ob2RlLGF0dHIpO1xuXG5cdCAgICAgICAgICAgIHZhciB0ID0gcG9pbnRzWydsMiddKCk7XG5cdCAgICAgICAgICAgIHJldHVybiB0WzFdO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLy8gcG9pbnRlckV2ZW50Oidub25lJyxcblx0ICAgICAgICBkcmFnOmZhbHNlLFxuXHQgICAgICAgIHdpZHRoOjEsXG5cdFx0XHRsaWtlOl90aGlzLmxpbmUyTGlrZVthdHRyLmxpa2VdLFxuXHRcdFx0Y29sb3I6YXR0ci5jb2xvcj9hdHRyLmNvbG9yOl90aGlzLmxpbmVDb2xvcixcblx0XHRcdHdpdGhUZXh0OmF0dHIudGV4dCxcblxuXHRcdFx0Ly/miopsMeWSjGwy5YGa5Liq5YWz6IGUXG5cdFx0XHRyZWxhdGlvbkxpbmVJZDpbbDEuaWQsbDMuaWRdLFxuXHRcdFx0bW91c2V1cDpmdW5jdGlvbihlLHBvcyl7XG5cdFx0XHRcdFx0XHRcdC8v5Y+z5Ye75pi+56S66I+c5Y2VXG5cdFx0XHRcdFx0XHRcdGlmKGUuYnV0dG9uID09ICcyJyl7IFxuXG5cdFx0XHRcdFx0XHRcdFx0X3RoaXMuY29udGV4dExpbmVNZW51Tm9kZSA9IHRoaXM7XG5cblx0XHRcdFx0XHRcdFx0XHRfdGhpcy5xY2FudmFzLnJhaXNlVG9Ub3AoX3RoaXMuY29udGV4dExpbmVNZW51TGF5ZXIpO1xuXHRcdFx0XHRcdFx0XHRcdF90aGlzLmluaXRMaW5lTWVudShwb3MpO1xuXHRcdFx0XHRcdFx0XHRcdF90aGlzLmxpbmVNZW51TGF5ZXJTaG93KCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdFx0X3RoaXMuY29udGV4dFNldHRpbmdIaWRlKCk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0ICAgIH0pXG4gICAgfSkoZnJvbU5vZGUsdG9Ob2RlLGF0dHIpIFxuICAgXG5cbiAgICByZXR1cm4gW2wxLGwyLGwzXTtcblxufVxuUWZsb3cucHJvdG90eXBlLnVwZGF0ZUluaXREYXRhID0gZnVuY3Rpb24ob2JqLGpzb25PYmopIHtcblx0anNvbk9iai54ID0gb2JqLnN0YXJ0WzBdO1xuXHRqc29uT2JqLnkgPSBvYmouc3RhcnRbMV07XG5cblxuXHRpZihqc29uT2JqLm5vZGVUeXBlID09ICdjb250YWluZXInKXtcblxuXHRcdC8v6ZmN5L2O5omn6KGM55qE6aKR5bqmXG5cdFx0Ly8gaWYoKHR5cGVvZiBqc29uT2JqLmF0dHIuY2FsbFRpbWUgIT0gJ3VuZGVmaW5lZCcgJiYgXG5cdFx0Ly8gXHQoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIGpzb25PYmouYXR0ci5jYWxsVGltZSA+MjAwKSkgfHwgXG5cdFx0Ly8gXHR0eXBlb2YganNvbk9iai5hdHRyLmNhbGxUaW1lID09ICd1bmRlZmluZWQnXG5cdFx0Ly8gXHQpe1xuXG5cdFx0XHQvL+avj+S4gOatpSDmm7TmlrBhdHRyLmdyaWRQb3NpdGlvbiBcblx0XHRcdC8v5YWI5a6e546wdG9wLWNlbnRlclxuXHRcdFx0Ly/lj6/ku6XmkYbmlL7lrZDpobnnmoTljLrln5/kvY3nva5b5bem5LiK6KeS5byA5aeL5L2N572u77yM5Y+z5LiL6KeS57uT5p2f5L2N572uXVxuXHRcdFx0dmFyIGNoaWxkQXJlYVBvc2l0aW9uID0gdGhpcy5nZXRDaGlsZEFyZWFQb3NpdGlvbihqc29uT2JqKTtcblxuXHRcdFx0Ly/lj6/ku6XmkYbmlL7lrZDpobnnmoTljLrln5/kvY3nva4g6K6h566X5Ye65ZCE5Liq5qC85a2Q55qE5Z2Q5qCHXG5cdFx0XHR2YXIgY2hpbGRQb3NpdGlvbiA9IHRoaXMuZ2V0Q2hpbGRQb3NpdGlvbihqc29uT2JqLGNoaWxkQXJlYVBvc2l0aW9uKTtcblxuXHRcdFx0Ly/miormoLzlrZDlnZDmoIfmt7vliqDliLBldHRy6YeMXG5cdFx0XHRqc29uT2JqLmF0dHIuZ3JpZFBvc2l0aW9uID0gY2hpbGRQb3NpdGlvbjtcblxuXHRcdFx0Ly8ganNvbk9iai5hdHRyLmNhbGxUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblx0XHQvLyB9XG5cblx0XHRcblxuXHRcdC8v56ys5LqM5q2lIOabtOaWsOWtkOmhueS9jee9riBcblx0XHQvLyBqc29uT2JqLmNoaWxkTm9kZXMgJiYganNvbk9iai5jaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSxpbmRleCl7XG5cdFx0Ly8gXHRpdGVtLnN0YXJ0ID0gW2NoaWxkUG9zaXRpb25baW5kZXhdLngsY2hpbGRQb3NpdGlvbltpbmRleF0ueV07IFxuXHRcdC8vIH0pXG5cdH1cbiBcblxuXG5cbn07XG5RZmxvdy5wcm90b3R5cGUuaW5pdE5vZGVUaXRsZSA9IGZ1bmN0aW9uKGpzb25PYmosbm9kZU9iaikge1xuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXHR2YXIgdCA9IHRoaXMucWNhbnZhcy5xdGV4dC50ZXh0KHtcblx0XHRcdHN0YXJ0OmZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciBzdGFydCA9IF90aGlzLnFjYW52YXMuaXNGdW4obm9kZU9iai5zdGFydCk/bm9kZU9iai5zdGFydCgpOm5vZGVPYmouc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBbc3RhcnRbMF0rbm9kZU9iai53aWR0aCowLjUsc3RhcnRbMV0rbm9kZU9iai5oZWlnaHQqMC41XVxuXHRcdFx0XHQvLyByZXR1cm4gW3RtcFswXS5zdGFydFswXSt0bXBbMF0ud2lkdGgqMC41LHRtcFswXS5zdGFydFsxXSt0bXBbMF0uaGVpZ2h0KjAuNV07XG5cdFx0XHR9LFxuXHRcdFx0dGV4dDpqc29uT2JqLnRleHQsXG5cdFx0XHRwb2ludGVyRXZlbnQ6J25vbmUnLFxuXHRcdFx0Y29sb3I6anNvbk9iai5hdHRyICYmIGpzb25PYmouYXR0ci5jb2xvcj9qc29uT2JqLmF0dHIuY29sb3I6JyMwMDAnLFxuXHRcdFx0Zm9udFNpemU6JzEycHgnLFxuXHRcdFx0b3duZXJJZDpqc29uT2JqLm5vZGVJZFxuXG5cdFx0fSlcblxuXHR0aGlzLnFub2Rlcy5wdXNoKHQpO1xuXHRqc29uT2JqLmF0dHIudGl0bGVJZCA9IHQuaWQ7XG5cblxuIFxufTtcbi8qKlxuICog57uZ5a655Zmo5Yib5bu65qCH6aKY6IqC54K5XG4gKiBAcGFyYW0gIHtbdHlwZV19IG9iaiAgW2pzb27mlbDmja7lr7nosaFdXG4gKiBAcGFyYW0gIHtbdHlwZV19IHFvYmogW+WuueWZqOiKgueCueWvueixoV1cbiAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXG4gKi9cblFmbG93LnByb3RvdHlwZS5pbml0Q29udGFpbmVyVGl0bGUgPSBmdW5jdGlvbihvYmoscW9iaikge1xuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXHQgXG5cblx0XHR2YXIgdCA9IHRoaXMucWNhbnZhcy5xdGV4dC50ZXh0KHtcblx0XHRcdFx0c3RhcnQ6ZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRyZXR1cm4gW3FvYmouc3RhcnRbMF0rcW9iai53aWR0aCowLjUscW9iai5zdGFydFsxXStfdGhpcy5jb250YWluZXJUaXRsZUhlaWdodCowLjVdO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0ZXh0Om9iai50ZXh0LFxuXHRcdFx0XHRwb2ludGVyRXZlbnQ6J25vbmUnLFxuXHRcdFx0XHRjb2xvcjpvYmouYXR0cj9vYmouYXR0ci5jb2xvcjonIzAwMCcsXG5cdFx0XHRcdGZvbnRTaXplOicxMnB4Jyxcblx0XHRcdFx0b3duZXJJZDpvYmoubm9kZUlkXG5cdFx0XHR9KVxuXG5cdFx0dGhpcy5xbm9kZXMucHVzaCh0KTtcblxuXHRcdC8v5qCH6aKY6IqC54K555qEaWTorrDliLBjb250YWluZXLoioLngrlqc29u5pWw5o2u5LiKXG5cdFx0b2JqLmF0dHIudGl0bGVJZCA9IHQuaWQ7XG4gXG59O1xuUWZsb3cucHJvdG90eXBlLmRyYXdOb2RlID0gZnVuY3Rpb24ocGFyZW50Tm9kZSxub2RlcykgeyBcbiBcblx0dmFyIF90aGlzID0gdGhpcztcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuXG5cdFx0aWYocGFyZW50Tm9kZSE9PSBudWxsKXtcblxuXHRcdFx0Ly/liJvlu7rmn5DkuKrlrrnlmajph4zljIXlkKvnmoToioLngrlcblx0XHRcdF90aGlzLmNyZWF0ZUNoaWxkc09mQ29udGFpbmVyKHBhcmVudE5vZGUsbm9kZXNbaV0saSk7XG4gXG5cdFx0fWVsc2V7XG5cblx0XHRcdGlmKG5vZGVzW2ldLm5vZGVUeXBlID09J3RpcCcpe1xuXHRcdFx0XHRfdGhpcy5jcmVhdGVUaXBOb2RlKG5vZGVzW2ldKTtcblxuXHRcdFx0fWVsc2V7XG5cblx0XHRcdFx0Ly/liJvlu7rlrrnlmajmiJboioLngrnvvIjpobbnuqfnmoTlubPooYzmlbDmja7vvIlcblx0XHRcdFx0X3RoaXMuY3JlYXRlQ29udGFpbmVyT3JOb2RlKG5vZGVzW2ldKTsgXG5cblx0XHRcdH1cblxuXHRcdH1cblx0fVxufTtcbi8qKlxuICog5Yib5bu6Y29udGFpbmVy55qE5a2Q6aG5XG4gKiBAcGFyYW0gIHtbdHlwZV19IHBhcmVudE5vZGUgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7W3R5cGVdfSBqc29uT2JqICAgIFvlrZDpoblqc29u5pWw5o2uXVxuICogQHBhcmFtICB7W3R5cGVdfSBpbmRleCAgICAgIFvlrZDpobnlnKhjb250YWluZXLph4znmoTntKLlvJVdXG4gKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5RZmxvdy5wcm90b3R5cGUuY3JlYXRlQ2hpbGRzT2ZDb250YWluZXIgPSBmdW5jdGlvbihwYXJlbnROb2RlLGpzb25PYmosaW5kZXgpIHtcblx0dmFyIF90aGlzID0gdGhpczsgXG5cdHZhciB0bXAgPSB0aGlzLnFjYW52YXMucXJlY3QucmVjdCh7XG5cdFx0XHRcdCAvLyBzdGFydDpbcGFyZW50Tm9kZS5hdHRyLmdyaWRQb3NpdGlvbltpbmRleF0ueCxwYXJlbnROb2RlLmF0dHIuZ3JpZFBvc2l0aW9uW2luZGV4XS55XSxcblxuXHRcdFx0XHQgc3RhcnQ6ZnVuY3Rpb24oKXtcblx0XHRcdFx0IFx0cmV0dXJuIFtwYXJlbnROb2RlLmF0dHIuZ3JpZFBvc2l0aW9uW3RoaXMuc29ydF0ueCxwYXJlbnROb2RlLmF0dHIuZ3JpZFBvc2l0aW9uW3RoaXMuc29ydF0ueV1cblx0XHRcdFx0IH0sXG5cdFx0XHRcdCBzb3J0OmluZGV4LFxuXHRcdFx0XHQgbm9kZVR5cGU6anNvbk9iai5ub2RlVHlwZSxcblx0XHRcdFx0IHdpZHRoOmpzb25PYmoud2lkdGg/anNvbk9iai53aWR0aDp0aGlzLmNoaWxkTm9kZVdpZHRoLFxuXHRcdFx0XHQgaGVpZ2h0Ompzb25PYmouaGVpZ2h0P2pzb25PYmouaGVpZ2h0OnRoaXMuY2hpbGROb2RlSGVpZ2h0LFxuXHRcdFx0XHQgYm9yZGVyQ29sb3I6anNvbk9iai5hdHRyICYmIGpzb25PYmouYXR0ci5ib3JkZXJDb2xvcj9qc29uT2JqLmF0dHIuYm9yZGVyQ29sb3I6dGhpcy5jaGlsZE5vZGVCb3JkZXJDb2xvciwgXG5cdFx0XHRcdCBmaWxsQ29sb3I6anNvbk9iai5hdHRyICYmIGpzb25PYmouYXR0ci5maWxsQ29sb3I/anNvbk9iai5hdHRyLmZpbGxDb2xvcjp0aGlzLmNoaWxkTm9kZUZpbGxDb2xvciwgXG5cdFx0XHRcdCBkYXNoZWQ6anNvbk9iai5hdHRyICYmIGpzb25PYmouYXR0ci5kYXNoZWQ/anNvbk9iai5hdHRyLmRhc2hlZDpmYWxzZSwgIFxuXHRcdFx0XHQgZHJhZzpmYWxzZSxcblx0XHRcdFx0IG93bmVySWQ6cGFyZW50Tm9kZS5ub2RlSWQsXG5cdFx0XHRcdCBsaW5lV2lkdGg6MSxcblx0XHRcdFx0IGdldFJhbmdlUG9pbnRzOmZ1bmN0aW9uKCl7IC8v6L+U5ZuecmVjdOi+ueS4iueahDjkuKrngrnnmoTlnZDmoIcgXG5cdFx0XHRcdCBcdHJldHVybiBfdGhpcy5jcmVhdGVSYW5nZVBvaW50cyh0aGlzLnBvbHlQb2ludHMoKSk7XG5cdFx0XHRcdCB9LFxuXHRcdFx0XHQgbW91c2VlbnRlcjpmdW5jdGlvbigpeyBcblx0XHRcdFx0XHRfdGhpcy5zZXR0aW5nSWNvU2hvdyh0aGlzKTtcblxuXHRcdFx0XHQgfSxcblx0XHRcdFx0IG1vdXNlZG93bjpmdW5jdGlvbigpeyBcblx0XHRcdFx0IFx0XHRfdGhpcy5kZWxUbXBMaW5lKCk7XG5cdFx0XHRcdCBcdFx0X3RoaXMuY3JlYXRlTmV3TGluZSh0aGlzLGpzb25PYmopO1xuXG5cdFx0XHRcdCBcdFx0X3RoaXMudGlwVGV4dEhpZGUoKTtcblx0XHRcdFx0IFx0XHRcblx0XHRcdFx0IFx0XHRfdGhpcy5tZW51TGF5ZXJIaWRlKCk7XG5cdFx0XHRcdFx0IFx0X3RoaXMuZHJhZ2luZyA9IHRydWU7XG5cdFx0XHRcdCB9LFxuXHRcdFx0XHQgbW91c2V1cDpmdW5jdGlvbihlLHBvcyl7XG5cdFx0XHRcdCBcdF90aGlzLnNldHRpbmdJY29IaWRlKCk7IFxuXHRcdFx0XHQgXHRfdGhpcy5tZW51TGF5ZXJIaWRlKCk7XG5cdFx0XHRcdFx0XG5cblx0XHRcdFx0IFx0X3RoaXMuZHJhZ2luZyA9IGZhbHNlO1xuXHRcdFx0XHQgXHQvL+WPs+WHu+aYvuekuuiPnOWNlVxuXHRcdFx0XHQgXHRpZihlLmJ1dHRvbiA9PSAnMicpe1xuXHRcdFx0XHQgXHRcdF90aGlzLmNvbnRleHRNZW51Tm9kZSA9IHRoaXM7XG5cdFx0XHRcdCBcdFx0X3RoaXMubWVudUxheWVyU2hvdyhwb3MpO1xuXHRcdFx0XHQgXHRcdC8vIF90aGlzLmNvbnRleHRTZXR0aW5nTm9kZSA9IHRoaXM7XG5cblx0XHRcdFx0IFx0XHQvLyAvL+WPs+mUruiPnOWNleWxgue6p+aUvuWIsOacgOmrmFxuXHRcdFx0XHQgXHRcdC8vIF90aGlzLnFjYW52YXMucmFpc2VUb1RvcChfdGhpcy5jb250ZXh0U2V0dGluZ0xheWVyKTtcblxuXHRcdFx0XHQgXHRcdC8vIF90aGlzLmNvbnRleHRTZXR0aW5nU2hvdy5jYWxsKF90aGlzLHBvcyk7XG5cblx0XHRcdFx0IFx0fVxuXG5cblx0XHRcdFx0IH0sXG5cdFx0XHRcdCBtb3VzZW1vdmU6ZnVuY3Rpb24oZSxwb3MpeyBcblxuXHRcdFx0XHQgXHRfdGhpcy51cGRhdGVUbXBMaW5lRW5kUG9zKHBvcyk7XG5cblx0XHRcdFx0XHRfdGhpcy5zZXR0aW5nSWNvU2hvdyh0aGlzKTtcblxuXG5cdFx0XHRcdCBcdF90aGlzLmRyYWdpbmcgJiYgXG5cdFx0XHRcdCBcdF90aGlzLnVwZGF0ZUluaXREYXRhLmNhbGwoX3RoaXMsdGhpcyxqc29uT2JqKTtcblxuXHRcdFx0XHQgfSxcblx0XHRcdFx0IG1vdXNlb3V0OmZ1bmN0aW9uKCl7XG5cdFx0XHRcdCBcdF90aGlzLnNldHRpbmdJY29IaWRlKCk7IFxuXHRcdFx0XHQgfSxcblx0XHRcdFx0IGRibGNsaWNrOmZ1bmN0aW9uKGUscG9zKXtcblxuXHRcdFx0XHQgXHRjb25zb2xlLmxvZygnZGJsJylcblx0XHRcdFx0IFx0X3RoaXMuc2V0dGluZ0ljb0hpZGUoKTsgXG5cdFx0XHRcdCBcdF90aGlzLm1lbnVMYXllckhpZGUoKTtcblxuXHRcdFx0XHQgXHRfdGhpcy5jb250YWluZXJEYmxjbGljay5jYWxsKF90aGlzLHRoaXMsZSxwb3MsanNvbk9iaik7IFxuXG5cdFx0XHRcdCB9XG5cdFx0XHRcdH0pXG5cdC8vcWNhbnZhc+WSjOaVsOaNruS9nOWFs+iBlCBcblx0aWYodHlwZW9mIGpzb25PYmouaWQgPT0gJ3VuZGVmaW5lZCcpe1xuXHRcdGpzb25PYmouaWQgPSB0bXAuaWRcblx0fVxuXHRqc29uT2JqLm5vZGVJZCA9IHRtcC5pZDtcblx0cGFyZW50Tm9kZS5jaGlsZE5vZGVzP3BhcmVudE5vZGUuY2hpbGROb2Rlcy5wdXNoKHRtcCk6KHBhcmVudE5vZGUuY2hpbGROb2RlcyA9IFt0bXBdKTtcblxuXHR0aGlzLnFub2Rlcy5wdXNoKHRtcCk7XG5cblxuXHR0aGlzLmluaXROb2RlVGl0bGUoanNvbk9iaix0bXApO1xuIFxuXG5cbn07XG5RZmxvdy5wcm90b3R5cGUuZ2V0Tm9kZU9iaiA9IGZ1bmN0aW9uKG5vZGVJZCkge1xuXHR2YXIgdG1wID0gdGhpcy5xbm9kZXMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pe1xuIFx0XHRyZXR1cm4gaXRlbS5pZCA9PSBub2RlSWQ7XG4gXHR9KVxuXG4gXHRpZih0bXAubGVuZ3RoPjApe1xuIFx0XHRyZXR1cm4gdG1wWzBdO1xuIFx0fWVsc2V7XG4gXHRcdHJldHVybiBudWxsO1xuIFx0fVxufTtcblxuUWZsb3cucHJvdG90eXBlLmdldEpzb25PYmogPSBmdW5jdGlvbihub2RlSWQpIHtcblxuXHR2YXIgdG1wID0gbnVsbDtcblx0Ly/mkJzntKLniLYg5a2Q6aG5XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLmluaXREYXRhLm5vZGUubGVuZ3RoOyBpKyspIHtcblxuXHRcdGlmKHRoaXMub3B0aW9ucy5pbml0RGF0YS5ub2RlW2ldLm5vZGVJZCA9PSBub2RlSWQpe1xuXHRcdFx0dG1wID0gdGhpcy5vcHRpb25zLmluaXREYXRhLm5vZGVbaV07XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0aWYodGhpcy5vcHRpb25zLmluaXREYXRhLm5vZGVbaV0uY2hpbGQpe1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLm9wdGlvbnMuaW5pdERhdGEubm9kZVtpXS5jaGlsZC5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRpZih0aGlzLm9wdGlvbnMuaW5pdERhdGEubm9kZVtpXS5jaGlsZFtqXS5ub2RlSWQgPT0gbm9kZUlkKXtcblx0XHRcdFx0XHR0bXAgPSB0aGlzLm9wdGlvbnMuaW5pdERhdGEubm9kZVtpXS5jaGlsZFtqXTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fSBcblx0XHR9XG5cdFx0XG5cdH1cblxuXHRyZXR1cm4gdG1wO1xuXG59O1xuXG5RZmxvdy5wcm90b3R5cGUuY29udGFpbmVyTW91c2VEb3duID0gZnVuY3Rpb24oY29udGFpbmVyLGpzb25PYmopIHtcblx0dmFyIF90aGlzID0gdGhpcztcblx0Ly/mj5Dpq5jlhYPntKDlsYLnuqdcbiBcdHRoaXMucWNhbnZhcy5yYWlzZVRvVG9wKGNvbnRhaW5lcik7XG5cbiBcdC8v5L+d6K+B6L+e57q/bGF5ZXLlnKjmnIDpq5jlsYJcbiBcdHRoaXMucWNhbnZhcy5yYWlzZVRvVG9wKHRoaXMubGluZUxheWVyKTtcblxuIFx0Ly/lkIzml7bmj5Dpq5jmoIfpopjoioLngrnlsYLnuqcgXG4gXHR2YXIgdGl0bGVOb2RlID0gX3RoaXMuZ2V0Tm9kZU9iaihqc29uT2JqLmF0dHIudGl0bGVJZCk7XG4gXHR0aXRsZU5vZGUgIT09bnVsbCAmJiBfdGhpcy5xY2FudmFzLnJhaXNlVG9Ub3AodGl0bGVOb2RlKTtcblxuIFx0Ly/lpoLmnpzmmK9jb250YWluZXIg5ZCM5pe25o+Q6auY5a6D55qE5a2Q6aG56IqC54K55Y+K5qCH6aKY6IqC54K5IOWPlua2iOS6i+S7tuWTjeW6lFxuIFx0aWYoanNvbk9iai5ub2RlVHlwZSA9PSAnY29udGFpbmVyJyl7XG5cbiBcdFx0anNvbk9iai5jaGlsZE5vZGVzICYmIGpzb25PYmouY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdCBcdF90aGlzLnFjYW52YXMucmFpc2VUb1RvcChpdGVtKTtcblx0XHQgXHRpdGVtLnNldFBvaW50ZXJFdmVudCgnbm9uZScpO1xuIFx0XHR9KVxuXG4gXHRcdGpzb25PYmouY2hpbGQgJiYganNvbk9iai5jaGlsZC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuIFx0XHRcdHZhciB0aXRsZU5vZGUgPSBfdGhpcy5nZXROb2RlT2JqKGl0ZW0uYXR0ci50aXRsZUlkKTtcblx0XHQgXHRpZih0aXRsZU5vZGUgIT09bnVsbCApe1xuXHRcdCBcdFx0X3RoaXMucWNhbnZhcy5yYWlzZVRvVG9wKHRpdGxlTm9kZSk7XG5cdFx0XHQgXHR0aXRsZU5vZGUuc2V0UG9pbnRlckV2ZW50KCdub25lJyk7XG5cblx0XHQgXHR9IFxuIFx0XHR9KVxuXG4gXHRcdC8v5L+d6K+B6L+e57q/bGF5ZXLlnKjmnIDpq5jlsYJcblx0IFx0dGhpcy5xY2FudmFzLnJhaXNlVG9Ub3AodGhpcy5saW5lTGF5ZXIpO1xuXG4gXHR9XG4gXHRcblxuIFx0X3RoaXMuZHJhZ2luZyA9IHRydWU7XG59O1xuUWZsb3cucHJvdG90eXBlLmNvbnRhaW5lck1vdXNlVXAgPSBmdW5jdGlvbihjb250YWluZXIsZSxwb3MsanNvbk9iaikge1xuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRfdGhpcy5kcmFnaW5nID0gZmFsc2U7XG5cbiBcdC8v5aaC5p6c5pivY29udGFpbmVyIOaBouWkjeS6i+S7tuWTjeW6lFxuIFx0aWYoanNvbk9iai5ub2RlVHlwZSA9PSAnY29udGFpbmVyJyl7XG5cbiBcdFx0anNvbk9iai5jaGlsZE5vZGVzICYmIGpzb25PYmouY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdCBcdGl0ZW0uc2V0UG9pbnRlckV2ZW50KCdhdXRvJyk7XG4gXHRcdH0pXG5cbiBcdFx0Ly8ganNvbk9iai5jaGlsZCAmJiBqc29uT2JqLmNoaWxkLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XG4gXHRcdC8vIFx0dmFyIHRpdGxlTm9kZSA9IF90aGlzLmdldE5vZGVPYmooaXRlbS5hdHRyLnRpdGxlSWQpO1xuXHRcdCAvLyBcdGlmKHRpdGxlTm9kZSAhPT1udWxsICl7XG5cdFx0XHQvLyAgXHR0aXRsZU5vZGUuc2V0UG9pbnRlckV2ZW50KCdhdXRvJyk7XG5cblx0XHQgLy8gXHR9IFxuIFx0XHQvLyB9KVxuXG4gXHR9XG5cblx0IFx0dGhpcy5pc1Jlc2l6ZUNhbnZhcyhqc29uT2JqLm5vZGVJZCk7XG5cbiBcdC8v5Y+z5Ye75pi+56S66I+c5Y2VXG4gXHRpZihlLmJ1dHRvbiA9PSAnMicpeyBcbiBcdFx0X3RoaXMuY29udGV4dE1lbnVOb2RlID0gY29udGFpbmVyO1xuIFx0XHRfdGhpcy5tZW51TGF5ZXJTaG93KHBvcyk7XG5cbiBcdFx0Ly8gX3RoaXMuY29udGV4dFNldHRpbmdOb2RlID0gY29udGFpbmVyO1xuXG4gXHRcdC8vIC8v5Y+z6ZSu6I+c5Y2V5bGC57qn5pS+5Yiw5pyA6auYXG4gXHRcdC8vIF90aGlzLnFjYW52YXMucmFpc2VUb1RvcChfdGhpcy5jb250ZXh0U2V0dGluZ0xheWVyKTtcblxuIFx0XHQvLyBfdGhpcy5jb250ZXh0U2V0dGluZ1Nob3cocG9zKTtcblxuIFx0fVxufTtcblFmbG93LnByb3RvdHlwZS5jb250YWluZXJEYmxjbGljayA9IGZ1bmN0aW9uKG5vZGUsZSxwb3MsanNvbk9iaikge1xuXHRjb25zb2xlLmxvZyhqc29uT2JqKTtcblx0Y29uc29sZS5sb2cobm9kZSlcblx0aWYoanNvbk9iai5ub2RlVHlwZSA9PSAnbm9kZScpe1xuXG5cdFx0dGhpcy5jb250ZXh0U2V0dGluZ05vZGUgPSBqc29uT2JqO1xuXG5cdFx0Ly/lj4zlh7voioLngrnlkI4g6K6h566XaW5wdXTnmoTkvY3nva7lj4rlrr3luqZcblx0XHR2YXIgdGl0bGVPYmogPSB0aGlzLmdldE5vZGVPYmooanNvbk9iai5hdHRyLnRpdGxlSWQpOyBcblx0XHRjb25zb2xlLmxvZyh0aXRsZU9iaik7XG5cdFx0dGhpcy5tb2RpVGl0bGVPYmogPSB0aXRsZU9iajsgXG5cblx0XHR2YXIgdG1wID0gdGl0bGVPYmouZm9ybWF0VGV4dC5jYWxsKHRoaXMsdGl0bGVPYmopO1xuXG5cdCBcdHZhciB3ID0gTWF0aC5tYXguYXBwbHkobnVsbCx0bXAud2lkdGgpO1xuXHQgXHR3ID0gdz5ub2RlLndpZHRoP3c6bm9kZS53aWR0aDtcblx0IFx0dmFyIHN0YXJ0ID0gdGhpcy5xY2FudmFzLmlzRnVuKG5vZGUuc3RhcnQpP25vZGUuc3RhcnQoKTpub2RlLnN0YXJ0O1xuXG5cdCBcdHZhciB4ID0gdyA+IG5vZGUud2lkdGg/KHN0YXJ0WzBdLSh3IC0gbm9kZS53aWR0aCkqMC41KTpzdGFydFswXTtcblxuXG5cdFx0dmFyIGggPSB0aGlzLmNoaWxkTm9kZUhlaWdodDtcblx0XHR2YXIgeSA9IHN0YXJ0WzFdO1xuXG5cblxuXG5cblxuXG5cdFx0dmFyIGQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGl0bGVJbnB1dCcpO1xuXHRcdGQuc3R5bGUubGVmdCA9IHgrJ3B4Jztcblx0XHRkLnN0eWxlLnRvcCA9IHkrJ3B4Jztcblx0XHRkLnN0eWxlLndpZHRoID0gdysncHgnO1xuXHRcdGQuc3R5bGUuaGVpZ2h0ID0gaCsncHgnO1xuXHRcdGQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdFx0ZC5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcblx0XHRkLnZhbHVlID0gdGl0bGVPYmoudGV4dDtcblx0XHRkLmZvY3VzKCk7XG5cblx0fVxuXG5cblx0aWYoanNvbk9iai5ub2RlVHlwZSA9PSAnY29udGFpbmVyJyl7ICAvL+WPjOWHu+WuueWZqFxuXG5cdFx0Ly/lpoLmnpzngrnlh7vliLDmoIfpopjljLrln58g5YiZ5Ye6546w5qCH6aKYaW5wdXRcblx0XHR2YXIgdGl0bGVBcmVhSGVpZ2h0ID0gMTY7XG5cdFx0dmFyIHN0YXJ0ID0gdGhpcy5xY2FudmFzLmlzRnVuKG5vZGUuc3RhcnQpP25vZGUuc3RhcnQoKTpub2RlLnN0YXJ0O1xuXHRcdGlmKHRoaXMucmF5Q2FzdGluZyhwb3MsW1xuXHRcdFx0e1xuXHRcdFx0XHR4OnN0YXJ0WzBdLFxuXHRcdFx0XHR5OnN0YXJ0WzFdLFxuXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHR4OnN0YXJ0WzBdK25vZGUud2lkdGgsXG5cdFx0XHRcdHk6c3RhcnRbMV0sXG5cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdHg6c3RhcnRbMF0rbm9kZS53aWR0aCxcblx0XHRcdFx0eTpzdGFydFsxXSt0aXRsZUFyZWFIZWlnaHQsXG5cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdHg6c3RhcnRbMF0sXG5cdFx0XHRcdHk6c3RhcnRbMV0rdGl0bGVBcmVhSGVpZ2h0LFxuXG5cdFx0XHR9LFxuXHRcdFx0XSkgPT0gJ2luJyl7XG5cblx0XHRcdGNvbnNvbGUubG9nKCflvIDlp4vnvJbovpHlrrnlmajmoIfpopgnKTtcblxuXHRcdFx0dGhpcy5jb250ZXh0U2V0dGluZ05vZGUgPSBqc29uT2JqO1xuXG5cdFx0XHQvL+WPjOWHu+iKgueCueWQjiDorqHnrpdpbnB1dOeahOS9jee9ruWPiuWuveW6plxuXHRcdFx0dmFyIHRpdGxlT2JqID0gdGhpcy5nZXROb2RlT2JqKGpzb25PYmouYXR0ci50aXRsZUlkKTsgXG5cdFx0XHRjb25zb2xlLmxvZyh0aXRsZU9iaik7XG5cdFx0XHR0aGlzLm1vZGlUaXRsZU9iaiA9IHRpdGxlT2JqOyBcblxuXHRcdFx0dmFyIHRtcCA9IHRpdGxlT2JqLmZvcm1hdFRleHQuY2FsbCh0aGlzLHRpdGxlT2JqKTtcblxuXHRcdCBcdHZhciB3ID0gTWF0aC5tYXguYXBwbHkobnVsbCx0bXAud2lkdGgpO1xuXHRcdCBcdHcgPSB3Pm5vZGUud2lkdGg/dzpub2RlLndpZHRoO1xuXHRcdCBcdHZhciBzdGFydCA9IHRoaXMucWNhbnZhcy5pc0Z1bihub2RlLnN0YXJ0KT9ub2RlLnN0YXJ0KCk6bm9kZS5zdGFydDtcblxuXHRcdCBcdHZhciB4ID0gdyA+IG5vZGUud2lkdGg/KHN0YXJ0WzBdLSh3IC0gbm9kZS53aWR0aCkqMC41KTpzdGFydFswXTtcblxuXG5cdFx0XHR2YXIgaCA9IHRoaXMuY2hpbGROb2RlSGVpZ2h0O1xuXHRcdFx0dmFyIHkgPSBzdGFydFsxXTtcblxuXG5cblxuXG5cblxuXHRcdFx0dmFyIGQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGl0bGVJbnB1dCcpO1xuXHRcdFx0ZC5zdHlsZS5sZWZ0ID0geCsncHgnO1xuXHRcdFx0ZC5zdHlsZS50b3AgPSB5KydweCc7XG5cdFx0XHRkLnN0eWxlLndpZHRoID0gdysncHgnO1xuXHRcdFx0ZC5zdHlsZS5oZWlnaHQgPSBoKydweCc7XG5cdFx0XHRkLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHRcdFx0ZC5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcblx0XHRcdGQudmFsdWUgPSB0aXRsZU9iai50ZXh0O1xuXHRcdFx0ZC5mb2N1cygpO1xuXG5cblx0XHR9XG4gXG5cblx0fVxuXG5cblxuXHRcbn07XG5RZmxvdy5wcm90b3R5cGUucmVzaXplQ2FudmFzID0gZnVuY3Rpb24od2lkdGgsaGVpZ2h0KSB7XG5cdHZhciBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbzsgLy8g5YGH6K6+ZHBy5Li6MlxuXG5cdHZhciBjX29iaiA9IHRoaXMucWNhbnZhcy5zdGFnZS5jYW52YXM7XG5cdGNfb2JqLndpZHRoID0gd2lkdGgqZHByO1xuXHRjX29iai5oZWlnaHQgPSBoZWlnaHQqZHByO1xuXHRjX29iai5zdHlsZS53aWR0aCA9IHdpZHRoKydweCc7XG5cdGNfb2JqLnN0eWxlLmhlaWdodCA9IGhlaWdodCsncHgnO1xuXG5cblx0dmFyIGNvbnRleHQgPSBjX29iai5nZXRDb250ZXh0KCcyZCcpO1xuXHQvLyDpnIDopoHlsIbnu5jliLbmr5TkvovmlL7lpKdcbiAgICBjb250ZXh0LnNjYWxlKGRwcixkcHIpO1xuXG5cblxuICAgIC8vbGF5ZXLnmoTlhYPntKDnmoTkuLTml7ZjYW52YXPkuZ/lvpflkIzmraXnvKnmlL5cbiAgICB0aGlzLnFjYW52YXMuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcbiAgICBcdGlmKGl0ZW0uVFlQRSA9PSAnbGF5ZXInKXtcblxuICAgIFx0XHQvLyBjb25zb2xlLmxvZyhpdGVtLmNhbnZhc0VsZSk7XG4gICAgXHRcdHZhciBsYXllcl9jYW52YXMgPSBpdGVtLmNhbnZhc0VsZTtcbiAgICBcdFx0bGF5ZXJfY2FudmFzLndpZHRoID0gd2lkdGgqZHByO1xuXHRcdFx0bGF5ZXJfY2FudmFzLmhlaWdodCA9IGhlaWdodCpkcHI7XG5cdFx0XHR2YXIgY29udGV4dCA9IGxheWVyX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdFx0Ly8g6ZyA6KaB5bCG57uY5Yi25q+U5L6L5pS+5aSnXG5cdFx0ICAgIGNvbnRleHQuc2NhbGUoZHByLGRwcik7XG5cbiAgICBcdH1cbiAgICB9KVxuXG4gICAgdGhpcy5vcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5vcHRpb25zLmhlaWdodCA9IGhlaWdodDtcblxuXHR0aGlzLnFjYW52YXMuc3RhZ2Uud2lkdGggPSB3aWR0aDtcblx0dGhpcy5xY2FudmFzLnN0YWdlLmhlaWdodCA9IGhlaWdodDtcblxuXG5cbn07XG5RZmxvdy5wcm90b3R5cGUuaXNSZXNpemVDYW52YXMgPSBmdW5jdGlvbihub2RlSWQpIHtcblx0dmFyIF90aGlzID0gdGhpcztcblx0dmFyIEYgPSBmdW5jdGlvbigpeyBcblx0XG5cdFx0dmFyIG9iaiA9IF90aGlzLmdldE5vZGVPYmoobm9kZUlkKTtcblx0XHRpZihvYmogIT09IG51bGwpe1xuXHRcdFx0dmFyIHN0YXJ0ID0gX3RoaXMucWNhbnZhcy5pc0Z1bihvYmouc3RhcnQpP29iai5zdGFydCgpOm9iai5zdGFydDtcblxuXHRcdFx0dmFyIG1heFggPSBzdGFydFswXSArIG9iai53aWR0aDtcblx0XHRcdHZhciBtYXhZID0gc3RhcnRbMV0gKyBvYmouaGVpZ2h0O1xuXG5cdFx0XHRpZihtYXhYID4gX3RoaXMub3B0aW9ucy53aWR0aCB8fCBcblx0XHRcdFx0bWF4WSA+IF90aGlzLm9wdGlvbnMuaGVpZ2h0KXtcblxuXHRcdFx0XHRjb25zb2xlLmxvZygn6ZyA6KaB6YeN572uY2FudmFz5bC65a+4Jyk7XG5cblx0XHRcdFx0X3RoaXMucmVzaXplQ2FudmFzKG1heFg+X3RoaXMub3B0aW9ucy53aWR0aD9tYXhYOl90aGlzLm9wdGlvbnMud2lkdGgsbWF4WT5fdGhpcy5vcHRpb25zLmhlaWdodD9tYXhZOl90aGlzLm9wdGlvbnMuaGVpZ2h0KTtcblxuXHRcdFx0fVxuXG5cblx0XHR9XG5cblxuXG5cdH1cblx0c2V0VGltZW91dChGLDIwMCk7XG5cblxuXHRcbn07XG5cblFmbG93LnByb3RvdHlwZS5jb250YWluZXJNb3VzZU1vdmUgPSBmdW5jdGlvbihjb250YWluZXIsanNvbk9iaikge1xuXG5cdC8vIHRoaXMuc2V0dGluZ0ljb1Nob3coY29udGFpbmVyKTtcblxuXG5cdHRoaXMuZHJhZ2luZyAmJiBcbiBcdHRoaXMudXBkYXRlSW5pdERhdGEoY29udGFpbmVyLGpzb25PYmopO1xufTtcblFmbG93LnByb3RvdHlwZS5nZXRNaWRkbGVDb29yZGluYXRlID0gZnVuY3Rpb24ocyxlKSB7XG4gXG5cdHZhciBzdGFydD1bcy54LHMueV0sZW5kPVtlLngsZS55XTtcblxuXHQvLyByZXR1cm4ge1xuXHQvLyBcdHg6KHN0YXJ0WzBdIDwgZW5kWzBdID8gc3RhcnRbMF06ZW5kWzBdKStNYXRoLmFicyhzdGFydFswXS1lbmRbMF0pICogMC41LFxuXHQvLyBcdHk6KHN0YXJ0WzFdIDwgZW5kWzFdID8gc3RhcnRbMV06ZW5kWzFdKStNYXRoLmFicyhzdGFydFsxXS1lbmRbMV0pICogMC41LFxuXHQvLyB9O1xuXHRyZXR1cm4gW1xuXHRcdChzdGFydFswXSA8IGVuZFswXSA/IHN0YXJ0WzBdOmVuZFswXSkrTWF0aC5hYnMoc3RhcnRbMF0tZW5kWzBdKSAqIDAuNSxcblx0XHQoc3RhcnRbMV0gPCBlbmRbMV0gPyBzdGFydFsxXTplbmRbMV0pK01hdGguYWJzKHN0YXJ0WzFdLWVuZFsxXSkgKiAwLjUsXG5cdF1cbn07XG5RZmxvdy5wcm90b3R5cGUuY3JlYXRlUmFuZ2VQb2ludHMgPSBmdW5jdGlvbihwb2x5UG9pbnRzKSB7XG5cdHZhciB0bXAgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5UG9pbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dG1wLnB1c2goW3BvbHlQb2ludHNbaV0ueCxwb2x5UG9pbnRzW2ldLnldKTtcblx0XHR0bXAucHVzaCh0aGlzLmdldE1pZGRsZUNvb3JkaW5hdGUocG9seVBvaW50c1tpXSxwb2x5UG9pbnRzW2krMT09cG9seVBvaW50cy5sZW5ndGg/MDppKzFdKSk7XG5cdH1cblxuXHRyZXR1cm4gdG1wO1xufTtcblxuUWZsb3cucHJvdG90eXBlLnRpcFRleHRIaWRlID0gZnVuY3Rpb24oKSB7XG5cdGlmKHRoaXMudGlwQ29udGV4dCAhPT0gbnVsbCl7XG4gICAgICB0aGlzLnRpcENvbnRleHQuc2V0Q29sb3IoJyNCNTgxMDUnKTsgXG4gICAgICB2YXIganNvbk9iaiA9IHRoaXMuZ2V0SnNvbk9iaih0aGlzLnRpcENvbnRleHQub3duZXJJZCk7XG4gXG5cbiAgICAgIC8vIGlmKHRoaXMudGlwQ29udGV4dC50ZXh0LmluZGV4T2YoJ1xcbicpID4gLTEpe1xuICAgICAgLy8gXHR2YXIgdG1wID0gdGhpcy50aXBDb250ZXh0LnRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgLy8gXHRqc29uT2JqLnRleHQgPSB0bXAuam9pbignXFxuJyk7XG5cbiAgICAgIC8vIH1lbHNle1xuXG5cdCAgICAgIGpzb25PYmoudGV4dCA9IHRoaXMudGlwQ29udGV4dC50ZXh0O1xuICAgICAgLy8gfVxuXG5cblxuICAgICAganNvbk9iai53aWR0aCAgPSB0aGlzLnRpcE5vZGVXaWR0aDtcbiAgICAgIGpzb25PYmouaGVpZ2h0ID0gdGhpcy50aXBDb250ZXh0LnJhbmdlLmhlaWdodDtcblxuXG4gICAgICB0aGlzLnRpcENvbnRleHQgPW51bGw7XG5cdH1cblx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RpcCcpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFxufTtcblFmbG93LnByb3RvdHlwZS51cGRhdGVUaXBUZXh0ID0gZnVuY3Rpb24odixoKSB7XG5cblx0aWYodGhpcy50aXBDb250ZXh0ICE9PSBudWxsKXtcblxuXHRcdHYgPSB0aGlzLmZvcm1hdFRpcFRleHQodik7XG5cdFx0dGhpcy50aXBDb250ZXh0LnNldFRleHQodik7IFxuXG5cblxuXHRcdHZhciB0aXBSZWN0ID0gdGhpcy5nZXROb2RlT2JqKHRoaXMudGlwQ29udGV4dC5vd25lcklkKTtcblx0XHR0aXBSZWN0LnNldEhlaWdodChoKTtcblxuXHR9XG59O1xuUWZsb3cucHJvdG90eXBlLm1lYXN1cmVUZXh0V2lkdGggPSBmdW5jdGlvbih2KSB7XG5cdHJldHVybiB0aGlzLnFjYW52YXMuY29udGV4dC5tZWFzdXJlVGV4dCh2KS53aWR0aDtcblxufTtcblFmbG93LnByb3RvdHlwZS5mb3JtYXRUaXBUZXh0ID0gZnVuY3Rpb24oc3RyKSB7XG5cdHZhciBsaW5lV2lkdGggPSAwO1xuICAgIHZhciBsYXN0U3ViU3RySW5kZXggPSAwOyAvL+avj+asoeW8gOWni+aIquWPlueahOWtl+espuS4sueahOe0ouW8lVxuICAgIHZhciBjID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpbmVXaWR0aCArPSB0aGlzLm1lYXN1cmVUZXh0V2lkdGgoc3RyW2ldKTsgXG4gICAgICBcbiAgICAgIC8v5pyJ5o2i6KGMIOmHjeaWsOiuoeeul1xuICAgICAgaWYoc3RyW2ldID09ICdcXG4nKXtcbiAgICAgICAgICBsaW5lV2lkdGggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAobGluZVdpZHRoID4gdGhpcy50aXBOb2RlV2lkdGgpIHtcbiAgICAgICAgYy5wdXNoKHN0ci5zdWJzdHJpbmcobGFzdFN1YlN0ckluZGV4LCBpKSk7Ly/nu5jliLbmiKrlj5bpg6jliIZcbiAgICAgICAgLy8gaW5pdEhlaWdodCArPSA3MDsvLzYw5Li65a2X5L2T55qE6auY5bqmXG4gICAgICAgIGxpbmVXaWR0aCA9IHRoaXMubWVhc3VyZVRleHRXaWR0aChzdHJbaV0pO1xuICAgICAgICBsYXN0U3ViU3RySW5kZXggPSBpO1xuICAgICAgfVxuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCAtIDEpIHsvL+e7mOWItuWJqeS9memDqOWIhlxuICAgICAgICBjLnB1c2goc3RyLnN1YnN0cmluZyhsYXN0U3ViU3RySW5kZXgsIGkgKyAxKSlcbiAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGMuam9pbignXFxuJyk7XG5cbiAgICAvLyB0ZXh0MS5zZXRUZXh0KGMuam9pbignXFxuJykpOyBcbn07XG5RZmxvdy5wcm90b3R5cGUuY2xvbmVUaXBOb2RlID0gZnVuY3Rpb24oKSB7XG5cdGNvbnNvbGUubG9nKHRoaXMuY29udGV4dE1lbnVOb2RlKTtcblx0dmFyIGpzb25PYmogPSB0aGlzLmdldEpzb25PYmoodGhpcy5jb250ZXh0TWVudU5vZGUuaWQpO1xuXHR2YXIganNvbiA9IHtcblx0XHRcdG5vZGVUeXBlOid0aXAnLCAvL+Wkh+azqOaWh+acrOiKgueCuVxuXHRcdFx0eDp0aGlzLmNvbnRleHRNZW51Tm9kZS5zdGFydFswXSsyMCxcblx0XHRcdHk6dGhpcy5jb250ZXh0TWVudU5vZGUuc3RhcnRbMV0rMjAsXG5cdFx0XHR3aWR0aDp0aGlzLnRpcE5vZGVXaWR0aCxcblx0XHRcdGhlaWdodDp0aGlzLmNvbnRleHRNZW51Tm9kZS5oZWlnaHQsXG5cdFx0XHR0ZXh0Ompzb25PYmoudGV4dCxcblx0XHRcdGF0dHI6e1xuXHRcdFx0XHQgYm9yZGVyQ29sb3I6JyM3RUM4Q0UnLCBcblx0XHRcdFx0IGNvbG9yOicjZmZmJywgXG5cdFx0XHRcdCBmaWxsQ29sb3I6JyM1ODVEQ0InLFxuXHRcdFx0XHQgZGFzaGVkOmZhbHNlLCBcblx0XHRcdH1cblx0fVxuXG5cblx0dGhpcy5jcmVhdGVUaXBOb2RlKGpzb24pO1xuXG5cblx0dGhpcy5vcHRpb25zLmluaXREYXRhLm5vZGUucHVzaChqc29uKTtcblxufTtcblFmbG93LnByb3RvdHlwZS5hZGRUaXBOb2RlID0gZnVuY3Rpb24ob2JqKSB7XG5cblx0dmFyIGpzb24gPSB7XG5cdFx0XHRub2RlVHlwZTondGlwJywgLy/lpIfms6jmlofmnKzoioLngrlcblx0XHRcdHg6b2JqLngsXG5cdFx0XHR5Om9iai55LFxuXHRcdFx0d2lkdGg6dGhpcy50aXBOb2RlV2lkdGgsIFxuXHRcdFx0dGV4dDon5aSH5rOoJyxcblx0XHRcdGF0dHI6e1xuXHRcdFx0XHQgYm9yZGVyQ29sb3I6JyM3RUM4Q0UnLCBcblx0XHRcdFx0IGNvbG9yOicjZmZmJywgXG5cdFx0XHRcdCBmaWxsQ29sb3I6JyM1ODVEQ0InLFxuXHRcdFx0XHQgZGFzaGVkOmZhbHNlLCBcblx0XHRcdH1cblx0fVxuXG5cblx0dGhpcy5jcmVhdGVUaXBOb2RlKGpzb24pO1xuXG5cblx0dGhpcy5vcHRpb25zLmluaXREYXRhLm5vZGUucHVzaChqc29uKTtcblx0XG59O1xuUWZsb3cucHJvdG90eXBlLmNyZWF0ZVRpcE5vZGUgPSBmdW5jdGlvbihqc29uT2JqKSB7XG5cdHZhciBfdGhpcyA9IHRoaXM7XG5cdHZhciB0bXAgPSB0aGlzLnFjYW52YXMucXJlY3QucmVjdCh7XG5cdFx0IHN0YXJ0Oltqc29uT2JqLngsanNvbk9iai55XSwgXG5cdFx0IG5vZGVUeXBlOmpzb25PYmoubm9kZVR5cGUsXG5cdFx0IHdpZHRoOmpzb25PYmoud2lkdGg/anNvbk9iai53aWR0aDp0aGlzLnRpcE5vZGVXaWR0aCxcblx0XHQgaGVpZ2h0Ompzb25PYmouaGVpZ2h0P2pzb25PYmouaGVpZ2h0OnRoaXMuY2hpbGROb2RlSGVpZ2h0LFxuXHRcdCBib3JkZXJDb2xvcjonb3JhbmdlJyxcblx0XHQgZmlsbENvbG9yOicjRkVGOERFJywgXG5cdFx0IGRhc2hlZDpqc29uT2JqLmF0dHIuZGFzaGVkLFxuXHRcdCAgZ2V0UmFuZ2VQb2ludHM6ZnVuY3Rpb24oKXsgLy/ov5Tlm55yZWN06L655LiK55qEOOS4queCueeahOWdkOaghyBcblx0XHQgXHRyZXR1cm4gX3RoaXMuY3JlYXRlUmFuZ2VQb2ludHModGhpcy5wb2x5UG9pbnRzKCkpO1xuXHRcdCB9LFxuXHRcdCBkYmxjbGljazpmdW5jdGlvbihlLHBvcyl7IFxuXHRcdCBcdHZhciB4ID0gdGhpcy5zdGFydFswXSx5ID0gdGhpcy5zdGFydFsxXTtcblx0ICAgICAgICB2YXIgZG9jID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RpcCcpO1xuXHQgICAgICAgIGRvYy5zdHlsZS50b3AgPSB5KydweCc7XG5cdCAgICAgICAgZG9jLnN0eWxlLmxlZnQgPSB4KydweCc7XG5cdCAgICAgICAgZG9jLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArJ3B4Jztcblx0ICAgICAgICBkb2Muc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQrJ3B4Jztcblx0ICAgICAgICBkb2Muc3R5bGUuZm9udFNpemU9XCIxMnB4XCI7XG5cdCAgICAgICAgZG9jLnN0eWxlLmxpbmVIZWlnaHQ9XCIxNHB4XCI7XG5cdCAgICAgICAgZG9jLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG5cdCAgICAgICAgX3RoaXMudGlwQ29udGV4dCA9ICBfdGhpcy5nZXROb2RlT2JqKGpzb25PYmouYXR0ci50aXRsZUlkKTtcbiAgICAgICAgICAgIF90aGlzLnRpcENvbnRleHQuc2V0Q29sb3IoJyNGRUY4REUnKTtcblxuXHQgICAgICAgIGRvYy52YWx1ZSA9IF90aGlzLnRpcENvbnRleHQudGV4dDtcblxuXHQgICAgICAgIGRvYy5mb2N1cygpO1xuXHRcdCB9LFxuXHRcdCBtb3VzZWRvd246ZnVuY3Rpb24oKXsgXG5cblx0XHQgXHRfdGhpcy5kZWxUbXBMaW5lKCk7XG5cdCBcdFx0X3RoaXMuY3JlYXRlTmV3TGluZSh0aGlzLGpzb25PYmopOyBcblxuXHQgXHRcdF90aGlzLm1lbnVMYXllckhpZGUoKTtcblx0XHQgXHRfdGhpcy5jb250YWluZXJNb3VzZURvd24uY2FsbChfdGhpcyx0aGlzLGpzb25PYmopOyBcblx0XHQgfSxcblx0XHQgbW91c2V1cDpmdW5jdGlvbihlLHBvcyl7XG5cdFx0IFx0X3RoaXMuc2V0dGluZ0ljb0hpZGUoKTsgXG5cdFx0IFx0X3RoaXMubWVudUxheWVySGlkZSgpO1xuXHRcdCBcdFxuXHRcdCBcdF90aGlzLmNvbnRhaW5lck1vdXNlVXAuY2FsbChfdGhpcyx0aGlzLGUscG9zLGpzb25PYmopOyBcblxuXHRcdCB9LFxuXHRcdCAgbW91c2Vtb3ZlOmZ1bmN0aW9uKGUscG9zKXtcblx0XHQgXHRfdGhpcy51cGRhdGVUbXBMaW5lRW5kUG9zKHBvcyk7IFxuXG5cdFx0IFx0X3RoaXMuY29udGFpbmVyTW91c2VNb3ZlLmNhbGwoX3RoaXMsdGhpcyxqc29uT2JqKTsgXG5cblxuXHRcdCAgICAgICAgaWYoX3RoaXMucWNhbnZhcy5kcmFnQWltID09PSBudWxsKXtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIHZhciB0aXRsZSA9ICBfdGhpcy5nZXROb2RlT2JqKGpzb25PYmouYXR0ci50aXRsZUlkKTsgXG5cblx0XHQgICAgICAgIC8vIHRpdGxlLnNldFN0YXJ0KFt0aGlzLnN0YXJ0WzBdLHRoaXMuc3RhcnRbMV0rM10pOyBcblxuXHRcdCAgICAgICAgLy8gdGl0bGUuc2V0Q29sb3IoJyNlZWUnKTtcblxuXHRcdCAgICB9XG5cdFx0fSlcblx0Ly9xY2FudmFz5ZKM5pWw5o2u5L2c5YWz6IGUXG5cdGlmKHR5cGVvZiBqc29uT2JqLmlkID09ICd1bmRlZmluZWQnKXtcblx0XHRqc29uT2JqLmlkID0gdG1wLmlkO1xuXHR9ICBcblx0anNvbk9iai5ub2RlSWQgPSB0bXAuaWQ7XG5cblx0dGhpcy5xbm9kZXMucHVzaCh0bXApO1xuXHR0aGlzLmJhc2VOb2Rlc1dpdGhDb29yZGluYXRlcy5wdXNoKHRtcCk7XG5cblx0dGhpcy5pbml0VGlwVGV4dChqc29uT2JqLHRtcCk7XG59O1xuUWZsb3cucHJvdG90eXBlLmluaXRUaXBUZXh0ID0gZnVuY3Rpb24ob2JqLHFvYmopIHtcblxuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIHQgPSB0aGlzLnFjYW52YXMucXRleHQudGV4dCh7XG5cdFx0XHRcdHN0YXJ0OmZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0cmV0dXJuIFtxb2JqLnN0YXJ0WzBdLHFvYmouc3RhcnRbMV0rM107XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIHN0YXJ0Oltxb2JqLnN0YXJ0WzBdLHFvYmouc3RhcnRbMV0rM10sXG5cdFx0XHRcdHRleHQ6b2JqLnRleHQsXG5cdFx0XHRcdGZvbnRTaXplOicxMnB4JywgXG5cdFx0XHQgICAgbGluZUhlaWdodDonMTRweCcsXG5cdFx0XHQgICAgY29sb3I6JyNCNTgxMDUnLFxuXHRcdFx0ICAgIHRleHRBbGlnbjonbGVmdCcsXG5cdFx0XHQgICAgdGV4dEJhc2VsaW5lOid0b3AnLFxuXHRcdFx0ICAgIHBvaW50ZXJFdmVudDonbm9uZScsXG5cdFx0XHRcdG93bmVySWQ6b2JqLm5vZGVJZFxuXHRcdFx0fSlcblxuXHRcdHRoaXMucW5vZGVzLnB1c2godCk7XG5cblx0XHQvL+agh+mimOiKgueCueeahGlk6K6w5YiwY29udGFpbmVy6IqC54K5anNvbuaVsOaNruS4ilxuXHRcdG9iai5hdHRyLnRpdGxlSWQgPSB0LmlkO1xuIFxufTtcblFmbG93LnByb3RvdHlwZS5jcmVhdGVDb250YWluZXJPck5vZGUgPSBmdW5jdGlvbihqc29uT2JqKSB7XG5cdHZhciBfdGhpcyA9IHRoaXM7XG5cdHZhciB0bXAgPSB0aGlzLnFjYW52YXMucXJlY3QucmVjdCh7XG5cdFx0IHN0YXJ0Oltqc29uT2JqLngsanNvbk9iai55XSwgXG5cdFx0IG5vZGVUeXBlOmpzb25PYmoubm9kZVR5cGUsXG5cdFx0IHdpZHRoOmpzb25PYmoud2lkdGg/anNvbk9iai53aWR0aDp0aGlzLmNoaWxkTm9kZVdpZHRoLFxuXHRcdCBoZWlnaHQ6anNvbk9iai5oZWlnaHQ/anNvbk9iai5oZWlnaHQ6dGhpcy5jaGlsZE5vZGVIZWlnaHQsXG5cdFx0IGJvcmRlckNvbG9yOmpzb25PYmouYXR0ci5ib3JkZXJDb2xvciwgXG5cdFx0IGZpbGxDb2xvcjpqc29uT2JqLmF0dHIuZmlsbENvbG9yLCBcblx0XHQgZGFzaGVkOmpzb25PYmouYXR0ci5kYXNoZWQsICBcblx0XHQgZ2V0UmFuZ2VQb2ludHM6ZnVuY3Rpb24oKXsgLy/ov5Tlm55yZWN06L655LiK55qEOOS4queCueeahOWdkOaghyBcblx0XHQgXHRyZXR1cm4gX3RoaXMuY3JlYXRlUmFuZ2VQb2ludHModGhpcy5wb2x5UG9pbnRzKCkpO1xuXHRcdCB9LFxuXHRcdCBtb3VzZWVudGVyOmZ1bmN0aW9uKCl7IFxuXHRcdCBcdF90aGlzLnNldHRpbmdJY29TaG93KHRoaXMpO1xuXHRcdCB9LFxuXHRcdCBtb3VzZWRvd246ZnVuY3Rpb24oKXsgXG5cblx0XHQgXHRfdGhpcy5kZWxUbXBMaW5lKCk7XG5cdCBcdFx0X3RoaXMuY3JlYXRlTmV3TGluZSh0aGlzLGpzb25PYmopO1xuXG5cdCBcdFx0X3RoaXMudGlwVGV4dEhpZGUoKTtcblx0XHQgXHRfdGhpcy5tZW51TGF5ZXJIaWRlKCk7XG5cdFx0IFx0X3RoaXMuY29udGFpbmVyTW91c2VEb3duLmNhbGwoX3RoaXMsdGhpcyxqc29uT2JqKTsgXG5cblx0XHQgXHRfdGhpcy5jb250ZXh0TWVudU5vZGUgPSBudWxsO1xuXHRcdCBcdF90aGlzLmNvbnRleHRTZXR0aW5nSGlkZSgpO1xuXG5cdFx0IH0sXG5cdFx0IG1vdXNldXA6ZnVuY3Rpb24oZSxwb3Mpe1xuXHRcdCBcdF90aGlzLnNldHRpbmdJY29IaWRlKCk7IFxuXHRcdCBcdF90aGlzLm1lbnVMYXllckhpZGUoKTtcblxuXG5cdFx0IFx0X3RoaXMuY29udGFpbmVyTW91c2VVcC5jYWxsKF90aGlzLHRoaXMsZSxwb3MsanNvbk9iaik7IFxuXG5cdFx0IH0sXG5cdFx0IG1vdXNlbW92ZTpmdW5jdGlvbihlLHBvcyl7XG5cdFx0IFx0X3RoaXMudXBkYXRlVG1wTGluZUVuZFBvcyhwb3MpO1xuXHRcdCBcdF90aGlzLnNldHRpbmdJY29TaG93KHRoaXMpO1xuXG5cdFx0IFx0X3RoaXMuY29udGFpbmVyTW91c2VNb3ZlLmNhbGwoX3RoaXMsdGhpcyxqc29uT2JqKTsgXG5cblx0XHQgfSxcblx0XHQgbW91c2VvdXQ6ZnVuY3Rpb24oKXtcblx0XHQgXHRfdGhpcy5zZXR0aW5nSWNvSGlkZSgpOyBcblx0XHQgfSxcblx0XHQgZGJsY2xpY2s6ZnVuY3Rpb24oZSxwb3Mpe1xuXHRcdCBcdF90aGlzLnNldHRpbmdJY29IaWRlKCk7IFxuXHRcdCBcdF90aGlzLm1lbnVMYXllckhpZGUoKTtcblxuXHRcdCBcdF90aGlzLmNvbnRhaW5lckRibGNsaWNrLmNhbGwoX3RoaXMsdGhpcyxlLHBvcyxqc29uT2JqKTsgXG5cblxuXHRcdCB9XG5cdH0pXG5cblxuXHQvL3FjYW52YXPlkozmlbDmja7kvZzlhbPogZRcblx0anNvbk9iai5ub2RlSWQgPSB0bXAuaWQ7XG5cblx0dGhpcy5xbm9kZXMucHVzaCh0bXApO1xuXHR0aGlzLmJhc2VOb2Rlc1dpdGhDb29yZGluYXRlcy5wdXNoKHRtcCk7XG5cblx0Ly/liJ3lp4vljJblrrnlmajnmoTmoIfpophcblx0anNvbk9iai5ub2RlVHlwZSA9PSAnY29udGFpbmVyJyAmJlxuXHR0aGlzLmluaXRDb250YWluZXJUaXRsZShqc29uT2JqLHRtcCk7XG5cblx0Ly/liJ3lp4vljJboioLngrnmoIfpophcblx0anNvbk9iai5ub2RlVHlwZSA9PSAnbm9kZScgJiZcblx0dGhpcy5pbml0Tm9kZVRpdGxlKGpzb25PYmosdG1wKTtcblxuXG5cblx0anNvbk9iai5ub2RlVHlwZSA9PSAnY29udGFpbmVyJyAmJiBcblx0dHlwZW9mIGpzb25PYmouY2hpbGQgIT0ndW5kZWZpbmVkJyAmJiBcblx0dGhpcy5pbml0Tm9kZShqc29uT2JqKTtcbn07XG5RZmxvdy5wcm90b3R5cGUuaW5pdE5vZGUgPSBmdW5jdGlvbihwYXJlbnROb2RlKSB7IFxuXG5cdGlmKHBhcmVudE5vZGUpe1xuXHRcdC8v5byA5aeL55S75a2Q6aG5XG5cdFx0dGhpcy5kcmF3Tm9kZShwYXJlbnROb2RlLHBhcmVudE5vZGUuY2hpbGQpO1xuXHR9ZWxzZXtcblxuXHRcdHRoaXMuZHJhd05vZGUobnVsbCx0aGlzLm9wdGlvbnMuaW5pdERhdGEubm9kZSk7XG5cdH1cblxuXHRcbn07XG5RZmxvdy5wcm90b3R5cGUuaW5pdENhbnZhcyA9IGZ1bmN0aW9uKCkge1xuIFxuXHR0aGlzLnFjYW52YXMgPSBuZXcgUWNhbnZhcyh7XG5cdFx0aWQ6dGhpcy5vcHRpb25zLmlkLFxuXHRcdHdpZHRoOnRoaXMub3B0aW9ucy53aWR0aCxcblx0XHRoZWlnaHQ6dGhpcy5vcHRpb25zLmhlaWdodCxcblx0XHRtb3VzZWRvd246dGhpcy5jYW52YXNEb3duRnVuLmJpbmQodGhpcyksXG5cdFx0bW91c2Vtb3ZlOnRoaXMuY2FudmFzTW92ZUZ1bi5iaW5kKHRoaXMpLFxuXHRcdG1vdXNldXA6dGhpcy5jYW52YXNVcEZ1bi5iaW5kKHRoaXMpLFxuXHRcdGRlbGF5UmVuZGVyOnRydWVcblxuXHR9KTtcblx0Ly8gdGhpcy50b29sTGF5ZXIgPSB0aGlzLnFjYW52YXMucWxheWVyLmxheWVyKCk7XG5cblx0Ly8gdGhpcy5pbml0VG9vbCgpO1xuXG59O1xuUWZsb3cucHJvdG90eXBlLmFkZENvbnRhaW5lciA9IGZ1bmN0aW9uKG9iaixhdHRyT2JqKSB7XG5cblx0dmFyIF90aGlzID0gdGhpcztcblxuXHQvL+a3u+WKoOWuueWZqFxuXHR2YXIgdG1wID0gdGhpcy5xY2FudmFzLnFyZWN0LnJlY3Qoe1xuXHRcdCBzdGFydDpbb2JqLngsb2JqLnldLFxuXHRcdCAvLyB3aWR0aDp0aGlzLmNvbnRhaW5lck5vZGVXaWR0aCxcblx0XHQgLy8gaGVpZ2h0OnRoaXMuY29udGFpbmVyTm9kZUhlaWdodCxcblx0XHQgd2lkdGg6KGF0dHJPYmogJiYgYXR0ck9iai53aWR0aCk/YXR0ck9iai53aWR0aDp0aGlzLmNvbnRhaW5lck5vZGVXaWR0aCxcblx0XHRoZWlnaHQ6KGF0dHJPYmogJiYgYXR0ck9iai5oZWlnaHQpP2F0dHJPYmouaGVpZ2h0OnRoaXMuY29udGFpbmVyTm9kZUhlaWdodCxcblx0XHQgYm9yZGVyQ29sb3I6dGhpcy5jb250YWluZXJGaWxsQ29sb3IsIFxuXHRcdCBmaWxsQ29sb3I6dGhpcy5jb250YWluZXJGaWxsQ29sb3IsXG5cdFx0IGRhc2hlZDpmYWxzZSwgIFxuXG5cblx0XHQgLy8vXG5cdFx0IGdldFJhbmdlUG9pbnRzOmZ1bmN0aW9uKCl7IC8v6L+U5ZuecmVjdOi+ueS4iueahDjkuKrngrnnmoTlnZDmoIcgXG5cdFx0IFx0cmV0dXJuIF90aGlzLmNyZWF0ZVJhbmdlUG9pbnRzKHRoaXMucG9seVBvaW50cygpKTtcblx0XHQgfSxcblx0XHQgbW91c2VlbnRlcjpmdW5jdGlvbigpeyBcblx0XHQgXHRfdGhpcy5zZXR0aW5nSWNvU2hvdyh0aGlzKTtcblx0XHQgfSxcblx0XHQgbW91c2Vkb3duOmZ1bmN0aW9uKCl7IFxuXG5cdFx0IFx0X3RoaXMuZGVsVG1wTGluZSgpO1xuXHQgXHRcdF90aGlzLmNyZWF0ZU5ld0xpbmUodGhpcyxqc29uT2JqKTtcblxuXG5cdFx0IFx0X3RoaXMubWVudUxheWVySGlkZSgpO1xuXHRcdCBcdF90aGlzLmNvbnRhaW5lck1vdXNlRG93bi5jYWxsKF90aGlzLHRoaXMsanNvbk9iaik7IFxuXG5cdFx0XHRfdGhpcy5jb250ZXh0TWVudU5vZGUgPSBudWxsO1xuXHRcdCBcdF90aGlzLmNvbnRleHRTZXR0aW5nSGlkZSgpO1xuXG5cdFx0IH0sXG5cdFx0IG1vdXNldXA6ZnVuY3Rpb24oZSxwb3Mpe1xuXHRcdCBcdF90aGlzLnNldHRpbmdJY29IaWRlKCk7IFxuXHRcdCBcdF90aGlzLm1lbnVMYXllckhpZGUoKTtcblx0XHQgXHRcblx0XHQgXHRfdGhpcy5jb250YWluZXJNb3VzZVVwLmNhbGwoX3RoaXMsdGhpcyxlLHBvcyxqc29uT2JqKTsgXG5cblx0XHQgfSxcblx0XHQgbW91c2Vtb3ZlOmZ1bmN0aW9uKGUscG9zKXtcblx0XHQgXHRfdGhpcy51cGRhdGVUbXBMaW5lRW5kUG9zKHBvcyk7XG5cdFx0IFx0X3RoaXMuc2V0dGluZ0ljb1Nob3codGhpcyk7XG5cblx0XHQgXHRfdGhpcy5jb250YWluZXJNb3VzZU1vdmUuY2FsbChfdGhpcyx0aGlzLGpzb25PYmopOyBcblxuXHRcdCB9LFxuXHRcdCBtb3VzZW91dDpmdW5jdGlvbigpe1xuXHRcdCBcdF90aGlzLnNldHRpbmdJY29IaWRlKCk7IFxuXHRcdCB9LFxuXHRcdCBkYmxjbGljazpmdW5jdGlvbihlLHBvcyl7XG5cdFx0IFx0X3RoaXMuc2V0dGluZ0ljb0hpZGUoKTsgXG5cdFx0IFx0X3RoaXMubWVudUxheWVySGlkZSgpO1xuXG5cdFx0IFx0X3RoaXMuY29udGFpbmVyRGJsY2xpY2suY2FsbChfdGhpcyx0aGlzLGUscG9zLGpzb25PYmopOyBcblxuXG5cdFx0IH1cblxuXHR9KVxuXG5cdHRoaXMucW5vZGVzLnB1c2godG1wKTtcblx0dGhpcy5iYXNlTm9kZXNXaXRoQ29vcmRpbmF0ZXMucHVzaCh0bXApO1xuXG5cblx0Ly90aGlzLm9wdGlvbnMuaW5pdERhdGEubm9kZemcgOimgea3u+WKoOS4gOmhuVxuXHR2YXIganNvbk9iaiA9IHtcblx0XHRpZDp0bXAuaWQsXG5cdFx0bm9kZUlkOnRtcC5pZCxcblx0XHRub2RlVHlwZTonY29udGFpbmVyJywgIC8v5a655Zmo57G75Z6LXG5cdFx0eDpvYmoueCxcblx0XHR5Om9iai55LFxuXHRcdHRleHQ6KGF0dHJPYmogJiYgYXR0ck9iai50ZXh0KT9hdHRyT2JqLnRleHQ6J+WuueWZqOagh+mimCcsXG5cdFx0d2lkdGg6KGF0dHJPYmogJiYgYXR0ck9iai53aWR0aCk/YXR0ck9iai53aWR0aDp0aGlzLmNvbnRhaW5lck5vZGVXaWR0aCxcblx0XHRoZWlnaHQ6KGF0dHJPYmogJiYgYXR0ck9iai5oZWlnaHQpP2F0dHJPYmouaGVpZ2h0OnRoaXMuY29udGFpbmVyTm9kZUhlaWdodCxcblx0XHRncmlkOihhdHRyT2JqICYmIGF0dHJPYmouZ3JpZCk/YXR0ck9iai5ncmlkOlsxLDFdLCAvL+ihjCDliJdcblx0XHRjaGlsZDpbXSxcblx0XHRjaGlsZE5vZGVzOltdLCAvL3FjYW52YXPlhYPntKDlr7nosaFcblx0XHRhdHRyOntcblx0XHRcdCB0aXRsZVBvc2l0aW9uOid0b3AtY2VudGVyJyxcblx0XHRcdCBjb2xvcjonI2ZmZicsIC8v5qCH6aKY5paH5a2X55qE6aKc6ImyXG5cdFx0XHQgYm9yZGVyQ29sb3I6dGhpcy5jb250YWluZXJGaWxsQ29sb3IsXG5cdFx0XHQgZmlsbENvbG9yOnRoaXMuY29udGFpbmVyRmlsbENvbG9yLFxuXHRcdFx0IGRhc2hlZDpmYWxzZSwgXG5cdFx0fVxuXHR9XG5cdHRoaXMub3B0aW9ucy5pbml0RGF0YS5ub2RlLnB1c2goanNvbk9iaik7XG5cblx0dGhpcy51cGRhdGVJbml0RGF0YSh0bXAsanNvbk9iaik7XG5cblxuXHQvL+a3u+WKoOWuueWZqOeahOagh+mimFxuXHR0aGlzLmluaXRDb250YWluZXJUaXRsZShqc29uT2JqLHRtcCk7XG5cdFxuXG5cdHJldHVybiB0bXAuaWQ7XG5cdFxufTtcblFmbG93LnByb3RvdHlwZS5tb2RpQ29udGFpbmVyR3JpZENvbHVtbiA9IGZ1bmN0aW9uKGNvbHVtbikgeyBcblx0dmFyIGNvbnRhaW5lck5vZGUgPSB0aGlzLmdldE5vZGVPYmoodGhpcy5jb250ZXh0U2V0dGluZ05vZGUuaWQpO1xuXHR2YXIgcGFyZW50SnNvbk5vZGUgPSB0aGlzLmdldEpzb25PYmoodGhpcy5jb250ZXh0U2V0dGluZ05vZGUuaWQpO1xuXG5cdHBhcmVudEpzb25Ob2RlLndpZHRoID0gdGhpcy5jaGlsZE5vZGVXaWR0aCpjb2x1bW4rKGNvbHVtbisxKSp0aGlzLmNvbnRhaW5lckNoaWxkTWFyZ2luO1xuXG5cdC8vIHBhcmVudEpzb25Ob2RlLmdyaWRbMV0gPSBjb2x1bW47XG5cblx0aWYocGFyZW50SnNvbk5vZGUuYXR0ci50aXRsZVBvc2l0aW9uID09ICd0b3AtY2VudGVyJyl7XG5cdFx0dmFyIHN0YXJ0UGxhY2VIb2xkZXJZID0gKHRoaXMuY29udGFpbmVyVGl0bGVIZWlnaHQrdGhpcy5jb250YWluZXJQYWRkaW5nKTtcblx0XHR2YXIgcm93ID0gTWF0aC5jZWlsKChwYXJlbnRKc29uTm9kZS5jaGlsZC5sZW5ndGg9PTA/MTpwYXJlbnRKc29uTm9kZS5jaGlsZC5sZW5ndGgpL2NvbHVtbik7XG5cdFx0cGFyZW50SnNvbk5vZGUuaGVpZ2h0ID0gc3RhcnRQbGFjZUhvbGRlclkgKyB0aGlzLmNoaWxkTm9kZUhlaWdodCpyb3crKHJvdykqdGhpcy5jb250YWluZXJDaGlsZE1hcmdpbjtcblx0XHRwYXJlbnRKc29uTm9kZS5ncmlkID0gW3Jvdyxjb2x1bW5dO1xuXG5cdH1cbiBcblx0Y29udGFpbmVyTm9kZS5zZXRXaWR0aChwYXJlbnRKc29uTm9kZS53aWR0aCk7XG5cdGNvbnRhaW5lck5vZGUuc2V0SGVpZ2h0KHBhcmVudEpzb25Ob2RlLmhlaWdodCk7XG5cblxuXHQvL+WPr+S7peaRhuaUvuWtkOmhueeahOWMuuWfn+S9jee9rlvlt6bkuIrop5LlvIDlp4vkvY3nva7vvIzlj7PkuIvop5Lnu5PmnZ/kvY3nva5dXG5cdHZhciBjaGlsZEFyZWFQb3NpdGlvbiA9IHRoaXMuZ2V0Q2hpbGRBcmVhUG9zaXRpb24ocGFyZW50SnNvbk5vZGUpOyBcblxuXG5cblx0Ly8gLy/lj6/ku6XmkYbmlL7lrZDpobnnmoTljLrln5/kvY3nva4g6K6h566X5Ye65ZCE5Liq5qC85a2Q55qE5Z2Q5qCHXG5cdHZhciBjaGlsZFBvc2l0aW9uID0gdGhpcy5nZXRDaGlsZFBvc2l0aW9uKHBhcmVudEpzb25Ob2RlLGNoaWxkQXJlYVBvc2l0aW9uKTtcblxuXG5cdC8vIC8v5oqK5qC85a2Q5Z2Q5qCH5re75Yqg5YiwYXR0cumHjFxuXHRwYXJlbnRKc29uTm9kZS5hdHRyLmdyaWRQb3NpdGlvbiA9IGNoaWxkUG9zaXRpb247XG5cblxufTtcblFmbG93LnByb3RvdHlwZS5pblNlcnRUb0NvbnRhaW5lciA9IGZ1bmN0aW9uKG9iaixhaW0sdGV4dCkge1xuXHQvL+a3u+WKoOiKgueCueWIsGNvbnRhaW5lclxuXHQvL+agueaNrmNvbnRhaW5lcumHjOeahOS9jee9riDliJ3lp4vljJboioLngrnkvY3nva5cblx0Y29uc29sZS5sb2coJ+WIm+W7uueahOiKgueCuemcgOimgeWIneWni+WIsOWuueWZqOmHjCcpO1xuXG5cdHZhciBwYXJlbnRKc29uTm9kZSA9IHRoaXMuZ2V0SnNvbk9iaihhaW0uaWQpO1xuXHR2YXIgcGFyZW50Tm9kZSA9IHRoaXMuZ2V0Tm9kZU9iaihhaW0uaWQpO1xuXG5cdC8v5piv5ZCm6ZyA6KaB5pS+5aSn5a655ZmoXG5cdC8vYXR0ci5ncmlkUG9zaXRpb25cblx0aWYocGFyZW50SnNvbk5vZGUuYXR0ci5ncmlkUG9zaXRpb24ubGVuZ3RoIDw9IHBhcmVudEpzb25Ob2RlLmNoaWxkLmxlbmd0aCl7IC8v6ZyA6KaB5pS+5aSnXG5cblx0XHQvL+aUvuWkp2NvbnRhaW5lcueahOS4gOihjOWtkOiKgueCueeahOmrmOW6piDlkIzml7bph43mlrDnlJ/miJBKU09O5pWw5o2u5Lit55qEZ3JpZFBvc3Rpb25cblx0XHRwYXJlbnRKc29uTm9kZS5oZWlnaHQgKz0gKHRoaXMuY2hpbGROb2RlSGVpZ2h0K3RoaXMuY29udGFpbmVyQ2hpbGRNYXJnaW4pO1xuXHRcdHBhcmVudEpzb25Ob2RlLmdyaWRbMF0gKz0gMTtcblxuXG5cdFx0Ly8gdmFyIHN0YXJ0UGxhY2VIb2xkZXJZID0gKHRoaXMuY29udGFpbmVyVGl0bGVIZWlnaHQrdGhpcy5jb250YWluZXJQYWRkaW5nKTtcblx0XHQvLyB2YXIgcm93ID0gTWF0aC5jZWlsKChwYXJlbnRKc29uTm9kZS5jaGlsZC5sZW5ndGg9PTA/MTpwYXJlbnRKc29uTm9kZS5jaGlsZC5sZW5ndGgpL2NvbHVtbik7XG5cdFx0Ly8gcGFyZW50SnNvbk5vZGUuaGVpZ2h0ID0gc3RhcnRQbGFjZUhvbGRlclkgKyB0aGlzLmNoaWxkTm9kZUhlaWdodCpyb3crKHJvdykqdGhpcy5jb250YWluZXJDaGlsZE1hcmdpbjtcblx0XHQvLyBwYXJlbnRKc29uTm9kZS5ncmlkID0gW3Jvdyxjb2x1bW5dO1xuXG5cdFx0cGFyZW50Tm9kZS5zZXRIZWlnaHQocGFyZW50SnNvbk5vZGUuaGVpZ2h0KTtcblx0XHRcblx0XHQvL+WPr+S7peaRhuaUvuWtkOmhueeahOWMuuWfn+S9jee9rlvlt6bkuIrop5LlvIDlp4vkvY3nva7vvIzlj7PkuIvop5Lnu5PmnZ/kvY3nva5dXG5cdFx0dmFyIGNoaWxkQXJlYVBvc2l0aW9uID0gdGhpcy5nZXRDaGlsZEFyZWFQb3NpdGlvbihwYXJlbnRKc29uTm9kZSk7XG5cblx0XHQvL+WPr+S7peaRhuaUvuWtkOmhueeahOWMuuWfn+S9jee9riDorqHnrpflh7rlkITkuKrmoLzlrZDnmoTlnZDmoIdcblx0XHR2YXIgY2hpbGRQb3NpdGlvbiA9IHRoaXMuZ2V0Q2hpbGRQb3NpdGlvbihwYXJlbnRKc29uTm9kZSxjaGlsZEFyZWFQb3NpdGlvbik7XG5cblx0XHQvL+aKiuagvOWtkOWdkOagh+a3u+WKoOWIsGF0dHLph4xcblx0XHRwYXJlbnRKc29uTm9kZS5hdHRyLmdyaWRQb3NpdGlvbiA9IGNoaWxkUG9zaXRpb247XG5cblx0fVxuXG5cblx0dmFyIGpzb25PYmogPSB7XG5cdFx0XHRub2RlVHlwZTonbm9kZScsXG5cdFx0XHR0ZXh0OnRleHQ/dGV4dDon5oiR5piv5paw5p2l55qEJyxcblx0XHRcdGF0dHI6e1xuXHRcdFx0XHRjb2xvcjonI2ZmZidcblx0XHRcdH1cblx0fVxuXG5cdHRoaXMuY3JlYXRlQ2hpbGRzT2ZDb250YWluZXIocGFyZW50SnNvbk5vZGUsanNvbk9iaixwYXJlbnRKc29uTm9kZS5jaGlsZC5sZW5ndGgpO1xuXHRcblx0cGFyZW50SnNvbk5vZGUuY2hpbGQucHVzaChqc29uT2JqKTsgXG5cblxufTtcblFmbG93LnByb3RvdHlwZS5hZGROb2RlID0gZnVuY3Rpb24ob2JqLHRpdGxlKSB7XG5cblx0dmFyIF90aGlzID0gdGhpcztcblxuXHQvL+a3u+WKoOiKgueCuVxuXHR2YXIgdG1wID0gdGhpcy5xY2FudmFzLnFyZWN0LnJlY3Qoe1xuXHRcdCBzdGFydDpbb2JqLngsb2JqLnldLFxuXHRcdCB3aWR0aDp0aGlzLmNoaWxkTm9kZVdpZHRoLFxuXHRcdCBoZWlnaHQ6dGhpcy5jaGlsZE5vZGVIZWlnaHQsXG5cdFx0IGJvcmRlckNvbG9yOnRoaXMuY2hpbGROb2RlQm9yZGVyQ29sb3IsIFxuXHRcdCBmaWxsQ29sb3I6dGhpcy5jaGlsZE5vZGVGaWxsQ29sb3IsIFxuXHRcdCBkYXNoZWQ6ZmFsc2UsICBcblx0XHQgZ2V0UmFuZ2VQb2ludHM6ZnVuY3Rpb24oKXsgLy/ov5Tlm55yZWN06L655LiK55qEOOS4queCueeahOWdkOaghyBcblx0XHQgXHRyZXR1cm4gX3RoaXMuY3JlYXRlUmFuZ2VQb2ludHModGhpcy5wb2x5UG9pbnRzKCkpO1xuXHRcdCB9LFxuXHRcdCBtb3VzZWVudGVyOmZ1bmN0aW9uKCl7IFxuXHRcdCBcdF90aGlzLnNldHRpbmdJY29TaG93KHRoaXMpO1xuXHRcdCB9LFxuXHRcdCBtb3VzZWRvd246ZnVuY3Rpb24oKXsgXG5cblx0XHQgXHRfdGhpcy5kZWxUbXBMaW5lKCk7XG5cdCBcdFx0X3RoaXMuY3JlYXRlTmV3TGluZSh0aGlzLGpzb25PYmopO1xuXG5cblx0XHQgXHRfdGhpcy5tZW51TGF5ZXJIaWRlKCk7XG5cdFx0IFx0X3RoaXMuY29udGFpbmVyTW91c2VEb3duLmNhbGwoX3RoaXMsdGhpcyxqc29uT2JqKTsgXG5cdFx0IH0sXG5cdFx0IG1vdXNldXA6ZnVuY3Rpb24oZSxwb3Mpe1xuXHRcdCBcdF90aGlzLnNldHRpbmdJY29IaWRlKCk7IFxuXHRcdCBcdF90aGlzLm1lbnVMYXllckhpZGUoKTtcblx0XHQgXHRcblx0XHQgXHRfdGhpcy5jb250YWluZXJNb3VzZVVwLmNhbGwoX3RoaXMsdGhpcyxlLHBvcyxqc29uT2JqKTsgXG5cblx0XHQgfSxcblx0XHQgbW91c2Vtb3ZlOmZ1bmN0aW9uKGUscG9zKXtcblx0XHQgXHRfdGhpcy51cGRhdGVUbXBMaW5lRW5kUG9zKHBvcyk7XG5cdFx0IFx0X3RoaXMuc2V0dGluZ0ljb1Nob3codGhpcyk7XG5cblx0XHQgXHRfdGhpcy5jb250YWluZXJNb3VzZU1vdmUuY2FsbChfdGhpcyx0aGlzLGpzb25PYmopOyBcblxuXHRcdCB9LFxuXHRcdCBtb3VzZW91dDpmdW5jdGlvbigpe1xuXHRcdCBcdF90aGlzLnNldHRpbmdJY29IaWRlKCk7IFxuXHRcdCB9LFxuXHRcdCBkYmxjbGljazpmdW5jdGlvbihlLHBvcyl7XG5cblx0XHQgXHRjb25zb2xlLmxvZygnZGJsJylcblx0XHQgXHRfdGhpcy5zZXR0aW5nSWNvSGlkZSgpOyBcblx0XHQgXHRfdGhpcy5tZW51TGF5ZXJIaWRlKCk7XG5cblx0XHQgXHRfdGhpcy5jb250YWluZXJEYmxjbGljay5jYWxsKF90aGlzLHRoaXMsZSxwb3MsanNvbk9iaik7IFxuXG5cdFx0IH1cblx0fSlcblxuXHR0aGlzLnFub2Rlcy5wdXNoKHRtcCk7XG5cdHRoaXMuYmFzZU5vZGVzV2l0aENvb3JkaW5hdGVzLnB1c2godG1wKTtcblxuXG5cdC8v5re75Yqg6IqC54K55Yiw55S75biD5LiKXG5cdHZhciBqc29uT2JqID0ge1x0IFxuXHRcdFx0aWQ6dG1wLmlkLFxuXHRcdFx0bm9kZUlkOnRtcC5pZCxcblx0XHRcdG5vZGVUeXBlOidub2RlJywgLy/mma7pgJroioLngrlcblx0XHRcdHg6b2JqLngsXG5cdFx0XHR5Om9iai55LFxuXHRcdFx0dGV4dDp0aXRsZT90aXRsZTon5qCH6aKYJyxcblx0XHRcdGF0dHI6e1xuXHRcdFx0XHQgYm9yZGVyQ29sb3I6dGhpcy5jaGlsZE5vZGVCb3JkZXJDb2xvciwgXG5cdFx0XHRcdCBjb2xvcjonI2ZmZicsXG5cdFx0XHRcdCBmaWxsQ29sb3I6dGhpcy5jaGlsZE5vZGVGaWxsQ29sb3IsXG5cdFx0XHRcdCBkYXNoZWQ6ZmFsc2UsIFxuXHRcdFx0fVxuXHR9XG5cblx0dGhpcy5vcHRpb25zLmluaXREYXRhLm5vZGUucHVzaChqc29uT2JqKTtcblxuXHQvL+WIneWni+WMluiKgueCueagh+mimFxuXHR0aGlzLmluaXROb2RlVGl0bGUoanNvbk9iaix0bXApO1xuXG59O1xuLyoqXG4gICAqIEBkZXNjcmlwdGlvbiDlsITnur/ms5XliKTmlq3ngrnmmK/lkKblnKjlpJrovrnlvaLlhoXpg6hcbiAgICogQHBhcmFtIHtPYmplY3R9IHAg5b6F5Yik5pat55qE54K577yM5qC85byP77yaeyB4OiBY5Z2Q5qCHLCB5OiBZ5Z2Q5qCHIH1cbiAgICogQHBhcmFtIHtBcnJheX0gcG9seSDlpJrovrnlvaLpobbngrnvvIzmlbDnu4TmiJDlkZjnmoTmoLzlvI/lkIwgcFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IOeCuSBwIOWSjOWkmui+ueW9oiBwb2x5IOeahOWHoOS9leWFs+ezu1xuICAgKi9cblFmbG93LnByb3RvdHlwZS5yYXlDYXN0aW5nID0gZnVuY3Rpb24ocCwgcG9seSkge1xuICAgIHZhciBweCA9IHAueCxcbiAgICAgICAgcHkgPSBwLnksXG4gICAgICAgIGZsYWcgPSBmYWxzZVxuXG4gICAgZm9yKHZhciBpID0gMCwgbCA9IHBvbHkubGVuZ3RoLCBqID0gbCAtIDE7IGkgPCBsOyBqID0gaSwgaSsrKSB7XG4gICAgICB2YXIgc3ggPSBwb2x5W2ldLngsXG4gICAgICAgICAgc3kgPSBwb2x5W2ldLnksXG4gICAgICAgICAgdHggPSBwb2x5W2pdLngsXG4gICAgICAgICAgdHkgPSBwb2x5W2pdLnlcblxuICAgICAgLy8g54K55LiO5aSa6L655b2i6aG254K56YeN5ZCIXG4gICAgICBpZigoc3ggPT09IHB4ICYmIHN5ID09PSBweSkgfHwgKHR4ID09PSBweCAmJiB0eSA9PT0gcHkpKSB7XG4gICAgICAgIHJldHVybiAnb24nXG4gICAgICB9XG5cbiAgICAgIC8vIOWIpOaWree6v+auteS4pOerr+eCueaYr+WQpuWcqOWwhOe6v+S4pOS+p1xuICAgICAgaWYoKHN5IDwgcHkgJiYgdHkgPj0gcHkpIHx8IChzeSA+PSBweSAmJiB0eSA8IHB5KSkge1xuICAgICAgICAvLyDnur/mrrXkuIrkuI7lsITnur8gWSDlnZDmoIfnm7jlkIznmoTngrnnmoQgWCDlnZDmoIdcbiAgICAgICAgdmFyIHggPSBzeCArIChweSAtIHN5KSAqICh0eCAtIHN4KSAvICh0eSAtIHN5KVxuXG4gICAgICAgIC8vIOeCueWcqOWkmui+ueW9oueahOi+ueS4ilxuICAgICAgICBpZih4ID09PSBweCkge1xuICAgICAgICAgIHJldHVybiAnb24nXG4gICAgICAgIH1cblxuICAgICAgICAvLyDlsITnur/nqb/ov4flpJrovrnlvaLnmoTovrnnlYxcbiAgICAgICAgaWYoeCA+IHB4KSB7XG4gICAgICAgICAgZmxhZyA9ICFmbGFnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDlsITnur/nqb/ov4flpJrovrnlvaLovrnnlYznmoTmrKHmlbDkuLrlpYfmlbDml7bngrnlnKjlpJrovrnlvaLlhoVcbiAgICByZXR1cm4gZmxhZyA/ICdpbicgOiAnb3V0J1xufTtcblFmbG93LnByb3RvdHlwZS5pbkNvbnRhaW5lciA9IGZ1bmN0aW9uKG9iaikgeyAgIFxuXG5cdHZhciBlbGUgPSB0aGlzLnFjYW52YXMuZWxlbWVudHM7IFxuXHQvLyBjb25zb2xlLmxvZyhlbGUpO1xuXHR2YXIgYWltID0gbnVsbDtcblx0Zm9yICh2YXIgaSA9IGVsZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdGlmKGVsZVtpXS5kaXNwbGF5ICE9J25vbmUnICYmIGVsZVtpXS5UWVBFICE9J2xheWVyJyAmJiB0aGlzLnJheUNhc3Rpbmcoe3g6b2JqLngseTpvYmoueX0sZWxlW2ldLnBvbHlQb2ludHMoKSkgPT0gJ2luJyl7XG5cdFx0XHRjb25zb2xlLmxvZygn5om+5Yiw5LqGJyk7XG5cdFx0XHRhaW0gPSBlbGVbaV07XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHR2YXIgc2lnbiA9IGZhbHNlO1xuXHRpZihhaW0gIT09IG51bGwpe1xuXG5cdFx0aWYodHlwZW9mIGFpbS5vd25lcklkICE9J3VuZGVmaW5lZCcpeyAvL+ebruagh+WcqOafkOS4quWuueWZqOmHjOeahOafkOS4quiKgueCueS4ilxuXG5cdFx0XHR2YXIgb3duZXJPYmogPSB0aGlzLmdldEpzb25PYmooYWltLm93bmVySWQpO1xuXHRcdFx0YWltID0gdGhpcy5nZXROb2RlT2JqKGFpbS5vd25lcklkKTtcblx0XHRcdGlmKG93bmVyT2JqLm5vZGVUeXBlID09ICdjb250YWluZXInKXtcblx0XHRcdFx0c2lnbiA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHR9ZWxzZXtcblxuXHRcdFx0dmFyIHRtcCA9IHRoaXMuZ2V0SnNvbk9iaihhaW0uaWQpO1xuXHRcdFx0aWYodG1wICE9PSBudWxsICYmIHRtcC5ub2RlVHlwZSA9PSAnY29udGFpbmVyJyl7XG5cdFx0XHRcdHNpZ24gPSB0cnVlO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHNpZ246c2lnbixcblx0XHRhaW06YWltXG5cdH1cblxuXG59O1xuXG5RZmxvdy5wcm90b3R5cGUuYWRkRWxlID0gZnVuY3Rpb24ob2JqKSB7XG5cblx0c3dpdGNoKG9iai5pZCl7XG5cdFx0Y2FzZSAnLTEnOlxuXHRcdFx0dmFyIGlkID0gdGhpcy5hZGRDb250YWluZXIob2JqKTtcblxuXHRcdFx0Ly/pu5jorqTliqDkuIDkuKroioLngrnov5vlrrnlmahcblx0XHRcdHRoaXMuaW5TZXJ0VG9Db250YWluZXIoe30se2lkOmlkfSwn5qCH6aKYJyk7XG5cblx0XHRicmVhaztcblx0XHRjYXNlICcxJzpcblx0XHRcdHZhciB0bXAgPSB0aGlzLmluQ29udGFpbmVyKG9iaik7Ly/liKTmlq3mmK/lkKbmi5bliqjliLDmn5DkuobkuKrlrrnlmajph4xcblx0XHRcdC8vIGNvbnNvbGUubG9nKHRtcCk7XG5cdFx0XHRpZih0bXAuc2lnbil7XG5cdFx0XHRcdHRoaXMuaW5TZXJ0VG9Db250YWluZXIob2JqLHRtcC5haW0pO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHRoaXMuYWRkTm9kZShvYmopO1xuXHRcdFx0fSBcblx0XHRicmVhaztcblx0XHRjYXNlICcyJzogLy/lpJrooYzmlofkvZPoioLngrlcblx0XHRcdHRoaXMuYWRkVGlwTm9kZShvYmopO1xuXHRcdGJyZWFrO1xuXG5cdH1cblx0XG5cblxuXG5cbn07XG5RZmxvdy5wcm90b3R5cGUuY2FudmFzVXBGdW4gPSBmdW5jdGlvbigpIHtcblx0Y29uc29sZS5sb2coJ2NhbnZhc1VwRnVuJyk7XG5cblxuXHQvL+WmguaenOaYr+aLluWKqOWujOWQjiDpnIDopoHmiop0aGlzLmJhc2VOb2Rlc1dpdGhDb29yZGluYXRlc+S4reeahOWvueixoeeahOWdkOagh+aVsOaNruWQjOatpeWIsOmdmeaAgWpzb27mlbDmja7kuK1cblx0XG5cbn07XG5RZmxvdy5wcm90b3R5cGUuY2FudmFzTW92ZUZ1biA9IGZ1bmN0aW9uKGUscG9zKSB7IFxuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXHR0aGlzLnVwZGF0ZVRtcExpbmVFbmRQb3MocG9zKTtcblxuXHRpZih0aGlzLnFjYW52YXMuZHJhZ0FpbSAhPT0gbnVsbCAmJlxuXHRcdHRoaXMucWNhbnZhcy5kcmFnQWltLmlkID09IHRoaXMucWNhbnZhcy5pZFxuXHRcdCl7XG5cblx0XHRpZih0aGlzLnFub2Rlcy5sZW5ndGggPT0gMCl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuIFxuXG5cdFx0Ly/np7vliqjnlLvluIPkuIrmiYDmnInlhYPntKBcblx0XHR0aGlzLmJhc2VOb2Rlc1dpdGhDb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuXG5cdFx0XHRpdGVtLnN0YXJ0ID0gW3Bvcy54LWl0ZW0uZGlzLngscG9zLnktaXRlbS5kaXMueV07XG4gXG5cdFx0IFx0KF90aGlzLmdldEpzb25PYmooaXRlbS5pZCkgIT09IG51bGwpICYmIF90aGlzLnVwZGF0ZUluaXREYXRhKGl0ZW0sX3RoaXMuZ2V0SnNvbk9iaihpdGVtLmlkKSk7XG5cblx0XHR9KSBcblxuXG5cdH1cbn07XG5RZmxvdy5wcm90b3R5cGUuY2FudmFzRG93bkZ1biA9IGZ1bmN0aW9uKGUscG9zKSB7XG5cdC8vIGNvbnNvbGUubG9nKCdjYW52YXNEb3duRnVuJyk7XG5cdHRoaXMuZGVsVG1wTGluZSgpO1xuXHR0aGlzLmNvbnRleHRNZW51Tm9kZSA9IG51bGw7XG5cblx0dGhpcy5tZW51TGF5ZXJIaWRlKCk7XG5cdHRoaXMubGluZU1lbnVMYXllckhpZGUoKTtcblxuXHR0aGlzLmNvbnRleHRTZXR0aW5nSGlkZSgpO1xuXG5cdHRoaXMudGlwVGV4dEhpZGUoKTtcblxuXHQvL+eUn+aIkOeUu+W4g+eCueWHu+S9jee9rui3nXRoaXMuYmFzZU5vZGVzV2l0aENvb3JkaW5hdGVz5Lit5q+P5Liq5a+56LGh5Z2Q5qCH5YC855qE6Led56a7XG5cdHRoaXMuYmFzZU5vZGVzV2l0aENvb3JkaW5hdGVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XG5cblx0XHRpdGVtLmRpcyA9IHtcblx0XHRcdHg6cG9zLnggLSBpdGVtLnN0YXJ0WzBdLFxuXHRcdFx0eTpwb3MueSAtIGl0ZW0uc3RhcnRbMV1cblx0XHR9XG5cdH0pIFxuXG5cblxufTtcblxuUWZsb3cucHJvdG90eXBlLnJlY3REb3duID0gZnVuY3Rpb24ocG9zKSB7XG5cdC8vIGNvbnNvbGUubG9nKHBvcyk7XG5cdC8vIGNvbnNvbGUubG9nKHRoaXMpO1xufTtcblxuXG5RZmxvdy5wcm90b3R5cGUuaW5pdFRvb2wgPSBmdW5jdGlvbigpIHtcblxuXHR2YXIgaCA9IHRoaXMub3B0aW9uc1syXTtcblx0dmFyIHRvb2wgPSB0aGlzLnFjYW52YXMucXJlY3QucmVjdCh7ICAvL+W3peWFt+agj+Wklui+ueahhlxuXHRcdFx0XHRzdGFydDpbMCwwXSxcblx0XHRcdFx0d2lkdGg6MjAwLFxuXHRcdFx0XHRsaW5lV2lkdGg6MC41LFxuXHRcdFx0XHRoZWlnaHQ6aCxcblx0XHRcdFx0ZHJhZzpmYWxzZVxuXHRcdFx0fSk7XG5cdHZhciByZWN0ID0gdGhpcy5xY2FudmFzLnFyZWN0LnJlY3QoeyAgLy/nn6nlvaLlhYPntKBcblx0XHRcdHN0YXJ0OmZ1bmN0aW9uKCl7cmV0dXJuIFt0b29sLnN0YXJ0WzBdKzIwLHRvb2wuc3RhcnRbMV0rMjBdfSxcblx0XHRcdHdpZHRoOjcwLFxuXHRcdFx0aGVpZ2h0OjUwLFxuXHRcdFx0ZHJhZzpmYWxzZSxcblx0XHRcdG1vdXNlZG93bjp0aGlzLnJlY3REb3duXG5cdFx0fSlcblx0dmFyIGRpYW1vbmQgPSB0aGlzLnFjYW52YXMucXNoYXBlLnNoYXBlKHtcblxuXHRcdC8vIHBvaW50czpbWzgwLDEwXSxbODAsNTBdLFsxNTAsNzBdLFsxNjAsMjBdXSxcblx0XHRmaWxsQ29sb3I6JycsXG5cdFx0cG9pbnRzOmZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRbdG9vbC5zdGFydFswXStyZWN0LndpZHRoKzMwLHRvb2wuc3RhcnRbMV0rNDVdLFxuXHRcdFx0XHRbdG9vbC5zdGFydFswXStyZWN0LndpZHRoKzcwLHRvb2wuc3RhcnRbMV0rMjBdLFxuXHRcdFx0XHRbdG9vbC5zdGFydFswXStyZWN0LndpZHRoKzExMCx0b29sLnN0YXJ0WzFdKzQ1XSwgXG5cdFx0XHRcdFt0b29sLnN0YXJ0WzBdK3JlY3Qud2lkdGgrNzAsdG9vbC5zdGFydFsxXSs3MF0sICBcblx0XHRcdF1cblx0XHR9LFxuXHRcdGRyYWc6ZmFsc2Vcblx0fSlcblxuXHR2YXIgYXJjID0gdGhpcy5xY2FudmFzLnFhcmMuYXJjKHtcblx0XHRzdGFydDpbMzAwLDEwMF0sXG5cdFx0c0FuZ2xlOjAsXG5cdFx0ZUFuZ2xlOjIwMCxcblx0XHRmaWxsQ29sb3I6JycsXG5cdFx0cjoxMFxuXHR9KVxuXG5cdHRoaXMudG9vbExheWVyLnB1c2godG9vbCxyZWN0LGRpYW1vbmQsYXJjKTtcblx0XG5cblxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5RZmxvdyA9IFFmbG93OyBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbGliL1FmbG93LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///34\n");

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    \"div\",\n    { attrs: { id: \"qflow_lay\" } },\n    [\n      _c(\"div\", { staticClass: \"tool\" }, [\n        _vm._m(0),\n        _vm._v(\" \"),\n        _vm._m(1),\n        _vm._v(\" \"),\n        _vm._m(2),\n        _vm._v(\" \"),\n        _c(\"span\", { staticClass: \"save\", on: { click: _vm.save } }, [\n          _c(\"img\", {\n            attrs: {\n              src:\n                \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjAyMjk4MDA1NzAyIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjQ0MTQiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PGRlZnM+PHN0eWxlIHR5cGU9InRleHQvY3NzIj48L3N0eWxlPjwvZGVmcz48cGF0aCBkPSJNODk1LjgzIDYyLjEwMmMzMS43NjEgNS4yOTQgNTIuOTM1IDI2LjQ2OCA2MC44NzYgNTIuOTM1IDcuOTQgMTguNTI3IDUuMjk0IDgyLjA0OSA1LjI5NCAxMDguNTE3djYxNi42OTVjMCAxOC41MjcgMCA0Mi4zNDktMi42NDcgNTUuNTgyLTIuNjQ3IDMxLjc2MS0yMy44MjEgNTIuOTM1LTUwLjI4OCA2MC44NzYtMTguNTI3IDcuOTQtODQuNjk3IDUuMjk0LTEwOC41MTcgNS4yOTQtMjA2LjQ0NyAwLTQxMi44OTUgMC02MTkuMzQyIDAtMTUuODgxIDAtMzkuNzAxIDAtNTUuNTgyLTIuNjQ3LTI5LjExNS0yLjY0Ny01Mi45MzUtMjMuODIxLTYwLjg3Ni01MC4yODgtNS4yOTQtMTguNTI3LTIuNjQ3LTg0LjY5Ny0yLjY0Ny0xMDguNTE3di02MTkuMzQyYzAtMTUuODgxIDAtMzcuMDU1IDAtNTIuOTM1IDUuMjk0LTMxLjc2MSAyNi40NjctNTIuOTM1IDUyLjkzNS02My41MjIgMTguNTI3LTUuMjk0IDgyLjA0OS0yLjY0NyAxMDguNTE3LTIuNjQ3IDIwNi40NDcgMCA0MTAuMjQ4IDAgNjE2LjY5NSAwIDE1Ljg4MSAwIDM5LjcwMSAwIDU1LjU4MiAwek0zMzQuNzE5IDM2MS4xODZoMzU0LjY2NmMxMC41ODcgMCAxMy4yMzQtNS4yOTQgMTMuMjM0LTEzLjIzNHYtMjMwLjI2OGgtMzgxLjEzM3YyMjIuMzI4YzAgMTUuODgxLTIuNjQ3IDIxLjE3MyAxMy4yMzQgMjEuMTczek03NTguMiAxMTcuNjg0djI0OC43OTZjMCAzNy4wNTUtNy45NCA1MC4yODgtNDQuOTk0IDUwLjI4OC05Ny45MyAwLTM3MC41NDYgMC00MTguMTg4IDAtMjEuMTczIDAtMjkuMTE1LTEwLjU4Ny0yOS4xMTUtMzcuMDU1di0yNjIuMDI5Yy0zMS43NjEgMC04NC42OTcgMC0xMTYuNDU4IDAtMTUuODgxIDAtMjYuNDY3IDAtMjkuMTE1IDEwLjU4Ny0yLjY0NyA3Ljk0LTIuNjQ3IDEzNy42MzItMi42NDcgMTU2LjE1OHY1OTIuODc0YzAgMTMuMjM0IDAgMjMuODIxIDEzLjIzNCAyNi40NjcgNS4yOTQgMi42NDcgMTM3LjYzMiAyLjY0NyAxNTYuMTU4IDIuNjQ3IDUyLjkzNSAwIDU4LjIyOCAwIDExMS4xNjQgMHYtMTc5Ljk3OWgyMjcuNjIxdjE3OS45NzljNzQuMTA5IDAgMTExLjE2NCAwIDE4Ny45MiAwIDEwLjU4NyAwIDc0LjEwOSAwIDc5LjQwMy0yLjY0NyAxMC41ODctMi42NDcgMTMuMjM0LTEwLjU4NyAxMy4yMzQtMjYuNDY3di02NjkuNjNjMC0xMy4yMzQgMC02OC44MTUtMi42NDctNzYuNzU2LTIuNjQ3LTEzLjIzNC0xOC41MjctMTMuMjM0LTI2LjQ2Ny0xMy4yMzQtMzQuNDA4IDAtODQuNjk3IDIuNjQ3LTExOS4xMDQgMHpNNDUzLjgyMyA5MDMuNzcybDExNi40NTggMi42NDd2LTEyNC4zOThoLTExNi40NTh2MTIxLjc1MXoiIHAtaWQ9IjQ0MTUiPjwvcGF0aD48L3N2Zz4=\",\n              height: \"20\",\n              alt: \"\",\n              draggable: \"false\"\n            }\n          })\n        ]),\n        _vm._v(\" \"),\n        _c(\"span\", { staticClass: \"download\", on: { click: _vm.download } }, [\n          _c(\"img\", {\n            attrs: {\n              src:\n                \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjAyMzk1NTUzNjQwIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjI0MDkiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PGRlZnM+PHN0eWxlIHR5cGU9InRleHQvY3NzIj48L3N0eWxlPjwvZGVmcz48cGF0aCBkPSJNODMyLjEgNTkyLjdjLTExIDAtMjAgOS0yMCAyMHYxNTEuMmMwIDExLTkgMjAtMjAgMjBIMjMxLjljLTExIDAtMjAtOS0yMC0yMFY2MTIuN2MwLTExLTktMjAtMjAtMjBzLTIwIDktMjAgMjB2MTUxLjJjMCAzMy4xIDI2LjkgNjAgNjAgNjBINzkyYzMzLjEgMCA2MC0yNi45IDYwLTYwVjYxMi43YzAuMS0xMS04LjktMjAtMTkuOS0yMHoiIHAtaWQ9IjI0MTAiPjwvcGF0aD48cGF0aCBkPSJNNDY4LjMgNjU4LjZjMTEuMyAxMS45IDI3LjIgMTguNyA0My42IDE4LjcgMTYuNCAwIDMyLjMtNi44IDQzLjYtMTguOGw5OS4xLTEwNC43YzcuNi04IDcuMi0yMC43LTAuOC0yOC4zLTgtNy42LTIwLjctNy4yLTI4LjMgMC44bC05My42IDk4LjlWMjIwYzAtMTEtOS0yMC0yMC0yMHMtMjAgOS0yMCAyMHY0MDUuMmwtOTMuNC05OC42Yy03LjYtOC0yMC4zLTguNC0yOC4zLTAuOC04IDcuNi04LjQgMjAuMy0wLjggMjguM2w5OC45IDEwNC41eiIgcC1pZD0iMjQxMSI+PC9wYXRoPjwvc3ZnPg==\",\n              height: \"20\",\n              alt: \"\",\n              draggable: \"false\"\n            }\n          })\n        ]),\n        _vm._v(\" \"),\n        _c(\"span\", { staticClass: \"json\", on: { click: _vm.jsShow } }, [\n          _c(\"img\", {\n            attrs: {\n              src:\n                \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjAzMzgyNzgzMzY1IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjI3MjgiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PGRlZnM+PHN0eWxlIHR5cGU9InRleHQvY3NzIj48L3N0eWxlPjwvZGVmcz48cGF0aCBkPSJNMjE2LjQgMTA3LjFoNTAuMmM1LjcgMCAxMC40IDQuNyAxMC40IDEwLjRWMTU2YzAgNS43LTQuNyAxMC40LTEwLjQgMTAuNGgtNDUuOGMtNS43IDAtMTMuNCA0LjYtMTMuNCAxMC40bC0xIDI0Ni42Yy0xLjMgMzUuMi0yNS4xIDkwLTU4LjYgOTEuNCAyMy4yLTEgNTkuNiAzOS41IDU5LjYgODkuNGwtMSAyNDIuNGMwIDUuOCA0LjcgMTkuNiAxMC42IDE5LjZoNDkuM2M1LjkgMCAxMC44IDYuOCAxMC44IDEyLjh2MzAuOWMwIDUuOS00LjggMTAuOC0xMC44IDEwLjhoLTQ5LjhjLTMyLjQtMTIuMi02MC42LTQwLjctNjAuNi05MC40di0xODFjMC00OS45LTI3LjEtOTAuNC02MC42LTkwLjRINzcuMWMtNi44IDAtMTIuMi01LjUtMTIuMi0xMi4ydi02NS45YzAtNi44IDUuNS0xMi4yIDEyLjItMTIuMmgxOC4xYzMzLjUgMCA2MC42LTQwLjUgNjAuNi05MC40VjE5Ny40YzAtNDkuOSAyNy4xLTkwLjMgNjAuNi05MC4zTTgwOC42IDEwNy4xYzMzLjUgMCA2MC42IDQwLjQgNjAuNiA5MC4zdjE4MC44YzAgNDkuOSAyNy4xIDkwLjQgNjAuNiA5MC40aDE4LjFjNi43IDAgMTIuMiA1LjQgMTIuMiAxMi4ydjY1LjljMCA2LjctNS40IDEyLjItMTIuMiAxMi4yaC0xOC4yYy0zMy41IDAtNjAuNiA0MC41LTYwLjYgOTAuNHYxODFjMCA0OS43LTI4LjIgNzguMi02MC42IDkwLjRoLTQ5LjhjLTYgMC0xMC44LTQuOS0xMC44LTEwLjhWODc5YzAtNiA0LjktMTIuOCAxMC44LTEyLjhIODA4YzUuOSAwIDEwLjYtMTMuOCAxMC42LTE5LjZsLTEtMjQyLjRjMC00OS45IDM2LjQtOTAuNCA1OS42LTg5LjQtMzMuNS0xLjQtNTcuMy01Ni4yLTU4LjYtOTEuNGwtMS0yNDYuNmMwLTUuOC03LjctMTAuNC0xMy40LTEwLjRoLTQ1LjhjLTUuNyAwLTEwLjQtNC43LTEwLjQtMTAuNHYtMzguNWMwLTUuNyA0LjctMTAuNCAxMC40LTEwLjRoNTAuMk01MDguNCA2NjcuOGMxNi44IDAgMzAuNCAxMy42IDMwLjQgMzAuNCAwIDE2LjgtMTMuNiAzMC40LTMwLjQgMzAuNC0xNi44IDAtMzAuNC0xMy42LTMwLjQtMzAuNCAwLTE2LjggMTMuNi0zMC40IDMwLjQtMzAuNE0zODYuOCA2NjcuOGMxNi44IDAgMzAuNCAxMy42IDMwLjQgMzAuNCAwIDE2LjgtMTMuNiAzMC40LTMwLjQgMzAuNC0xNi44IDAtMzAuNC0xMy42LTMwLjQtMzAuNCAwLTE2LjggMTMuNi0zMC40IDMwLjQtMzAuNE02MzAgNjY3LjhjMTYuOCAwIDMwLjQgMTMuNiAzMC40IDMwLjQgMCAxNi44LTEzLjYgMzAuNC0zMC40IDMwLjQtMTYuOCAwLTMwLjQtMTMuNi0zMC40LTMwLjQgMC0xNi44IDEzLjYtMzAuNCAzMC40LTMwLjR6IiBwLWlkPSIyNzI5Ij48L3BhdGg+PC9zdmc+\",\n              height: \"20\",\n              alt: \"\",\n              draggable: \"false\"\n            }\n          })\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\n        \"div\",\n        {\n          style: { height: _vm.initHeight + \"px\" },\n          attrs: { id: \"qcanvas_lay\" }\n        },\n        [\n          _c(\"canvas\", { attrs: { id: \"qcanvas\" } }),\n          _vm._v(\" \"),\n          _c(\"input\", {\n            directives: [\n              {\n                name: \"model\",\n                rawName: \"v-model\",\n                value: _vm.nodeTitle,\n                expression: \"nodeTitle\"\n              }\n            ],\n            attrs: { type: \"text\", id: \"titleInput\", autocomplete: \"off\" },\n            domProps: { value: _vm.nodeTitle },\n            on: {\n              input: [\n                function($event) {\n                  if ($event.target.composing) {\n                    return\n                  }\n                  _vm.nodeTitle = $event.target.value\n                },\n                _vm.modiTitle\n              ],\n              keyup: function($event) {\n                if (\n                  !$event.type.indexOf(\"key\") &&\n                  _vm._k($event.keyCode, \"enter\", 13, $event.key, \"Enter\")\n                ) {\n                  return null\n                }\n                return _vm.onSubmit($event)\n              }\n            }\n          }),\n          _vm._v(\" \"),\n          _c(\"input\", {\n            directives: [\n              {\n                name: \"model\",\n                rawName: \"v-model.number\",\n                value: _vm.containerGridColumn,\n                expression: \"containerGridColumn\",\n                modifiers: { number: true }\n              }\n            ],\n            attrs: {\n              type: \"text\",\n              id: \"containerGridColumn\",\n              autocomplete: \"off\"\n            },\n            domProps: { value: _vm.containerGridColumn },\n            on: {\n              input: [\n                function($event) {\n                  if ($event.target.composing) {\n                    return\n                  }\n                  _vm.containerGridColumn = _vm._n($event.target.value)\n                },\n                _vm.modiContainerGridColumn\n              ],\n              blur: function($event) {\n                return _vm.$forceUpdate()\n              }\n            }\n          }),\n          _vm._v(\" \"),\n          _c(\"textarea\", {\n            directives: [\n              {\n                name: \"model\",\n                rawName: \"v-model\",\n                value: _vm.tipText,\n                expression: \"tipText\"\n              }\n            ],\n            attrs: { name: \"\", id: \"tip\" },\n            domProps: { value: _vm.tipText },\n            on: {\n              input: [\n                function($event) {\n                  if ($event.target.composing) {\n                    return\n                  }\n                  _vm.tipText = $event.target.value\n                },\n                function($event) {\n                  return _vm.modTip($event)\n                }\n              ]\n            }\n          }),\n          _vm._v(\" \"),\n          _c(\"input\", {\n            directives: [\n              {\n                name: \"model\",\n                rawName: \"v-model\",\n                value: _vm.lineNodeTitle,\n                expression: \"lineNodeTitle\"\n              }\n            ],\n            attrs: { type: \"text\", id: \"lineTitleInput\", autocomplete: \"off\" },\n            domProps: { value: _vm.lineNodeTitle },\n            on: {\n              input: [\n                function($event) {\n                  if ($event.target.composing) {\n                    return\n                  }\n                  _vm.lineNodeTitle = $event.target.value\n                },\n                _vm.modiLineTitle\n              ]\n            }\n          }),\n          _vm._v(\" \"),\n          _c(\n            \"select\",\n            {\n              directives: [\n                {\n                  name: \"model\",\n                  rawName: \"v-model\",\n                  value: _vm.lineLike,\n                  expression: \"lineLike\"\n                }\n              ],\n              attrs: { id: \"lineLike\", autocomplete: \"off\" },\n              on: {\n                change: [\n                  function($event) {\n                    var $$selectedVal = Array.prototype.filter\n                      .call($event.target.options, function(o) {\n                        return o.selected\n                      })\n                      .map(function(o) {\n                        var val = \"_value\" in o ? o._value : o.value\n                        return val\n                      })\n                    _vm.lineLike = $event.target.multiple\n                      ? $$selectedVal\n                      : $$selectedVal[0]\n                  },\n                  _vm.modiLineLike\n                ]\n              }\n            },\n            _vm._l(_vm.lineStyleList, function(item) {\n              return _c(\"option\", { domProps: { value: item.value } }, [\n                _vm._v(_vm._s(item.name))\n              ])\n            }),\n            0\n          ),\n          _vm._v(\" \"),\n          _c(\n            \"select\",\n            {\n              directives: [\n                {\n                  name: \"model\",\n                  rawName: \"v-model\",\n                  value: _vm.lineType,\n                  expression: \"lineType\"\n                }\n              ],\n              attrs: { id: \"lineType\", autocomplete: \"off\" },\n              on: {\n                change: [\n                  function($event) {\n                    var $$selectedVal = Array.prototype.filter\n                      .call($event.target.options, function(o) {\n                        return o.selected\n                      })\n                      .map(function(o) {\n                        var val = \"_value\" in o ? o._value : o.value\n                        return val\n                      })\n                    _vm.lineType = $event.target.multiple\n                      ? $$selectedVal\n                      : $$selectedVal[0]\n                  },\n                  _vm.modiLineType\n                ]\n              }\n            },\n            _vm._l(_vm.lineTypeList, function(item) {\n              return _c(\"option\", { domProps: { value: item.value } }, [\n                _vm._v(_vm._s(item.name))\n              ])\n            }),\n            0\n          )\n        ]\n      ),\n      _vm._v(\" \"),\n      _c(\n        \"el-dialog\",\n        {\n          attrs: { title: \"json数据\", visible: _vm.show, width: \"30%\" },\n          on: {\n            \"update:visible\": function($event) {\n              _vm.show = $event\n            },\n            close: _vm.close\n          }\n        },\n        [\n          _c(\"div\", { staticClass: \"json_lay\" }, [\n            _vm._v(\"\\n\\t    \\t\" + _vm._s(_vm.json) + \"\\n\\t    \")\n          ])\n        ]\n      )\n    ],\n    1\n  )\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"span\", { staticClass: \"drag_ele\", attrs: { \"data-id\": \"-1\" } }, [\n      _c(\"img\", {\n        attrs: {\n          src:\n            \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjAyMjk3NTk0ODc5IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjIxNDciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PGRlZnM+PHN0eWxlIHR5cGU9InRleHQvY3NzIj48L3N0eWxlPjwvZGVmcz48cGF0aCBkPSJNMjU2IDI4OGg2NHY2NGgtNjR6IG0xMjggMzg0aDM4NHY2NEgzODR6TTI1NiA0ODBoNjR2NjRoLTY0eiBtMCAxOTJoNjR2NjRoLTY0eiIgZmlsbD0iIzMzMzMzMyIgcC1pZD0iMjE0OCI+PC9wYXRoPjxwYXRoIGQ9Ik04MzIgNjRIMTkyYy0zNS4yIDAtNjQgMjguOC02NCA2NHY3NjhjMCAzNS4yIDI4LjggNjQgNjQgNjRoNjQwYzM1LjIgMCA2NC0yOC44IDY0LTY0VjEyOGMwLTM1LjItMjguOC02NC02NC02NHogbTAgODAwYzAgMTkuMi0xNiAzMi0zMiAzMkgyMjRjLTE2IDAtMzItMTIuOC0zMi0zMlYxNjBjMC0xOS4yIDE2LTMyIDMyLTMyaDU3NmMxNiAwIDMyIDEyLjggMzIgMzJ2NzA0eiIgZmlsbD0iIzMzMzMzMyIgcC1pZD0iMjE0OSI+PC9wYXRoPjxwYXRoIGQ9Ik0zODQgNDgwaDM4NHY2NEgzODR6IG0wLTE5MmgzODR2NjRIMzg0eiIgZmlsbD0iIzMzMzMzMyIgcC1pZD0iMjE1MCI+PC9wYXRoPjwvc3ZnPg==\",\n          height: \"20\",\n          alt: \"\",\n          draggable: \"false\"\n        }\n      })\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"span\", { staticClass: \"drag_ele\", attrs: { \"data-id\": \"1\" } }, [\n      _c(\"img\", {\n        attrs: {\n          src:\n            \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjAyMjk3ODY3NDcwIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM1MjYiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PGRlZnM+PHN0eWxlIHR5cGU9InRleHQvY3NzIj48L3N0eWxlPjwvZGVmcz48cGF0aCBkPSJNNDU4LjIgMzcxSDExMi42Qzg2LjkgMzcxIDY2IDM1MC4xIDY2IDMyNC41VjE2NC45YzAtMjUuNyAyMC45LTQ2LjUgNDYuNS00Ni41aDM0NS42YzI1LjcgMCA0Ni41IDIwLjkgNDYuNSA0Ni41djE1OS41YzAuMSAyNS43LTIwLjggNDYuNi00Ni40IDQ2LjZ6TTExMi42IDE1OC4zYy0zLjYgMC02LjYgMy02LjYgNi42djE1OS41YzAgMy42IDMgNi42IDYuNiA2LjZoMzQ1LjZjMy42IDAgNi42LTMgNi42LTYuNlYxNjQuOWMwLTMuNi0zLTYuNi02LjYtNi42SDExMi42ek05MTAuMSA5MDhIMjU4LjhjLTI1LjcgMC00Ni41LTIwLjktNDYuNS00Ni41VjUxNS45YzAtMjUuNyAyMC45LTQ2LjUgNDYuNS00Ni41aDY1MS4zYzI1LjcgMCA0Ni41IDIwLjkgNDYuNSA0Ni41djM0NS42YzAgMjUuNy0yMC44IDQ2LjUtNDYuNSA0Ni41ek0yNTguOCA1MDkuMmMtMy42IDAtNi42IDMtNi42IDYuNnYzNDUuNmMwIDMuNiAzIDYuNiA2LjYgNi42aDY1MS4zYzMuNiAwIDYuNi0zIDYuNi02LjZWNTE1LjljMC0zLjYtMy02LjYtNi42LTYuNkgyNTguOHoiIGZpbGw9IiM0RjRGNEYiIHAtaWQ9IjM1MjciPjwvcGF0aD48cGF0aCBkPSJNMjI1LjUgNjk1LjNoLTU5LjNjLTE4LjMgMC0zMy4yLTE0LjktMzMuMi0zMy4xbC0wLjUtMzA1LjhjMC0xMSA4LjktMjAgMTkuOS0yMCAxMSAwIDE5LjkgOC45IDE5LjkgMTkuOWwwLjUgMjk5LjFoNTIuN2MxMSAwIDE5LjkgOC45IDE5LjkgMTkuOXMtOC44IDIwLTE5LjkgMjB6IiBmaWxsPSIjNEY0RjRGIiBwLWlkPSIzNTI4Ij48L3BhdGg+PC9zdmc+\",\n          height: \"20\",\n          alt: \"\",\n          draggable: \"false\"\n        }\n      })\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"span\", { staticClass: \"drag_ele\", attrs: { \"data-id\": \"2\" } }, [\n      _c(\"img\", {\n        attrs: {\n          src:\n            \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjAzMDgxOTIxMDg0IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjMxMjEiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PGRlZnM+PHN0eWxlIHR5cGU9InRleHQvY3NzIj48L3N0eWxlPjwvZGVmcz48cGF0aCBkPSJNNjQuNzEzODg0IDY1MC40MDQyMWw4OTIuNjg0MjMyIDAgMCA1NS4wNTM4NzMtODkyLjY4NDIzMiAwIDAtNTUuMDUzODczWiIgcC1pZD0iMzEyMiI+PC9wYXRoPjxwYXRoIGQ9Ik01MTEuMDU3NTM1IDIzNy40ODc4NzlsNDQ2LjM0MDU4MSAwIDAgNTUuMDU2OTQzLTQ0Ni4zNDA1ODEgMCAwLTU1LjA1Njk0M1oiIHAtaWQ9IjMxMjMiPjwvcGF0aD48cGF0aCBkPSJNMTg5LjIyNTY4OSA0ODQuMzY3NjYzbDE4OC45NTM0OSAwIDQ2LjI4ODIzMyAxMTQuNzQ4NDQxIDY0Ljc0MTUxMyAwTDMxNi4zNjk0MzggMTc5LjkwNDM5M2wtNjIuNjk0OTAxIDBMODAuODMzMDAzIDU5OS4xMTYxMDNsNjQuNzQzNTYgMEwxODkuMjI1Njg5IDQ4NC4zNjc2NjN6TTI3NS42NDkwMTQgMjYyLjcxOTU0YzIuNzMxMjA0LTYuODU2MTUyIDUuMTcyODEzLTE2LjU5NzAwMyA3LjMxOTcwOS0yOS4yMjk3MThsMS40Njc0MjEgMGMyLjUzNTc1MyAxMy44OTU0NzUgNC44ODAxNDcgMjMuNjM2MzI3IDcuMDMwMTE0IDI5LjIyOTcxOGw2OC41NDkyMzYgMTc0LjI4ODQ4OEwyMDcuNjgyMDQgNDM3LjAwODAyOSAyNzUuNjQ5MDE0IDI2Mi43MTk1NHoiIHAtaWQ9IjMxMjQiPjwvcGF0aD48cGF0aCBkPSJNNTExLjA1NzUzNSAzNzUuMTI4NzAzbDQ0Ni4zNDA1ODEgMCAwIDU1LjA1Mzg3My00NDYuMzQwNTgxIDAgMC01NS4wNTM4NzNaIiBwLWlkPSIzMTI1Ij48L3BhdGg+PHBhdGggZD0iTTY0LjcxMzg4NCA3ODguMDQwOTRsODkyLjY4NDIzMiAwIDAgNTUuMDU0ODk3LTg5Mi42ODQyMzIgMCAwLTU1LjA1NDg5N1oiIHAtaWQ9IjMxMjYiPjwvcGF0aD48cGF0aCBkPSJNNTExLjA1NzUzNSA1MTIuNzY2NDU2bDQ0Ni4zNDA1ODEgMCAwIDU1LjA1NDg5Ny00NDYuMzQwNTgxIDAgMC01NS4wNTQ4OTdaIiBwLWlkPSIzMTI3Ij48L3BhdGg+PC9zdmc+\",\n          height: \"20\",\n          alt: \"\",\n          draggable: \"false\"\n        }\n      })\n    ])\n  }\n]\nrender._withStripped = true\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n    require(\"vue-hot-reload-api\")      .rerender(\"data-v-7e00ef64\", esExports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcXJlbGF0aW9uLnZ1ZT82NjBiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssU0FBUyxrQkFBa0IsRUFBRTtBQUNsQztBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQixrQkFBa0IsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0Isc0JBQXNCLEVBQUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCLG9CQUFvQixFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0NBQWdDO0FBQ2xELGtCQUFrQjtBQUNsQixTQUFTO0FBQ1Q7QUFDQSx3QkFBd0IsU0FBUyxnQkFBZ0IsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBc0Q7QUFDMUUsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwREFBMEQ7QUFDOUUsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNDQUFzQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxtQ0FBbUMsWUFBWSxvQkFBb0IsRUFBRTtBQUNyRTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0NBQXNDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG1DQUFtQyxZQUFZLG9CQUFvQixFQUFFO0FBQ3JFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtREFBbUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtDQUFrQyxrQkFBa0IsRUFBRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0NBQWtDLGlCQUFpQixFQUFFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQ0FBa0MsaUJBQWlCLEVBQUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ0Ysa0VBQVM7QUFDeEIsSUFBSSxLQUFVO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzNS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7IGF0dHJzOiB7IGlkOiBcInFmbG93X2xheVwiIH0gfSxcbiAgICBbXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInRvb2xcIiB9LCBbXG4gICAgICAgIF92bS5fbSgwKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX3ZtLl9tKDEpLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfdm0uX20oMiksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInNhdmVcIiwgb246IHsgY2xpY2s6IF92bS5zYXZlIH0gfSwgW1xuICAgICAgICAgIF9jKFwiaW1nXCIsIHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIHNyYzpcbiAgICAgICAgICAgICAgICBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCemRHRnVaR0ZzYjI1bFBTSnVieUkvUGp3aFJFOURWRmxRUlNCemRtY2dVRlZDVEVsRElDSXRMeTlYTTBNdkwwUlVSQ0JUVmtjZ01TNHhMeTlGVGlJZ0ltaDBkSEE2THk5M2QzY3Vkek11YjNKbkwwZHlZWEJvYVdOekwxTldSeTh4TGpFdlJGUkVMM04yWnpFeExtUjBaQ0krUEhOMlp5QjBQU0l4TmpBeU1qazRNREExTnpBeUlpQmpiR0Z6Y3owaWFXTnZiaUlnZG1sbGQwSnZlRDBpTUNBd0lERXdNalFnTVRBeU5DSWdkbVZ5YzJsdmJqMGlNUzR4SWlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhBdGFXUTlJalEwTVRRaUlIaHRiRzV6T25oc2FXNXJQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUwzaHNhVzVySWlCM2FXUjBhRDBpTWpBd0lpQm9aV2xuYUhROUlqSXdNQ0krUEdSbFpuTStQSE4wZVd4bElIUjVjR1U5SW5SbGVIUXZZM056SWo0OEwzTjBlV3hsUGp3dlpHVm1jejQ4Y0dGMGFDQmtQU0pOT0RrMUxqZ3pJRFl5TGpFd01tTXpNUzQzTmpFZ05TNHlPVFFnTlRJdU9UTTFJREkyTGpRMk9DQTJNQzQ0TnpZZ05USXVPVE0xSURjdU9UUWdNVGd1TlRJM0lEVXVNamswSURneUxqQTBPU0ExTGpJNU5DQXhNRGd1TlRFM2RqWXhOaTQyT1RWak1DQXhPQzQxTWpjZ01DQTBNaTR6TkRrdE1pNDJORGNnTlRVdU5UZ3lMVEl1TmpRM0lETXhMamMyTVMweU15NDRNakVnTlRJdU9UTTFMVFV3TGpJNE9DQTJNQzQ0TnpZdE1UZ3VOVEkzSURjdU9UUXRPRFF1TmprM0lEVXVNamswTFRFd09DNDFNVGNnTlM0eU9UUXRNakEyTGpRME55QXdMVFF4TWk0NE9UVWdNQzAyTVRrdU16UXlJREF0TVRVdU9EZ3hJREF0TXprdU56QXhJREF0TlRVdU5UZ3lMVEl1TmpRM0xUSTVMakV4TlMweUxqWTBOeTAxTWk0NU16VXRNak11T0RJeExUWXdMamczTmkwMU1DNHlPRGd0TlM0eU9UUXRNVGd1TlRJM0xUSXVOalEzTFRnMExqWTVOeTB5TGpZME55MHhNRGd1TlRFM2RpMDJNVGt1TXpReVl6QXRNVFV1T0RneElEQXRNemN1TURVMUlEQXROVEl1T1RNMUlEVXVNamswTFRNeExqYzJNU0F5Tmk0ME5qY3ROVEl1T1RNMUlEVXlMamt6TlMwMk15NDFNaklnTVRndU5USTNMVFV1TWprMElEZ3lMakEwT1MweUxqWTBOeUF4TURndU5URTNMVEl1TmpRM0lESXdOaTQwTkRjZ01DQTBNVEF1TWpRNElEQWdOakUyTGpZNU5TQXdJREUxTGpnNE1TQXdJRE01TGpjd01TQXdJRFUxTGpVNE1pQXdlazB6TXpRdU56RTVJRE0yTVM0eE9EWm9NelUwTGpZMk5tTXhNQzQxT0RjZ01DQXhNeTR5TXpRdE5TNHlPVFFnTVRNdU1qTTBMVEV6TGpJek5IWXRNak13TGpJMk9HZ3RNemd4TGpFek0zWXlNakl1TXpJNFl6QWdNVFV1T0RneExUSXVOalEzSURJeExqRTNNeUF4TXk0eU16UWdNakV1TVRjemVrMDNOVGd1TWlBeE1UY3VOamcwZGpJME9DNDNPVFpqTUNBek55NHdOVFV0Tnk0NU5DQTFNQzR5T0RndE5EUXVPVGswSURVd0xqSTRPQzA1Tnk0NU15QXdMVE0zTUM0MU5EWWdNQzAwTVRndU1UZzRJREF0TWpFdU1UY3pJREF0TWprdU1URTFMVEV3TGpVNE55MHlPUzR4TVRVdE16Y3VNRFUxZGkweU5qSXVNREk1WXkwek1TNDNOakVnTUMwNE5DNDJPVGNnTUMweE1UWXVORFU0SURBdE1UVXVPRGd4SURBdE1qWXVORFkzSURBdE1qa3VNVEUxSURFd0xqVTROeTB5TGpZME55QTNMamswTFRJdU5qUTNJREV6Tnk0Mk16SXRNaTQyTkRjZ01UVTJMakUxT0hZMU9USXVPRGMwWXpBZ01UTXVNak0wSURBZ01qTXVPREl4SURFekxqSXpOQ0F5Tmk0ME5qY2dOUzR5T1RRZ01pNDJORGNnTVRNM0xqWXpNaUF5TGpZME55QXhOVFl1TVRVNElESXVOalEzSURVeUxqa3pOU0F3SURVNExqSXlPQ0F3SURFeE1TNHhOalFnTUhZdE1UYzVMamszT1dneU1qY3VOakl4ZGpFM09TNDVOemxqTnpRdU1UQTVJREFnTVRFeExqRTJOQ0F3SURFNE55NDVNaUF3SURFd0xqVTROeUF3SURjMExqRXdPU0F3SURjNUxqUXdNeTB5TGpZME55QXhNQzQxT0RjdE1pNDJORGNnTVRNdU1qTTBMVEV3TGpVNE55QXhNeTR5TXpRdE1qWXVORFkzZGkwMk5qa3VOak5qTUMweE15NHlNelFnTUMwMk9DNDRNVFV0TWk0Mk5EY3ROell1TnpVMkxUSXVOalEzTFRFekxqSXpOQzB4T0M0MU1qY3RNVE11TWpNMExUSTJMalEyTnkweE15NHlNelF0TXpRdU5EQTRJREF0T0RRdU5qazNJREl1TmpRM0xURXhPUzR4TURRZ01IcE5ORFV6TGpneU15QTVNRE11TnpjeWJERXhOaTQwTlRnZ01pNDJORGQyTFRFeU5DNHpPVGhvTFRFeE5pNDBOVGgyTVRJeExqYzFNWG9pSUhBdGFXUTlJalEwTVRVaVBqd3ZjR0YwYUQ0OEwzTjJaejQ9XCIsXG4gICAgICAgICAgICAgIGhlaWdodDogXCIyMFwiLFxuICAgICAgICAgICAgICBhbHQ6IFwiXCIsXG4gICAgICAgICAgICAgIGRyYWdnYWJsZTogXCJmYWxzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImRvd25sb2FkXCIsIG9uOiB7IGNsaWNrOiBfdm0uZG93bmxvYWQgfSB9LCBbXG4gICAgICAgICAgX2MoXCJpbWdcIiwge1xuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgc3JjOlxuICAgICAgICAgICAgICAgIFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJ6ZEdGdVpHRnNiMjVsUFNKdWJ5SS9QandoUkU5RFZGbFFSU0J6ZG1jZ1VGVkNURWxESUNJdEx5OVhNME12TDBSVVJDQlRWa2NnTVM0eEx5OUZUaUlnSW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTDBkeVlYQm9hV056TDFOV1J5OHhMakV2UkZSRUwzTjJaekV4TG1SMFpDSStQSE4yWnlCMFBTSXhOakF5TXprMU5UVXpOalF3SWlCamJHRnpjejBpYVdOdmJpSWdkbWxsZDBKdmVEMGlNQ0F3SURFd01qUWdNVEF5TkNJZ2RtVnljMmx2YmowaU1TNHhJaUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSEF0YVdROUlqSTBNRGtpSUhodGJHNXpPbmhzYVc1clBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1TDNoc2FXNXJJaUIzYVdSMGFEMGlNakF3SWlCb1pXbG5hSFE5SWpJd01DSStQR1JsWm5NK1BITjBlV3hsSUhSNWNHVTlJblJsZUhRdlkzTnpJajQ4TDNOMGVXeGxQand2WkdWbWN6NDhjR0YwYUNCa1BTSk5PRE15TGpFZ05Ua3lMamRqTFRFeElEQXRNakFnT1MweU1DQXlNSFl4TlRFdU1tTXdJREV4TFRrZ01qQXRNakFnTWpCSU1qTXhMamxqTFRFeElEQXRNakF0T1MweU1DMHlNRlkyTVRJdU4yTXdMVEV4TFRrdE1qQXRNakF0TWpCekxUSXdJRGt0TWpBZ01qQjJNVFV4TGpKak1DQXpNeTR4SURJMkxqa2dOakFnTmpBZ05qQklOemt5WXpNekxqRWdNQ0EyTUMweU5pNDVJRFl3TFRZd1ZqWXhNaTQzWXpBdU1TMHhNUzA0TGprdE1qQXRNVGt1T1MweU1Ib2lJSEF0YVdROUlqSTBNVEFpUGp3dmNHRjBhRDQ4Y0dGMGFDQmtQU0pOTkRZNExqTWdOalU0TGpaak1URXVNeUF4TVM0NUlESTNMaklnTVRndU55QTBNeTQySURFNExqY2dNVFl1TkNBd0lETXlMak10Tmk0NElEUXpMall0TVRndU9HdzVPUzR4TFRFd05DNDNZemN1TmkwNElEY3VNaTB5TUM0M0xUQXVPQzB5T0M0ekxUZ3ROeTQyTFRJd0xqY3ROeTR5TFRJNExqTWdNQzQ0YkMwNU15NDJJRGs0TGpsV01qSXdZekF0TVRFdE9TMHlNQzB5TUMweU1ITXRNakFnT1MweU1DQXlNSFkwTURVdU1td3RPVE11TkMwNU9DNDJZeTAzTGpZdE9DMHlNQzR6TFRndU5DMHlPQzR6TFRBdU9DMDRJRGN1TmkwNExqUWdNakF1TXkwd0xqZ2dNamd1TTJ3NU9DNDVJREV3TkM0MWVpSWdjQzFwWkQwaU1qUXhNU0krUEM5d1lYUm9Qand2YzNablBnPT1cIixcbiAgICAgICAgICAgICAgaGVpZ2h0OiBcIjIwXCIsXG4gICAgICAgICAgICAgIGFsdDogXCJcIixcbiAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBcImZhbHNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICBdKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwianNvblwiLCBvbjogeyBjbGljazogX3ZtLmpzU2hvdyB9IH0sIFtcbiAgICAgICAgICBfYyhcImltZ1wiLCB7XG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICBzcmM6XG4gICAgICAgICAgICAgICAgXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQnpkR0Z1WkdGc2IyNWxQU0p1YnlJL1Bqd2hSRTlEVkZsUVJTQnpkbWNnVUZWQ1RFbERJQ0l0THk5WE0wTXZMMFJVUkNCVFZrY2dNUzR4THk5RlRpSWdJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MMGR5WVhCb2FXTnpMMU5XUnk4eExqRXZSRlJFTDNOMlp6RXhMbVIwWkNJK1BITjJaeUIwUFNJeE5qQXpNemd5Tnpnek16WTFJaUJqYkdGemN6MGlhV052YmlJZ2RtbGxkMEp2ZUQwaU1DQXdJREV3TWpRZ01UQXlOQ0lnZG1WeWMybHZiajBpTVM0eElpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIQXRhV1E5SWpJM01qZ2lJSGh0Ykc1ek9uaHNhVzVyUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMM2hzYVc1cklpQjNhV1IwYUQwaU1qQXdJaUJvWldsbmFIUTlJakl3TUNJK1BHUmxabk0rUEhOMGVXeGxJSFI1Y0dVOUluUmxlSFF2WTNOeklqNDhMM04wZVd4bFBqd3ZaR1ZtY3o0OGNHRjBhQ0JrUFNKTk1qRTJMalFnTVRBM0xqRm9OVEF1TW1NMUxqY2dNQ0F4TUM0MElEUXVOeUF4TUM0MElERXdMalJXTVRVMll6QWdOUzQzTFRRdU55QXhNQzQwTFRFd0xqUWdNVEF1TkdndE5EVXVPR010TlM0M0lEQXRNVE11TkNBMExqWXRNVE11TkNBeE1DNDBiQzB4SURJME5pNDJZeTB4TGpNZ016VXVNaTB5TlM0eElEa3dMVFU0TGpZZ09URXVOQ0F5TXk0eUxURWdOVGt1TmlBek9TNDFJRFU1TGpZZ09Ea3VOR3d0TVNBeU5ESXVOR013SURVdU9DQTBMamNnTVRrdU5pQXhNQzQySURFNUxqWm9ORGt1TTJNMUxqa2dNQ0F4TUM0NElEWXVPQ0F4TUM0NElERXlMamgyTXpBdU9XTXdJRFV1T1MwMExqZ2dNVEF1T0MweE1DNDRJREV3TGpob0xUUTVMamhqTFRNeUxqUXRNVEl1TWkwMk1DNDJMVFF3TGpjdE5qQXVOaTA1TUM0MGRpMHhPREZqTUMwME9TNDVMVEkzTGpFdE9UQXVOQzAyTUM0MkxUa3dMalJJTnpjdU1XTXROaTQ0SURBdE1USXVNaTAxTGpVdE1USXVNaTB4TWk0eWRpMDJOUzQ1WXpBdE5pNDRJRFV1TlMweE1pNHlJREV5TGpJdE1USXVNbWd4T0M0eFl6TXpMalVnTUNBMk1DNDJMVFF3TGpVZ05qQXVOaTA1TUM0MFZqRTVOeTQwWXpBdE5Ea3VPU0F5Tnk0eExUa3dMak1nTmpBdU5pMDVNQzR6VFRnd09DNDJJREV3Tnk0eFl6TXpMalVnTUNBMk1DNDJJRFF3TGpRZ05qQXVOaUE1TUM0emRqRTRNQzQ0WXpBZ05Ea3VPU0F5Tnk0eElEa3dMalFnTmpBdU5pQTVNQzQwYURFNExqRmpOaTQzSURBZ01USXVNaUExTGpRZ01USXVNaUF4TWk0eWRqWTFMamxqTUNBMkxqY3ROUzQwSURFeUxqSXRNVEl1TWlBeE1pNHlhQzB4T0M0eVl5MHpNeTQxSURBdE5qQXVOaUEwTUM0MUxUWXdMallnT1RBdU5IWXhPREZqTUNBME9TNDNMVEk0TGpJZ056Z3VNaTAyTUM0MklEa3dMalJvTFRRNUxqaGpMVFlnTUMweE1DNDRMVFF1T1MweE1DNDRMVEV3TGpoV09EYzVZekF0TmlBMExqa3RNVEl1T0NBeE1DNDRMVEV5TGpoSU9EQTRZelV1T1NBd0lERXdMall0TVRNdU9DQXhNQzQyTFRFNUxqWnNMVEV0TWpReUxqUmpNQzAwT1M0NUlETTJMalF0T1RBdU5DQTFPUzQyTFRnNUxqUXRNek11TlMweExqUXROVGN1TXkwMU5pNHlMVFU0TGpZdE9URXVOR3d0TVMweU5EWXVObU13TFRVdU9DMDNMamN0TVRBdU5DMHhNeTQwTFRFd0xqUm9MVFExTGpoakxUVXVOeUF3TFRFd0xqUXROQzQzTFRFd0xqUXRNVEF1TkhZdE16Z3VOV013TFRVdU55QTBMamN0TVRBdU5DQXhNQzQwTFRFd0xqUm9OVEF1TWswMU1EZ3VOQ0EyTmpjdU9HTXhOaTQ0SURBZ016QXVOQ0F4TXk0MklETXdMalFnTXpBdU5DQXdJREUyTGpndE1UTXVOaUF6TUM0MExUTXdMalFnTXpBdU5DMHhOaTQ0SURBdE16QXVOQzB4TXk0MkxUTXdMalF0TXpBdU5DQXdMVEUyTGpnZ01UTXVOaTB6TUM0MElETXdMalF0TXpBdU5FMHpPRFl1T0NBMk5qY3VPR014Tmk0NElEQWdNekF1TkNBeE15NDJJRE13TGpRZ016QXVOQ0F3SURFMkxqZ3RNVE11TmlBek1DNDBMVE13TGpRZ016QXVOQzB4Tmk0NElEQXRNekF1TkMweE15NDJMVE13TGpRdE16QXVOQ0F3TFRFMkxqZ2dNVE11Tmkwek1DNDBJRE13TGpRdE16QXVORTAyTXpBZ05qWTNMamhqTVRZdU9DQXdJRE13TGpRZ01UTXVOaUF6TUM0MElETXdMalFnTUNBeE5pNDRMVEV6TGpZZ016QXVOQzB6TUM0MElETXdMalF0TVRZdU9DQXdMVE13TGpRdE1UTXVOaTB6TUM0MExUTXdMalFnTUMweE5pNDRJREV6TGpZdE16QXVOQ0F6TUM0MExUTXdMalI2SWlCd0xXbGtQU0l5TnpJNUlqNDhMM0JoZEdnK1BDOXpkbWMrXCIsXG4gICAgICAgICAgICAgIGhlaWdodDogXCIyMFwiLFxuICAgICAgICAgICAgICBhbHQ6IFwiXCIsXG4gICAgICAgICAgICAgIGRyYWdnYWJsZTogXCJmYWxzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgXSlcbiAgICAgIF0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IHsgaGVpZ2h0OiBfdm0uaW5pdEhlaWdodCArIFwicHhcIiB9LFxuICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInFjYW52YXNfbGF5XCIgfVxuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXCJjYW52YXNcIiwgeyBhdHRyczogeyBpZDogXCJxY2FudmFzXCIgfSB9KSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0ubm9kZVRpdGxlLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwibm9kZVRpdGxlXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwidGV4dFwiLCBpZDogXCJ0aXRsZUlucHV0XCIsIGF1dG9jb21wbGV0ZTogXCJvZmZcIiB9LFxuICAgICAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS5ub2RlVGl0bGUgfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIGlucHV0OiBbXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfdm0ubm9kZVRpdGxlID0gJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX3ZtLm1vZGlUaXRsZVxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBrZXl1cDogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgISRldmVudC50eXBlLmluZGV4T2YoXCJrZXlcIikgJiZcbiAgICAgICAgICAgICAgICAgIF92bS5faygkZXZlbnQua2V5Q29kZSwgXCJlbnRlclwiLCAxMywgJGV2ZW50LmtleSwgXCJFbnRlclwiKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF92bS5vblN1Ym1pdCgkZXZlbnQpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbC5udW1iZXJcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLmNvbnRhaW5lckdyaWRDb2x1bW4sXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJjb250YWluZXJHcmlkQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzOiB7IG51bWJlcjogdHJ1ZSB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgaWQ6IFwiY29udGFpbmVyR3JpZENvbHVtblwiLFxuICAgICAgICAgICAgICBhdXRvY29tcGxldGU6IFwib2ZmXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb21Qcm9wczogeyB2YWx1ZTogX3ZtLmNvbnRhaW5lckdyaWRDb2x1bW4gfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIGlucHV0OiBbXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfdm0uY29udGFpbmVyR3JpZENvbHVtbiA9IF92bS5fbigkZXZlbnQudGFyZ2V0LnZhbHVlKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX3ZtLm1vZGlDb250YWluZXJHcmlkQ29sdW1uXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIGJsdXI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdm0uJGZvcmNlVXBkYXRlKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJ0ZXh0YXJlYVwiLCB7XG4gICAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICAgICAgICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IF92bS50aXBUZXh0LFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwidGlwVGV4dFwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBhdHRyczogeyBuYW1lOiBcIlwiLCBpZDogXCJ0aXBcIiB9LFxuICAgICAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS50aXBUZXh0IH0sXG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICBpbnB1dDogW1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX3ZtLnRpcFRleHQgPSAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdm0ubW9kVGlwKCRldmVudClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0ubGluZU5vZGVUaXRsZSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImxpbmVOb2RlVGl0bGVcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJ0ZXh0XCIsIGlkOiBcImxpbmVUaXRsZUlucHV0XCIsIGF1dG9jb21wbGV0ZTogXCJvZmZcIiB9LFxuICAgICAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS5saW5lTm9kZVRpdGxlIH0sXG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICBpbnB1dDogW1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX3ZtLmxpbmVOb2RlVGl0bGUgPSAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfdm0ubW9kaUxpbmVUaXRsZVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwic2VsZWN0XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0ubGluZUxpa2UsXG4gICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImxpbmVMaWtlXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcImxpbmVMaWtlXCIsIGF1dG9jb21wbGV0ZTogXCJvZmZcIiB9LFxuICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIGNoYW5nZTogW1xuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkJHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgIC5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucywgZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8uc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IFwiX3ZhbHVlXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIF92bS5saW5lTGlrZSA9ICRldmVudC50YXJnZXQubXVsdGlwbGVcbiAgICAgICAgICAgICAgICAgICAgICA/ICQkc2VsZWN0ZWRWYWxcbiAgICAgICAgICAgICAgICAgICAgICA6ICQkc2VsZWN0ZWRWYWxbMF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBfdm0ubW9kaUxpbmVMaWtlXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3ZtLl9sKF92bS5saW5lU3R5bGVMaXN0LCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfYyhcIm9wdGlvblwiLCB7IGRvbVByb3BzOiB7IHZhbHVlOiBpdGVtLnZhbHVlIH0gfSwgW1xuICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoaXRlbS5uYW1lKSlcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgMFxuICAgICAgICAgICksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwic2VsZWN0XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0ubGluZVR5cGUsXG4gICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImxpbmVUeXBlXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcImxpbmVUeXBlXCIsIGF1dG9jb21wbGV0ZTogXCJvZmZcIiB9LFxuICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIGNoYW5nZTogW1xuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkJHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgIC5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucywgZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8uc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IFwiX3ZhbHVlXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIF92bS5saW5lVHlwZSA9ICRldmVudC50YXJnZXQubXVsdGlwbGVcbiAgICAgICAgICAgICAgICAgICAgICA/ICQkc2VsZWN0ZWRWYWxcbiAgICAgICAgICAgICAgICAgICAgICA6ICQkc2VsZWN0ZWRWYWxbMF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBfdm0ubW9kaUxpbmVUeXBlXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3ZtLl9sKF92bS5saW5lVHlwZUxpc3QsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jKFwib3B0aW9uXCIsIHsgZG9tUHJvcHM6IHsgdmFsdWU6IGl0ZW0udmFsdWUgfSB9LCBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhpdGVtLm5hbWUpKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAwXG4gICAgICAgICAgKVxuICAgICAgICBdXG4gICAgICApLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcImVsLWRpYWxvZ1wiLFxuICAgICAgICB7XG4gICAgICAgICAgYXR0cnM6IHsgdGl0bGU6IFwianNvbuaVsOaNrlwiLCB2aXNpYmxlOiBfdm0uc2hvdywgd2lkdGg6IFwiMzAlXCIgfSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgXCJ1cGRhdGU6dmlzaWJsZVwiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgX3ZtLnNob3cgPSAkZXZlbnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZTogX3ZtLmNsb3NlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJqc29uX2xheVwiIH0sIFtcbiAgICAgICAgICAgIF92bS5fdihcIlxcblxcdCAgICBcXHRcIiArIF92bS5fcyhfdm0uanNvbikgKyBcIlxcblxcdCAgICBcIilcbiAgICAgICAgICBdKVxuICAgICAgICBdXG4gICAgICApXG4gICAgXSxcbiAgICAxXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImRyYWdfZWxlXCIsIGF0dHJzOiB7IFwiZGF0YS1pZFwiOiBcIi0xXCIgfSB9LCBbXG4gICAgICBfYyhcImltZ1wiLCB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgc3JjOlxuICAgICAgICAgICAgXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQnpkR0Z1WkdGc2IyNWxQU0p1YnlJL1Bqd2hSRTlEVkZsUVJTQnpkbWNnVUZWQ1RFbERJQ0l0THk5WE0wTXZMMFJVUkNCVFZrY2dNUzR4THk5RlRpSWdJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MMGR5WVhCb2FXTnpMMU5XUnk4eExqRXZSRlJFTDNOMlp6RXhMbVIwWkNJK1BITjJaeUIwUFNJeE5qQXlNamszTlRrME9EYzVJaUJqYkdGemN6MGlhV052YmlJZ2RtbGxkMEp2ZUQwaU1DQXdJREV3TWpRZ01UQXlOQ0lnZG1WeWMybHZiajBpTVM0eElpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIQXRhV1E5SWpJeE5EY2lJSGh0Ykc1ek9uaHNhVzVyUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMM2hzYVc1cklpQjNhV1IwYUQwaU1qQXdJaUJvWldsbmFIUTlJakl3TUNJK1BHUmxabk0rUEhOMGVXeGxJSFI1Y0dVOUluUmxlSFF2WTNOeklqNDhMM04wZVd4bFBqd3ZaR1ZtY3o0OGNHRjBhQ0JrUFNKTk1qVTJJREk0T0dnMk5IWTJOR2d0TmpSNklHMHhNamdnTXpnMGFETTROSFkyTkVnek9EUjZUVEkxTmlBME9EQm9OalIyTmpSb0xUWTBlaUJ0TUNBeE9USm9OalIyTmpSb0xUWTBlaUlnWm1sc2JEMGlJek16TXpNek15SWdjQzFwWkQwaU1qRTBPQ0krUEM5d1lYUm9Qanh3WVhSb0lHUTlJazA0TXpJZ05qUklNVGt5WXkwek5TNHlJREF0TmpRZ01qZ3VPQzAyTkNBMk5IWTNOamhqTUNBek5TNHlJREk0TGpnZ05qUWdOalFnTmpSb05qUXdZek0xTGpJZ01DQTJOQzB5T0M0NElEWTBMVFkwVmpFeU9HTXdMVE0xTGpJdE1qZ3VPQzAyTkMwMk5DMDJOSG9nYlRBZ09EQXdZekFnTVRrdU1pMHhOaUF6TWkwek1pQXpNa2d5TWpSakxURTJJREF0TXpJdE1USXVPQzB6TWkwek1sWXhOakJqTUMweE9TNHlJREUyTFRNeUlETXlMVE15YURVM05tTXhOaUF3SURNeUlERXlMamdnTXpJZ016SjJOekEwZWlJZ1ptbHNiRDBpSXpNek16TXpNeUlnY0MxcFpEMGlNakUwT1NJK1BDOXdZWFJvUGp4d1lYUm9JR1E5SWswek9EUWdORGd3YURNNE5IWTJORWd6T0RSNklHMHdMVEU1TW1nek9EUjJOalJJTXpnMGVpSWdabWxzYkQwaUl6TXpNek16TXlJZ2NDMXBaRDBpTWpFMU1DSStQQzl3WVhSb1Bqd3ZjM1puUGc9PVwiLFxuICAgICAgICAgIGhlaWdodDogXCIyMFwiLFxuICAgICAgICAgIGFsdDogXCJcIixcbiAgICAgICAgICBkcmFnZ2FibGU6IFwiZmFsc2VcIlxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF0pXG4gIH0sXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImRyYWdfZWxlXCIsIGF0dHJzOiB7IFwiZGF0YS1pZFwiOiBcIjFcIiB9IH0sIFtcbiAgICAgIF9jKFwiaW1nXCIsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBzcmM6XG4gICAgICAgICAgICBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCemRHRnVaR0ZzYjI1bFBTSnVieUkvUGp3aFJFOURWRmxRUlNCemRtY2dVRlZDVEVsRElDSXRMeTlYTTBNdkwwUlVSQ0JUVmtjZ01TNHhMeTlGVGlJZ0ltaDBkSEE2THk5M2QzY3Vkek11YjNKbkwwZHlZWEJvYVdOekwxTldSeTh4TGpFdlJGUkVMM04yWnpFeExtUjBaQ0krUEhOMlp5QjBQU0l4TmpBeU1qazNPRFkzTkRjd0lpQmpiR0Z6Y3owaWFXTnZiaUlnZG1sbGQwSnZlRDBpTUNBd0lERXdNalFnTVRBeU5DSWdkbVZ5YzJsdmJqMGlNUzR4SWlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhBdGFXUTlJak0xTWpZaUlIaHRiRzV6T25oc2FXNXJQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUwzaHNhVzVySWlCM2FXUjBhRDBpTWpBd0lpQm9aV2xuYUhROUlqSXdNQ0krUEdSbFpuTStQSE4wZVd4bElIUjVjR1U5SW5SbGVIUXZZM056SWo0OEwzTjBlV3hsUGp3dlpHVm1jejQ4Y0dGMGFDQmtQU0pOTkRVNExqSWdNemN4U0RFeE1pNDJRemcyTGprZ016Y3hJRFkySURNMU1DNHhJRFkySURNeU5DNDFWakUyTkM0NVl6QXRNalV1TnlBeU1DNDVMVFEyTGpVZ05EWXVOUzAwTmk0MWFETTBOUzQyWXpJMUxqY2dNQ0EwTmk0MUlESXdMamtnTkRZdU5TQTBOaTQxZGpFMU9TNDFZekF1TVNBeU5TNDNMVEl3TGpnZ05EWXVOaTAwTmk0MElEUTJMalo2VFRFeE1pNDJJREUxT0M0ell5MHpMallnTUMwMkxqWWdNeTAyTGpZZ05pNDJkakUxT1M0MVl6QWdNeTQySURNZ05pNDJJRFl1TmlBMkxqWm9NelExTGpaak15NDJJREFnTmk0MkxUTWdOaTQyTFRZdU5sWXhOalF1T1dNd0xUTXVOaTB6TFRZdU5pMDJMall0Tmk0MlNERXhNaTQyZWswNU1UQXVNU0E1TURoSU1qVTRMamhqTFRJMUxqY2dNQzAwTmk0MUxUSXdMamt0TkRZdU5TMDBOaTQxVmpVeE5TNDVZekF0TWpVdU55QXlNQzQ1TFRRMkxqVWdORFl1TlMwME5pNDFhRFkxTVM0ell6STFMamNnTUNBME5pNDFJREl3TGprZ05EWXVOU0EwTmk0MWRqTTBOUzQyWXpBZ01qVXVOeTB5TUM0NElEUTJMalV0TkRZdU5TQTBOaTQxZWsweU5UZ3VPQ0ExTURrdU1tTXRNeTQySURBdE5pNDJJRE10Tmk0MklEWXVObll6TkRVdU5tTXdJRE11TmlBeklEWXVOaUEyTGpZZ05pNDJhRFkxTVM0ell6TXVOaUF3SURZdU5pMHpJRFl1TmkwMkxqWldOVEUxTGpsak1DMHpMall0TXkwMkxqWXROaTQyTFRZdU5rZ3lOVGd1T0hvaUlHWnBiR3c5SWlNMFJqUkdORVlpSUhBdGFXUTlJak0xTWpjaVBqd3ZjR0YwYUQ0OGNHRjBhQ0JrUFNKTk1qSTFMalVnTmprMUxqTm9MVFU1TGpOakxURTRMak1nTUMwek15NHlMVEUwTGprdE16TXVNaTB6TXk0eGJDMHdMalV0TXpBMUxqaGpNQzB4TVNBNExqa3RNakFnTVRrdU9TMHlNQ0F4TVNBd0lERTVMamtnT0M0NUlERTVMamtnTVRrdU9Xd3dMalVnTWprNUxqRm9OVEl1TjJNeE1TQXdJREU1TGprZ09DNDVJREU1TGprZ01Ua3VPWE10T0M0NElESXdMVEU1TGprZ01qQjZJaUJtYVd4c1BTSWpORVkwUmpSR0lpQndMV2xrUFNJek5USTRJajQ4TDNCaGRHZytQQzl6ZG1jK1wiLFxuICAgICAgICAgIGhlaWdodDogXCIyMFwiLFxuICAgICAgICAgIGFsdDogXCJcIixcbiAgICAgICAgICBkcmFnZ2FibGU6IFwiZmFsc2VcIlxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF0pXG4gIH0sXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImRyYWdfZWxlXCIsIGF0dHJzOiB7IFwiZGF0YS1pZFwiOiBcIjJcIiB9IH0sIFtcbiAgICAgIF9jKFwiaW1nXCIsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBzcmM6XG4gICAgICAgICAgICBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCemRHRnVaR0ZzYjI1bFBTSnVieUkvUGp3aFJFOURWRmxRUlNCemRtY2dVRlZDVEVsRElDSXRMeTlYTTBNdkwwUlVSQ0JUVmtjZ01TNHhMeTlGVGlJZ0ltaDBkSEE2THk5M2QzY3Vkek11YjNKbkwwZHlZWEJvYVdOekwxTldSeTh4TGpFdlJGUkVMM04yWnpFeExtUjBaQ0krUEhOMlp5QjBQU0l4TmpBek1EZ3hPVEl4TURnMElpQmpiR0Z6Y3owaWFXTnZiaUlnZG1sbGQwSnZlRDBpTUNBd0lERXdNalFnTVRBeU5DSWdkbVZ5YzJsdmJqMGlNUzR4SWlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhBdGFXUTlJak14TWpFaUlIaHRiRzV6T25oc2FXNXJQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUwzaHNhVzVySWlCM2FXUjBhRDBpTWpBd0lpQm9aV2xuYUhROUlqSXdNQ0krUEdSbFpuTStQSE4wZVd4bElIUjVjR1U5SW5SbGVIUXZZM056SWo0OEwzTjBlV3hsUGp3dlpHVm1jejQ4Y0dGMGFDQmtQU0pOTmpRdU56RXpPRGcwSURZMU1DNDBNRFF5TVd3NE9USXVOamcwTWpNeUlEQWdNQ0ExTlM0d05UTTROek10T0RreUxqWTROREl6TWlBd0lEQXROVFV1TURVek9EY3pXaUlnY0MxcFpEMGlNekV5TWlJK1BDOXdZWFJvUGp4d1lYUm9JR1E5SWswMU1URXVNRFUzTlRNMUlESXpOeTQwT0RjNE56bHNORFEyTGpNME1EVTRNU0F3SURBZ05UVXVNRFUyT1RRekxUUTBOaTR6TkRBMU9ERWdNQ0F3TFRVMUxqQTFOamswTTFvaUlIQXRhV1E5SWpNeE1qTWlQand2Y0dGMGFENDhjR0YwYUNCa1BTSk5NVGc1TGpJeU5UWTRPU0EwT0RRdU16WTNOall6YkRFNE9DNDVOVE0wT1NBd0lEUTJMakk0T0RJek15QXhNVFF1TnpRNE5EUXhJRFkwTGpjME1UVXhNeUF3VERNeE5pNHpOamswTXpnZ01UYzVMamt3TkRNNU0yd3ROakl1TmprME9UQXhJREJNT0RBdU9ETXpNREF6SURVNU9TNHhNVFl4TUROc05qUXVOelF6TlRZZ01Fd3hPRGt1TWpJMU5qZzVJRFE0TkM0ek5qYzJOak42VFRJM05TNDJORGt3TVRRZ01qWXlMamN4T1RVMFl6SXVOek14TWpBMExUWXVPRFUyTVRVeUlEVXVNVGN5T0RFekxURTJMalU1TnpBd015QTNMak14T1Rjd09TMHlPUzR5TWprM01UaHNNUzQwTmpjME1qRWdNR015TGpVek5UYzFNeUF4TXk0NE9UVTBOelVnTkM0NE9EQXhORGNnTWpNdU5qTTJNekkzSURjdU1ETXdNVEUwSURJNUxqSXlPVGN4T0d3Mk9DNDFORGt5TXpZZ01UYzBMakk0T0RRNE9Fd3lNRGN1TmpneU1EUWdORE0zTGpBd09EQXlPU0F5TnpVdU5qUTVNREUwSURJMk1pNDNNVGsxTkhvaUlIQXRhV1E5SWpNeE1qUWlQand2Y0dGMGFENDhjR0YwYUNCa1BTSk5OVEV4TGpBMU56VXpOU0F6TnpVdU1USTROekF6YkRRME5pNHpOREExT0RFZ01DQXdJRFUxTGpBMU16ZzNNeTAwTkRZdU16UXdOVGd4SURBZ01DMDFOUzR3TlRNNE56TmFJaUJ3TFdsa1BTSXpNVEkxSWo0OEwzQmhkR2crUEhCaGRHZ2daRDBpVFRZMExqY3hNemc0TkNBM09EZ3VNRFF3T1RSc09Ea3lMalk0TkRJek1pQXdJREFnTlRVdU1EVTBPRGszTFRnNU1pNDJPRFF5TXpJZ01DQXdMVFUxTGpBMU5EZzVOMW9pSUhBdGFXUTlJak14TWpZaVBqd3ZjR0YwYUQ0OGNHRjBhQ0JrUFNKTk5URXhMakExTnpVek5TQTFNVEl1TnpZMk5EVTJiRFEwTmk0ek5EQTFPREVnTUNBd0lEVTFMakExTkRnNU55MDBORFl1TXpRd05UZ3hJREFnTUMwMU5TNHdOVFE0T1RkYUlpQndMV2xrUFNJek1USTNJajQ4TDNCaGRHZytQQzl6ZG1jK1wiLFxuICAgICAgICAgIGhlaWdodDogXCIyMFwiLFxuICAgICAgICAgIGFsdDogXCJcIixcbiAgICAgICAgICBkcmFnZ2FibGU6IFwiZmFsc2VcIlxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF0pXG4gIH1cbl1cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbmV4cG9ydCBkZWZhdWx0IGVzRXhwb3J0c1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi03ZTAwZWY2NFwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTdlMDBlZjY0XCIsXCJoYXNTY29wZWRcIjp0cnVlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvcXJlbGF0aW9uLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///35\n");

/***/ })
/******/ ]);
});